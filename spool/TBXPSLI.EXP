Export Definitions - Interactive PSL and SQL|Created On 01/25/2008  03:57 PM|SYSDEV|V5.0


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
<BOH>
EXPORT|TBXPSLI|||
PROC|TBXINTERP|||
ROUTINE|MRPC121||60939,57480|11/05/2007
ROUTINE|TBXDQSVR||60983,77340|12/19/2007
PROC|MRPC155|||
GLOBAL|^SCATBL(5,155|
<EOH>

Transferring files on 25-JAN-08 at 3:57 PM
^DBTBL("SYSDEV",17,"TBXPSLI"

^DBTBL("SYSDEV",17,"TBXPSLI")
Interactive PSL and SQL|61005|joycej
^DBTBL("SYSDEV",17,"TBXPSLI",1)
EXPORT|TBXPSLI|
^DBTBL("SYSDEV",17,"TBXPSLI",2)
PROC|TBXINTERP|
^DBTBL("SYSDEV",17,"TBXPSLI",3)
ROUTINE|MRPC121|
^DBTBL("SYSDEV",17,"TBXPSLI",4)
ROUTINE|TBXDQSVR|
^DBTBL("SYSDEV",17,"TBXPSLI",5)
PROC|MRPC155|
^DBTBL("SYSDEV",17,"TBXPSLI",6)
GLOBAL|^SCATBL(5,155|
***DONE***

Transferring files on 25-JAN-08 at 3:57 PM
^DBTBL("SYSDEV",25,"MRPC155"

^DBTBL("SYSDEV",25,"MRPC155")
SQL Reports|MRPC155|61020|e0101711|25379||||||||||||||||||1
^DBTBL("SYSDEV",25,"MRPC155",1)
public MRPC155(String RETURN, Number VERSN, String EXPR)
^DBTBL("SYSDEV",25,"MRPC155",2)
 	/*
^DBTBL("SYSDEV",25,"MRPC155",3)
	ORIG: Jim Joyce - 04/06/2000
^DBTBL("SYSDEV",25,"MRPC155",4)
	DESC: SQL SELECT Interpreter
^DBTBL("SYSDEV",25,"MRPC155",5)

^DBTBL("SYSDEV",25,"MRPC155",6)
	---- Comments --------------------------------------------------------
^DBTBL("SYSDEV",25,"MRPC155",7)

^DBTBL("SYSDEV",25,"MRPC155",8)
	   . RETURN	Return Value	/NOREQ/MECH=REF
^DBTBL("SYSDEV",25,"MRPC155",9)

^DBTBL("SYSDEV",25,"MRPC155",10)
	   . VERSN	Version Number	/REQ/MECH=VAL
^DBTBL("SYSDEV",25,"MRPC155",11)

^DBTBL("SYSDEV",25,"MRPC155",12)
	   . EXPR	SQL Query	/REQ/MECH=VAL
^DBTBL("SYSDEV",25,"MRPC155",13)

^DBTBL("SYSDEV",25,"MRPC155",14)

^DBTBL("SYSDEV",25,"MRPC155",15)
	   RETURNS:
^DBTBL("SYSDEV",25,"MRPC155",16)
	   . $$     	Error Message		/TYP=T
^DBTBL("SYSDEV",25,"MRPC155",17)
	     Null= No Error
^DBTBL("SYSDEV",25,"MRPC155",18)
	
^DBTBL("SYSDEV",25,"MRPC155",19)
	   RELATED:
^DBTBL("SYSDEV",25,"MRPC155",20)
	   . $$^PBSMRPC 		- MRPC Service Class Driver
^DBTBL("SYSDEV",25,"MRPC155",21)
	
^DBTBL("SYSDEV",25,"MRPC155",22)
	   EXAMPLE:
^DBTBL("SYSDEV",25,"MRPC155",23)
	   S RM=$$^MRPC155(.RETURN,1,"SELECT CID,BAL FROM DEP")
^DBTBL("SYSDEV",25,"MRPC155",24)

^DBTBL("SYSDEV",25,"MRPC155",25)
	---- Revision History ------------------------------------------------
^DBTBL("SYSDEV",25,"MRPC155",26)

^DBTBL("SYSDEV",25,"MRPC155",27)
	  03/22/05 - Jim Joyce 
^DBTBL("SYSDEV",25,"MRPC155",28)
	  	Created new MRPC to seperate this function from other 
^DBTBL("SYSDEV",25,"MRPC155",29)
	  	development RPC functions (MRPC121). 
^DBTBL("SYSDEV",25,"MRPC155",30)
	  	
^DBTBL("SYSDEV",25,"MRPC155",31)
	*/
^DBTBL("SYSDEV",25,"MRPC155",32)

^DBTBL("SYSDEV",25,"MRPC155",33)
	type public Boolean ER = false		// Error indicator
^DBTBL("SYSDEV",25,"MRPC155",34)
	type public String RM = ""		// Error message (if any)
^DBTBL("SYSDEV",25,"MRPC155",35)
	type Literal String LF = $c(10)		// Unix / Linux record delimiter
^DBTBL("SYSDEV",25,"MRPC155",36)
	type Number vstart = $$GETTIM^%ZFUNC	// Start time of code execution, set below
^DBTBL("SYSDEV",25,"MRPC155",37)

^DBTBL("SYSDEV",25,"MRPC155",38)
	set RETURN = $$SELECT(EXPR)
^DBTBL("SYSDEV",25,"MRPC155",39)
	set RETURN = "%SQL-Runtime: " _ (($$GETTIM^%ZFUNC - vstart)/1000000) _ " Seconds" _ LF _ RETURN
^DBTBL("SYSDEV",25,"MRPC155",40)

^DBTBL("SYSDEV",25,"MRPC155",41)
	quit RM
^DBTBL("SYSDEV",25,"MRPC155",42)

^DBTBL("SYSDEV",25,"MRPC155",43)
public SELECT(String expr)    //         Run Interactive SQL
^DBTBL("SYSDEV",25,"MRPC155",44)

^DBTBL("SYSDEV",25,"MRPC155",45)
	/* This utility outputs SQL SELECT statements to a file in either
^DBTBL("SYSDEV",25,"MRPC155",46)
	   HTML or plain text format.  It replaces and extends the green
^DBTBL("SYSDEV",25,"MRPC155",47)
	   screen SQL browser (^SQLI) and the Data-Qwik Qwik-report
^DBTBL("SYSDEV",25,"MRPC155",48)
	   functionality.
^DBTBL("SYSDEV",25,"MRPC155",49)

^DBTBL("SYSDEV",25,"MRPC155",50)
	   The SQL SELECT syntax is extended to allow STATEMENT and
^DBTBL("SYSDEV",25,"MRPC155",51)
	   COLUMN qualifiers.  STATEMENT qualifiers follow a comment
^DBTBL("SYSDEV",25,"MRPC155",52)
	   string (//).  COLUMN qualifiers are enclosed in brackets ([])
^DBTBL("SYSDEV",25,"MRPC155",53)
	   immediately following the column expression.
^DBTBL("SYSDEV",25,"MRPC155",54)
	*/
^DBTBL("SYSDEV",25,"MRPC155",55)

^DBTBL("SYSDEV",25,"MRPC155",56)
	type String outputBuffer = ""
^DBTBL("SYSDEV",25,"MRPC155",57)
	// Capture execution error and return with results
^DBTBL("SYSDEV",25,"MRPC155",58)
	catch error {
^DBTBL("SYSDEV",25,"MRPC155",59)
	
^DBTBL("SYSDEV",25,"MRPC155",60)
		type Public String outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",61)
		// quit $ZS _ outputBuffer.get()
^DBTBL("SYSDEV",25,"MRPC155",62)
	}
^DBTBL("SYSDEV",25,"MRPC155",63)
	
^DBTBL("SYSDEV",25,"MRPC155",64)
	type Literal String LF = $c(10)			// Unix / Linux record delimiter
^DBTBL("SYSDEV",25,"MRPC155",65)
	type Literal String CRLF = $c(13,10)		// CrLf String
^DBTBL("SYSDEV",25,"MRPC155",66)
	type Literal String TAB = $c(9)
^DBTBL("SYSDEV",25,"MRPC155",67)

^DBTBL("SYSDEV",25,"MRPC155",68)
	type Public String %MSKE,MSKN,%MSKL,%MSKD,%MSKC
^DBTBL("SYSDEV",25,"MRPC155",69)

^DBTBL("SYSDEV",25,"MRPC155",70)
	type Number ER = 0
^DBTBL("SYSDEV",25,"MRPC155",71)

^DBTBL("SYSDEV",25,"MRPC155",72)
	type Boolean altbg,code,plan
^DBTBL("SYSDEV",25,"MRPC155",73)
	type Number I,IORM,PN,break,cache,col,i,line,match,rows,sqlcnt,sqlsta,tot()
^DBTBL("SYSDEV",25,"MRPC155",74)
	type String exe(),fsn(),ovf(),pars(),vdd(),vsql(),xcol()
^DBTBL("SYSDEV",25,"MRPC155",75)
	type String colgrp,cursor,hdg,msk,par,parms,sqldta,sqlind,title,tok,typ,d,z
^DBTBL("SYSDEV",25,"MRPC155",76)
	type String SELECT,FROM,WHERE,ORDER,GROUP,RM
^DBTBL("SYSDEV",25,"MRPC155",77)

^DBTBL("SYSDEV",25,"MRPC155",78)
	type String IO = ""
^DBTBL("SYSDEV",25,"MRPC155",79)
	type Number IOSL = 0
^DBTBL("SYSDEV",25,"MRPC155",80)

^DBTBL("SYSDEV",25,"MRPC155",81)
	set cursor = 0 					// Enhance when cursor option is enabled
^DBTBL("SYSDEV",25,"MRPC155",82)

^DBTBL("SYSDEV",25,"MRPC155",83)
	type Literal String PARMS ="BREAK,CACHE,CAPTION,CODE,COLS,DEBUG,DQMODE,HEADINGS,LAYOUT,MARKUP,MATCH,OUTPUT,PAGE,PLAN,ROWS,STYLE,TEMPLATE,TITLE"
^DBTBL("SYSDEV",25,"MRPC155",84)

^DBTBL("SYSDEV",25,"MRPC155",85)
	set expr = $$TOKEN^%ZS(expr,.tok)		// Tokenize quoted Strings
^DBTBL("SYSDEV",25,"MRPC155",86)

^DBTBL("SYSDEV",25,"MRPC155",87)
	if expr.contains("//") do {
^DBTBL("SYSDEV",25,"MRPC155",88)
		set parms = expr.piece("//",2,expr.length()), expr = expr.piece("//",1)
^DBTBL("SYSDEV",25,"MRPC155",89)
		if parms.contains($c(0)) set parms = $$UNTOK^%ZS(parms,.tok)
^DBTBL("SYSDEV",25,"MRPC155",90)

^DBTBL("SYSDEV",25,"MRPC155",91)
		do parse(parms, .pars(), "/", "=", true, 0, 1, PARMS)
^DBTBL("SYSDEV",25,"MRPC155",92)
	} 
^DBTBL("SYSDEV",25,"MRPC155",93)

^DBTBL("SYSDEV",25,"MRPC155",94)
	// Parse our special column definition syntax
^DBTBL("SYSDEV",25,"MRPC155",95)

^DBTBL("SYSDEV",25,"MRPC155",96)
	while expr.contains("{") do { if ER quit
^DBTBL("SYSDEV",25,"MRPC155",97)

^DBTBL("SYSDEV",25,"MRPC155",98)
		type Number colNum = expr.piece("{",1).length(",")
^DBTBL("SYSDEV",25,"MRPC155",99)

^DBTBL("SYSDEV",25,"MRPC155",100)
		if 'expr.contains("}") do ERROR("Column Qualifier terminator '}' expected on column # " _ colNum,"") quit
^DBTBL("SYSDEV",25,"MRPC155",101)

^DBTBL("SYSDEV",25,"MRPC155",102)
		set parms = expr.piece("{",2).piece("}",1)
^DBTBL("SYSDEV",25,"MRPC155",103)
		if parms.contains($c(0)) set parms = $$UNTOK^%ZS(parms,.tok)
^DBTBL("SYSDEV",25,"MRPC155",104)

^DBTBL("SYSDEV",25,"MRPC155",105)
		set expr = expr.piece("{",1) _ expr.piece("}",2,expr.length())
^DBTBL("SYSDEV",25,"MRPC155",106)
		do dispOpts(parms, colNum, .xcol(), .tok)
^DBTBL("SYSDEV",25,"MRPC155",107)
	}
^DBTBL("SYSDEV",25,"MRPC155",108)

^DBTBL("SYSDEV",25,"MRPC155",109)
	if ER quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",110)

^DBTBL("SYSDEV",25,"MRPC155",111)
	// FRS - May not be necessary to untokenize here, check this out
^DBTBL("SYSDEV",25,"MRPC155",112)
	if expr.contains($c(0)) set expr = $$UNTOK^%ZS(expr,.tok)
^DBTBL("SYSDEV",25,"MRPC155",113)
	set expr = $$SQL^%ZS(expr,.tok)
^DBTBL("SYSDEV",25,"MRPC155",114)

^DBTBL("SYSDEV",25,"MRPC155",115)
	if ER do ERROR(RM.get()) quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",116)

^DBTBL("SYSDEV",25,"MRPC155",117)
	set expr = expr.extract("SELECT ".length() + 1, expr.length()).trim()
^DBTBL("SYSDEV",25,"MRPC155",118)

^DBTBL("SYSDEV",25,"MRPC155",119)
	type Boolean isHTML = true			// Default markup
^DBTBL("SYSDEV",25,"MRPC155",120)
	if (pars("MARKUP").get().upperCase() = "TEXT") set isHTML = false
^DBTBL("SYSDEV",25,"MRPC155",121)

^DBTBL("SYSDEV",25,"MRPC155",122)
	type Boolean isPortrait = false
^DBTBL("SYSDEV",25,"MRPC155",123)
	if (pars("LAYOUT").get().lowerCase() = "portrait")  set isPortrait = true
^DBTBL("SYSDEV",25,"MRPC155",124)

^DBTBL("SYSDEV",25,"MRPC155",125)
	if 'pars("TEMPLATE").get().isNull() do template(pars("TEMPLATE"), .pars())
^DBTBL("SYSDEV",25,"MRPC155",126)
	if ER quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",127)

^DBTBL("SYSDEV",25,"MRPC155",128)
	if 'pars("DEBUG").get().isNull() do { if ER quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",129)

^DBTBL("SYSDEV",25,"MRPC155",130)
		if (pars("DEBUG").lowerCase() = "syntax") do showPars(.pars(), .xcol(), .isHTML) quit
^DBTBL("SYSDEV",25,"MRPC155",131)

^DBTBL("SYSDEV",25,"MRPC155",132)
		type String msg()
^DBTBL("SYSDEV",25,"MRPC155",133)
		do RUN^SQLTESTS(expr,0,.msg,.par,.tok)
^DBTBL("SYSDEV",25,"MRPC155",134)
		do caption("Debug SQL Statement", "UT", isHTML, 40) 
^DBTBL("SYSDEV",25,"MRPC155",135)

^DBTBL("SYSDEV",25,"MRPC155",136)
		for I = 1:1 quit:'msg(I).exists()  do writeln(LF _ msg(I))
^DBTBL("SYSDEV",25,"MRPC155",137)
		do section(80,isHTML)
^DBTBL("SYSDEV",25,"MRPC155",138)
		set ER = (ER = 2)
^DBTBL("SYSDEV",25,"MRPC155",139)
	}
^DBTBL("SYSDEV",25,"MRPC155",140)
	
^DBTBL("SYSDEV",25,"MRPC155",141)
	set SELECT = $$TOK^SQL(expr,"FROM,WHERE,ORDER,GROUP",.tok)
^DBTBL("SYSDEV",25,"MRPC155",142)
	if ER do ERROR(RM.get()) quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",143)

^DBTBL("SYSDEV",25,"MRPC155",144)
	if SELECT.isNull() do ERROR($$^MSG(8569),"") quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",145)
	if FROM.get().isNull() do ERROR($$^MSG(8561),"") quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",146)

^DBTBL("SYSDEV",25,"MRPC155",147)
	type Boolean distinct = SELECT.beginsWith("DISTINCT ")
^DBTBL("SYSDEV",25,"MRPC155",148)

^DBTBL("SYSDEV",25,"MRPC155",149)
	if distinct set SELECT = SELECT.extract("DISTINCT ".length() + 1, SELECT.length())
^DBTBL("SYSDEV",25,"MRPC155",150)
	else  if SELECT.beginsWith("ALL ") set SELECT = SELECT.extract("ALL ".length() + 1, SELECT.length())
^DBTBL("SYSDEV",25,"MRPC155",151)

^DBTBL("SYSDEV",25,"MRPC155",152)
	if SELECT.beginsWith("*") do { if ER quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",153)

^DBTBL("SYSDEV",25,"MRPC155",154)
		if (SELECT = "*") set SELECT = $$COLLIST^DBSDD(FROM,0,1,0)
^DBTBL("SYSDEV",25,"MRPC155",155)
		else  set SELECT = $$selectWild(SELECT, FROM, .xcol(), .fsn(), .tok)
^DBTBL("SYSDEV",25,"MRPC155",156)
	}
^DBTBL("SYSDEV",25,"MRPC155",157)

^DBTBL("SYSDEV",25,"MRPC155",158)
	// Build the columm array col()
^DBTBL("SYSDEV",25,"MRPC155",159)
	do bldcol(SELECT, FROM, ORDER.get(), .col(), .xcol(), .pars(), .tok, .fsn, .vdd)
^DBTBL("SYSDEV",25,"MRPC155",160)
	if ER quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",161)

^DBTBL("SYSDEV",25,"MRPC155",162)
	if 'pars("TITLE").get().isNull() set pars("title") = $$bldTitle(pars("TITLE"), isHTML, .col(), .pars(), FROM, WHERE.get(), .tok)
^DBTBL("SYSDEV",25,"MRPC155",163)

^DBTBL("SYSDEV",25,"MRPC155",164)
	set IORM = 0							// Initialize right margin	
^DBTBL("SYSDEV",25,"MRPC155",165)

^DBTBL("SYSDEV",25,"MRPC155",166)
	set hdg = $$bldhdg(.col(),.xcol(),isHTML,.IORM,.colgrp,.tot(), isPortrait) if ER quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",167)

^DBTBL("SYSDEV",25,"MRPC155",168)
	set rows = pars("ROWS").get() do rangeCheck(rows,"0:","Rows")
^DBTBL("SYSDEV",25,"MRPC155",169)
	set code = pars("CODE").get() if code.isNull() set code = pars("CODE").exists()
^DBTBL("SYSDEV",25,"MRPC155",170)
	set cache = pars("CACHE").get() if cache.isNull() set cache = pars("CACHE").exists()
^DBTBL("SYSDEV",25,"MRPC155",171)
	set plan = pars("PLAN").get() if plan.isNull() set plan = pars("PLAN").exists()
^DBTBL("SYSDEV",25,"MRPC155",172)

^DBTBL("SYSDEV",25,"MRPC155",173)
	if (plan & cache) set cache = 0 do writeln(LF _ " *** Cache disabled to display plan ***")
^DBTBL("SYSDEV",25,"MRPC155",174)

^DBTBL("SYSDEV",25,"MRPC155",175)
	if rows.isNull() set rows = 1000        // Default 1000 rows
^DBTBL("SYSDEV",25,"MRPC155",176)

^DBTBL("SYSDEV",25,"MRPC155",177)
	// Remove and/or set these parameters to fix bug in SQL
^DBTBL("SYSDEV",25,"MRPC155",178)
	kill pars("ROWS")
^DBTBL("SYSDEV",25,"MRPC155",179)
	set pars("CACHE") = cache
^DBTBL("SYSDEV",25,"MRPC155",180)

^DBTBL("SYSDEV",25,"MRPC155",181)
	set expr = SELECT _ " FROM " _ FROM
^DBTBL("SYSDEV",25,"MRPC155",182)
	if 'WHERE.get().isNull() set expr = expr _ " WHERE " _ WHERE
^DBTBL("SYSDEV",25,"MRPC155",183)
	if 'ORDER.get().isNull() set expr = expr _ " ORDER " _ ORDER
^DBTBL("SYSDEV",25,"MRPC155",184)
	if 'GROUP.get().isNull() set expr = expr _ " GROUP " _ GROUP
^DBTBL("SYSDEV",25,"MRPC155",185)

^DBTBL("SYSDEV",25,"MRPC155",186)
	if distinct set expr = ("DISTINCT " _ expr)
^DBTBL("SYSDEV",25,"MRPC155",187)

^DBTBL("SYSDEV",25,"MRPC155",188)
	do SELECT^SQL(expr,.pars(),.sqlsta,.sqldta,.sqlcnt,.sqlind,.tok,-1)
^DBTBL("SYSDEV",25,"MRPC155",189)

^DBTBL("SYSDEV",25,"MRPC155",190)
	if ER do ERROR(RM.get()) quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",191)

^DBTBL("SYSDEV",25,"MRPC155",192)
	If plan do plan(.pars(), .vsql(), isHTML)
^DBTBL("SYSDEV",25,"MRPC155",193)
	if code do code(.pars(), .vsql(), .exe(), isHTML)
^DBTBL("SYSDEV",25,"MRPC155",194)

^DBTBL("SYSDEV",25,"MRPC155",195)
	if (rows = 0) ! (vsql = 0) do writeln("Complete :| 0 rows processed. ") quit outputBuffer  
^DBTBL("SYSDEV",25,"MRPC155",196)

^DBTBL("SYSDEV",25,"MRPC155",197)
	if 'pars("OUTPUT").get().isNull() do { if ER do ERROR(RM.get()) quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",198)

^DBTBL("SYSDEV",25,"MRPC155",199)
		type String X = pars("OUTPUT")
^DBTBL("SYSDEV",25,"MRPC155",200)

^DBTBL("SYSDEV",25,"MRPC155",201)
		type String AUXPTR,HDG,IOHDG,IOPAR,IOSUB,IOTYP,mod
^DBTBL("SYSDEV",25,"MRPC155",202)

^DBTBL("SYSDEV",25,"MRPC155",203)
		type Number %EXT = 1
^DBTBL("SYSDEV",25,"MRPC155",204)

^DBTBL("SYSDEV",25,"MRPC155",205)
		do writeln("Output directed to: " _ X)
^DBTBL("SYSDEV",25,"MRPC155",206)
		do ^SCAIO
^DBTBL("SYSDEV",25,"MRPC155",207)
		use IO
^DBTBL("SYSDEV",25,"MRPC155",208)
	}                            
^DBTBL("SYSDEV",25,"MRPC155",209)

^DBTBL("SYSDEV",25,"MRPC155",210)
	// Format heading for HTML table output and start table
^DBTBL("SYSDEV",25,"MRPC155",211)
	if (isHTML = true) do newTable(.pars(), "RS", colgrp)
^DBTBL("SYSDEV",25,"MRPC155",212)

^DBTBL("SYSDEV",25,"MRPC155",213)
	set altbg = 'pars("xstyle").get().getSub("alt-row-color",";",":").isNull()
^DBTBL("SYSDEV",25,"MRPC155",214)

^DBTBL("SYSDEV",25,"MRPC155",215)
	if (isPortrait = true)  do portrait(hdg, isHTML, altbg, .col(), .pars(), IO, IOSL, IORM, rows) quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",216)

^DBTBL("SYSDEV",25,"MRPC155",217)
	set PN = 0, line = 0						// Initialize
^DBTBL("SYSDEV",25,"MRPC155",218)
	set sqlind = ""							// Protection indicator
^DBTBL("SYSDEV",25,"MRPC155",219)

^DBTBL("SYSDEV",25,"MRPC155",220)
	if 'pars("CAPTION").get().isNull() do caption(pars("CAPTION"), "RS", isHTML) set line = (line + pars("CAPTION").length(LF))
^DBTBL("SYSDEV",25,"MRPC155",221)

^DBTBL("SYSDEV",25,"MRPC155",222)
	for sqlcnt = 1:1 do { if (vsql(0) = 100) quit
^DBTBL("SYSDEV",25,"MRPC155",223)

^DBTBL("SYSDEV",25,"MRPC155",224)
		set vsql = $$^SQLF(.exe,.sqldta,.sqlind) if (vsql = 0) set sqlcnt = (sqlcnt - 1) quit
^DBTBL("SYSDEV",25,"MRPC155",225)

^DBTBL("SYSDEV",25,"MRPC155",226)
		if sqlind.contains(1) set sqldta = $$protect(sqldta,sqlind)
^DBTBL("SYSDEV",25,"MRPC155",227)
		if isHTML set sqldta = $$escape(sqldta) 		// Process HTML escapes
^DBTBL("SYSDEV",25,"MRPC155",228)

^DBTBL("SYSDEV",25,"MRPC155",229)
		set d = $$bldRow(sqldta, .col(), isHTML, .tot(), .break)
^DBTBL("SYSDEV",25,"MRPC155",230)
		do wrtRow(d, hdg, isHTML, .pars(), .break, .line, altbg, .IOSL, IORM, .PN)
^DBTBL("SYSDEV",25,"MRPC155",231)

^DBTBL("SYSDEV",25,"MRPC155",232)
		if 'rows.isNull() set rows = (rows - 1) if (rows = 0) set vsql(0) = 100
^DBTBL("SYSDEV",25,"MRPC155",233)
	}
^DBTBL("SYSDEV",25,"MRPC155",234)

^DBTBL("SYSDEV",25,"MRPC155",235)
	do totals(.tot(), hdg, .col(), isHTML, IOSL, IORM, line, altbg, PN, .pars())
^DBTBL("SYSDEV",25,"MRPC155",236)
	do close(cursor, isHTML, IO, sqlcnt, true)
^DBTBL("SYSDEV",25,"MRPC155",237)
	quit outputBuffer
^DBTBL("SYSDEV",25,"MRPC155",238)

^DBTBL("SYSDEV",25,"MRPC155",239)

^DBTBL("SYSDEV",25,"MRPC155",240)

^DBTBL("SYSDEV",25,"MRPC155",241)
bldRow(String rowdta, String col(), Boolean isHTML, String tot(), Number break)	// Format a row
^DBTBL("SYSDEV",25,"MRPC155",242)

^DBTBL("SYSDEV",25,"MRPC155",243)
	/* 
^DBTBL("SYSDEV",25,"MRPC155",244)
	This function returns a formatted row in either plain text or HTML
^DBTBL("SYSDEV",25,"MRPC155",245)
	format.  It applies the column formatting attributes to the row
^DBTBL("SYSDEV",25,"MRPC155",246)
	*/
^DBTBL("SYSDEV",25,"MRPC155",247)

^DBTBL("SYSDEV",25,"MRPC155",248)
	type Public String %MSKD
^DBTBL("SYSDEV",25,"MRPC155",249)

^DBTBL("SYSDEV",25,"MRPC155",250)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",251)
	type Literal String COLPAR = "length,type,decimal,format,align,merge,space,math,wrap,repeat,null,break,style,heading,title,minus"
^DBTBL("SYSDEV",25,"MRPC155",252)

^DBTBL("SYSDEV",25,"MRPC155",253)
	type Number I
^DBTBL("SYSDEV",25,"MRPC155",254)
	type Number cptr = 0 
^DBTBL("SYSDEV",25,"MRPC155",255)

^DBTBL("SYSDEV",25,"MRPC155",256)
	set break = 0
^DBTBL("SYSDEV",25,"MRPC155",257)

^DBTBL("SYSDEV",25,"MRPC155",258)
	type Row colrec,accum
^DBTBL("SYSDEV",25,"MRPC155",259)

^DBTBL("SYSDEV",25,"MRPC155",260)
	type String z
^DBTBL("SYSDEV",25,"MRPC155",261)
	type String d = "", ovf = ""
^DBTBL("SYSDEV",25,"MRPC155",262)

^DBTBL("SYSDEV",25,"MRPC155",263)
	for I = 1:1:col do {
^DBTBL("SYSDEV",25,"MRPC155",264)

^DBTBL("SYSDEV",25,"MRPC155",265)
		set colrec = col(I).toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",266)

^DBTBL("SYSDEV",25,"MRPC155",267)
		set z = rowdta.piece($C(9),I)
^DBTBL("SYSDEV",25,"MRPC155",268)

^DBTBL("SYSDEV",25,"MRPC155",269)
		if (z.isNull() & 'colrec.null.isNull()) set z = colrec.null 
^DBTBL("SYSDEV",25,"MRPC155",270)

^DBTBL("SYSDEV",25,"MRPC155",271)
		if '(colrec.math.isNull() ! z.isNull()) do {			// Process accumulators
^DBTBL("SYSDEV",25,"MRPC155",272)

^DBTBL("SYSDEV",25,"MRPC155",273)
			set accum = tot(I).toRow("flags,count,sum,max,min",$c(9))
^DBTBL("SYSDEV",25,"MRPC155",274)
			// if "N$".contains(colrec.type) & z.contains(".") set z = +z
^DBTBL("SYSDEV",25,"MRPC155",275)

^DBTBL("SYSDEV",25,"MRPC155",276)
			// Save for histogram
^DBTBL("SYSDEV",25,"MRPC155",277)
			if (accum.flags.extract(5) = 1) set tot(I,z) = tot(I,z).get() + 1 
^DBTBL("SYSDEV",25,"MRPC155",278)
			if 'accum.flags.extract(1,4).contains(1) quit
^DBTBL("SYSDEV",25,"MRPC155",279)

^DBTBL("SYSDEV",25,"MRPC155",280)
			if (accum.flags.extract(1) = 1) set accum.count = accum.count + 1
^DBTBL("SYSDEV",25,"MRPC155",281)
			if (accum.flags.extract(2) = 1) set accum.sum = accum.sum + z	
^DBTBL("SYSDEV",25,"MRPC155",282)

^DBTBL("SYSDEV",25,"MRPC155",283)
			if (accum.flags.extract(3) = 1) do {	// MAX
^DBTBL("SYSDEV",25,"MRPC155",284)
				if accum.max.isNull() set accum.max = z 
^DBTBL("SYSDEV",25,"MRPC155",285)
				else  if "N$DC".contains(colrec.type) set:(z > accum.max) accum.max = z
^DBTBL("SYSDEV",25,"MRPC155",286)
				else  if z.follows(accum.max) set accum.max = z
^DBTBL("SYSDEV",25,"MRPC155",287)
			}
^DBTBL("SYSDEV",25,"MRPC155",288)

^DBTBL("SYSDEV",25,"MRPC155",289)
			if (accum.flags.extract(4) = 1) do {	// MIN
^DBTBL("SYSDEV",25,"MRPC155",290)
				if accum.min.isNull() set accum.min = z
^DBTBL("SYSDEV",25,"MRPC155",291)
				else  if "N$DC".contains(colrec.type) set:(z < accum.min) accum.min = z
^DBTBL("SYSDEV",25,"MRPC155",292)
				else  if accum.min.follows(z) set accum.min = z
^DBTBL("SYSDEV",25,"MRPC155",293)
			}
^DBTBL("SYSDEV",25,"MRPC155",294)

^DBTBL("SYSDEV",25,"MRPC155",295)
			set tot(I) = accum.toString()
^DBTBL("SYSDEV",25,"MRPC155",296)
		}
^DBTBL("SYSDEV",25,"MRPC155",297)

^DBTBL("SYSDEV",25,"MRPC155",298)
		if (colrec.break & '(col(I,0).get() = z)) do {			// Break line
^DBTBL("SYSDEV",25,"MRPC155",299)

^DBTBL("SYSDEV",25,"MRPC155",300)
			type Number i
^DBTBL("SYSDEV",25,"MRPC155",301)

^DBTBL("SYSDEV",25,"MRPC155",302)
			if 'col(I,0).get().isNull()  do {
^DBTBL("SYSDEV",25,"MRPC155",303)
				if (colrec.break < 0) set break = colrec.break
^DBTBL("SYSDEV",25,"MRPC155",304)
				else  if (colrec.break > break) & '(break < 0) set break = colrec.break
^DBTBL("SYSDEV",25,"MRPC155",305)
			} 
^DBTBL("SYSDEV",25,"MRPC155",306)

^DBTBL("SYSDEV",25,"MRPC155",307)
			set col(I,0) = z, colrec.repeat = 1
^DBTBL("SYSDEV",25,"MRPC155",308)

^DBTBL("SYSDEV",25,"MRPC155",309)
			// Force columns to the right always repeat after break
^DBTBL("SYSDEV",25,"MRPC155",310)
			for i = I+1:1:col if col(i,0).exists() set col(i,0) = ""
^DBTBL("SYSDEV",25,"MRPC155",311)
		}
^DBTBL("SYSDEV",25,"MRPC155",312)

^DBTBL("SYSDEV",25,"MRPC155",313)
		if (colrec.length = 0) set col(I,0) = z quit			// Save value and quit
^DBTBL("SYSDEV",25,"MRPC155",314)

^DBTBL("SYSDEV",25,"MRPC155",315)
		if (colrec.repeat = 0) do {					// Repeat option
^DBTBL("SYSDEV",25,"MRPC155",316)
			
^DBTBL("SYSDEV",25,"MRPC155",317)
			//if 'IOSL.isNull() & (line + 1 > IOSL) set col(I,0) = ""
^DBTBL("SYSDEV",25,"MRPC155",318)

^DBTBL("SYSDEV",25,"MRPC155",319)
			if (col(I,0).get() = z) set z = ""				// Null if same as last
^DBTBL("SYSDEV",25,"MRPC155",320)
			else  set col(I,0) = z
^DBTBL("SYSDEV",25,"MRPC155",321)
		}
^DBTBL("SYSDEV",25,"MRPC155",322)

^DBTBL("SYSDEV",25,"MRPC155",323)
		if z.isNull() do { quit						// Null column
^DBTBL("SYSDEV",25,"MRPC155",324)

^DBTBL("SYSDEV",25,"MRPC155",325)
			if 'colrec.merge.isNull() quit
^DBTBL("SYSDEV",25,"MRPC155",326)

^DBTBL("SYSDEV",25,"MRPC155",327)
			if isHTML set d = d _ "<td>" 
^DBTBL("SYSDEV",25,"MRPC155",328)
			else  set cptr = (cptr + colrec.length + colrec.space)
^DBTBL("SYSDEV",25,"MRPC155",329)
		}
^DBTBL("SYSDEV",25,"MRPC155",330)

^DBTBL("SYSDEV",25,"MRPC155",331)
		if 'colrec.format.isNull() do {					// FOrmat value
^DBTBL("SYSDEV",25,"MRPC155",332)

^DBTBL("SYSDEV",25,"MRPC155",333)
			if ("N$".contains(colrec.type)) set z = $$NUM^%ZM(z,colrec.decimal,colrec.format)
^DBTBL("SYSDEV",25,"MRPC155",334)
			else  if (colrec.type = "D") set z = $$DAT^%ZM(z,colrec.format)
^DBTBL("SYSDEV",25,"MRPC155",335)
			else  if (colrec.type = "L") set z = $$LOG^%ZM(z,colrec.format)
^DBTBL("SYSDEV",25,"MRPC155",336)
			else  if (colrec.type = "C") do {			// Oracle time handling
^DBTBL("SYSDEV",25,"MRPC155",337)

^DBTBL("SYSDEV",25,"MRPC155",338)
				if 'colrec.format.contains("DATE") set z = $$TIM^%ZM(z,colrec.format)
^DBTBL("SYSDEV",25,"MRPC155",339)
				// 21550= 01/01/1900 DATE0 format (ORACLE datetime format)
^DBTBL("SYSDEV",25,"MRPC155",340)
				else  if colrec.format.contains("DATE0") set z = $$DAT^%ZM(21550,%MSKD) _ $$TIM^%ZM(z,colrec.format.piece("DATE0",2))
^DBTBL("SYSDEV",25,"MRPC155",341)
				else  set z = $$DAT^%ZM(+$H,%MSKD) _ $$TIM^%ZM(z,colrec.format.piece("DATE",2))
^DBTBL("SYSDEV",25,"MRPC155",342)
			}
^DBTBL("SYSDEV",25,"MRPC155",343)
			else  if ("MTU".contains(colrec.type)) set z = $$STRFormat(z, colrec.format)
^DBTBL("SYSDEV",25,"MRPC155",344)

^DBTBL("SYSDEV",25,"MRPC155",345)
		}
^DBTBL("SYSDEV",25,"MRPC155",346)

^DBTBL("SYSDEV",25,"MRPC155",347)
		else  if 'colrec.decimal.isNull() set z = $j(z,0,colrec.decimal)
^DBTBL("SYSDEV",25,"MRPC155",348)

^DBTBL("SYSDEV",25,"MRPC155",349)
		if isHTML do {
^DBTBL("SYSDEV",25,"MRPC155",350)

^DBTBL("SYSDEV",25,"MRPC155",351)
			if (colrec.wrap = 2) set z = z.extract(1,colrec.length)			//Truncate
^DBTBL("SYSDEV",25,"MRPC155",352)
			if (z.beginsWith("-") & 'colrec.minus.isNull()) set z = "<span style=" _ colrec.minus _ ">" _ z _ "</span>"
^DBTBL("SYSDEV",25,"MRPC155",353)

^DBTBL("SYSDEV",25,"MRPC155",354)
			if colrec.merge.isNull() set d = d _ "<td>" _ z
^DBTBL("SYSDEV",25,"MRPC155",355)

^DBTBL("SYSDEV",25,"MRPC155",356)
			else  do {
^DBTBL("SYSDEV",25,"MRPC155",357)
				if 'colrec.style.isNull() set z = "<span style=" _ colrec.style _ ">" _ z _ "</span>"
^DBTBL("SYSDEV",25,"MRPC155",358)
				set d = d _ colrec.merge _ z
^DBTBL("SYSDEV",25,"MRPC155",359)
			}
^DBTBL("SYSDEV",25,"MRPC155",360)

^DBTBL("SYSDEV",25,"MRPC155",361)
		}
^DBTBL("SYSDEV",25,"MRPC155",362)

^DBTBL("SYSDEV",25,"MRPC155",363)
		else  do {
^DBTBL("SYSDEV",25,"MRPC155",364)

^DBTBL("SYSDEV",25,"MRPC155",365)
			if 'colrec.align.isNull() do {
^DBTBL("SYSDEV",25,"MRPC155",366)
	
^DBTBL("SYSDEV",25,"MRPC155",367)
				if colrec.align = "right" set z = z.justify(colrec.length,1)	// Right
^DBTBL("SYSDEV",25,"MRPC155",368)
				else  if colrec.align = "center" set z = "".justify((colrec.length - z.length()) \ 2) _ z
^DBTBL("SYSDEV",25,"MRPC155",369)
			}
^DBTBL("SYSDEV",25,"MRPC155",370)

^DBTBL("SYSDEV",25,"MRPC155",371)
			if 'colrec.merge.isNull() do {
^DBTBL("SYSDEV",25,"MRPC155",372)

^DBTBL("SYSDEV",25,"MRPC155",373)
				set z = colrec.merge _ z
^DBTBL("SYSDEV",25,"MRPC155",374)

^DBTBL("SYSDEV",25,"MRPC155",375)
				type Number i
^DBTBL("SYSDEV",25,"MRPC155",376)
				for i = I-1:-1:1 set colrec = col(i).toRow(COLPAR,"|") if (colrec.merge.isNull() & (colrec.length > 0)) quit
^DBTBL("SYSDEV",25,"MRPC155",377)

^DBTBL("SYSDEV",25,"MRPC155",378)
				set cptr = (cptr - colrec.length - colrec.space)		// Reset position
^DBTBL("SYSDEV",25,"MRPC155",379)

^DBTBL("SYSDEV",25,"MRPC155",380)
				// Prepend prior overflow
^DBTBL("SYSDEV",25,"MRPC155",381)
				for i = ovf.length(LF):-1:1 if (ovf.piece(LF,i).length() > cptr) set z = LF _ ovf.piece(LF,i).extract(cptr + 1, 9999) _ z, ovf.piece(LF,i) = ovf.piece(LF,i).extract(1,cptr)
^DBTBL("SYSDEV",25,"MRPC155",382)
				set z = d.extract(cptr + 1,d.length()) _ z			// Concatenate to prior column
^DBTBL("SYSDEV",25,"MRPC155",383)

^DBTBL("SYSDEV",25,"MRPC155",384)
				if z.beginsWith(" ") set z = z.trim(-1) 			// Remove leading whitespace
^DBTBL("SYSDEV",25,"MRPC155",385)
				set d = d.extract(1,cptr)
^DBTBL("SYSDEV",25,"MRPC155",386)
			}
^DBTBL("SYSDEV",25,"MRPC155",387)

^DBTBL("SYSDEV",25,"MRPC155",388)
			if z.contains(LF) do {
^DBTBL("SYSDEV",25,"MRPC155",389)

^DBTBL("SYSDEV",25,"MRPC155",390)
				type Number i1,i2
^DBTBL("SYSDEV",25,"MRPC155",391)
				for i1 = 1:1:ovf.length(LF) if (ovf.piece(LF,i1).length() <= cptr) quit
^DBTBL("SYSDEV",25,"MRPC155",392)
				for i2 = 2:1:z.length(LF) set ovf.piece(LF,i1) = ovf.piece(LF,i1) _ "".justify(cptr - ovf.piece(LF,i1).length()) _ z.piece(LF,i2), i1 = i1 + 1
^DBTBL("SYSDEV",25,"MRPC155",393)
				set z = z.piece(LF,1)
^DBTBL("SYSDEV",25,"MRPC155",394)
			}
^DBTBL("SYSDEV",25,"MRPC155",395)

^DBTBL("SYSDEV",25,"MRPC155",396)
			if (colrec.wrap > 0) & (z.length() > colrec.length) do {
^DBTBL("SYSDEV",25,"MRPC155",397)

^DBTBL("SYSDEV",25,"MRPC155",398)
				if (colrec.wrap = 2) set z = z.extract(1,colrec.length)		// Truncate
^DBTBL("SYSDEV",25,"MRPC155",399)
				else  set z = $$overflow(z,cptr,colrec.length,.ovf)		// Wrap
^DBTBL("SYSDEV",25,"MRPC155",400)
			}
^DBTBL("SYSDEV",25,"MRPC155",401)

^DBTBL("SYSDEV",25,"MRPC155",402)
			set d = d _ "".justify(cptr - d.length()) _ z, cptr = (cptr + colrec.length + colrec.space)
^DBTBL("SYSDEV",25,"MRPC155",403)
		}
^DBTBL("SYSDEV",25,"MRPC155",404)
	}
^DBTBL("SYSDEV",25,"MRPC155",405)

^DBTBL("SYSDEV",25,"MRPC155",406)
	set d = (d _ LF)
^DBTBL("SYSDEV",25,"MRPC155",407)

^DBTBL("SYSDEV",25,"MRPC155",408)
	if isHTML set d = ("<tr>" _ d)
^DBTBL("SYSDEV",25,"MRPC155",409)
	else  if 'ovf.isNull() set d = (d _ ovf _ LF)
^DBTBL("SYSDEV",25,"MRPC155",410)

^DBTBL("SYSDEV",25,"MRPC155",411)
	quit d
^DBTBL("SYSDEV",25,"MRPC155",412)

^DBTBL("SYSDEV",25,"MRPC155",413)

^DBTBL("SYSDEV",25,"MRPC155",414)
STRFormat(String str, String format)	// String format
^DBTBL("SYSDEV",25,"MRPC155",415)
	
^DBTBL("SYSDEV",25,"MRPC155",416)
	// May want to 'beef up'the url syntax and either add "http:..." and/or
^DBTBL("SYSDEV",25,"MRPC155",417)
	// remove attributes onthe displayed portion.  May also wantot add masks.
^DBTBL("SYSDEV",25,"MRPC155",418)

^DBTBL("SYSDEV",25,"MRPC155",419)
	if format = "URL" quit "<a href=" _ str.addQuotes() _ "> " _ str _ "</a>"
^DBTBL("SYSDEV",25,"MRPC155",420)
	if format = "IMAGE" quit "<img src=" _ str.addQuotes() _ ">"
^DBTBL("SYSDEV",25,"MRPC155",421)
	if format = "HTML" quit $$unEscape(str)
^DBTBL("SYSDEV",25,"MRPC155",422)
	quit str
^DBTBL("SYSDEV",25,"MRPC155",423)

^DBTBL("SYSDEV",25,"MRPC155",424)

^DBTBL("SYSDEV",25,"MRPC155",425)
overflow(String val, Number cptr, Number len, String ovf) // Data overflow with orphan control
^DBTBL("SYSDEV",25,"MRPC155",426)

^DBTBL("SYSDEV",25,"MRPC155",427)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",428)

^DBTBL("SYSDEV",25,"MRPC155",429)
	type Number i,j
^DBTBL("SYSDEV",25,"MRPC155",430)
	type String x
^DBTBL("SYSDEV",25,"MRPC155",431)

^DBTBL("SYSDEV",25,"MRPC155",432)
	set x = val.extract(len + 1, val.length())
^DBTBL("SYSDEV",25,"MRPC155",433)
	set val = val.extract(1,len)
^DBTBL("SYSDEV",25,"MRPC155",434)

^DBTBL("SYSDEV",25,"MRPC155",435)
	// Append a single orphan character after break to the current string 
^DBTBL("SYSDEV",25,"MRPC155",436)
	// or back up halfway through the string and find a break delimiter
^DBTBL("SYSDEV",25,"MRPC155",437)
	if " ,".contains(x.extract(2)) set val = val _ x.extract(1),  x = x.extract(2,x.length())
^DBTBL("SYSDEV",25,"MRPC155",438)
	if x.endsWith(" ") set x = x.trim(1)
^DBTBL("SYSDEV",25,"MRPC155",439)

^DBTBL("SYSDEV",25,"MRPC155",440)
	if 'x.isNull() do {
^DBTBL("SYSDEV",25,"MRPC155",441)

^DBTBL("SYSDEV",25,"MRPC155",442)
		for j = len:-1:1 if " ,".contains(val.extract(j)) quit
^DBTBL("SYSDEV",25,"MRPC155",443)
		if  set x = val.extract(j + 1, val.length()) _ x, val = val.extract(1,j)
^DBTBL("SYSDEV",25,"MRPC155",444)
	}
^DBTBL("SYSDEV",25,"MRPC155",445)

^DBTBL("SYSDEV",25,"MRPC155",446)
	if x.beginsWith(" ") set x = x.trim(-1)
^DBTBL("SYSDEV",25,"MRPC155",447)
	if x.isNull() quit val
^DBTBL("SYSDEV",25,"MRPC155",448)

^DBTBL("SYSDEV",25,"MRPC155",449)
	for i=1:1 do { if x.isNull() quit
^DBTBL("SYSDEV",25,"MRPC155",450)

^DBTBL("SYSDEV",25,"MRPC155",451)
		set ovf.piece(LF,i) = ovf.piece(LF,i).justify(cptr,-1," ") _ x.extract(1,len).trim(-1)
^DBTBL("SYSDEV",25,"MRPC155",452)
		set x = x.extract(len + 1,x.length())
^DBTBL("SYSDEV",25,"MRPC155",453)

^DBTBL("SYSDEV",25,"MRPC155",454)
		if " ,".contains(x.extract(2)) set ovf.piece(LF,i) = ovf.piece(LF,i) _ x.extract(1),  x = x.extract(2,x.length())
^DBTBL("SYSDEV",25,"MRPC155",455)
		if x.endsWith(" ") set x = x.trim(1)
^DBTBL("SYSDEV",25,"MRPC155",456)

^DBTBL("SYSDEV",25,"MRPC155",457)
		if 'x.isNull() do {
^DBTBL("SYSDEV",25,"MRPC155",458)
			type Number start = ovf.piece(LF,i).length()
^DBTBL("SYSDEV",25,"MRPC155",459)
			type Number end = (start - len + 1)
^DBTBL("SYSDEV",25,"MRPC155",460)

^DBTBL("SYSDEV",25,"MRPC155",461)
			for j = start:-1:end if " ,".contains(ovf.piece(LF,i).extract(j)) quit
^DBTBL("SYSDEV",25,"MRPC155",462)
			if  set x = ovf.piece(LF,i).extract(j + 1, ovf.piece(LF,i).length()) _ x, ovf.piece(LF,i) = ovf.piece(LF,i).extract(1,j)
^DBTBL("SYSDEV",25,"MRPC155",463)
		}
^DBTBL("SYSDEV",25,"MRPC155",464)
	}
^DBTBL("SYSDEV",25,"MRPC155",465)

^DBTBL("SYSDEV",25,"MRPC155",466)
	quit val
^DBTBL("SYSDEV",25,"MRPC155",467)

^DBTBL("SYSDEV",25,"MRPC155",468)

^DBTBL("SYSDEV",25,"MRPC155",469)
wrtRow(String rd, String hdg, Boolean isHTML, String pars(), Number break, Number line, Boolean altbg, Number IOSL, Number IORM, Number PN)	// Output a row
^DBTBL("SYSDEV",25,"MRPC155",470)

^DBTBL("SYSDEV",25,"MRPC155",471)
	type literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",472)

^DBTBL("SYSDEV",25,"MRPC155",473)
	if ((isHTML = true) & altbg & (line#2)) set rd = "<tr class=d1" _ rd.extract("<tr>".length(),rd.length())
^DBTBL("SYSDEV",25,"MRPC155",474)

^DBTBL("SYSDEV",25,"MRPC155",475)
	if (break & (line > 0)) do {
^DBTBL("SYSDEV",25,"MRPC155",476)

^DBTBL("SYSDEV",25,"MRPC155",477)
		if (break < 0) do {	quit				// Form-Feed value (-1)
^DBTBL("SYSDEV",25,"MRPC155",478)

^DBTBL("SYSDEV",25,"MRPC155",479)
			if IOSL.isNull() set IOSL = 0			// No heading - just FF
^DBTBL("SYSDEV",25,"MRPC155",480)
			else  set line = (IOSL + 1)			// Force heading & FF
^DBTBL("SYSDEV",25,"MRPC155",481)
			set break = 0
^DBTBL("SYSDEV",25,"MRPC155",482)
		}
^DBTBL("SYSDEV",25,"MRPC155",483)

^DBTBL("SYSDEV",25,"MRPC155",484)
		if (isHTML = true) set rd = ("<tr>" _ rd)	
^DBTBL("SYSDEV",25,"MRPC155",485)
		else  set rd = "".justify(break,1,LF) _ rd, line = (line + break)
^DBTBL("SYSDEV",25,"MRPC155",486)
	}
^DBTBL("SYSDEV",25,"MRPC155",487)

^DBTBL("SYSDEV",25,"MRPC155",488)
	if isHTML set line = line + 1
^DBTBL("SYSDEV",25,"MRPC155",489)
	else  set line = (line + rd.length(LF) - 1)			// Consider overflow
^DBTBL("SYSDEV",25,"MRPC155",490)

^DBTBL("SYSDEV",25,"MRPC155",491)
	if 'IOSL.isNull() & (line > IOSL) do {
^DBTBL("SYSDEV",25,"MRPC155",492)

^DBTBL("SYSDEV",25,"MRPC155",493)
		if break set rd = rd.piece(LF,(break + 1),rd.length())	// Remove break Linefeed on new page
^DBTBL("SYSDEV",25,"MRPC155",494)
 
^DBTBL("SYSDEV",25,"MRPC155",495)
		set PN = (PN + 1)
^DBTBL("SYSDEV",25,"MRPC155",496)

^DBTBL("SYSDEV",25,"MRPC155",497)
		set hdg = $$title(.pars(), isHTML, IORM, PN) _ hdg
^DBTBL("SYSDEV",25,"MRPC155",498)

^DBTBL("SYSDEV",25,"MRPC155",499)
		if (IOSL  = 0) do {
^DBTBL("SYSDEV",25,"MRPC155",500)
			set IOSL = pars("PAGE").get()		// First line
^DBTBL("SYSDEV",25,"MRPC155",501)
			if isHTML set hdg = (LF _ "<thead>" _ LF _ "<tr>" _ hdg _ LF _ "<tbody>")
^DBTBL("SYSDEV",25,"MRPC155",502)
		}
^DBTBL("SYSDEV",25,"MRPC155",503)

^DBTBL("SYSDEV",25,"MRPC155",504)
		else  set hdg = ($s(isHTML:"<tr>",1:$c(12)) _ hdg)	// Form-feed
^DBTBL("SYSDEV",25,"MRPC155",505)

^DBTBL("SYSDEV",25,"MRPC155",506)
		set line = $s(isHTML:1,1:hdg.length(LF))
^DBTBL("SYSDEV",25,"MRPC155",507)
		set rd = (hdg _ rd)
^DBTBL("SYSDEV",25,"MRPC155",508)
	}
^DBTBL("SYSDEV",25,"MRPC155",509)

^DBTBL("SYSDEV",25,"MRPC155",510)
	do writeln(rd)
^DBTBL("SYSDEV",25,"MRPC155",511)
	quit
^DBTBL("SYSDEV",25,"MRPC155",512)

^DBTBL("SYSDEV",25,"MRPC155",513)

^DBTBL("SYSDEV",25,"MRPC155",514)

^DBTBL("SYSDEV",25,"MRPC155",515)
protect(String sqldta, String sqlind)	// Set protected columns to Null
^DBTBL("SYSDEV",25,"MRPC155",516)

^DBTBL("SYSDEV",25,"MRPC155",517)
	type Number y = 0
^DBTBL("SYSDEV",25,"MRPC155",518)
	for  set y = sqlind.find(1,y) quit:y = 0  set sqldta.piece($c(9),y - 1) = ""
^DBTBL("SYSDEV",25,"MRPC155",519)
	quit sqldta
^DBTBL("SYSDEV",25,"MRPC155",520)

^DBTBL("SYSDEV",25,"MRPC155",521)

^DBTBL("SYSDEV",25,"MRPC155",522)
title(String pars(), Boolean isHTML, Number IORM, Number PN)	// Display title
^DBTBL("SYSDEV",25,"MRPC155",523)
	
^DBTBL("SYSDEV",25,"MRPC155",524)
	// This is a structured element that was is created by the bldTitle procedure
^DBTBL("SYSDEV",25,"MRPC155",525)

^DBTBL("SYSDEV",25,"MRPC155",526)
	type Literal String DR = $c(0)				// Delimiter - Record
^DBTBL("SYSDEV",25,"MRPC155",527)
	type Literal String DF = $c(1)				// Delimiter - Field
^DBTBL("SYSDEV",25,"MRPC155",528)
	type Literal String TAB = $c(9)
^DBTBL("SYSDEV",25,"MRPC155",529)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",530)

^DBTBL("SYSDEV",25,"MRPC155",531)
	type String x,dec,fmt,var,typ,style
^DBTBL("SYSDEV",25,"MRPC155",532)
	type Number i
^DBTBL("SYSDEV",25,"MRPC155",533)

^DBTBL("SYSDEV",25,"MRPC155",534)
	type String title = pars("title").get()
^DBTBL("SYSDEV",25,"MRPC155",535)
	if title.isNull()  quit ""
^DBTBL("SYSDEV",25,"MRPC155",536)

^DBTBL("SYSDEV",25,"MRPC155",537)
	// Perform Variable substitution in title
^DBTBL("SYSDEV",25,"MRPC155",538)

^DBTBL("SYSDEV",25,"MRPC155",539)
	type List vars
^DBTBL("SYSDEV",25,"MRPC155",540)

^DBTBL("SYSDEV",25,"MRPC155",541)
	set vars = title.piece(DR,1), title = title.piece(DR, 2, title.length())
^DBTBL("SYSDEV",25,"MRPC155",542)

^DBTBL("SYSDEV",25,"MRPC155",543)
	for i = 1:1:vars.length(DF) do {
^DBTBL("SYSDEV",25,"MRPC155",544)

^DBTBL("SYSDEV",25,"MRPC155",545)
		set x = vars.piece(DF,i)			// Get the variable
^DBTBL("SYSDEV",25,"MRPC155",546)

^DBTBL("SYSDEV",25,"MRPC155",547)
		set typ = x.piece("|",2), dec = x.piece("|",3), style = x.piece("|",4), fmt = x.piece("|",5)
^DBTBL("SYSDEV",25,"MRPC155",548)

^DBTBL("SYSDEV",25,"MRPC155",549)
		#ACCEPT DATE=12/04/07; PGM=Frank Sanchez; CR=unknown
^DBTBL("SYSDEV",25,"MRPC155",550)
		xecute ("set var=" _ x.piece("|",1))
^DBTBL("SYSDEV",25,"MRPC155",551)

^DBTBL("SYSDEV",25,"MRPC155",552)
		if ("N$".contains(typ)) set var = $$NUM^%ZM(var,dec,fmt)
^DBTBL("SYSDEV",25,"MRPC155",553)
		else  if (typ = "D") set var = $$DAT^%ZM(var,fmt)
^DBTBL("SYSDEV",25,"MRPC155",554)
		else  if (typ = "L") set var = $$LOG^%ZM(var,fmt)
^DBTBL("SYSDEV",25,"MRPC155",555)
		else  if (typ = "C") set var = $$TIM^%ZM(var,fmt)
^DBTBL("SYSDEV",25,"MRPC155",556)

^DBTBL("SYSDEV",25,"MRPC155",557)
		if 'style.isNull() & isHTML  set var = "<span style="_ style.addQuotes() _ ">" _ var _ "</span>"
^DBTBL("SYSDEV",25,"MRPC155",558)

^DBTBL("SYSDEV",25,"MRPC155",559)
		set title = title.piece(DF,1) _ var _ title.piece(DF, 2, title.length())
^DBTBL("SYSDEV",25,"MRPC155",560)

^DBTBL("SYSDEV",25,"MRPC155",561)
		}
^DBTBL("SYSDEV",25,"MRPC155",562)
	
^DBTBL("SYSDEV",25,"MRPC155",563)
	if ('isHTML & title.contains(TAB)) do {				// Adjust padding for variables, right float
^DBTBL("SYSDEV",25,"MRPC155",564)

^DBTBL("SYSDEV",25,"MRPC155",565)
		type Number i
^DBTBL("SYSDEV",25,"MRPC155",566)
		for i = 1:1:title.length(LF) do {
^DBTBL("SYSDEV",25,"MRPC155",567)

^DBTBL("SYSDEV",25,"MRPC155",568)
			set x = title.piece(LF,i)
^DBTBL("SYSDEV",25,"MRPC155",569)
			if x.contains(TAB) do {
^DBTBL("SYSDEV",25,"MRPC155",570)
				set x = x.piece(TAB,1) _ "".justify(IORM - x.length() + 1) _ x.piece(TAB,2)
^DBTBL("SYSDEV",25,"MRPC155",571)
				set title.piece(LF,i) = x
^DBTBL("SYSDEV",25,"MRPC155",572)
			}
^DBTBL("SYSDEV",25,"MRPC155",573)
		}
^DBTBL("SYSDEV",25,"MRPC155",574)
	}
^DBTBL("SYSDEV",25,"MRPC155",575)

^DBTBL("SYSDEV",25,"MRPC155",576)
	quit title
^DBTBL("SYSDEV",25,"MRPC155",577)

^DBTBL("SYSDEV",25,"MRPC155",578)

^DBTBL("SYSDEV",25,"MRPC155",579)
close(String cursor, Boolean isHTML, String IO, Number sqlcnt, Boolean complete)
^DBTBL("SYSDEV",25,"MRPC155",580)

^DBTBL("SYSDEV",25,"MRPC155",581)

^DBTBL("SYSDEV",25,"MRPC155",582)
	do CLOSE^SQLM(cursor)                                           // Close SQL cursor
^DBTBL("SYSDEV",25,"MRPC155",583)

^DBTBL("SYSDEV",25,"MRPC155",584)
	if (isHTML = true) do writeln("</table>")
^DBTBL("SYSDEV",25,"MRPC155",585)

^DBTBL("SYSDEV",25,"MRPC155",586)
	if (complete = true) do paragraph("Complete :> "_ sqlcnt _ " rows processed.", "RS", isHTML)
^DBTBL("SYSDEV",25,"MRPC155",587)
	quit
^DBTBL("SYSDEV",25,"MRPC155",588)

^DBTBL("SYSDEV",25,"MRPC155",589)

^DBTBL("SYSDEV",25,"MRPC155",590)
border(String col(), String chr)	// Return border break line
^DBTBL("SYSDEV",25,"MRPC155",591)

^DBTBL("SYSDEV",25,"MRPC155",592)
	// This function returns a formatted plain text line
^DBTBL("SYSDEV",25,"MRPC155",593)

^DBTBL("SYSDEV",25,"MRPC155",594)
	type Literal String COLPAR = "length,type,decimal,format,align,merge,space,math,wrap,repeat,null,break,style,heading,name"
^DBTBL("SYSDEV",25,"MRPC155",595)

^DBTBL("SYSDEV",25,"MRPC155",596)
	type Number I
^DBTBL("SYSDEV",25,"MRPC155",597)
	type Number cptr = 0
^DBTBL("SYSDEV",25,"MRPC155",598)
	type Row colrec
^DBTBL("SYSDEV",25,"MRPC155",599)
	type String d = ""
^DBTBL("SYSDEV",25,"MRPC155",600)

^DBTBL("SYSDEV",25,"MRPC155",601)
	set d = ""
^DBTBL("SYSDEV",25,"MRPC155",602)
	for I = 1:1:col do {
^DBTBL("SYSDEV",25,"MRPC155",603)

^DBTBL("SYSDEV",25,"MRPC155",604)
		set colrec = col(I).toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",605)

^DBTBL("SYSDEV",25,"MRPC155",606)
		if '(colrec.length & colrec.merge.isNull()) quit
^DBTBL("SYSDEV",25,"MRPC155",607)

^DBTBL("SYSDEV",25,"MRPC155",608)
 		if (cptr > 0) set d = (d _ "".justify(cptr - d.length()))
^DBTBL("SYSDEV",25,"MRPC155",609)
		set d = d _ "".justify(colrec.length, "", chr)
^DBTBL("SYSDEV",25,"MRPC155",610)
		set cptr = (cptr + colrec.length + colrec.space)
^DBTBL("SYSDEV",25,"MRPC155",611)
	}
^DBTBL("SYSDEV",25,"MRPC155",612)

^DBTBL("SYSDEV",25,"MRPC155",613)
	quit d
^DBTBL("SYSDEV",25,"MRPC155",614)

^DBTBL("SYSDEV",25,"MRPC155",615)

^DBTBL("SYSDEV",25,"MRPC155",616)
caption(String text, String class, Boolean isHTML, Number length)	// Output a table caption
^DBTBL("SYSDEV",25,"MRPC155",617)

^DBTBL("SYSDEV",25,"MRPC155",618)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",619)
	type Literal String SP = "&nbsp;"
^DBTBL("SYSDEV",25,"MRPC155",620)

^DBTBL("SYSDEV",25,"MRPC155",621)
	if (isHTML = true) set text = "<caption><p class=PSL-" _ class _ ">" _ text.replace("  ",(SP _ SP)).replace(LF,"<BR>") _ "</p></caption>"
^DBTBL("SYSDEV",25,"MRPC155",622)
	else  set text = "*** " _ text _ " ***", text = ("".justify((length - text.length()) \ 2) _ text)
^DBTBL("SYSDEV",25,"MRPC155",623)

^DBTBL("SYSDEV",25,"MRPC155",624)
	do writeln(LF _ text _ LF)
^DBTBL("SYSDEV",25,"MRPC155",625)
	quit
^DBTBL("SYSDEV",25,"MRPC155",626)

^DBTBL("SYSDEV",25,"MRPC155",627)

^DBTBL("SYSDEV",25,"MRPC155",628)
paragraph(String text, String class, Boolean isHTML)	// Output a paragraph
^DBTBL("SYSDEV",25,"MRPC155",629)
	
^DBTBL("SYSDEV",25,"MRPC155",630)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",631)
	type Literal String SP = "&nbsp;"
^DBTBL("SYSDEV",25,"MRPC155",632)

^DBTBL("SYSDEV",25,"MRPC155",633)
	if (isHTML = true) set text = "<p class=PSL-" _ class _ ">" _ text.replace("  ",(SP _ SP)).replace(LF,"<BR>") _ "</p>"
^DBTBL("SYSDEV",25,"MRPC155",634)
	do writeln(LF _ text _ LF)
^DBTBL("SYSDEV",25,"MRPC155",635)
	quit
^DBTBL("SYSDEV",25,"MRPC155",636)

^DBTBL("SYSDEV",25,"MRPC155",637)

^DBTBL("SYSDEV",25,"MRPC155",638)
section(Number length, Boolean isHTML)	// Output a section break (horizontal rule)
^DBTBL("SYSDEV",25,"MRPC155",639)
	
^DBTBL("SYSDEV",25,"MRPC155",640)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",641)

^DBTBL("SYSDEV",25,"MRPC155",642)
	type String text	
^DBTBL("SYSDEV",25,"MRPC155",643)
	if (isHTML = true) set text = "<br><hr /><br>"
^DBTBL("SYSDEV",25,"MRPC155",644)
	else  set text = "".justify($s((length < 80):80,1:length),"","-") 
^DBTBL("SYSDEV",25,"MRPC155",645)
	do writeln(LF _ text _ LF)
^DBTBL("SYSDEV",25,"MRPC155",646)
	quit
^DBTBL("SYSDEV",25,"MRPC155",647)

^DBTBL("SYSDEV",25,"MRPC155",648)

^DBTBL("SYSDEV",25,"MRPC155",649)
totals(String tot(), String hdg, String col(), Boolean isHTML, Number IOSL, Number IORM, Number line, Boolean altbg, Number PN, String pars())	// output totals
^DBTBL("SYSDEV",25,"MRPC155",650)

^DBTBL("SYSDEV",25,"MRPC155",651)
	if tot("").order().isNull() quit
^DBTBL("SYSDEV",25,"MRPC155",652)
 
^DBTBL("SYSDEV",25,"MRPC155",653)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",654)
	type Literal String TAB = $c(9)
^DBTBL("SYSDEV",25,"MRPC155",655)
	type Literal String COLPAR = "length,type,decimal,format,align,merge,space,math,wrap,repeat,null,break,style,heading,title,minus"
^DBTBL("SYSDEV",25,"MRPC155",656)
	type Number I,i,break,colNum
^DBTBL("SYSDEV",25,"MRPC155",657)
	type String fl,func,rd,row(),x,xcol(),z
^DBTBL("SYSDEV",25,"MRPC155",658)
	type Row accum,colrec
^DBTBL("SYSDEV",25,"MRPC155",659)

^DBTBL("SYSDEV",25,"MRPC155",660)
	set xcol = col
^DBTBL("SYSDEV",25,"MRPC155",661)

^DBTBL("SYSDEV",25,"MRPC155",662)
	// Lay out the row / function map
^DBTBL("SYSDEV",25,"MRPC155",663)
	for I = 1:1:col  do {
^DBTBL("SYSDEV",25,"MRPC155",664)

^DBTBL("SYSDEV",25,"MRPC155",665)
		set colrec = col(I).toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",666)
		
^DBTBL("SYSDEV",25,"MRPC155",667)
		set fl = colrec.math		// function list
^DBTBL("SYSDEV",25,"MRPC155",668)

^DBTBL("SYSDEV",25,"MRPC155",669)
		if fl.isNull() quit
^DBTBL("SYSDEV",25,"MRPC155",670)

^DBTBL("SYSDEV",25,"MRPC155",671)
		for i = 1:1:fl.length(";") do {
^DBTBL("SYSDEV",25,"MRPC155",672)
			set x = row(i).get()
^DBTBL("SYSDEV",25,"MRPC155",673)
			set x.piece(TAB,I) = fl.piece(";",i)
^DBTBL("SYSDEV",25,"MRPC155",674)
			set row(i) = x
^DBTBL("SYSDEV",25,"MRPC155",675)
		}
^DBTBL("SYSDEV",25,"MRPC155",676)
	}
^DBTBL("SYSDEV",25,"MRPC155",677)

^DBTBL("SYSDEV",25,"MRPC155",678)
	if row(0).order().isNull() quit
^DBTBL("SYSDEV",25,"MRPC155",679)

^DBTBL("SYSDEV",25,"MRPC155",680)
	// Output underlines or empty row
^DBTBL("SYSDEV",25,"MRPC155",681)
	if (isHTML = true) set break = 1	// In HTML force an empty row
^DBTBL("SYSDEV",25,"MRPC155",682)
	else  do {				// In text mode, output underlines
^DBTBL("SYSDEV",25,"MRPC155",683)
		set rd = ($$border(.col(),"=") _ LF), break = 0
^DBTBL("SYSDEV",25,"MRPC155",684)
		do wrtRow(rd, hdg, isHTML, .pars(), break, .line, altbg, .IOSL, IORM, .PN)
^DBTBL("SYSDEV",25,"MRPC155",685)
	}
^DBTBL("SYSDEV",25,"MRPC155",686)

^DBTBL("SYSDEV",25,"MRPC155",687)
	type String n = ""
^DBTBL("SYSDEV",25,"MRPC155",688)

^DBTBL("SYSDEV",25,"MRPC155",689)
	for  set n = row(n).order() quit:n.isNull()  do {
^DBTBL("SYSDEV",25,"MRPC155",690)

^DBTBL("SYSDEV",25,"MRPC155",691)
		set rd = ""
^DBTBL("SYSDEV",25,"MRPC155",692)
		set colNum = 0
^DBTBL("SYSDEV",25,"MRPC155",693)

^DBTBL("SYSDEV",25,"MRPC155",694)
		// First generate rows to map the functions
^DBTBL("SYSDEV",25,"MRPC155",695)
		for I = 1:1:col  do {
^DBTBL("SYSDEV",25,"MRPC155",696)

^DBTBL("SYSDEV",25,"MRPC155",697)

^DBTBL("SYSDEV",25,"MRPC155",698)
			set colrec = col(I).toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",699)

^DBTBL("SYSDEV",25,"MRPC155",700)
			if ((colrec.length = 0) ! 'colrec.merge.isNull())  quit
^DBTBL("SYSDEV",25,"MRPC155",701)

^DBTBL("SYSDEV",25,"MRPC155",702)
			set colNum = colNum + 1
^DBTBL("SYSDEV",25,"MRPC155",703)
			set func = row(n).piece(TAB,I)
^DBTBL("SYSDEV",25,"MRPC155",704)
	
^DBTBL("SYSDEV",25,"MRPC155",705)
			set colrec.math = "", colrec.break = "", colrec.repeat= "", colrec.null = ""
^DBTBL("SYSDEV",25,"MRPC155",706)
			if func.isNull() set xcol(colNum) = colrec.toString() quit
^DBTBL("SYSDEV",25,"MRPC155",707)

^DBTBL("SYSDEV",25,"MRPC155",708)
			set colrec.title = func _ "(" _ $$escape(colrec.title).piece(" ",1) _")"
^DBTBL("SYSDEV",25,"MRPC155",709)

^DBTBL("SYSDEV",25,"MRPC155",710)
			set accum = tot(I).toRow("flags,count,sum,max,min",TAB)
^DBTBL("SYSDEV",25,"MRPC155",711)

^DBTBL("SYSDEV",25,"MRPC155",712)
			if func = "COUNT" set z = accum.count
^DBTBL("SYSDEV",25,"MRPC155",713)
			else  if func = "SUM" set z = accum.sum
^DBTBL("SYSDEV",25,"MRPC155",714)
			else  if func = "MAX" set z = accum.max
^DBTBL("SYSDEV",25,"MRPC155",715)
			else  if func = "MIN" set z = accum.min
^DBTBL("SYSDEV",25,"MRPC155",716)
			else  if func = "AVG" do {
^DBTBL("SYSDEV",25,"MRPC155",717)

^DBTBL("SYSDEV",25,"MRPC155",718)
				if (accum.count > 0) set z = (accum.sum / accum.count)
^DBTBL("SYSDEV",25,"MRPC155",719)
				else  set z = ""
^DBTBL("SYSDEV",25,"MRPC155",720)

^DBTBL("SYSDEV",25,"MRPC155",721)
				if z.contains(".") & colrec.decimal.isNull() set colrec.decimal = 2			
^DBTBL("SYSDEV",25,"MRPC155",722)
			}
^DBTBL("SYSDEV",25,"MRPC155",723)

^DBTBL("SYSDEV",25,"MRPC155",724)
			else  if func = "UNIQUE" do {		// Count unique
^DBTBL("SYSDEV",25,"MRPC155",725)

^DBTBL("SYSDEV",25,"MRPC155",726)
				type Number v = ""
^DBTBL("SYSDEV",25,"MRPC155",727)
				for z = 0:1 set v = tot(I,v).order() quit:v.isNull()
^DBTBL("SYSDEV",25,"MRPC155",728)
			}
^DBTBL("SYSDEV",25,"MRPC155",729)

^DBTBL("SYSDEV",25,"MRPC155",730)
			else  if func = "MED" do {		// Find median
^DBTBL("SYSDEV",25,"MRPC155",731)

^DBTBL("SYSDEV",25,"MRPC155",732)
				type Number t = (accum.count / 2)
^DBTBL("SYSDEV",25,"MRPC155",733)
				type Number c = 0
^DBTBL("SYSDEV",25,"MRPC155",734)
				type Number v = ""
^DBTBL("SYSDEV",25,"MRPC155",735)
				set z = ""
^DBTBL("SYSDEV",25,"MRPC155",736)

^DBTBL("SYSDEV",25,"MRPC155",737)
				for  set v = tot(I,v).order() quit:v.isNull()  set c = (c + tot(I,v)) quit:(c > t)  set z = v
^DBTBL("SYSDEV",25,"MRPC155",738)
				if 'v.isNull() set z = $s(t#1:v,1:((z + v) / 2)))
^DBTBL("SYSDEV",25,"MRPC155",739)

^DBTBL("SYSDEV",25,"MRPC155",740)
				if z.contains(".") & colrec.decimal.isNull() set colrec.decimal = 2
^DBTBL("SYSDEV",25,"MRPC155",741)
			}
^DBTBL("SYSDEV",25,"MRPC155",742)

^DBTBL("SYSDEV",25,"MRPC155",743)
			else  if func = "LEAST" do {		// Find least popular value
^DBTBL("SYSDEV",25,"MRPC155",744)

^DBTBL("SYSDEV",25,"MRPC155",745)
				type Number n = tot(I,"").order() if n.isNull() set z = "" quit
^DBTBL("SYSDEV",25,"MRPC155",746)
				type String v = tot(I,n)
^DBTBL("SYSDEV",25,"MRPC155",747)

^DBTBL("SYSDEV",25,"MRPC155",748)
				set z = n
^DBTBL("SYSDEV",25,"MRPC155",749)
				for  set n = tot(I,n).order() quit:n.isNull()  do {
^DBTBL("SYSDEV",25,"MRPC155",750)
					if (tot(I,n) < v) set v = tot(I,n), z = n
^DBTBL("SYSDEV",25,"MRPC155",751)
					else  if (tot(I,n) = v) set z = (z _ LF _ n)
^DBTBL("SYSDEV",25,"MRPC155",752)
				}
^DBTBL("SYSDEV",25,"MRPC155",753)
			}
^DBTBL("SYSDEV",25,"MRPC155",754)

^DBTBL("SYSDEV",25,"MRPC155",755)
			else  if func = "MOST" do {		// Find most popular value
^DBTBL("SYSDEV",25,"MRPC155",756)

^DBTBL("SYSDEV",25,"MRPC155",757)
				type Number n = tot(I,"").order() if n.isNull() set z = "" quit
^DBTBL("SYSDEV",25,"MRPC155",758)
				type String v = tot(I,n)
^DBTBL("SYSDEV",25,"MRPC155",759)

^DBTBL("SYSDEV",25,"MRPC155",760)
				set z = n
^DBTBL("SYSDEV",25,"MRPC155",761)
				for  set n = tot(I,n).order() quit:n.isNull()  do {
^DBTBL("SYSDEV",25,"MRPC155",762)
					if (tot(I,n) > v) set v = tot(I,n), z = n
^DBTBL("SYSDEV",25,"MRPC155",763)
					else  if (tot(I,n) = v) set z = (z _ LF _ n)
^DBTBL("SYSDEV",25,"MRPC155",764)
				}
^DBTBL("SYSDEV",25,"MRPC155",765)
			}
^DBTBL("SYSDEV",25,"MRPC155",766)

^DBTBL("SYSDEV",25,"MRPC155",767)
			else  if func = "COUNT-LEAST" do {		// Find # occurrances of least popular value
^DBTBL("SYSDEV",25,"MRPC155",768)

^DBTBL("SYSDEV",25,"MRPC155",769)
				type Number v = tot(I,"").order() if v.isNull() set z = "" quit
^DBTBL("SYSDEV",25,"MRPC155",770)
				set z = tot(I,v)
^DBTBL("SYSDEV",25,"MRPC155",771)

^DBTBL("SYSDEV",25,"MRPC155",772)
				for  set v = tot(I,v).order() quit:v.isNull()  if (tot(I,v) < z) set z = tot(I,v)
^DBTBL("SYSDEV",25,"MRPC155",773)
			}
^DBTBL("SYSDEV",25,"MRPC155",774)

^DBTBL("SYSDEV",25,"MRPC155",775)
			else  if func = "COUNT-MOST" do {		// Find # occurrances of most popular value
^DBTBL("SYSDEV",25,"MRPC155",776)

^DBTBL("SYSDEV",25,"MRPC155",777)
				type Number v = tot(I,"").order() if v.isNull() set z = "" quit
^DBTBL("SYSDEV",25,"MRPC155",778)
				set z = tot(I,v)
^DBTBL("SYSDEV",25,"MRPC155",779)

^DBTBL("SYSDEV",25,"MRPC155",780)
				for  set v = tot(I,v).order() quit:v.isNull()  if (tot(I,v) > z) set z = tot(I,v)
^DBTBL("SYSDEV",25,"MRPC155",781)
			}
^DBTBL("SYSDEV",25,"MRPC155",782)

^DBTBL("SYSDEV",25,"MRPC155",783)
			else  if func.beginsWith("t-") do {	// Special 'tie value' syntax
^DBTBL("SYSDEV",25,"MRPC155",784)

^DBTBL("SYSDEV",25,"MRPC155",785)
				set colrec.title = "t-" _ (func.piece("t-",2) - 5) _ "(" _ colrec.title.piece("(",2,999)
^DBTBL("SYSDEV",25,"MRPC155",786)

^DBTBL("SYSDEV",25,"MRPC155",787)
				set z = {String}accum.piece(TAB,func.piece("t-",2))
^DBTBL("SYSDEV",25,"MRPC155",788)
				if "$NDCL".contains(colrec.type) set z = $$EXT^%ZM(z,colrec.format,colrec.decimal), colrec.format = "", colrec.decimal = ""
^DBTBL("SYSDEV",25,"MRPC155",789)
				set z = ("t-" _ z)		//Display ties
^DBTBL("SYSDEV",25,"MRPC155",790)
			}
^DBTBL("SYSDEV",25,"MRPC155",791)

^DBTBL("SYSDEV",25,"MRPC155",792)
			if {List}"COUNT,COUNT-LEAST,COUNT-MOST,UNIQUE".contains(func) set colrec.decimal = ""
^DBTBL("SYSDEV",25,"MRPC155",793)

^DBTBL("SYSDEV",25,"MRPC155",794)
			set xcol(colNum) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",795)

^DBTBL("SYSDEV",25,"MRPC155",796)
			// Results contain more than one value, insert rows to handle and shift down
^DBTBL("SYSDEV",25,"MRPC155",797)
			if z.contains(LF) do {
^DBTBL("SYSDEV",25,"MRPC155",798)

^DBTBL("SYSDEV",25,"MRPC155",799)
				type Number t = 5
^DBTBL("SYSDEV",25,"MRPC155",800)
				type Number r = n
^DBTBL("SYSDEV",25,"MRPC155",801)
				type Number s = ""
^DBTBL("SYSDEV",25,"MRPC155",802)
				type String x,y
^DBTBL("SYSDEV",25,"MRPC155",803)
				type String xaccum = accum.toString()
^DBTBL("SYSDEV",25,"MRPC155",804)

^DBTBL("SYSDEV",25,"MRPC155",805)
				// Shift rows down within this column (start at end)
^DBTBL("SYSDEV",25,"MRPC155",806)
				for  set s = row(s).order(-1) quit:(s = r)  do {
^DBTBL("SYSDEV",25,"MRPC155",807)

^DBTBL("SYSDEV",25,"MRPC155",808)
					set x = row(s)
^DBTBL("SYSDEV",25,"MRPC155",809)
					if x.piece(TAB,I).isNull() quit		// No function for column
^DBTBL("SYSDEV",25,"MRPC155",810)
					set y = row(s + z.length(LF) - 1).get()
^DBTBL("SYSDEV",25,"MRPC155",811)
					set y.piece(TAB,I) = x.piece(TAB,I)
^DBTBL("SYSDEV",25,"MRPC155",812)
					set row(s + z.length(LF) - 1) = y
^DBTBL("SYSDEV",25,"MRPC155",813)
				}
^DBTBL("SYSDEV",25,"MRPC155",814)

^DBTBL("SYSDEV",25,"MRPC155",815)
				for i = 2:1:z.length(LF) do {
^DBTBL("SYSDEV",25,"MRPC155",816)

^DBTBL("SYSDEV",25,"MRPC155",817)
					set t = (t + 1)
^DBTBL("SYSDEV",25,"MRPC155",818)
					set r = (r + 1)
^DBTBL("SYSDEV",25,"MRPC155",819)

^DBTBL("SYSDEV",25,"MRPC155",820)
					type String y = accum.toString()		// PSL error forces this
^DBTBL("SYSDEV",25,"MRPC155",821)
					set xaccum.piece(TAB,t) = z.piece(LF,i)		// Add value to accumm (sic y)
^DBTBL("SYSDEV",25,"MRPC155",822)
					set x = row(r).get()
^DBTBL("SYSDEV",25,"MRPC155",823)
					set x.piece(TAB,I) = ("t-" _ t)
^DBTBL("SYSDEV",25,"MRPC155",824)
					set row(r) = x
^DBTBL("SYSDEV",25,"MRPC155",825)
				}
^DBTBL("SYSDEV",25,"MRPC155",826)

^DBTBL("SYSDEV",25,"MRPC155",827)
				set tot(I) = xaccum
^DBTBL("SYSDEV",25,"MRPC155",828)
				set z = z.piece(LF,1)
^DBTBL("SYSDEV",25,"MRPC155",829)
			}
^DBTBL("SYSDEV",25,"MRPC155",830)

^DBTBL("SYSDEV",25,"MRPC155",831)

^DBTBL("SYSDEV",25,"MRPC155",832)
			set rd.piece(TAB,colNum) = z
^DBTBL("SYSDEV",25,"MRPC155",833)
		}
^DBTBL("SYSDEV",25,"MRPC155",834)

^DBTBL("SYSDEV",25,"MRPC155",835)
		set xcol = colNum
^DBTBL("SYSDEV",25,"MRPC155",836)
		set rd = $$bldRow(rd, .xcol(), isHTML)
^DBTBL("SYSDEV",25,"MRPC155",837)

^DBTBL("SYSDEV",25,"MRPC155",838)
		if (isHTML = true) do {							// Poke titles into columns
^DBTBL("SYSDEV",25,"MRPC155",839)

^DBTBL("SYSDEV",25,"MRPC155",840)
			for I = 1:1:colNum  do {
^DBTBL("SYSDEV",25,"MRPC155",841)

^DBTBL("SYSDEV",25,"MRPC155",842)
				set colrec = xcol(I).get().toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",843)
				if 'colrec.title.isNull() set rd = rd.piece("<td", 1, I) _ "<td title=" _ colrec.title _ rd.piece("<td", I + 1, rd.length())
^DBTBL("SYSDEV",25,"MRPC155",844)
			}
^DBTBL("SYSDEV",25,"MRPC155",845)
		}
^DBTBL("SYSDEV",25,"MRPC155",846)

^DBTBL("SYSDEV",25,"MRPC155",847)
		do wrtRow(rd, hdg, isHTML, .pars(), break, .line, altbg, .IOSL, IORM, PN)
^DBTBL("SYSDEV",25,"MRPC155",848)
		set break = 0
^DBTBL("SYSDEV",25,"MRPC155",849)
	}
^DBTBL("SYSDEV",25,"MRPC155",850)

^DBTBL("SYSDEV",25,"MRPC155",851)
	quit
^DBTBL("SYSDEV",25,"MRPC155",852)

^DBTBL("SYSDEV",25,"MRPC155",853)

^DBTBL("SYSDEV",25,"MRPC155",854)

^DBTBL("SYSDEV",25,"MRPC155",855)
bldcol(String sel, String from, String order, String col(), String xcol(), String pars(), String tok, String fsn(), String vdd())	// Return internal column array
^DBTBL("SYSDEV",25,"MRPC155",856)

^DBTBL("SYSDEV",25,"MRPC155",857)
	// This procedure returns a column array based on the data dictionary 
^DBTBL("SYSDEV",25,"MRPC155",858)
	// and overridden by xcol
^DBTBL("SYSDEV",25,"MRPC155",859)

^DBTBL("SYSDEV",25,"MRPC155",860)
	type Literal String COLPAR = "length,type,decimal,format,align,merge,space,math,wrap,repeat,null,break,style,heading,title,minus"
^DBTBL("SYSDEV",25,"MRPC155",861)
	type Literal String CLASSES = "blob,logical,currency,date,frequency,memo,number,text,time,upper"
^DBTBL("SYSDEV",25,"MRPC155",862)
	type Literal String TAB = $c(9)
^DBTBL("SYSDEV",25,"MRPC155",863)

^DBTBL("SYSDEV",25,"MRPC155",864)
	type Public Number ER
^DBTBL("SYSDEV",25,"MRPC155",865)
	type String RM = ""
^DBTBL("SYSDEV",25,"MRPC155",866)

^DBTBL("SYSDEV",25,"MRPC155",867)
	set from = $$^SQLJ(from,,.fsn,,.tok) 
^DBTBL("SYSDEV",25,"MRPC155",868)
	if ER do ERROR(RM) quit
^DBTBL("SYSDEV",25,"MRPC155",869)

^DBTBL("SYSDEV",25,"MRPC155",870)
	type Number length,ptr
^DBTBL("SYSDEV",25,"MRPC155",871)
	type String agf,att,align,break,class,datatype,format,name,hdg,str,style,title,n,p,x,z
^DBTBL("SYSDEV",25,"MRPC155",872)
        type Row colrec,forext,schema
^DBTBL("SYSDEV",25,"MRPC155",873)

^DBTBL("SYSDEV",25,"MRPC155",874)
	type Boolean isError = false					// Group error indicator
^DBTBL("SYSDEV",25,"MRPC155",875)
	
^DBTBL("SYSDEV",25,"MRPC155",876)
	// Initialize format to %MSK global formats
^DBTBL("SYSDEV",25,"MRPC155",877)
	
^DBTBL("SYSDEV",25,"MRPC155",878)
	type String dftAtts = $$dftFormat()				// Initialize %MASK global formats
^DBTBL("SYSDEV",25,"MRPC155",879)
	if pars("COLS").exists() set dftAtts = dftAtts _ "," _  pars("COLS")
^DBTBL("SYSDEV",25,"MRPC155",880)

^DBTBL("SYSDEV",25,"MRPC155",881)
	type String zpars(),gcol()
^DBTBL("SYSDEV",25,"MRPC155",882)
	do parse(dftAtts, .zpars(), ",", "=", false, "none", "default", COLPAR)
^DBTBL("SYSDEV",25,"MRPC155",883)

^DBTBL("SYSDEV",25,"MRPC155",884)
	/* To simplify lookup and cascading logic, copy attributes into records
^DBTBL("SYSDEV",25,"MRPC155",885)
	   keyed by class in the same structure as the column record.  Then merge
^DBTBL("SYSDEV",25,"MRPC155",886)
	   root attributes with class attributes.
^DBTBL("SYSDEV",25,"MRPC155",887)
	*/
^DBTBL("SYSDEV",25,"MRPC155",888)

^DBTBL("SYSDEV",25,"MRPC155",889)
	set n = ""
^DBTBL("SYSDEV",25,"MRPC155",890)
	for  set n = zpars(n).order() quit:n.isNull()  do {
^DBTBL("SYSDEV",25,"MRPC155",891)

^DBTBL("SYSDEV",25,"MRPC155",892)
		if ER set isError = true, ER = 0		// Mark error & continue
^DBTBL("SYSDEV",25,"MRPC155",893)

^DBTBL("SYSDEV",25,"MRPC155",894)
		set class = n.piece(".",1), att = n.piece(".",2)
^DBTBL("SYSDEV",25,"MRPC155",895)
		set z = zpars(n) 
^DBTBL("SYSDEV",25,"MRPC155",896)

^DBTBL("SYSDEV",25,"MRPC155",897)
		if att.isNull() set att = class, class = "."
^DBTBL("SYSDEV",25,"MRPC155",898)
		else  if class.isNull() set class = "."
^DBTBL("SYSDEV",25,"MRPC155",899)

^DBTBL("SYSDEV",25,"MRPC155",900)
		set p = {List}COLPAR.position(att)
^DBTBL("SYSDEV",25,"MRPC155",901)
		if 'p do ERROR("Invalid Column Parameter",n) quit
^DBTBL("SYSDEV",25,"MRPC155",902)

^DBTBL("SYSDEV",25,"MRPC155",903)
		if (z = "default") set z = ",,,,, ,2,,1,1,,1,,".piece(",",p)
^DBTBL("SYSDEV",25,"MRPC155",904)

^DBTBL("SYSDEV",25,"MRPC155",905)
		// Save for title or other formatting if necessary
^DBTBL("SYSDEV",25,"MRPC155",906)
		if (att = "format") set pars(class _ "." _ att) = z
^DBTBL("SYSDEV",25,"MRPC155",907)

^DBTBL("SYSDEV",25,"MRPC155",908)
		//if z.piece(":",2,2,"""").isNull() set z = "mask:" _ z 
^DBTBL("SYSDEV",25,"MRPC155",909)

^DBTBL("SYSDEV",25,"MRPC155",910)
		// Move this into the appropriate column in gcol
^DBTBL("SYSDEV",25,"MRPC155",911)
		set x = gcol(class).get(), x.piece("|",p) = z, gcol(class) = x
^DBTBL("SYSDEV",25,"MRPC155",912)

^DBTBL("SYSDEV",25,"MRPC155",913)

^DBTBL("SYSDEV",25,"MRPC155",914)
	}
^DBTBL("SYSDEV",25,"MRPC155",915)

^DBTBL("SYSDEV",25,"MRPC155",916)

^DBTBL("SYSDEV",25,"MRPC155",917)
	if 'gcol(".").get().isNull() do {			// Merge Root & classes
^DBTBL("SYSDEV",25,"MRPC155",918)

^DBTBL("SYSDEV",25,"MRPC155",919)
		type Number i
^DBTBL("SYSDEV",25,"MRPC155",920)
		type Number n = "."
^DBTBL("SYSDEV",25,"MRPC155",921)

^DBTBL("SYSDEV",25,"MRPC155",922)
		type String x,z 
^DBTBL("SYSDEV",25,"MRPC155",923)
		set x = gcol(".")				// Root class record
^DBTBL("SYSDEV",25,"MRPC155",924)

^DBTBL("SYSDEV",25,"MRPC155",925)
		for  set n = gcol(n).order() quit:n.isNull()  do {
^DBTBL("SYSDEV",25,"MRPC155",926)

^DBTBL("SYSDEV",25,"MRPC155",927)
			set z = gcol(n)				// Class record
^DBTBL("SYSDEV",25,"MRPC155",928)
			for i=1:1:x.length("|") if 'x.piece("|",i).isNull() set z.piece("|",i) = $$mergeProperties(x.piece("|",i), z.piece("|",i))
^DBTBL("SYSDEV",25,"MRPC155",929)
			set gcol(n) = z
^DBTBL("SYSDEV",25,"MRPC155",930)
		}
^DBTBL("SYSDEV",25,"MRPC155",931)
	}
^DBTBL("SYSDEV",25,"MRPC155",932)

^DBTBL("SYSDEV",25,"MRPC155",933)
	if (isError = true) set ER = 1
^DBTBL("SYSDEV",25,"MRPC155",934)

^DBTBL("SYSDEV",25,"MRPC155",935)
	if ER quit
^DBTBL("SYSDEV",25,"MRPC155",936)

^DBTBL("SYSDEV",25,"MRPC155",937)
	if pars("BREAK").exists() do {				// Initialize orderby to set-up auto break
^DBTBL("SYSDEV",25,"MRPC155",938)

^DBTBL("SYSDEV",25,"MRPC155",939)
		type string table = from.piece(",",1)
^DBTBL("SYSDEV",25,"MRPC155",940)
		type String keys = fsn(table).piece("|",3)
^DBTBL("SYSDEV",25,"MRPC155",941)

^DBTBL("SYSDEV",25,"MRPC155",942)
		if order.isNull() set order = keys
^DBTBL("SYSDEV",25,"MRPC155",943)

^DBTBL("SYSDEV",25,"MRPC155",944)
		for col = 1:1:order.length(",") do { if ER quit
^DBTBL("SYSDEV",25,"MRPC155",945)
			set str = order.piece(",",col).piece(" ",1).trim()
^DBTBL("SYSDEV",25,"MRPC155",946)
			set str = $$MCOL^SQLCOL(str, from,,,, .fsn , , , .tok, .vdd, 1)
^DBTBL("SYSDEV",25,"MRPC155",947)
			set order.piece(",",col) = str.piece($c(1),2)	
^DBTBL("SYSDEV",25,"MRPC155",948)
		}
^DBTBL("SYSDEV",25,"MRPC155",949)

^DBTBL("SYSDEV",25,"MRPC155",950)
		if order.piece(",",col) = (table _ "." _ keys.piece(",",keys.length(","))) set order = order.piece(",",1,order.length(",") - 1)
^DBTBL("SYSDEV",25,"MRPC155",951)
	}
^DBTBL("SYSDEV",25,"MRPC155",952)

^DBTBL("SYSDEV",25,"MRPC155",953)
	set ptr = 0
^DBTBL("SYSDEV",25,"MRPC155",954)

^DBTBL("SYSDEV",25,"MRPC155",955)
        for col = 1:1 set str = $$GETCOL^SQLCOL(sel,.ptr) do { if (ptr > sel.length()) quit
^DBTBL("SYSDEV",25,"MRPC155",956)

^DBTBL("SYSDEV",25,"MRPC155",957)
		if ER set isError = true, ER = 0			// Mark error & continue
^DBTBL("SYSDEV",25,"MRPC155",958)

^DBTBL("SYSDEV",25,"MRPC155",959)
		set colrec = "".toRow(COLPAR,"|")			// Initialize column record
^DBTBL("SYSDEV",25,"MRPC155",960)
		set length = "", datatype = ""
^DBTBL("SYSDEV",25,"MRPC155",961)

^DBTBL("SYSDEV",25,"MRPC155",962)
		// For aggregate functions, get the root column
^DBTBL("SYSDEV",25,"MRPC155",963)
		if str.contains("(") set agf = str.piece("(",1), str = str.piece("(",2).piece(")",1)
^DBTBL("SYSDEV",25,"MRPC155",964)
		else  set agf = ""
^DBTBL("SYSDEV",25,"MRPC155",965)

^DBTBL("SYSDEV",25,"MRPC155",966)
		set str = $$MCOL^SQLCOL(str, from, .length, .datatype,, .fsn , , , .tok, .vdd, 1)
^DBTBL("SYSDEV",25,"MRPC155",967)
		if ER do ERROR(RM) quit
^DBTBL("SYSDEV",25,"MRPC155",968)

^DBTBL("SYSDEV",25,"MRPC155",969)
		if length.isNull() set length = str.length()
^DBTBL("SYSDEV",25,"MRPC155",970)
		if datatype.isNull() set datatype = $s(str=+str:"N",1:"T")
^DBTBL("SYSDEV",25,"MRPC155",971)

^DBTBL("SYSDEV",25,"MRPC155",972)
		set class = $$getClass(datatype)
^DBTBL("SYSDEV",25,"MRPC155",973)

^DBTBL("SYSDEV",25,"MRPC155",974)
		/* Cascading precedence is: 1) [columnQualifiers] 
^DBTBL("SYSDEV",25,"MRPC155",975)
                                            2) /COLS=StatementQualifiers
^DBTBL("SYSDEV",25,"MRPC155",976)
                                            3) /TEMPLATE=templates 
^DBTBL("SYSDEV",25,"MRPC155",977)
                                            4) Data-Qwik schema [DBTB1D] and format defaults from %MSK*
^DBTBL("SYSDEV",25,"MRPC155",978)
		*/
^DBTBL("SYSDEV",25,"MRPC155",979)

^DBTBL("SYSDEV",25,"MRPC155",980)
		set forext = xcol(col).get().toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",981)
		if 'forext.type.isNull() set class = forext.type.lowerCase(), datatype = $$getType(class)
^DBTBL("SYSDEV",25,"MRPC155",982)

^DBTBL("SYSDEV",25,"MRPC155",983)
		set forext = $$getColAtts(class, .gcol(), forext.toString()).toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",984)
		
^DBTBL("SYSDEV",25,"MRPC155",985)
		// Support one global shift of datatype - could be implemented to be recursive (trap a-->b-->a)
^DBTBL("SYSDEV",25,"MRPC155",986)
		if '(forext.type.isNull() ! (forext.type.lowerCase() = class)) do {
^DBTBL("SYSDEV",25,"MRPC155",987)

^DBTBL("SYSDEV",25,"MRPC155",988)
			set class = forext.type.lowerCase(), datatype = $$getType(class)
^DBTBL("SYSDEV",25,"MRPC155",989)
			set forext = $$getColAtts(class, .gcol(), forext.toString()).toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",990)
		}
^DBTBL("SYSDEV",25,"MRPC155",991)

^DBTBL("SYSDEV",25,"MRPC155",992)
		if datatype.isNull() do ERROR("Invalid DataType",class) quit
^DBTBL("SYSDEV",25,"MRPC155",993)

^DBTBL("SYSDEV",25,"MRPC155",994)
		set colrec.type = datatype
^DBTBL("SYSDEV",25,"MRPC155",995)
	
^DBTBL("SYSDEV",25,"MRPC155",996)
		if str.contains($c(1)) set name = str.piece($c(1),2)
^DBTBL("SYSDEV",25,"MRPC155",997)
		else  set name = str
^DBTBL("SYSDEV",25,"MRPC155",998)

^DBTBL("SYSDEV",25,"MRPC155",999)
		set schema = vdd(name).get().toRow("nod,len,dft,dom,tbl,ptn,,,typ,des,,min,max,dec,req,cmp,,ofs,siz,del,pos,rhd,,,ltd","|")
^DBTBL("SYSDEV",25,"MRPC155",1000)

^DBTBL("SYSDEV",25,"MRPC155",1001)

^DBTBL("SYSDEV",25,"MRPC155",1002)
		set hdg = forext.heading					// User attribute input
^DBTBL("SYSDEV",25,"MRPC155",1003)
		if (hdg = "none") set hdg = ""
^DBTBL("SYSDEV",25,"MRPC155",1004)
		else  if hdg.isNull() set hdg = schema.rhd.translate("@"," ").trim() if 'agf.isNull() set hdg = agf _ " " _ hdg
^DBTBL("SYSDEV",25,"MRPC155",1005)
		set colrec.heading = hdg
^DBTBL("SYSDEV",25,"MRPC155",1006)

^DBTBL("SYSDEV",25,"MRPC155",1007)

^DBTBL("SYSDEV",25,"MRPC155",1008)
		set title = forext.title					// User attribute input
^DBTBL("SYSDEV",25,"MRPC155",1009)
		if (title = "none") set title = ""
^DBTBL("SYSDEV",25,"MRPC155",1010)
		else  if title.isNull() do {
^DBTBL("SYSDEV",25,"MRPC155",1011)

^DBTBL("SYSDEV",25,"MRPC155",1012)
			if 'agf.isNull() set name = (agf _ "(" _ name _ ")")
^DBTBL("SYSDEV",25,"MRPC155",1013)

^DBTBL("SYSDEV",25,"MRPC155",1014)
			set title = name  _ " " _ class
^DBTBL("SYSDEV",25,"MRPC155",1015)

^DBTBL("SYSDEV",25,"MRPC155",1016)
			if '"BLDCM".contains(datatype) do {			// Add length and decimal schema values
^DBTBL("SYSDEV",25,"MRPC155",1017)

^DBTBL("SYSDEV",25,"MRPC155",1018)
				set title = title _ "(" _ schema.len
^DBTBL("SYSDEV",25,"MRPC155",1019)

^DBTBL("SYSDEV",25,"MRPC155",1020)
				if 'schema.dec.isNull() set title = title _ "," _ schema.dec
^DBTBL("SYSDEV",25,"MRPC155",1021)
				set title = title _ ")"
^DBTBL("SYSDEV",25,"MRPC155",1022)
			}
^DBTBL("SYSDEV",25,"MRPC155",1023)

^DBTBL("SYSDEV",25,"MRPC155",1024)
			if schema.nod.contains("*") set title = title _ " Primary-Key"
^DBTBL("SYSDEV",25,"MRPC155",1025)
			if 'schema.tbl.isNull() do {
^DBTBL("SYSDEV",25,"MRPC155",1026)

^DBTBL("SYSDEV",25,"MRPC155",1027)
				if schema.tbl.beginsWith("[") set title = title _ " Table-Ref: " _ schema.tbl.piece("[",2).piece("]",1)
^DBTBL("SYSDEV",25,"MRPC155",1028)
				if schema.tbl.beginsWith(",") set title = title _ " Enum-List: " _ schema.tbl.extract(2,999).addQuotes()
^DBTBL("SYSDEV",25,"MRPC155",1029)
			}
^DBTBL("SYSDEV",25,"MRPC155",1030)

^DBTBL("SYSDEV",25,"MRPC155",1031)
			if 'schema.cmp.isNull() set title = title _ " Computed: " _ schema.cmp
^DBTBL("SYSDEV",25,"MRPC155",1032)
		}
^DBTBL("SYSDEV",25,"MRPC155",1033)
		set colrec.title = title
^DBTBL("SYSDEV",25,"MRPC155",1034)

^DBTBL("SYSDEV",25,"MRPC155",1035)
		// Length can be set to zero to hide the column (no output)
^DBTBL("SYSDEV",25,"MRPC155",1036)
		if 'forext.length.isNull() set length = forext.length		// User attribute input
^DBTBL("SYSDEV",25,"MRPC155",1037)
		if (length = "none") set length = 0
^DBTBL("SYSDEV",25,"MRPC155",1038)
		if (length = 0) set forext.space = 0, forext.math = ""		// Hidden column
^DBTBL("SYSDEV",25,"MRPC155",1039)
		set colrec.length = length
^DBTBL("SYSDEV",25,"MRPC155",1040)

^DBTBL("SYSDEV",25,"MRPC155",1041)

^DBTBL("SYSDEV",25,"MRPC155",1042)
		set align = $S("CLDF".contains(datatype):"center","N$".contains(datatype):"right",1:"")
^DBTBL("SYSDEV",25,"MRPC155",1043)
		if 'forext.align.isNull() set align = forext.align.lowerCase()
^DBTBL("SYSDEV",25,"MRPC155",1044)
		if (align = "left" ! (align = "none")) set align = ""		// Always default in output
^DBTBL("SYSDEV",25,"MRPC155",1045)
		set colrec.align = align
^DBTBL("SYSDEV",25,"MRPC155",1046)

^DBTBL("SYSDEV",25,"MRPC155",1047)
		set break = forext.break					// User attribute input
^DBTBL("SYSDEV",25,"MRPC155",1048)
		if (break = "none") set break = 0
^DBTBL("SYSDEV",25,"MRPC155",1049)
		else  if (break.isNull() & pars("BREAK").exists()) set break = $s((order.piece(",",col) = name):pars("BREAK"),1:0)
^DBTBL("SYSDEV",25,"MRPC155",1050)
		if (break = "page") set break = -1
^DBTBL("SYSDEV",25,"MRPC155",1051)
		set colrec.break = break
^DBTBL("SYSDEV",25,"MRPC155",1052)

^DBTBL("SYSDEV",25,"MRPC155",1053)
		set style = forext.style
^DBTBL("SYSDEV",25,"MRPC155",1054)
		if (style = "none") set style = ""
^DBTBL("SYSDEV",25,"MRPC155",1055)
		else  if 'style.isNull() do {
^DBTBL("SYSDEV",25,"MRPC155",1056)

^DBTBL("SYSDEV",25,"MRPC155",1057)
			set z = style.getSub("minus-color", ";",":")
^DBTBL("SYSDEV",25,"MRPC155",1058)
			if 'z.isNull() set style = $$remProperty(style,"minus-color"), colrec.minus = "color:" _ z
^DBTBL("SYSDEV",25,"MRPC155",1059)
		}
^DBTBL("SYSDEV",25,"MRPC155",1060)
		set colrec.style = style
^DBTBL("SYSDEV",25,"MRPC155",1061)

^DBTBL("SYSDEV",25,"MRPC155",1062)
		set format = forext.format					// User attribute input
^DBTBL("SYSDEV",25,"MRPC155",1063)
		if (format = "none") set colrec.format = "", colrec.decimal = ""
^DBTBL("SYSDEV",25,"MRPC155",1064)
		else  do {
^DBTBL("SYSDEV",25,"MRPC155",1065)
			set colrec.decimal = $$getProperty("decimal-size", format, schema.dec)
^DBTBL("SYSDEV",25,"MRPC155",1066)
			set colrec.format = $$getFormat(class, format)
^DBTBL("SYSDEV",25,"MRPC155",1067)
		}
^DBTBL("SYSDEV",25,"MRPC155",1068)

^DBTBL("SYSDEV",25,"MRPC155",1069)

^DBTBL("SYSDEV",25,"MRPC155",1070)
		if (forext.wrap = "none") set forext.wrap = 0
^DBTBL("SYSDEV",25,"MRPC155",1071)
		else  if forext.wrap.isNull() set forext.wrap = 1
^DBTBL("SYSDEV",25,"MRPC155",1072)
		else  if "truncate".beginsWith(forext.wrap) set forext.wrap = 2
^DBTBL("SYSDEV",25,"MRPC155",1073)

^DBTBL("SYSDEV",25,"MRPC155",1074)
		if (forext.math = "none") set forext.math = ""
^DBTBL("SYSDEV",25,"MRPC155",1075)
		if (forext.null = "none") set forext.null = ""
^DBTBL("SYSDEV",25,"MRPC155",1076)

^DBTBL("SYSDEV",25,"MRPC155",1077)
		if (forext.space = "none") set forext.space = 0
^DBTBL("SYSDEV",25,"MRPC155",1078)
		else  if forext.space.isNull() set forext.space = 2
^DBTBL("SYSDEV",25,"MRPC155",1079)

^DBTBL("SYSDEV",25,"MRPC155",1080)
		if (forext.merge = "none") set forext.merge = ""
^DBTBL("SYSDEV",25,"MRPC155",1081)
		if (forext.repeat = "none") set forext.repeat = 0
^DBTBL("SYSDEV",25,"MRPC155",1082)

^DBTBL("SYSDEV",25,"MRPC155",1083)
		set colrec.repeat = forext.repeat
^DBTBL("SYSDEV",25,"MRPC155",1084)
		set colrec.null = forext.null
^DBTBL("SYSDEV",25,"MRPC155",1085)
		set colrec.wrap = forext.wrap
^DBTBL("SYSDEV",25,"MRPC155",1086)
		set colrec.math = forext.math.upperCase()
^DBTBL("SYSDEV",25,"MRPC155",1087)
		set colrec.merge = forext.merge
^DBTBL("SYSDEV",25,"MRPC155",1088)
		set colrec.space = forext.space
^DBTBL("SYSDEV",25,"MRPC155",1089)

^DBTBL("SYSDEV",25,"MRPC155",1090)
		// If break or norepeat are specified, set the other default
^DBTBL("SYSDEV",25,"MRPC155",1091)
		if (colrec.repeat.isNull() & colrec.break) set colrec.repeat = 0
^DBTBL("SYSDEV",25,"MRPC155",1092)
		else  if (colrec.break.isNull() & (colrec.repeat = 0)) set colrec.break = 1
^DBTBL("SYSDEV",25,"MRPC155",1093)

^DBTBL("SYSDEV",25,"MRPC155",1094)
		set col(col) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1095)
	}
^DBTBL("SYSDEV",25,"MRPC155",1096)

^DBTBL("SYSDEV",25,"MRPC155",1097)
	if (isError = true) set ER = 1					// Signal to return error
^DBTBL("SYSDEV",25,"MRPC155",1098)

^DBTBL("SYSDEV",25,"MRPC155",1099)
	quit
^DBTBL("SYSDEV",25,"MRPC155",1100)

^DBTBL("SYSDEV",25,"MRPC155",1101)

^DBTBL("SYSDEV",25,"MRPC155",1102)
bldhdg(String col(),				// Default column atttributes
^DBTBL("SYSDEV",25,"MRPC155",1103)
	String xcol(), 				// User override
^DBTBL("SYSDEV",25,"MRPC155",1104)
	Boolean isHTML,				// Is HTML output
^DBTBL("SYSDEV",25,"MRPC155",1105)
	Number IORM,				// Calculated right margin
^DBTBL("SYSDEV",25,"MRPC155",1106)
	String colgrp,				// HTML column group
^DBTBL("SYSDEV",25,"MRPC155",1107)
	Number tot(),				// Initialized totals
^DBTBL("SYSDEV",25,"MRPC155",1108)
	Boolean isPortrait)			// Portrait more flag
^DBTBL("SYSDEV",25,"MRPC155",1109)

^DBTBL("SYSDEV",25,"MRPC155",1110)
	// This utility generates a heading and other returned parameters
^DBTBL("SYSDEV",25,"MRPC155",1111)

^DBTBL("SYSDEV",25,"MRPC155",1112)
	type Literal String COLPAR = "length,type,decimal,format,align,merge,space,math,wrap,repeat,null,break,style,heading,title,minus"
^DBTBL("SYSDEV",25,"MRPC155",1113)
	type literal String TAB = $c(9)
^DBTBL("SYSDEV",25,"MRPC155",1114)
	type literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",1115)

^DBTBL("SYSDEV",25,"MRPC155",1116)
	type Number I,i
^DBTBL("SYSDEV",25,"MRPC155",1117)
	type Row colrec
^DBTBL("SYSDEV",25,"MRPC155",1118)

^DBTBL("SYSDEV",25,"MRPC155",1119)
	type String d,z
^DBTBL("SYSDEV",25,"MRPC155",1120)
	type String hdg = ""
^DBTBL("SYSDEV",25,"MRPC155",1121)

^DBTBL("SYSDEV",25,"MRPC155",1122)
	set colgrp = ""
^DBTBL("SYSDEV",25,"MRPC155",1123)

^DBTBL("SYSDEV",25,"MRPC155",1124)
	for I = 1:1:col do {						// Patch & validate format options
^DBTBL("SYSDEV",25,"MRPC155",1125)

^DBTBL("SYSDEV",25,"MRPC155",1126)
		set colrec = col(I).toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",1127)

^DBTBL("SYSDEV",25,"MRPC155",1128)
		// Don't display this column, typically used for keys if imbedded in heading
^DBTBL("SYSDEV",25,"MRPC155",1129)
		if (colrec.length = 0) quit
^DBTBL("SYSDEV",25,"MRPC155",1130)

^DBTBL("SYSDEV",25,"MRPC155",1131)
		if 'colrec.math.isNull() set tot(I) = $$initMath(.colrec.math)
^DBTBL("SYSDEV",25,"MRPC155",1132)

^DBTBL("SYSDEV",25,"MRPC155",1133)
		// This section ignores the linebreak '@' defined in the report heading and
^DBTBL("SYSDEV",25,"MRPC155",1134)
		// constructs the heading based on the available field length.  It will also
^DBTBL("SYSDEV",25,"MRPC155",1135)
		// expand the field length to fit the longest word in the heading. 
^DBTBL("SYSDEV",25,"MRPC155",1136)
 
^DBTBL("SYSDEV",25,"MRPC155",1137)
		type String label = colrec.heading
^DBTBL("SYSDEV",25,"MRPC155",1138)

^DBTBL("SYSDEV",25,"MRPC155",1139)
		if label.contains("  ") set label = label.replace("  "," ")		// Remove extra whitespace
^DBTBL("SYSDEV",25,"MRPC155",1140)

^DBTBL("SYSDEV",25,"MRPC155",1141)
		// if 'isHTML do {
^DBTBL("SYSDEV",25,"MRPC155",1142)

^DBTBL("SYSDEV",25,"MRPC155",1143)
		// Minimum field length must at least fit the longest heading word
^DBTBL("SYSDEV",25,"MRPC155",1144)
		for i = 1:1:label.length(" ") if (label.piece(" ",i).length() > colrec.length) do {
^DBTBL("SYSDEV",25,"MRPC155",1145)
	
^DBTBL("SYSDEV",25,"MRPC155",1146)
			set colrec.length = label.piece(" ",i).length()
^DBTBL("SYSDEV",25,"MRPC155",1147)
			set col(I) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1148)
		}
^DBTBL("SYSDEV",25,"MRPC155",1149)

^DBTBL("SYSDEV",25,"MRPC155",1150)
		// Starting at the end, fit as many words into each line as possible
^DBTBL("SYSDEV",25,"MRPC155",1151)
		if (label.length() > colrec.length) do {		
^DBTBL("SYSDEV",25,"MRPC155",1152)

^DBTBL("SYSDEV",25,"MRPC155",1153)
			type Number p = label.length(" ")
^DBTBL("SYSDEV",25,"MRPC155",1154)
			for i = (p - 1):-1:1 if (label.piece(" ",i,p).length() > colrec.length) set label = label.piece(" ",1,i) _ LF _ label.piece(" ",i + 1,999), p = i 
^DBTBL("SYSDEV",25,"MRPC155",1155)
		}
^DBTBL("SYSDEV",25,"MRPC155",1156)

^DBTBL("SYSDEV",25,"MRPC155",1157)
		if label.contains(TAB) do {						// Check for markup type
^DBTBL("SYSDEV",25,"MRPC155",1158)

^DBTBL("SYSDEV",25,"MRPC155",1159)
			if (label.piece(TAB,1).upperCase() = "HTML") set label = label.piece(TAB,2,label.length())
^DBTBL("SYSDEV",25,"MRPC155",1160)
			else  if (isHTML = true) set label = $$escape(label)
^DBTBL("SYSDEV",25,"MRPC155",1161)
		}
^DBTBL("SYSDEV",25,"MRPC155",1162)

^DBTBL("SYSDEV",25,"MRPC155",1163)
		if 'colrec.merge.isNull() & (I > 1) do { quit				// Merge with prior column
^DBTBL("SYSDEV",25,"MRPC155",1164)

^DBTBL("SYSDEV",25,"MRPC155",1165)
			type String merge = colrec.merge
^DBTBL("SYSDEV",25,"MRPC155",1166)
			if (merge ?1N.E) set merge = $$ASCIItoHTML(merge, isHTML)
^DBTBL("SYSDEV",25,"MRPC155",1167)

^DBTBL("SYSDEV",25,"MRPC155",1168)
			if (isHTML = true) do {							// Modify heading & title
^DBTBL("SYSDEV",25,"MRPC155",1169)

^DBTBL("SYSDEV",25,"MRPC155",1170)
				if merge.contains("  ") set merge = merge.replace("  "," &nbsp;")
^DBTBL("SYSDEV",25,"MRPC155",1171)

^DBTBL("SYSDEV",25,"MRPC155",1172)
				if 'label.isNull() set hdg = hdg.extract(1, hdg.length() - 5) _ merge _ label _ "</th>"
^DBTBL("SYSDEV",25,"MRPC155",1173)

^DBTBL("SYSDEV",25,"MRPC155",1174)
				// Patch the title to add the column header info
^DBTBL("SYSDEV",25,"MRPC155",1175)
				type String p = "<th title="				// Pattern to patch, get last occurrance
^DBTBL("SYSDEV",25,"MRPC155",1176)
				type Number c = hdg.length(p)
^DBTBL("SYSDEV",25,"MRPC155",1177)
				type String z = hdg.piece(p,c) 
^DBTBL("SYSDEV",25,"MRPC155",1178)
				type String h = z.piece(">",2,99)
^DBTBL("SYSDEV",25,"MRPC155",1179)
				type String s = z.piece(" style=",2)			// Parse out style= qualifier
^DBTBL("SYSDEV",25,"MRPC155",1180)

^DBTBL("SYSDEV",25,"MRPC155",1181)
				set z = z.piece(">",1)
^DBTBL("SYSDEV",25,"MRPC155",1182)
				if 's.isNull() set z = z.piece(" style=",1)
^DBTBL("SYSDEV",25,"MRPC155",1183)

^DBTBL("SYSDEV",25,"MRPC155",1184)
				set z = (z.stripQuotes() _ LF _ $$escape(colrec.title)).addQuotes()
^DBTBL("SYSDEV",25,"MRPC155",1185)
				if 's.isNull() set z = (z _ " style=" _ s)
^DBTBL("SYSDEV",25,"MRPC155",1186)

^DBTBL("SYSDEV",25,"MRPC155",1187)
				set hdg.piece(p,c) = (z _ ">" _ h)
^DBTBL("SYSDEV",25,"MRPC155",1188)
			}
^DBTBL("SYSDEV",25,"MRPC155",1189)

^DBTBL("SYSDEV",25,"MRPC155",1190)
			else  do {							// Text Markup
^DBTBL("SYSDEV",25,"MRPC155",1191)

^DBTBL("SYSDEV",25,"MRPC155",1192)
				set merge = merge.replace("<br>",LF)
^DBTBL("SYSDEV",25,"MRPC155",1193)
				set merge = merge.replace("<BR>",LF)
^DBTBL("SYSDEV",25,"MRPC155",1194)

^DBTBL("SYSDEV",25,"MRPC155",1195)
				if label.isNull() quit
^DBTBL("SYSDEV",25,"MRPC155",1196)

^DBTBL("SYSDEV",25,"MRPC155",1197)
				type Number pcol
^DBTBL("SYSDEV",25,"MRPC155",1198)
				type Row pcolrec
^DBTBL("SYSDEV",25,"MRPC155",1199)

^DBTBL("SYSDEV",25,"MRPC155",1200)
				for pcol = I-1:-1:1 set pcolrec = col(pcol).toRow(COLPAR,"|") if (pcolrec.merge.isNull() & (pcolrec.length > 0)) quit
^DBTBL("SYSDEV",25,"MRPC155",1201)

^DBTBL("SYSDEV",25,"MRPC155",1202)
				// Modify merge 'into' column length to fit merged columns
^DBTBL("SYSDEV",25,"MRPC155",1203)

^DBTBL("SYSDEV",25,"MRPC155",1204)
				set IORM = (IORM - pcolrec.length - pcolrec.space)
^DBTBL("SYSDEV",25,"MRPC155",1205)

^DBTBL("SYSDEV",25,"MRPC155",1206)
				set col(pcol) = pcolrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1207)

^DBTBL("SYSDEV",25,"MRPC155",1208)
				// merge heading to prior heading
^DBTBL("SYSDEV",25,"MRPC155",1209)
				set label = hdg.piece(LF,5).extract(IORM + 1, 999) _ merge _ label
^DBTBL("SYSDEV",25,"MRPC155",1210)
				set hdg.piece(LF,5) = hdg.piece(LF,5).extract(1, IORM)
^DBTBL("SYSDEV",25,"MRPC155",1211)

^DBTBL("SYSDEV",25,"MRPC155",1212)
				type Number p
^DBTBL("SYSDEV",25,"MRPC155",1213)

^DBTBL("SYSDEV",25,"MRPC155",1214)
				for p = 4:-1:1 if (hdg.piece(LF,p).length() > IORM) do {
^DBTBL("SYSDEV",25,"MRPC155",1215)
					set label = hdg.piece(LF,p).extract(IORM + 1, 999) _ LF _ label
^DBTBL("SYSDEV",25,"MRPC155",1216)
					set hdg.piece(LF,p) = hdg.piece(LF,p).extract(1,IORM)
^DBTBL("SYSDEV",25,"MRPC155",1217)
				}
^DBTBL("SYSDEV",25,"MRPC155",1218)

^DBTBL("SYSDEV",25,"MRPC155",1219)
				set p = label.length(LF)
^DBTBL("SYSDEV",25,"MRPC155",1220)

^DBTBL("SYSDEV",25,"MRPC155",1221)
				for i = p:-1:1 do {
^DBTBL("SYSDEV",25,"MRPC155",1222)
					set z = label.piece(LF,i)
^DBTBL("SYSDEV",25,"MRPC155",1223)
					set d = hdg.piece(LF,(5 + i - p))
^DBTBL("SYSDEV",25,"MRPC155",1224)

^DBTBL("SYSDEV",25,"MRPC155",1225)
					if (IORM > 0) set d = d _ "".justify(IORM - d.length())		// Pad
^DBTBL("SYSDEV",25,"MRPC155",1226)
					if (colrec.align = "right") set z = z.justify(colrec.length,1)	// Right
^DBTBL("SYSDEV",25,"MRPC155",1227)
					else  if (colrec.align = "center") set z = "".justify((colrec.length - z.length()) \ 2) _ z
^DBTBL("SYSDEV",25,"MRPC155",1228)
					set hdg.piece(LF,(5 + i - p)) = (d _ z)
^DBTBL("SYSDEV",25,"MRPC155",1229)
				}
^DBTBL("SYSDEV",25,"MRPC155",1230)

^DBTBL("SYSDEV",25,"MRPC155",1231)
				set d = hdg.piece(LF,6).extract(1,IORM) _ "".justify(pcolrec.length,"","-") _ "".justify(pcolrec.space)
^DBTBL("SYSDEV",25,"MRPC155",1232)
				set hdg.piece(LF,6) = d
^DBTBL("SYSDEV",25,"MRPC155",1233)

^DBTBL("SYSDEV",25,"MRPC155",1234)
				set IORM = (IORM + pcolrec.length + pcolrec.space)
^DBTBL("SYSDEV",25,"MRPC155",1235)
			}
^DBTBL("SYSDEV",25,"MRPC155",1236)

^DBTBL("SYSDEV",25,"MRPC155",1237)
		set colrec.merge = merge
^DBTBL("SYSDEV",25,"MRPC155",1238)
		set colrec.math = ""
^DBTBL("SYSDEV",25,"MRPC155",1239)
		set colrec.align = ""
^DBTBL("SYSDEV",25,"MRPC155",1240)
		set col(I) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1241)
		}
^DBTBL("SYSDEV",25,"MRPC155",1242)

^DBTBL("SYSDEV",25,"MRPC155",1243)
		if (isHTML = true) do {
^DBTBL("SYSDEV",25,"MRPC155",1244)

^DBTBL("SYSDEV",25,"MRPC155",1245)
			set label = label.replace(LF,"<br>")
^DBTBL("SYSDEV",25,"MRPC155",1246)

^DBTBL("SYSDEV",25,"MRPC155",1247)
			set hdg = hdg _ LF _ "<th"
^DBTBL("SYSDEV",25,"MRPC155",1248)
			if 'colrec.title.isNull() set hdg = hdg _ " title=" _ $$escape(colrec.title).addQuotes() 
^DBTBL("SYSDEV",25,"MRPC155",1249)
			if 'colrec.style.isNull() set hdg = hdg _ " style=color:black"
^DBTBL("SYSDEV",25,"MRPC155",1250)
			set hdg = hdg _ ">" _ label _ "</th>"			
^DBTBL("SYSDEV",25,"MRPC155",1251)

^DBTBL("SYSDEV",25,"MRPC155",1252)
			set colgrp = colgrp _ "<col"
^DBTBL("SYSDEV",25,"MRPC155",1253)

^DBTBL("SYSDEV",25,"MRPC155",1254)
			if 'colrec.align.isNull() set colgrp = (colgrp _ " align=" _ colrec.align)
^DBTBL("SYSDEV",25,"MRPC155",1255)
			if 'colrec.style.isNull() set colgrp = (colgrp _ " style=" _ colrec.style.translate("= ",":;").addQuotes())
^DBTBL("SYSDEV",25,"MRPC155",1256)

^DBTBL("SYSDEV",25,"MRPC155",1257)
			set colgrp = (colgrp _ ">" _ LF)
^DBTBL("SYSDEV",25,"MRPC155",1258)
		}
^DBTBL("SYSDEV",25,"MRPC155",1259)

^DBTBL("SYSDEV",25,"MRPC155",1260)
		else  do {								// Create plain text heading
^DBTBL("SYSDEV",25,"MRPC155",1261)

^DBTBL("SYSDEV",25,"MRPC155",1262)
			type Number p = label.length(LF)
^DBTBL("SYSDEV",25,"MRPC155",1263)

^DBTBL("SYSDEV",25,"MRPC155",1264)
			for i = p:-1:1 do {
^DBTBL("SYSDEV",25,"MRPC155",1265)
				set z = label.piece(LF,i)
^DBTBL("SYSDEV",25,"MRPC155",1266)
				set d = hdg.piece(LF,(5 + i - p))
^DBTBL("SYSDEV",25,"MRPC155",1267)

^DBTBL("SYSDEV",25,"MRPC155",1268)
				if (IORM > 0) set d = d _ "".justify(IORM - d.length())		// Pad
^DBTBL("SYSDEV",25,"MRPC155",1269)
				if (colrec.align = "right") set z = z.justify(colrec.length,1)	// Right
^DBTBL("SYSDEV",25,"MRPC155",1270)
				else  if (colrec.align = "center") set z = "".justify((colrec.length - z.length()) \ 2) _ z
^DBTBL("SYSDEV",25,"MRPC155",1271)
				set hdg.piece(LF,(5 + i - p)) = (d _ z)
^DBTBL("SYSDEV",25,"MRPC155",1272)
			}
^DBTBL("SYSDEV",25,"MRPC155",1273)

^DBTBL("SYSDEV",25,"MRPC155",1274)
			set d = hdg.piece(LF,6) _ "".justify(IORM - d.length()) _ "".justify(colrec.length,"","-") _ "".justify(colrec.space)
^DBTBL("SYSDEV",25,"MRPC155",1275)
			set hdg.piece(LF,6) = d
^DBTBL("SYSDEV",25,"MRPC155",1276)
		}
^DBTBL("SYSDEV",25,"MRPC155",1277)
	
^DBTBL("SYSDEV",25,"MRPC155",1278)
		set IORM = (IORM + colrec.length + colrec.space)	// Nominal Right margin
^DBTBL("SYSDEV",25,"MRPC155",1279)
	}
^DBTBL("SYSDEV",25,"MRPC155",1280)

^DBTBL("SYSDEV",25,"MRPC155",1281)
	if hdg.beginsWith(LF) set hdg = hdg.trim(-1,LF)
^DBTBL("SYSDEV",25,"MRPC155",1282)
	quit hdg _ LF
^DBTBL("SYSDEV",25,"MRPC155",1283)

^DBTBL("SYSDEV",25,"MRPC155",1284)

^DBTBL("SYSDEV",25,"MRPC155",1285)

^DBTBL("SYSDEV",25,"MRPC155",1286)
bldTitle(String title, Boolean isHTML, String col(), String pars(), String from, String where, String tok)	// Initialize title 
^DBTBL("SYSDEV",25,"MRPC155",1287)

^DBTBL("SYSDEV",25,"MRPC155",1288)
	// Format title from fixed template and pre-process variable substitution
^DBTBL("SYSDEV",25,"MRPC155",1289)

^DBTBL("SYSDEV",25,"MRPC155",1290)
	type Literal String COLPAR = "length,type,decimal,format,align,merge,space,math,wrap,repeat,null,break,style,heading,title,minus"
^DBTBL("SYSDEV",25,"MRPC155",1291)

^DBTBL("SYSDEV",25,"MRPC155",1292)
	type Literal String DR = $c(0)				// Delimiter - Record
^DBTBL("SYSDEV",25,"MRPC155",1293)
	type Literal String DF = $c(1)				// Delimiter - Field
^DBTBL("SYSDEV",25,"MRPC155",1294)
	type Literal String TAB = $c(9)
^DBTBL("SYSDEV",25,"MRPC155",1295)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",1296)

^DBTBL("SYSDEV",25,"MRPC155",1297)

^DBTBL("SYSDEV",25,"MRPC155",1298)
	type Number i,y,yz
^DBTBL("SYSDEV",25,"MRPC155",1299)
	type String v,var,cakwd(),class,parms,L1,L2,R1,R2
^DBTBL("SYSDEV",25,"MRPC155",1300)
	type Row colrec
^DBTBL("SYSDEV",25,"MRPC155",1301)

^DBTBL("SYSDEV",25,"MRPC155",1302)
	if (title = "default") do {				// Generate a default title
^DBTBL("SYSDEV",25,"MRPC155",1303)

^DBTBL("SYSDEV",25,"MRPC155",1304)
		type String table = $$UNTOK^%ZS(from.piece(" ",1).piece(",",1),.tok)
^DBTBL("SYSDEV",25,"MRPC155",1305)
 		type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1","%LIBS = ""SYSDEV"" ,FID=:table",1)
^DBTBL("SYSDEV",25,"MRPC155",1306)
		set title = dbtbl1.des
^DBTBL("SYSDEV",25,"MRPC155",1307)
		if 'where.isNull() set title = title _ " ( " _ $$UNTOK^%ZS(where,.tok) _ ")"
^DBTBL("SYSDEV",25,"MRPC155",1308)
	}
^DBTBL("SYSDEV",25,"MRPC155",1309)
	
^DBTBL("SYSDEV",25,"MRPC155",1310)
	type Boolean txtHTML = false				// Title is in HTML text format
^DBTBL("SYSDEV",25,"MRPC155",1311)

^DBTBL("SYSDEV",25,"MRPC155",1312)
	if title.contains(TAB) do {
^DBTBL("SYSDEV",25,"MRPC155",1313)

^DBTBL("SYSDEV",25,"MRPC155",1314)
		if (title.piece(TAB,1).upperCase() = "HTML") set txtHTML = true, title = title.piece(TAB,2,title.length())
^DBTBL("SYSDEV",25,"MRPC155",1315)
		if title.contains(TAB) set title = title.replace(TAB," ")
^DBTBL("SYSDEV",25,"MRPC155",1316)
	}
^DBTBL("SYSDEV",25,"MRPC155",1317)

^DBTBL("SYSDEV",25,"MRPC155",1318)
	set L1 = ""
^DBTBL("SYSDEV",25,"MRPC155",1319)
	#IF 'CUVAR.CONAM.isNull() set L1 = CUVAR.CONAM
^DBTBL("SYSDEV",25,"MRPC155",1320)
	
^DBTBL("SYSDEV",25,"MRPC155",1321)
	if ((%SystemDate = %CurrentDate) ! %SystemDate.isNull()) set R1 = ""
^DBTBL("SYSDEV",25,"MRPC155",1322)
	else  set R1 = "Effective: <:%SystemDate>" 
^DBTBL("SYSDEV",25,"MRPC155",1323)

^DBTBL("SYSDEV",25,"MRPC155",1324)
	if (pars("PAGE").get() > 0) set R1 = (R1 _ "  Page: <:PN>")
^DBTBL("SYSDEV",25,"MRPC155",1325)
	set R2 = "Run Date: <:%CurrentDate>   <:%CurrentTime>"
^DBTBL("SYSDEV",25,"MRPC155",1326)

^DBTBL("SYSDEV",25,"MRPC155",1327)
	if (isHTML = true) do {
^DBTBL("SYSDEV",25,"MRPC155",1328)

^DBTBL("SYSDEV",25,"MRPC155",1329)
		if 'L1.isNull() set title = (L1 _ LF _ title)
^DBTBL("SYSDEV",25,"MRPC155",1330)
		if 'R1.isNull() set R2 = (R1 _ LF _ R2)
^DBTBL("SYSDEV",25,"MRPC155",1331)

^DBTBL("SYSDEV",25,"MRPC155",1332)
		set title = (title _ TAB _ R2)
^DBTBL("SYSDEV",25,"MRPC155",1333)
	}
^DBTBL("SYSDEV",25,"MRPC155",1334)

^DBTBL("SYSDEV",25,"MRPC155",1335)
	else  do {
^DBTBL("SYSDEV",25,"MRPC155",1336)

^DBTBL("SYSDEV",25,"MRPC155",1337)
		if 'R1.isNull() set L1 = (L1 _  TAB _ R1)
^DBTBL("SYSDEV",25,"MRPC155",1338)
		if 'R2.isNull() set title.piece(LF,1) = (title.piece(LF,1) _  TAB _ R2)
^DBTBL("SYSDEV",25,"MRPC155",1339)
		set title = (title _ LF)
^DBTBL("SYSDEV",25,"MRPC155",1340)
		if 'L1.isNull() set title = (L1 _ LF _ title _ LF)
^DBTBL("SYSDEV",25,"MRPC155",1341)
	}
^DBTBL("SYSDEV",25,"MRPC155",1342)

^DBTBL("SYSDEV",25,"MRPC155",1343)
	type List vars = ""
^DBTBL("SYSDEV",25,"MRPC155",1344)
	
^DBTBL("SYSDEV",25,"MRPC155",1345)
	set y = 0
^DBTBL("SYSDEV",25,"MRPC155",1346)
	for  set y = title.find("<:",y) quit:(y = 0)  do {			// Parse variable insertion
^DBTBL("SYSDEV",25,"MRPC155",1347)

^DBTBL("SYSDEV",25,"MRPC155",1348)
		set yz = title.find(">",y) if (yz = 0) quit
^DBTBL("SYSDEV",25,"MRPC155",1349)
		set v = title.extract(y,yz - 2)		// element expression
^DBTBL("SYSDEV",25,"MRPC155",1350)

^DBTBL("SYSDEV",25,"MRPC155",1351)
		set parms = v.piece(" ",2,v.length()).trim(), var = v.piece(" ",1)
^DBTBL("SYSDEV",25,"MRPC155",1352)

^DBTBL("SYSDEV",25,"MRPC155",1353)
		if var.contains(".") do {					// Find Column reference in column title
^DBTBL("SYSDEV",25,"MRPC155",1354)
			set var = var.upperCase()
^DBTBL("SYSDEV",25,"MRPC155",1355)
			for i=1:1:col set colrec = col(i).toRow(COLPAR,"|") if (colrec.title.piece(" ",1) = var) set var = i quit
^DBTBL("SYSDEV",25,"MRPC155",1356)
		}
^DBTBL("SYSDEV",25,"MRPC155",1357)

^DBTBL("SYSDEV",25,"MRPC155",1358)
		if var?1N.N & col(var).exists() set colrec = col(var).toRow(COLPAR,"|"), var = ("col(" _ var _ ",0)")
^DBTBL("SYSDEV",25,"MRPC155",1359)

^DBTBL("SYSDEV",25,"MRPC155",1360)
		else if var.beginsWith("%") do { quit:var.isNull()
^DBTBL("SYSDEV",25,"MRPC155",1361)

^DBTBL("SYSDEV",25,"MRPC155",1362)
			set var = $$kwdRow^UCDTAUTL(var,.cakwd()) if var.isNull() do ERROR("Invalid variable syntax",v) quit
^DBTBL("SYSDEV",25,"MRPC155",1363)
			set colrec = "".toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",1364)
			set colrec.type =  $s(var.piece("|",4) = "Time":"C",1:var.piece("|",4).extract(1))
^DBTBL("SYSDEV",25,"MRPC155",1365)
			set class = $$getClass(colrec.type)
^DBTBL("SYSDEV",25,"MRPC155",1366)
			set colrec.format = $$getFormat(class, pars(class _ ".format").get())
^DBTBL("SYSDEV",25,"MRPC155",1367)
 
^DBTBL("SYSDEV",25,"MRPC155",1368)
			set var = var.piece("|",2)
^DBTBL("SYSDEV",25,"MRPC155",1369)
		}
^DBTBL("SYSDEV",25,"MRPC155",1370)

^DBTBL("SYSDEV",25,"MRPC155",1371)
		else  if '(var = "PN") do ERROR("Invalid variable syntax",v) quit // Could add more local vars if required (e.g., sqlcnt)
^DBTBL("SYSDEV",25,"MRPC155",1372)

^DBTBL("SYSDEV",25,"MRPC155",1373)
		if 'var.beginsWith("$") set var = "$G(" _ var _")"		// Prevent undefined errors
^DBTBL("SYSDEV",25,"MRPC155",1374)

^DBTBL("SYSDEV",25,"MRPC155",1375)
		if 'parms.isNull() do {
^DBTBL("SYSDEV",25,"MRPC155",1376)

^DBTBL("SYSDEV",25,"MRPC155",1377)
			type String format,style
^DBTBL("SYSDEV",25,"MRPC155",1378)

^DBTBL("SYSDEV",25,"MRPC155",1379)
			set class = $$getClass(colrec.type)
^DBTBL("SYSDEV",25,"MRPC155",1380)

^DBTBL("SYSDEV",25,"MRPC155",1381)
			do parse(parms, pars(), ",", "=",,,, "format,style")
^DBTBL("SYSDEV",25,"MRPC155",1382)
			set format = pars("format").get(), style = pars("style").get()
^DBTBL("SYSDEV",25,"MRPC155",1383)

^DBTBL("SYSDEV",25,"MRPC155",1384)
			if format.isNull() set format = colrec.format
^DBTBL("SYSDEV",25,"MRPC155",1385)
			else  if (format = "none") set format = ""
^DBTBL("SYSDEV",25,"MRPC155",1386)
			else  set format = $$getFormat(class, format)
^DBTBL("SYSDEV",25,"MRPC155",1387)

^DBTBL("SYSDEV",25,"MRPC155",1388)
			set colrec.decimal = $$getProperty("decimal-size", format, colrec.decimal)
^DBTBL("SYSDEV",25,"MRPC155",1389)
			//if (colrec.decimal = "none") set colrec.decimal = ""
^DBTBL("SYSDEV",25,"MRPC155",1390)
			set colrec.format = format, colrec.style = style
^DBTBL("SYSDEV",25,"MRPC155",1391)
		}
^DBTBL("SYSDEV",25,"MRPC155",1392)

^DBTBL("SYSDEV",25,"MRPC155",1393)
	set vars = vars.add(var _ "|"_ colrec.type _ "|"_ colrec.decimal _ "|" _ colrec.style _ "|" _ colrec.format, DF)
^DBTBL("SYSDEV",25,"MRPC155",1394)
	set title = title.extract(1,y - 3) _ DF _ title.extract(yz,title.length())
^DBTBL("SYSDEV",25,"MRPC155",1395)
	}
^DBTBL("SYSDEV",25,"MRPC155",1396)

^DBTBL("SYSDEV",25,"MRPC155",1397)
	if (txtHTML = false & (isHTML = true)) set title = $$escape(title)		// Escape HTML chars
^DBTBL("SYSDEV",25,"MRPC155",1398)
	if (txtHTML = true  & (isHTML = false)) do {	
^DBTBL("SYSDEV",25,"MRPC155",1399)
	// Insert code to replace HTML tags with appropriate plain text (e.g., alternate text)
^DBTBL("SYSDEV",25,"MRPC155",1400)
	}
^DBTBL("SYSDEV",25,"MRPC155",1401)

^DBTBL("SYSDEV",25,"MRPC155",1402)
	if (isHTML = true) do {
^DBTBL("SYSDEV",25,"MRPC155",1403)

^DBTBL("SYSDEV",25,"MRPC155",1404)
		set title = title.replace(LF,"<br>")
^DBTBL("SYSDEV",25,"MRPC155",1405)
		set title = ("<div style=float:left;color:black>" _ title.piece(TAB,1) _ "</div><div style=float:right;color:black>" _ title.piece(TAB,2) _ "</div>")
^DBTBL("SYSDEV",25,"MRPC155",1406)
	
^DBTBL("SYSDEV",25,"MRPC155",1407)
		// Count the number of unhidden and unmerged columns for colspan
^DBTBL("SYSDEV",25,"MRPC155",1408)
		type Number i
^DBTBL("SYSDEV",25,"MRPC155",1409)
		type Number c = 0
^DBTBL("SYSDEV",25,"MRPC155",1410)

^DBTBL("SYSDEV",25,"MRPC155",1411)
		for i = 1:1:col set colrec = col(i).toRow(COLPAR,"|") if ((colrec.length > 0) & colrec.merge.isNull()) set c = (c + 1)
^DBTBL("SYSDEV",25,"MRPC155",1412)
		set title = ("<tr><th colspan=" _ c _ " align=left>" _ title _"</th></tr>" _ LF)
^DBTBL("SYSDEV",25,"MRPC155",1413)
	}
^DBTBL("SYSDEV",25,"MRPC155",1414)

^DBTBL("SYSDEV",25,"MRPC155",1415)
	set title = vars _ DR _ title
^DBTBL("SYSDEV",25,"MRPC155",1416)

^DBTBL("SYSDEV",25,"MRPC155",1417)
	quit title
^DBTBL("SYSDEV",25,"MRPC155",1418)

^DBTBL("SYSDEV",25,"MRPC155",1419)

^DBTBL("SYSDEV",25,"MRPC155",1420)

^DBTBL("SYSDEV",25,"MRPC155",1421)
plan(String pars(), String vsql(), Boolean isHTML) // Display execution IO plan
^DBTBL("SYSDEV",25,"MRPC155",1422)

^DBTBL("SYSDEV",25,"MRPC155",1423)
	type Literal String COLPAR = "length,type,decimal,format,align,merge,space,math,wrap,repeat,null,break,style,heading,title"
^DBTBL("SYSDEV",25,"MRPC155",1424)
	type Literal String TAB = $c(9)
^DBTBL("SYSDEV",25,"MRPC155",1425)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",1426)

^DBTBL("SYSDEV",25,"MRPC155",1427)
	type String d,colgrp,hdg
^DBTBL("SYSDEV",25,"MRPC155",1428)
	type String i,z
^DBTBL("SYSDEV",25,"MRPC155",1429)
	type String index = ""
^DBTBL("SYSDEV",25,"MRPC155",1430)
	type String xcol(),sort()
^DBTBL("SYSDEV",25,"MRPC155",1431)

^DBTBL("SYSDEV",25,"MRPC155",1432)
	type Number IORM = 0
^DBTBL("SYSDEV",25,"MRPC155",1433)

^DBTBL("SYSDEV",25,"MRPC155",1434)
	type Row colrec = "".toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",1435)

^DBTBL("SYSDEV",25,"MRPC155",1436)
	set xcol = 5
^DBTBL("SYSDEV",25,"MRPC155",1437)
	set colrec.space = 2
^DBTBL("SYSDEV",25,"MRPC155",1438)
	set colrec.type = "T"
^DBTBL("SYSDEV",25,"MRPC155",1439)

^DBTBL("SYSDEV",25,"MRPC155",1440)
	set colrec.length = 12
^DBTBL("SYSDEV",25,"MRPC155",1441)
	set colrec.align = "left"
^DBTBL("SYSDEV",25,"MRPC155",1442)
	set colrec.heading = "Index"
^DBTBL("SYSDEV",25,"MRPC155",1443)

^DBTBL("SYSDEV",25,"MRPC155",1444)
	set xcol(1) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1445)

^DBTBL("SYSDEV",25,"MRPC155",1446)
	set colrec.length = 30
^DBTBL("SYSDEV",25,"MRPC155",1447)
	set colrec.heading = "Primary Keys"
^DBTBL("SYSDEV",25,"MRPC155",1448)
	set xcol(2) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1449)

^DBTBL("SYSDEV",25,"MRPC155",1450)
	set colrec.length = 7
^DBTBL("SYSDEV",25,"MRPC155",1451)
	set colrec.align = "center"
^DBTBL("SYSDEV",25,"MRPC155",1452)
	set colrec.heading = "Cost"
^DBTBL("SYSDEV",25,"MRPC155",1453)
	set xcol(3) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1454)

^DBTBL("SYSDEV",25,"MRPC155",1455)
	set colrec.length = 4
^DBTBL("SYSDEV",25,"MRPC155",1456)
	set colrec.heading = "Code"
^DBTBL("SYSDEV",25,"MRPC155",1457)
	set xcol(4) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1458)

^DBTBL("SYSDEV",25,"MRPC155",1459)
	set colrec.length = 20
^DBTBL("SYSDEV",25,"MRPC155",1460)
	set colrec.align = "left"
^DBTBL("SYSDEV",25,"MRPC155",1461)
	set colrec.heading = "Distribution"
^DBTBL("SYSDEV",25,"MRPC155",1462)
	set xcol(5) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1463)

^DBTBL("SYSDEV",25,"MRPC155",1464)
	set hdg = $$bldhdg(.xcol(),,isHTML,.IORM,.colgrp)
^DBTBL("SYSDEV",25,"MRPC155",1465)

^DBTBL("SYSDEV",25,"MRPC155",1466)
	if (isHTML = true) do newTable(pars(), "UT", colgrp)
^DBTBL("SYSDEV",25,"MRPC155",1467)

^DBTBL("SYSDEV",25,"MRPC155",1468)
	// First sort index by cost
^DBTBL("SYSDEV",25,"MRPC155",1469)
	for i = 1:1 set index = vsql("P",index).order() quit:index.isNull()  do {
^DBTBL("SYSDEV",25,"MRPC155",1470)

^DBTBL("SYSDEV",25,"MRPC155",1471)
		set z = vsql("P",index)
^DBTBL("SYSDEV",25,"MRPC155",1472)
		set sort(z.piece("|",4) + (i / 100)) = index
^DBTBL("SYSDEV",25,"MRPC155",1473)
	}
^DBTBL("SYSDEV",25,"MRPC155",1474)

^DBTBL("SYSDEV",25,"MRPC155",1475)
	do caption("Display SQL IO Access Plan - " _ (i - 1) _ " Indexes", "UT", isHTML, IORM) 
^DBTBL("SYSDEV",25,"MRPC155",1476)
	do writeln(LF _ hdg)	
^DBTBL("SYSDEV",25,"MRPC155",1477)

^DBTBL("SYSDEV",25,"MRPC155",1478)
	type String n = ""
^DBTBL("SYSDEV",25,"MRPC155",1479)
	for  set n = sort(n).order() quit:n.isNull()  do {
^DBTBL("SYSDEV",25,"MRPC155",1480)

^DBTBL("SYSDEV",25,"MRPC155",1481)
		set index = sort(n)
^DBTBL("SYSDEV",25,"MRPC155",1482)
		set z = vsql("P",index)
^DBTBL("SYSDEV",25,"MRPC155",1483)
		set d = index _ TAB _ z.piece("|",2) _ TAB _ ((z.piece("|",4) + .05) \ 1) _ TAB _ z.piece("|",5) _ TAB _ z.piece("|",3)
^DBTBL("SYSDEV",25,"MRPC155",1484)
		if (isHTML = true) set d = $$escape(d)
^DBTBL("SYSDEV",25,"MRPC155",1485)
		do writeln($$bldRow(d, .xcol(), isHTML))
^DBTBL("SYSDEV",25,"MRPC155",1486)
	}
^DBTBL("SYSDEV",25,"MRPC155",1487)

^DBTBL("SYSDEV",25,"MRPC155",1488)
	if (isHTML = true) do writeln(LF _ "</table>")
^DBTBL("SYSDEV",25,"MRPC155",1489)
	do section(IORM,isHTML)
^DBTBL("SYSDEV",25,"MRPC155",1490)
	Quit
^DBTBL("SYSDEV",25,"MRPC155",1491)

^DBTBL("SYSDEV",25,"MRPC155",1492)

^DBTBL("SYSDEV",25,"MRPC155",1493)
dftCSS(String pars(), String class)	// Default CSS
^DBTBL("SYSDEV",25,"MRPC155",1494)

^DBTBL("SYSDEV",25,"MRPC155",1495)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",1496)
	type Literal String LT = $c(10,9)
^DBTBL("SYSDEV",25,"MRPC155",1497)

^DBTBL("SYSDEV",25,"MRPC155",1498)
	if pars("css",class).exists() quit	// Already output
^DBTBL("SYSDEV",25,"MRPC155",1499)
	set pars("css",class) = ""
^DBTBL("SYSDEV",25,"MRPC155",1500)

^DBTBL("SYSDEV",25,"MRPC155",1501)
	type Public Number ER
^DBTBL("SYSDEV",25,"MRPC155",1502)

^DBTBL("SYSDEV",25,"MRPC155",1503)
	type String n,m
^DBTBL("SYSDEV",25,"MRPC155",1504)
	type String alt,css(),hstyle,tstyle,xstyle
^DBTBL("SYSDEV",25,"MRPC155",1505)

^DBTBL("SYSDEV",25,"MRPC155",1506)
	// Frank's hard-coded default style sheet
^DBTBL("SYSDEV",25,"MRPC155",1507)
	set tstyle = "border-width:1px;padding:2px;border-spacing:;border-style:inset;border-color:#788cb3;border-collapse:collapse;background-color:#FCFDFE;font-family:Verdana;font-size:80%"
^DBTBL("SYSDEV",25,"MRPC155",1508)

^DBTBL("SYSDEV",25,"MRPC155",1509)
	// Process user declaration of style attributes
^DBTBL("SYSDEV",25,"MRPC155",1510)
	if (class = "RS") do parse(pars("STYLE").get(), .css(), ";", ":", false, "none", "default", "")
^DBTBL("SYSDEV",25,"MRPC155",1511)

^DBTBL("SYSDEV",25,"MRPC155",1512)
	if ER quit
^DBTBL("SYSDEV",25,"MRPC155",1513)
 
^DBTBL("SYSDEV",25,"MRPC155",1514)
	// Add additional table level custom properties for alt-row (not standard css, move to xstyle)
^DBTBL("SYSDEV",25,"MRPC155",1515)

^DBTBL("SYSDEV",25,"MRPC155",1516)
	set xstyle = ""
^DBTBL("SYSDEV",25,"MRPC155",1517)
	set n = "alt-row-", m = n
^DBTBL("SYSDEV",25,"MRPC155",1518)

^DBTBL("SYSDEV",25,"MRPC155",1519)
	for  set m = css(m).order() quit:'m.beginsWith(n)  do {
^DBTBL("SYSDEV",25,"MRPC155",1520)
		if (css(m) = "none") set xstyle = $$remProperty(xstyle, m)
^DBTBL("SYSDEV",25,"MRPC155",1521)
		else  set xstyle = $$setProperty(xstyle, m, css(m))
^DBTBL("SYSDEV",25,"MRPC155",1522)
		kill css(m)
^DBTBL("SYSDEV",25,"MRPC155",1523)
	}
^DBTBL("SYSDEV",25,"MRPC155",1524)

^DBTBL("SYSDEV",25,"MRPC155",1525)
	set n = ""
^DBTBL("SYSDEV",25,"MRPC155",1526)
	for  set n = css(n).order() quit:n.isNull()  set tstyle = $$setProperty(tstyle, n, css(n))
^DBTBL("SYSDEV",25,"MRPC155",1527)
	
^DBTBL("SYSDEV",25,"MRPC155",1528)

^DBTBL("SYSDEV",25,"MRPC155",1529)
	set hstyle = $$setProperty(tstyle,"padding","3px")
^DBTBL("SYSDEV",25,"MRPC155",1530)
	set hstyle = $$setProperty(hstyle,"background-color","#EBEEF4")
^DBTBL("SYSDEV",25,"MRPC155",1531)

^DBTBL("SYSDEV",25,"MRPC155",1532)
	if class = "UT" set tstyle = $$setProperty(tstyle,"border-color","#d2b48c")
^DBTBL("SYSDEV",25,"MRPC155",1533)

^DBTBL("SYSDEV",25,"MRPC155",1534)
	// Output style sheet in HTML format
^DBTBL("SYSDEV",25,"MRPC155",1535)

^DBTBL("SYSDEV",25,"MRPC155",1536)
	do writeln((LF _ "<style type=""text/css"">" _ LF))
^DBTBL("SYSDEV",25,"MRPC155",1537)
	do writeln((LF _ "table.PSL-" _ class _ " {" _ tstyle.replace(";",(";" _ LT)) _ "}" _ LF))
^DBTBL("SYSDEV",25,"MRPC155",1538)
	do writeln((LF _ "table.PSL-" _ class _" th {" _ hstyle.replace(";",(";" _ LT)) _ "}" _ LF))
^DBTBL("SYSDEV",25,"MRPC155",1539)

^DBTBL("SYSDEV",25,"MRPC155",1540)
	// Alternate row background modifies the bottom border of the table
^DBTBL("SYSDEV",25,"MRPC155",1541)
	set alt = xstyle.getSub("alt-row-color",";",":")	// Alternate Row backround
^DBTBL("SYSDEV",25,"MRPC155",1542)
	if (alt = "default") set alt = "#EFFFDF"
^DBTBL("SYSDEV",25,"MRPC155",1543)

^DBTBL("SYSDEV",25,"MRPC155",1544)
	if (alt = tstyle.getSub("background-color",";",":")) set alt = ""	// Same as alternate row
^DBTBL("SYSDEV",25,"MRPC155",1545)

^DBTBL("SYSDEV",25,"MRPC155",1546)
	if (alt.isNull() ! (alt = "none")) set xstyle = $$remProperty(xstyle,"alt-row-color")
^DBTBL("SYSDEV",25,"MRPC155",1547)
	else  set tstyle = $$setProperty(tstyle,"border-bottom-color", alt)
^DBTBL("SYSDEV",25,"MRPC155",1548)
  
^DBTBL("SYSDEV",25,"MRPC155",1549)
	do writeln((LF _ "table.PSL-" _ class _ " td {" _ tstyle.replace(";",(";" _ LT)) _ "}" _ LF))
^DBTBL("SYSDEV",25,"MRPC155",1550)

^DBTBL("SYSDEV",25,"MRPC155",1551)
	if 'alt.isNull() do writeln((LF _ "table.PSL-" _ class _" tr.d1 td {background-color:" _ alt _ "}" _ LF))
^DBTBL("SYSDEV",25,"MRPC155",1552)

^DBTBL("SYSDEV",25,"MRPC155",1553)
	if 'xstyle.translate(";","").isNull() do {
^DBTBL("SYSDEV",25,"MRPC155",1554)

^DBTBL("SYSDEV",25,"MRPC155",1555)
		do writeln((LT _ "/* PROFILE-SQL extended style properties" _ LT))
^DBTBL("SYSDEV",25,"MRPC155",1556)
		do writeln(xstyle.replace(";",(";" _ LT)))
^DBTBL("SYSDEV",25,"MRPC155",1557)
		do writeln(("*/" _ LF))
^DBTBL("SYSDEV",25,"MRPC155",1558)
	}
^DBTBL("SYSDEV",25,"MRPC155",1559)

^DBTBL("SYSDEV",25,"MRPC155",1560)
	do writeln(LF _ "</style>" _ LF)
^DBTBL("SYSDEV",25,"MRPC155",1561)

^DBTBL("SYSDEV",25,"MRPC155",1562)
	set pars("tstyle") = tstyle
^DBTBL("SYSDEV",25,"MRPC155",1563)
	set pars("xstyle") = xstyle
^DBTBL("SYSDEV",25,"MRPC155",1564)

^DBTBL("SYSDEV",25,"MRPC155",1565)
	quit
^DBTBL("SYSDEV",25,"MRPC155",1566)

^DBTBL("SYSDEV",25,"MRPC155",1567)

^DBTBL("SYSDEV",25,"MRPC155",1568)
dftFormat()	// Return application format defaults derived from %MSK* runtime variables
^DBTBL("SYSDEV",25,"MRPC155",1569)

^DBTBL("SYSDEV",25,"MRPC155",1570)
	type Public String %MSKC,%MSKD,%MSKE,%MSKL,%MSKN
^DBTBL("SYSDEV",25,"MRPC155",1571)
	if %MSKN.get().isNull() set %MSKN = "."
^DBTBL("SYSDEV",25,"MRPC155",1572)
	if %MSKE.get().isNull() set %MSKE = "."
^DBTBL("SYSDEV",25,"MRPC155",1573)
	if %MSKD.get().isNull() set %MSKD = "MM/DD/YEAR"
^DBTBL("SYSDEV",25,"MRPC155",1574)
	if %MSKC.get().isNull() set %MSKC = "12:60 AM"
^DBTBL("SYSDEV",25,"MRPC155",1575)
	if %MSKL.get().isNull() set %MSKL = "NY"
^DBTBL("SYSDEV",25,"MRPC155",1576)

^DBTBL("SYSDEV",25,"MRPC155",1577)
	type String format
^DBTBL("SYSDEV",25,"MRPC155",1578)

^DBTBL("SYSDEV",25,"MRPC155",1579)
	// Set the application default to global masks %MSK*
^DBTBL("SYSDEV",25,"MRPC155",1580)

^DBTBL("SYSDEV",25,"MRPC155",1581)
	set format = "number.format=decimal-separator:" _ %MSKN.extract(1).addQuotes()
^DBTBL("SYSDEV",25,"MRPC155",1582)
	if %MSKN.length() > 1 set format = format _ ";group-separator:" _ %MSKN.extract(2).addQuotes() _ ";group-size:3"
^DBTBL("SYSDEV",25,"MRPC155",1583)
	if %MSKN.length() > 2 set format = format _ ";minus-format:" _ %MSKN.extract(3).addQuotes()
^DBTBL("SYSDEV",25,"MRPC155",1584)

^DBTBL("SYSDEV",25,"MRPC155",1585)
	set format = format _ ",currency.format=decimal-separator:" _ %MSKE.extract(1).addQuotes()
^DBTBL("SYSDEV",25,"MRPC155",1586)
	if %MSKE.length() > 1 set format = format _ ";group-separator:" _ %MSKE.extract(2).addQuotes() _ ";group-size:3"
^DBTBL("SYSDEV",25,"MRPC155",1587)
	if %MSKE.length() > 2 set format = format _ ";minus-format:" _ %MSKE.extract(3).addQuotes()
^DBTBL("SYSDEV",25,"MRPC155",1588)

^DBTBL("SYSDEV",25,"MRPC155",1589)
 	if '%MSKC.get().isNull() set format = format _ ",time.format=" _ %MSKC.addQuotes()
^DBTBL("SYSDEV",25,"MRPC155",1590)
 	if '%MSKD.get().isNull() set format = format _ ",date.format=" _ %MSKD.addQuotes()
^DBTBL("SYSDEV",25,"MRPC155",1591)
 	if '%MSKL.get().isNull() set format = format _ ",logical.format=" _ %MSKL.addQuotes()
^DBTBL("SYSDEV",25,"MRPC155",1592)

^DBTBL("SYSDEV",25,"MRPC155",1593)
	quit format
^DBTBL("SYSDEV",25,"MRPC155",1594)

^DBTBL("SYSDEV",25,"MRPC155",1595)

^DBTBL("SYSDEV",25,"MRPC155",1596)
getFormat(String class, String format)	// Return internal format from external format
^DBTBL("SYSDEV",25,"MRPC155",1597)

^DBTBL("SYSDEV",25,"MRPC155",1598)
	if class = "currency" ! (class = "number") do {
^DBTBL("SYSDEV",25,"MRPC155",1599)
	
^DBTBL("SYSDEV",25,"MRPC155",1600)
		type Number z
^DBTBL("SYSDEV",25,"MRPC155",1601)

^DBTBL("SYSDEV",25,"MRPC155",1602)
		// Note: group-size is specified but not implemented, will default to 3 in NUM^%ZM
^DBTBL("SYSDEV",25,"MRPC155",1603)
		set z = $$getProperty("decimal-separator", format)
^DBTBL("SYSDEV",25,"MRPC155",1604)
		set z = z _ $$getProperty("group-separator", format)
^DBTBL("SYSDEV",25,"MRPC155",1605)
		set z = z _ $$getProperty("minus-format", format)
^DBTBL("SYSDEV",25,"MRPC155",1606)

^DBTBL("SYSDEV",25,"MRPC155",1607)
		set format = z if format = "." set format = ""			// Standard decimal
^DBTBL("SYSDEV",25,"MRPC155",1608)
	}
^DBTBL("SYSDEV",25,"MRPC155",1609)

^DBTBL("SYSDEV",25,"MRPC155",1610)
	// else  set format = $$getProperty("mask", format)
^DBTBL("SYSDEV",25,"MRPC155",1611)
	// if z.piece(":",2,2,"""").isNull() set z = "mask:" _ z 
^DBTBL("SYSDEV",25,"MRPC155",1612)
	// Other formats don't have multiple properties
^DBTBL("SYSDEV",25,"MRPC155",1613)

^DBTBL("SYSDEV",25,"MRPC155",1614)
	if (format = "none") set format = ""
^DBTBL("SYSDEV",25,"MRPC155",1615)
	else  set format = format.upperCase()
^DBTBL("SYSDEV",25,"MRPC155",1616)

^DBTBL("SYSDEV",25,"MRPC155",1617)
	quit format
^DBTBL("SYSDEV",25,"MRPC155",1618)

^DBTBL("SYSDEV",25,"MRPC155",1619)

^DBTBL("SYSDEV",25,"MRPC155",1620)
getProperty(String property, String input, String default)	// Return property value
^DBTBL("SYSDEV",25,"MRPC155",1621)

^DBTBL("SYSDEV",25,"MRPC155",1622)
	if 'input.beginsWith(";") set input = ";" _ input
^DBTBL("SYSDEV",25,"MRPC155",1623)
 
^DBTBL("SYSDEV",25,"MRPC155",1624)
	type String value = input.piece((";" _ property _ ":"),2,2,"""").piece(";",1,1,"""")
^DBTBL("SYSDEV",25,"MRPC155",1625)
 
^DBTBL("SYSDEV",25,"MRPC155",1626)
	if value.contains("""") set value = value.stripQuotes()
^DBTBL("SYSDEV",25,"MRPC155",1627)

^DBTBL("SYSDEV",25,"MRPC155",1628)
	if ((value = "default") ! value.isNull()) set value = default.get()
^DBTBL("SYSDEV",25,"MRPC155",1629)
	if (value = "none") set value = ""
^DBTBL("SYSDEV",25,"MRPC155",1630)
 
^DBTBL("SYSDEV",25,"MRPC155",1631)
	quit value
^DBTBL("SYSDEV",25,"MRPC155",1632)

^DBTBL("SYSDEV",25,"MRPC155",1633)

^DBTBL("SYSDEV",25,"MRPC155",1634)
setProperty(String expr, String name, String val, String tok)	// Insert or update a property in expr
^DBTBL("SYSDEV",25,"MRPC155",1635)

^DBTBL("SYSDEV",25,"MRPC155",1636)
	/* Add or update a property to a string using the delimiter ';'
^DBTBL("SYSDEV",25,"MRPC155",1637)
	   to seperate properties and ':' to seperate property names from values.
^DBTBL("SYSDEV",25,"MRPC155",1638)

^DBTBL("SYSDEV",25,"MRPC155",1639)
	   New properties are added to the end, found properties are changed in place.
^DBTBL("SYSDEV",25,"MRPC155",1640)
	*/
^DBTBL("SYSDEV",25,"MRPC155",1641)

^DBTBL("SYSDEV",25,"MRPC155",1642)
	type Boolean isTokenized = true
^DBTBL("SYSDEV",25,"MRPC155",1643)

^DBTBL("SYSDEV",25,"MRPC155",1644)
	if (tok.get().isNull() & expr.contains("""")) set isTokenized = false, expr = $$token(expr,.tok)
^DBTBL("SYSDEV",25,"MRPC155",1645)

^DBTBL("SYSDEV",25,"MRPC155",1646)
	if val.isNull() quit name
^DBTBL("SYSDEV",25,"MRPC155",1647)
	if (val.contains(":") ! (val.contains(";"))) set val = val.addQuotes("""")	// Quote to protect delimiters
^DBTBL("SYSDEV",25,"MRPC155",1648)

^DBTBL("SYSDEV",25,"MRPC155",1649)
	set name = (";" _ name _ ":"), expr= (";" _ expr)
^DBTBL("SYSDEV",25,"MRPC155",1650)

^DBTBL("SYSDEV",25,"MRPC155",1651)
	if expr.endsWith(";") set expr = expr.extract(1,expr.length() - 1)
^DBTBL("SYSDEV",25,"MRPC155",1652)

^DBTBL("SYSDEV",25,"MRPC155",1653)
	if '(";" _ expr _ ":").contains(name) set expr = (expr _ name _ val)	// Insert at end
^DBTBL("SYSDEV",25,"MRPC155",1654)
	else  set expr = expr.piece(name,1) _ name _ val _ ";" _ expr.piece(name,2,999).piece(";",2,999)
^DBTBL("SYSDEV",25,"MRPC155",1655)

^DBTBL("SYSDEV",25,"MRPC155",1656)
	set expr = expr.trim(-1,";")
^DBTBL("SYSDEV",25,"MRPC155",1657)

^DBTBL("SYSDEV",25,"MRPC155",1658)
	if (isTokenized = false) set expr = $$UNTOK^%ZS(expr,.tok)
^DBTBL("SYSDEV",25,"MRPC155",1659)

^DBTBL("SYSDEV",25,"MRPC155",1660)
	quit expr
^DBTBL("SYSDEV",25,"MRPC155",1661)

^DBTBL("SYSDEV",25,"MRPC155",1662)

^DBTBL("SYSDEV",25,"MRPC155",1663)
mergeProperties(String expr, String add, String tok)	// Merge or add column attributes (properties) to expr
^DBTBL("SYSDEV",25,"MRPC155",1664)

^DBTBL("SYSDEV",25,"MRPC155",1665)
	if add.isNull() quit expr
^DBTBL("SYSDEV",25,"MRPC155",1666)

^DBTBL("SYSDEV",25,"MRPC155",1667)
	if {List}"none,default".contains(expr.lowerCase()) set expr = ""
^DBTBL("SYSDEV",25,"MRPC155",1668)
	if expr.isNull() quit add
^DBTBL("SYSDEV",25,"MRPC155",1669)

^DBTBL("SYSDEV",25,"MRPC155",1670)
	type Boolean isTokenized = true
^DBTBL("SYSDEV",25,"MRPC155",1671)

^DBTBL("SYSDEV",25,"MRPC155",1672)
	if (tok.get().isNull() & expr.contains("""")) set isTokenized = false, expr = $$token(expr,.tok)
^DBTBL("SYSDEV",25,"MRPC155",1673)

^DBTBL("SYSDEV",25,"MRPC155",1674)
	type Number i
^DBTBL("SYSDEV",25,"MRPC155",1675)
	for i = 1:1:add.length(";") set expr = $$setProperty(expr, add.piece(":",1), add.piece(":",2,add.length()), .tok)
^DBTBL("SYSDEV",25,"MRPC155",1676)

^DBTBL("SYSDEV",25,"MRPC155",1677)
	if (isTokenized = false) set expr = $$UNTOK^%ZS(expr,.tok)
^DBTBL("SYSDEV",25,"MRPC155",1678)

^DBTBL("SYSDEV",25,"MRPC155",1679)
	quit expr
^DBTBL("SYSDEV",25,"MRPC155",1680)

^DBTBL("SYSDEV",25,"MRPC155",1681)
 
^DBTBL("SYSDEV",25,"MRPC155",1682)
remProperty(String expr, String name, String tok)	// Remove a property from an expression
^DBTBL("SYSDEV",25,"MRPC155",1683)

^DBTBL("SYSDEV",25,"MRPC155",1684)
	type Boolean isTokenized = true
^DBTBL("SYSDEV",25,"MRPC155",1685)

^DBTBL("SYSDEV",25,"MRPC155",1686)
	if (tok.get().isNull() & expr.contains("""")) set isTokenized = false, expr = $$token(expr,.tok)
^DBTBL("SYSDEV",25,"MRPC155",1687)

^DBTBL("SYSDEV",25,"MRPC155",1688)
	set name = (";" _ name _ ":")
^DBTBL("SYSDEV",25,"MRPC155",1689)
	if 'expr.beginsWith(";") set expr = (";" _ expr)
^DBTBL("SYSDEV",25,"MRPC155",1690)
	set expr = expr.piece(name,1) _ ";" _ expr.piece(name,2,999).piece(";",2,999)
^DBTBL("SYSDEV",25,"MRPC155",1691)
	if expr.beginsWith(";") set expr = expr.extract(2,expr.length())
^DBTBL("SYSDEV",25,"MRPC155",1692)

^DBTBL("SYSDEV",25,"MRPC155",1693)
	if (isTokenized = false) set expr = $$UNTOK^%ZS(expr,.tok)
^DBTBL("SYSDEV",25,"MRPC155",1694)

^DBTBL("SYSDEV",25,"MRPC155",1695)
	quit expr
^DBTBL("SYSDEV",25,"MRPC155",1696)

^DBTBL("SYSDEV",25,"MRPC155",1697)

^DBTBL("SYSDEV",25,"MRPC155",1698)
token(String expr, String tok)	// Tokenize a string
^DBTBL("SYSDEV",25,"MRPC155",1699)

^DBTBL("SYSDEV",25,"MRPC155",1700)
	if expr.contains("""") set expr = $$TOKEN^%ZS(expr,.tok,"""")
^DBTBL("SYSDEV",25,"MRPC155",1701)

^DBTBL("SYSDEV",25,"MRPC155",1702)
	// Issue with two string delimiters, disable single quote for now at least
^DBTBL("SYSDEV",25,"MRPC155",1703)
	// if expr.contains("'") set expr = $$TOKEN^%ZS(expr,.tok,"'")
^DBTBL("SYSDEV",25,"MRPC155",1704)
	quit expr
^DBTBL("SYSDEV",25,"MRPC155",1705)

^DBTBL("SYSDEV",25,"MRPC155",1706)

^DBTBL("SYSDEV",25,"MRPC155",1707)
parse(String input, String return(), String de, String dv, Boolean upCase, String falseText, String trueText, List valid)	// Parse string into array
^DBTBL("SYSDEV",25,"MRPC155",1708)

^DBTBL("SYSDEV",25,"MRPC155",1709)
	/* Generate a return(tag) = value array
^DBTBL("SYSDEV",25,"MRPC155",1710)
	   - Alway returns untokenized values
^DBTBL("SYSDEV",25,"MRPC155",1711)

^DBTBL("SYSDEV",25,"MRPC155",1712)
	input :== expression <de> expression
^DBTBL("SYSDEV",25,"MRPC155",1713)
	        expression :== tag <dv> value
^DBTBL("SYSDEV",25,"MRPC155",1714)

^DBTBL("SYSDEV",25,"MRPC155",1715)
	- Whitespace is stripped from tags and values
^DBTBL("SYSDEV",25,"MRPC155",1716)
	- Allows either single or double quotes, one layer of quotes is stripped
^DBTBL("SYSDEV",25,"MRPC155",1717)
	- Tags are converted to either upper or lower case (default = lower)
^DBTBL("SYSDEV",25,"MRPC155",1718)
	- Tags with space characters moves afterSpace string to value, e.g.
^DBTBL("SYSDEV",25,"MRPC155",1719)
	  
^DBTBL("SYSDEV",25,"MRPC155",1720)
	  input="heading HTML='<br> Myheading'"  ==>  return("heading")="HTML" _ $c(9) _ "<br> Myheading"
^DBTBL("SYSDEV",25,"MRPC155",1721)

^DBTBL("SYSDEV",25,"MRPC155",1722)
	*/
^DBTBL("SYSDEV",25,"MRPC155",1723)

^DBTBL("SYSDEV",25,"MRPC155",1724)
	type Number i
^DBTBL("SYSDEV",25,"MRPC155",1725)
	type String a,c,x
^DBTBL("SYSDEV",25,"MRPC155",1726)

^DBTBL("SYSDEV",25,"MRPC155",1727)
	if de.get().isNull() set de = ","
^DBTBL("SYSDEV",25,"MRPC155",1728)
	if dv.get().isNull() set dv = "="
^DBTBL("SYSDEV",25,"MRPC155",1729)
	if upCase.get().isNull() set upCase = false
^DBTBL("SYSDEV",25,"MRPC155",1730)
	if falseText.get().isNull() set falseText = "none"
^DBTBL("SYSDEV",25,"MRPC155",1731)
	if trueText.get().isNull() set trueText = "default"
^DBTBL("SYSDEV",25,"MRPC155",1732)

^DBTBL("SYSDEV",25,"MRPC155",1733)
	set valid = valid.get()
^DBTBL("SYSDEV",25,"MRPC155",1734)

^DBTBL("SYSDEV",25,"MRPC155",1735)
	if (input = "?") do ERROR(valid,"?") quit
^DBTBL("SYSDEV",25,"MRPC155",1736)

^DBTBL("SYSDEV",25,"MRPC155",1737)
	type Number y = 0, yz = 1
^DBTBL("SYSDEV",25,"MRPC155",1738)

^DBTBL("SYSDEV",25,"MRPC155",1739)
	for  set y = input.find(de, y) do { if (y > input.length()) quit
^DBTBL("SYSDEV",25,"MRPC155",1740)

^DBTBL("SYSDEV",25,"MRPC155",1741)
		if (y = 0) set y = input.length() + 2
^DBTBL("SYSDEV",25,"MRPC155",1742)

^DBTBL("SYSDEV",25,"MRPC155",1743)
		if '(input.extract(yz, y - 1).length("""")#2) quit
^DBTBL("SYSDEV",25,"MRPC155",1744)

^DBTBL("SYSDEV",25,"MRPC155",1745)
		set x = input.extract(yz,y - 2).trim(), yz = y 
^DBTBL("SYSDEV",25,"MRPC155",1746)
		if x.isNull() quit
^DBTBL("SYSDEV",25,"MRPC155",1747)
		set a = x.piece(dv,1).trim(1)
^DBTBL("SYSDEV",25,"MRPC155",1748)
		set x = x.piece(dv,2,x.length()).trim(-1)
^DBTBL("SYSDEV",25,"MRPC155",1749)

^DBTBL("SYSDEV",25,"MRPC155",1750)
		if a.contains(".") set c = a.piece(".",1) _ ".", a = a.piece(".",2)
^DBTBL("SYSDEV",25,"MRPC155",1751)
		else  set c = ""
^DBTBL("SYSDEV",25,"MRPC155",1752)

^DBTBL("SYSDEV",25,"MRPC155",1753)
		if """'".contains(x.extract(1)) set x = x.stripQuotes(x.extract(1))
^DBTBL("SYSDEV",25,"MRPC155",1754)

^DBTBL("SYSDEV",25,"MRPC155",1755)
		if a.contains(" ") set x = a.piece(" ",2,a.length()) _ $c(9) _ x, a = a.piece(" ",1)
^DBTBL("SYSDEV",25,"MRPC155",1756)
		if a.isNull() do ERROR("Property name or tag expected",input.piece(de,i)) quit
^DBTBL("SYSDEV",25,"MRPC155",1757)

^DBTBL("SYSDEV",25,"MRPC155",1758)
		if upCase set a = a.upperCase()
^DBTBL("SYSDEV",25,"MRPC155",1759)
		else  set a = a.lowerCase()
^DBTBL("SYSDEV",25,"MRPC155",1760)

^DBTBL("SYSDEV",25,"MRPC155",1761)
		if x.isNull() do {
^DBTBL("SYSDEV",25,"MRPC155",1762)

^DBTBL("SYSDEV",25,"MRPC155",1763)
			if (upCase = true & a.beginsWith("NO")) set x = falseText, a = a.extract(3,a.length())
^DBTBL("SYSDEV",25,"MRPC155",1764)
			else  if a.beginsWith("no") set x = falseText, a = a.extract(3,a.length())
^DBTBL("SYSDEV",25,"MRPC155",1765)
			else  set x = trueText
^DBTBL("SYSDEV",25,"MRPC155",1766)
			}
^DBTBL("SYSDEV",25,"MRPC155",1767)

^DBTBL("SYSDEV",25,"MRPC155",1768)
		if '(valid.isNull() ! valid.contains(a)) do ERROR("Invalid property name or tag",a) quit
^DBTBL("SYSDEV",25,"MRPC155",1769)

^DBTBL("SYSDEV",25,"MRPC155",1770)
		// Join the class back to the property, if this is a root property change all classes
^DBTBL("SYSDEV",25,"MRPC155",1771)
		// Implemented through 'brute-force' scan (should be OK unless list is very large)
^DBTBL("SYSDEV",25,"MRPC155",1772)

^DBTBL("SYSDEV",25,"MRPC155",1773)
		if 'c.isNull() set a = c _ a if (c = ".") do {
^DBTBL("SYSDEV",25,"MRPC155",1774)

^DBTBL("SYSDEV",25,"MRPC155",1775)
			type String n = ""
^DBTBL("SYSDEV",25,"MRPC155",1776)
			for  set n = return(n).order() quit:n.isNull()  if n.contains(a) set return(n) = $$mergeProperties(return(n), x)
^DBTBL("SYSDEV",25,"MRPC155",1777)
		}
^DBTBL("SYSDEV",25,"MRPC155",1778)

^DBTBL("SYSDEV",25,"MRPC155",1779)

^DBTBL("SYSDEV",25,"MRPC155",1780)
		// Multi-value syntax (tag:value;)
^DBTBL("SYSDEV",25,"MRPC155",1781)
		if ('(dv = ":") & return(a).exists()) set x = $$mergeProperties(return(a), x)
^DBTBL("SYSDEV",25,"MRPC155",1782)

^DBTBL("SYSDEV",25,"MRPC155",1783)
		set return(a) = x
^DBTBL("SYSDEV",25,"MRPC155",1784)
	}
^DBTBL("SYSDEV",25,"MRPC155",1785)

^DBTBL("SYSDEV",25,"MRPC155",1786)
	quit
^DBTBL("SYSDEV",25,"MRPC155",1787)

^DBTBL("SYSDEV",25,"MRPC155",1788)

^DBTBL("SYSDEV",25,"MRPC155",1789)
code(String pars(), String vsql(), String exe(), Boolean isHTML)		  // Display SQL code and data region
^DBTBL("SYSDEV",25,"MRPC155",1790)

^DBTBL("SYSDEV",25,"MRPC155",1791)
	type Literal String COLPAR = "length,type,decimal,format,align,merge,space,math,wrap,repeat,null,break,style,heading,title"
^DBTBL("SYSDEV",25,"MRPC155",1792)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",1793)
	type Literal String TAB = $c(9)
^DBTBL("SYSDEV",25,"MRPC155",1794)

^DBTBL("SYSDEV",25,"MRPC155",1795)
	type String d,hdg,colgrp,n,m
^DBTBL("SYSDEV",25,"MRPC155",1796)
	type String xcol()
^DBTBL("SYSDEV",25,"MRPC155",1797)

^DBTBL("SYSDEV",25,"MRPC155",1798)
	type Number IORM = 0
^DBTBL("SYSDEV",25,"MRPC155",1799)

^DBTBL("SYSDEV",25,"MRPC155",1800)
	type Row colrec = "".toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",1801)

^DBTBL("SYSDEV",25,"MRPC155",1802)
	set xcol = 2
^DBTBL("SYSDEV",25,"MRPC155",1803)

^DBTBL("SYSDEV",25,"MRPC155",1804)
	set colrec.type = "T"
^DBTBL("SYSDEV",25,"MRPC155",1805)
	set colrec.space = 2
^DBTBL("SYSDEV",25,"MRPC155",1806)
	set colrec.align = "left"
^DBTBL("SYSDEV",25,"MRPC155",1807)

^DBTBL("SYSDEV",25,"MRPC155",1808)
	set colrec.length = 4
^DBTBL("SYSDEV",25,"MRPC155",1809)
	set colrec.heading = "Line"
^DBTBL("SYSDEV",25,"MRPC155",1810)
	set xcol(1) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1811)

^DBTBL("SYSDEV",25,"MRPC155",1812)
	set colrec.length = 74
^DBTBL("SYSDEV",25,"MRPC155",1813)
	set colrec.heading = "Code"
^DBTBL("SYSDEV",25,"MRPC155",1814)
	set colrec.title = "exe(line)"
^DBTBL("SYSDEV",25,"MRPC155",1815)
	set xcol(2) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1816)

^DBTBL("SYSDEV",25,"MRPC155",1817)
	if '(exe.get() = exe("").order(-1)) do writeln(LF _ "** Program pointer is: " _ exe)
^DBTBL("SYSDEV",25,"MRPC155",1818)

^DBTBL("SYSDEV",25,"MRPC155",1819)
	set hdg = $$bldhdg(.xcol(), , isHTML, .IORM, .colgrp)
^DBTBL("SYSDEV",25,"MRPC155",1820)

^DBTBL("SYSDEV",25,"MRPC155",1821)
	if (isHTML = true) do newTable(pars(), "UT", colgrp)
^DBTBL("SYSDEV",25,"MRPC155",1822)

^DBTBL("SYSDEV",25,"MRPC155",1823)
	do caption("Show SQL Executable Code ", "UT", isHTML, IORM) 
^DBTBL("SYSDEV",25,"MRPC155",1824)
	do writeln(LF _ hdg)
^DBTBL("SYSDEV",25,"MRPC155",1825)

^DBTBL("SYSDEV",25,"MRPC155",1826)
	set n = ""
^DBTBL("SYSDEV",25,"MRPC155",1827)
	for  set n = exe(n).order() quit:n.isNull()  do {
^DBTBL("SYSDEV",25,"MRPC155",1828)

^DBTBL("SYSDEV",25,"MRPC155",1829)
		set d = n _ TAB _ exe(n)
^DBTBL("SYSDEV",25,"MRPC155",1830)
		if (isHTML = true) set d = $$escape(d)
^DBTBL("SYSDEV",25,"MRPC155",1831)
		do writeln($$bldRow(d, .xcol(), isHTML))
^DBTBL("SYSDEV",25,"MRPC155",1832)
	}
^DBTBL("SYSDEV",25,"MRPC155",1833)

^DBTBL("SYSDEV",25,"MRPC155",1834)
	if (isHTML = true) do writeln(LF _ "</table>" _ LF)
^DBTBL("SYSDEV",25,"MRPC155",1835)

^DBTBL("SYSDEV",25,"MRPC155",1836)
	do section(IORM, isHTML)
^DBTBL("SYSDEV",25,"MRPC155",1837)

^DBTBL("SYSDEV",25,"MRPC155",1838)
	// Display vsql array 
^DBTBL("SYSDEV",25,"MRPC155",1839)

^DBTBL("SYSDEV",25,"MRPC155",1840)
	set IORM = 0
^DBTBL("SYSDEV",25,"MRPC155",1841)

^DBTBL("SYSDEV",25,"MRPC155",1842)
	set colrec.length = 12
^DBTBL("SYSDEV",25,"MRPC155",1843)
	set colrec.heading = "Key"
^DBTBL("SYSDEV",25,"MRPC155",1844)
	set colrec.title = "vsql(key)"
^DBTBL("SYSDEV",25,"MRPC155",1845)
	set xcol(1) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1846)

^DBTBL("SYSDEV",25,"MRPC155",1847)
	set colrec.length = 40
^DBTBL("SYSDEV",25,"MRPC155",1848)
	set colrec.heading = "Value"
^DBTBL("SYSDEV",25,"MRPC155",1849)
	set xcol(2) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1850)

^DBTBL("SYSDEV",25,"MRPC155",1851)
	set hdg = $$bldhdg(.xcol(), , isHTML, .IORM, .colgrp)
^DBTBL("SYSDEV",25,"MRPC155",1852)

^DBTBL("SYSDEV",25,"MRPC155",1853)
	if (isHTML = true) do newTable(pars(), "UT", colgrp)
^DBTBL("SYSDEV",25,"MRPC155",1854)

^DBTBL("SYSDEV",25,"MRPC155",1855)
	do caption("Show Data Context", "UT", isHTML, IORM)
^DBTBL("SYSDEV",25,"MRPC155",1856)
	do writeln(LF _ hdg)
^DBTBL("SYSDEV",25,"MRPC155",1857)

^DBTBL("SYSDEV",25,"MRPC155",1858)
	set n = "", m = ""
^DBTBL("SYSDEV",25,"MRPC155",1859)
	for  set n = vsql(n).order() quit:n.isNull()  do {
^DBTBL("SYSDEV",25,"MRPC155",1860)

^DBTBL("SYSDEV",25,"MRPC155",1861)
		if (vsql(n).exists() # 2) do {
^DBTBL("SYSDEV",25,"MRPC155",1862)

^DBTBL("SYSDEV",25,"MRPC155",1863)
			set d = n _ TAB _ vsql(n).addQuotes()
^DBTBL("SYSDEV",25,"MRPC155",1864)
			if (isHTML = true) set d = $$escape(d)
^DBTBL("SYSDEV",25,"MRPC155",1865)
			do writeln($$bldRow(d, .xcol(), isHTML))
^DBTBL("SYSDEV",25,"MRPC155",1866)
		}
^DBTBL("SYSDEV",25,"MRPC155",1867)

^DBTBL("SYSDEV",25,"MRPC155",1868)
		if (n = "P") quit				// Don't show access plan
^DBTBL("SYSDEV",25,"MRPC155",1869)

^DBTBL("SYSDEV",25,"MRPC155",1870)
		for  set m = vsql(n,m).order() quit:m.isNull()  do {
^DBTBL("SYSDEV",25,"MRPC155",1871)
	
^DBTBL("SYSDEV",25,"MRPC155",1872)
			if (vsql(n,m).exists() # 2) do {
^DBTBL("SYSDEV",25,"MRPC155",1873)

^DBTBL("SYSDEV",25,"MRPC155",1874)
				set d = n _ "," _ m _ TAB _ vsql(n,m).addQuotes()
^DBTBL("SYSDEV",25,"MRPC155",1875)
				if (isHTML = true) set d = $$escape(d)
^DBTBL("SYSDEV",25,"MRPC155",1876)
				do writeln($$bldRow(d, .xcol(), isHTML))
^DBTBL("SYSDEV",25,"MRPC155",1877)
			}
^DBTBL("SYSDEV",25,"MRPC155",1878)
		}
^DBTBL("SYSDEV",25,"MRPC155",1879)
	}
^DBTBL("SYSDEV",25,"MRPC155",1880)

^DBTBL("SYSDEV",25,"MRPC155",1881)
	if (isHTML = true) do writeln(LF _ "</table>")
^DBTBL("SYSDEV",25,"MRPC155",1882)
	do section(IORM, isHTML)
^DBTBL("SYSDEV",25,"MRPC155",1883)
	quit
^DBTBL("SYSDEV",25,"MRPC155",1884)

^DBTBL("SYSDEV",25,"MRPC155",1885)

^DBTBL("SYSDEV",25,"MRPC155",1886)
showPars(String pars(), String xcol(), Boolean isHTML)	// Show user parameter input
^DBTBL("SYSDEV",25,"MRPC155",1887)

^DBTBL("SYSDEV",25,"MRPC155",1888)
	// This procedure outputs input parameters
^DBTBL("SYSDEV",25,"MRPC155",1889)
	// For table and column properties
^DBTBL("SYSDEV",25,"MRPC155",1890)

^DBTBL("SYSDEV",25,"MRPC155",1891)
	type Literal String COLPAR = "length,type,decimal,format,align,merge,space,math,wrap,repeat,null,break,style,heading,title"
^DBTBL("SYSDEV",25,"MRPC155",1892)
	type Literal String TAB = $c(9)
^DBTBL("SYSDEV",25,"MRPC155",1893)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",1894)

^DBTBL("SYSDEV",25,"MRPC155",1895)
	type String d,n,hdg,colgrp
^DBTBL("SYSDEV",25,"MRPC155",1896)
	type String zcol()
^DBTBL("SYSDEV",25,"MRPC155",1897)

^DBTBL("SYSDEV",25,"MRPC155",1898)
	type Number i,IORM
^DBTBL("SYSDEV",25,"MRPC155",1899)

^DBTBL("SYSDEV",25,"MRPC155",1900)
	type Row colrec = "".toRow(COLPAR,"|")
^DBTBL("SYSDEV",25,"MRPC155",1901)

^DBTBL("SYSDEV",25,"MRPC155",1902)
	// Display // Table level qualifiers
^DBTBL("SYSDEV",25,"MRPC155",1903)

^DBTBL("SYSDEV",25,"MRPC155",1904)
	set zcol = 2, IORM = 0
^DBTBL("SYSDEV",25,"MRPC155",1905)

^DBTBL("SYSDEV",25,"MRPC155",1906)
	set colrec.space = 2
^DBTBL("SYSDEV",25,"MRPC155",1907)
	set colrec.length = 12
^DBTBL("SYSDEV",25,"MRPC155",1908)
	set colrec.heading = "Name"
^DBTBL("SYSDEV",25,"MRPC155",1909)
	set zcol(1) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1910)

^DBTBL("SYSDEV",25,"MRPC155",1911)
	set colrec.length = 40
^DBTBL("SYSDEV",25,"MRPC155",1912)
	set colrec.heading = "Value"
^DBTBL("SYSDEV",25,"MRPC155",1913)
	set zcol(2) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1914)

^DBTBL("SYSDEV",25,"MRPC155",1915)
	set hdg = $$bldhdg(.zcol(), ,isHTML, .IORM, .colgrp)
^DBTBL("SYSDEV",25,"MRPC155",1916)

^DBTBL("SYSDEV",25,"MRPC155",1917)
	if (isHTML = true) do newTable(pars(), "UT", colgrp)
^DBTBL("SYSDEV",25,"MRPC155",1918)

^DBTBL("SYSDEV",25,"MRPC155",1919)
	do caption("Show Input Table Qualifiers", "UT", isHTML, IORM) 
^DBTBL("SYSDEV",25,"MRPC155",1920)
	do writeln(LF _ hdg)
^DBTBL("SYSDEV",25,"MRPC155",1921)

^DBTBL("SYSDEV",25,"MRPC155",1922)
	set n = ""
^DBTBL("SYSDEV",25,"MRPC155",1923)
	for  set n = pars(n).order() quit:(n.isNull() ! (n?1L.E))  if (pars(n).exists() # 2)  do {
^DBTBL("SYSDEV",25,"MRPC155",1924)

^DBTBL("SYSDEV",25,"MRPC155",1925)
		set d = n _ TAB _ pars(n)
^DBTBL("SYSDEV",25,"MRPC155",1926)
		if (isHTML = true) set d = $$escape(d)
^DBTBL("SYSDEV",25,"MRPC155",1927)
	 	do writeln($$bldRow(d, .zcol(), isHTML))
^DBTBL("SYSDEV",25,"MRPC155",1928)
	}
^DBTBL("SYSDEV",25,"MRPC155",1929)

^DBTBL("SYSDEV",25,"MRPC155",1930)
	if (isHTML = true) do writeln(LF _ "</table>")
^DBTBL("SYSDEV",25,"MRPC155",1931)

^DBTBL("SYSDEV",25,"MRPC155",1932)
	do section(IORM, isHTML)
^DBTBL("SYSDEV",25,"MRPC155",1933)

^DBTBL("SYSDEV",25,"MRPC155",1934)
	// Display [ Column qualifiers]
^DBTBL("SYSDEV",25,"MRPC155",1935)

^DBTBL("SYSDEV",25,"MRPC155",1936)
	type String colpar = COLPAR
^DBTBL("SYSDEV",25,"MRPC155",1937)

^DBTBL("SYSDEV",25,"MRPC155",1938)
	set colrec.length = 6
^DBTBL("SYSDEV",25,"MRPC155",1939)
	set colrec.type = "N"
^DBTBL("SYSDEV",25,"MRPC155",1940)
	set colrec.heading = "Column"
^DBTBL("SYSDEV",25,"MRPC155",1941)
	set zcol(1) = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1942)

^DBTBL("SYSDEV",25,"MRPC155",1943)
	set colrec.type = "T"
^DBTBL("SYSDEV",25,"MRPC155",1944)
	set colrec.length = 8
^DBTBL("SYSDEV",25,"MRPC155",1945)

^DBTBL("SYSDEV",25,"MRPC155",1946)
	for i = 1:1:colpar.length(",") set colrec.heading = colpar.piece(",", i), zcol(i + 1)  = colrec.toString()
^DBTBL("SYSDEV",25,"MRPC155",1947)
 		
^DBTBL("SYSDEV",25,"MRPC155",1948)
	set zcol = (i + 1), IORM = 0
^DBTBL("SYSDEV",25,"MRPC155",1949)

^DBTBL("SYSDEV",25,"MRPC155",1950)
	set hdg = $$bldhdg(.zcol(), ,isHTML, .IORM, .colgrp)
^DBTBL("SYSDEV",25,"MRPC155",1951)

^DBTBL("SYSDEV",25,"MRPC155",1952)
	if (isHTML = true) do newTable(pars(), "UT", colgrp)
^DBTBL("SYSDEV",25,"MRPC155",1953)

^DBTBL("SYSDEV",25,"MRPC155",1954)
	do caption("Show Input Column Properties", "UT", isHTML, IORM) 
^DBTBL("SYSDEV",25,"MRPC155",1955)
	do writeln(LF _ hdg)
^DBTBL("SYSDEV",25,"MRPC155",1956)

^DBTBL("SYSDEV",25,"MRPC155",1957)
	set n = ""
^DBTBL("SYSDEV",25,"MRPC155",1958)
	for  set n = xcol(n).order() quit:n.isNull()  if (xcol(n).exists() # 2) do {
^DBTBL("SYSDEV",25,"MRPC155",1959)

^DBTBL("SYSDEV",25,"MRPC155",1960)
		set d = n _ TAB _ xcol(n).replace("|", TAB)
^DBTBL("SYSDEV",25,"MRPC155",1961)
		if (isHTML = true) set d = $$escape(d)
^DBTBL("SYSDEV",25,"MRPC155",1962)
	 	do writeln($$bldRow(d, .zcol(), isHTML))
^DBTBL("SYSDEV",25,"MRPC155",1963)
	}
^DBTBL("SYSDEV",25,"MRPC155",1964)
	if (isHTML = true) do writeln(LF _ "</table>")
^DBTBL("SYSDEV",25,"MRPC155",1965)

^DBTBL("SYSDEV",25,"MRPC155",1966)
	do section(IORM, isHTML)
^DBTBL("SYSDEV",25,"MRPC155",1967)
	quit
^DBTBL("SYSDEV",25,"MRPC155",1968)

^DBTBL("SYSDEV",25,"MRPC155",1969)

^DBTBL("SYSDEV",25,"MRPC155",1970)
newTable(String pars(), String class, String colgrp)	// Start a new HTML table
^DBTBL("SYSDEV",25,"MRPC155",1971)
	type Literal String LF = $c(13)
^DBTBL("SYSDEV",25,"MRPC155",1972)
	if 'pars("css",class).exists() do dftCSS(pars(), class) set pars("css",class) = ""
^DBTBL("SYSDEV",25,"MRPC155",1973)
	do writeln(LF _ "<table class=PSL-" _ class _ ">" _ LF _ colgrp)
^DBTBL("SYSDEV",25,"MRPC155",1974)
	quit
^DBTBL("SYSDEV",25,"MRPC155",1975)

^DBTBL("SYSDEV",25,"MRPC155",1976)

^DBTBL("SYSDEV",25,"MRPC155",1977)
escape(String str) // Escape HTML characters
^DBTBL("SYSDEV",25,"MRPC155",1978)

^DBTBL("SYSDEV",25,"MRPC155",1979)
	if str.contains("&") set str = str.replace("&","&amp;")
^DBTBL("SYSDEV",25,"MRPC155",1980)
	if str.contains("<") set str = str.replace("<","&lt;")
^DBTBL("SYSDEV",25,"MRPC155",1981)
	if str.contains(">") set str = str.replace(">","&gt;")
^DBTBL("SYSDEV",25,"MRPC155",1982)
	if str.contains("""") set str = str.replace("""","&quot;")
^DBTBL("SYSDEV",25,"MRPC155",1983)

^DBTBL("SYSDEV",25,"MRPC155",1984)
	quit str
^DBTBL("SYSDEV",25,"MRPC155",1985)

^DBTBL("SYSDEV",25,"MRPC155",1986)

^DBTBL("SYSDEV",25,"MRPC155",1987)
unEscape(String str)	// Unescape HTML characters
^DBTBL("SYSDEV",25,"MRPC155",1988)

^DBTBL("SYSDEV",25,"MRPC155",1989)
	type Number y = 0
^DBTBL("SYSDEV",25,"MRPC155",1990)
	type String x
^DBTBL("SYSDEV",25,"MRPC155",1991)

^DBTBL("SYSDEV",25,"MRPC155",1992)
	for  set y = str.find("&",y) quit:(y = 0)  do {
^DBTBL("SYSDEV",25,"MRPC155",1993)
		set x = str.extract(y,y + 4)
^DBTBL("SYSDEV",25,"MRPC155",1994)
	
^DBTBL("SYSDEV",25,"MRPC155",1995)
		if x.beginsWith("lt ") set str = str.extract(y - 2) _ "<" _ str.extract( y + 3, str.length())
^DBTBL("SYSDEV",25,"MRPC155",1996)
		else  if x.beginsWith("gt ") set str = str.extract(y - 2) _ ">" _ str.extract( y + 3, str.length())
^DBTBL("SYSDEV",25,"MRPC155",1997)
		else  if x.beginsWith("amp ") set str = str.extract(y - 2) _ "&" _ str.extract( y + 4, str.length())
^DBTBL("SYSDEV",25,"MRPC155",1998)
		else  if x = "apos " set str = str.extract(y - 2) _ "'" _ str.extract( y + 5, str.length())
^DBTBL("SYSDEV",25,"MRPC155",1999)
		else  if x = "quot " set str = str.extract(y - 2) _ """" _ str.extract( y + 5, str.length())
^DBTBL("SYSDEV",25,"MRPC155",2000)
		}
^DBTBL("SYSDEV",25,"MRPC155",2001)

^DBTBL("SYSDEV",25,"MRPC155",2002)
	quit str
^DBTBL("SYSDEV",25,"MRPC155",2003)

^DBTBL("SYSDEV",25,"MRPC155",2004)

^DBTBL("SYSDEV",25,"MRPC155",2005)
ASCIItoHTML(String expr, Boolean isHTML)	// Convert an ASCII string to chars then to html HTML 
^DBTBL("SYSDEV",25,"MRPC155",2006)

^DBTBL("SYSDEV",25,"MRPC155",2007)
	type Number i
^DBTBL("SYSDEV",25,"MRPC155",2008)
	type String chars = $c(expr.piece(",",1))
^DBTBL("SYSDEV",25,"MRPC155",2009)
	if expr.length(",") > 1 for i = 2:1:expr.length(",") set chars = chars _ $c(expr.piece(",",i))
^DBTBL("SYSDEV",25,"MRPC155",2010)

^DBTBL("SYSDEV",25,"MRPC155",2011)
	if 'isHTML quit chars.replace("<br>",$c(10))		// Leave in ASCII 
^DBTBL("SYSDEV",25,"MRPC155",2012)
	
^DBTBL("SYSDEV",25,"MRPC155",2013)
	if chars.contains($c(13,10)) set chars = chars.replace($c(13,10),"<br>")
^DBTBL("SYSDEV",25,"MRPC155",2014)
	if chars.contains($c(10)) set chars = chars.replace($c(10),"<br>")
^DBTBL("SYSDEV",25,"MRPC155",2015)
	if chars.contains($c(13)) set chars = chars.replace($c(13),"<br>")
^DBTBL("SYSDEV",25,"MRPC155",2016)

^DBTBL("SYSDEV",25,"MRPC155",2017)
	quit chars
^DBTBL("SYSDEV",25,"MRPC155",2018)

^DBTBL("SYSDEV",25,"MRPC155",2019)

^DBTBL("SYSDEV",25,"MRPC155",2020)
dispOpts(String parms, String index, List xcol(), String tok)	// Specify display options
^DBTBL("SYSDEV",25,"MRPC155",2021)

^DBTBL("SYSDEV",25,"MRPC155",2022)
	type Public Number ER
^DBTBL("SYSDEV",25,"MRPC155",2023)

^DBTBL("SYSDEV",25,"MRPC155",2024)
	if parms.isNull() quit
^DBTBL("SYSDEV",25,"MRPC155",2025)
	if parms.contains($c(0)) set parms = $$UNTOK^%ZS(parms,.tok)
^DBTBL("SYSDEV",25,"MRPC155",2026)

^DBTBL("SYSDEV",25,"MRPC155",2027)
	type String data,x,tag,pars()
^DBTBL("SYSDEV",25,"MRPC155",2028)

^DBTBL("SYSDEV",25,"MRPC155",2029)
	type List record = "length,type,,format,align,merge,space,math,wrap,repeat,null,break,style,heading,title"
^DBTBL("SYSDEV",25,"MRPC155",2030)

^DBTBL("SYSDEV",25,"MRPC155",2031)
	do parse(parms, .pars(), ",", "=", false, "none", "default", record)
^DBTBL("SYSDEV",25,"MRPC155",2032)

^DBTBL("SYSDEV",25,"MRPC155",2033)
	set tag = "", data= ""
^DBTBL("SYSDEV",25,"MRPC155",2034)
	for  set tag = pars(tag).order() quit:tag.isNull()  do {
^DBTBL("SYSDEV",25,"MRPC155",2035)

^DBTBL("SYSDEV",25,"MRPC155",2036)
		set x = pars(tag)
^DBTBL("SYSDEV",25,"MRPC155",2037)
		if x = "default" set x = ",,,,,32,2,,1,1,,1,,".piece(",",record.position(tag))
^DBTBL("SYSDEV",25,"MRPC155",2038)

^DBTBL("SYSDEV",25,"MRPC155",2039)
		set data.piece("|",record.position(tag)) = x
^DBTBL("SYSDEV",25,"MRPC155",2040)
	}
^DBTBL("SYSDEV",25,"MRPC155",2041)

^DBTBL("SYSDEV",25,"MRPC155",2042)
	set xcol(index) = data
^DBTBL("SYSDEV",25,"MRPC155",2043)
	Quit
^DBTBL("SYSDEV",25,"MRPC155",2044)

^DBTBL("SYSDEV",25,"MRPC155",2045)

^DBTBL("SYSDEV",25,"MRPC155",2046)
rangeCheck(Number val, String ranges, String par)	// Perform valid  range check on input
^DBTBL("SYSDEV",25,"MRPC155",2047)

^DBTBL("SYSDEV",25,"MRPC155",2048)
	// Validate input against ranges
^DBTBL("SYSDEV",25,"MRPC155",2049)
	//                        ranges == range[,...]
^DBTBL("SYSDEV",25,"MRPC155",2050)
	//                                  range == min[:max]
^DBTBL("SYSDEV",25,"MRPC155",2051)

^DBTBL("SYSDEV",25,"MRPC155",2052)
	if val.isNull() quit
^DBTBL("SYSDEV",25,"MRPC155",2053)

^DBTBL("SYSDEV",25,"MRPC155",2054)
	if '{String}val.isNumber() do ERROR("Number Expected",val,par) quit
^DBTBL("SYSDEV",25,"MRPC155",2055)

^DBTBL("SYSDEV",25,"MRPC155",2056)
	type Public Number ER
^DBTBL("SYSDEV",25,"MRPC155",2057)
	type Boolean isRange = true
^DBTBL("SYSDEV",25,"MRPC155",2058)

^DBTBL("SYSDEV",25,"MRPC155",2059)
	if ranges.contains(":") do {
^DBTBL("SYSDEV",25,"MRPC155",2060)

^DBTBL("SYSDEV",25,"MRPC155",2061)
		type Number i,min,max
^DBTBL("SYSDEV",25,"MRPC155",2062)
		type String range
^DBTBL("SYSDEV",25,"MRPC155",2063)

^DBTBL("SYSDEV",25,"MRPC155",2064)
		for i=1:1:ranges.length(",") do { if (isRange = false) quit
^DBTBL("SYSDEV",25,"MRPC155",2065)

^DBTBL("SYSDEV",25,"MRPC155",2066)
			set range = ranges.piece(",",i)
^DBTBL("SYSDEV",25,"MRPC155",2067)
			set min = range.piece(":",1), max = range.piece(":",2)
^DBTBL("SYSDEV",25,"MRPC155",2068)
			if ('min.isNull() & (val < min)) set isRange = false
^DBTBL("SYSDEV",25,"MRPC155",2069)
			else  if ('max.isNull() & (val > max)) set isRange = false
^DBTBL("SYSDEV",25,"MRPC155",2070)
		}
^DBTBL("SYSDEV",25,"MRPC155",2071)
	}
^DBTBL("SYSDEV",25,"MRPC155",2072)

^DBTBL("SYSDEV",25,"MRPC155",2073)
	else  if '{List}ranges.contains(val) set isRange = false		// Simple list
^DBTBL("SYSDEV",25,"MRPC155",2074)

^DBTBL("SYSDEV",25,"MRPC155",2075)
	if isRange = false do ERROR("Not in valid range (" _ ranges _ ")",val,par)
^DBTBL("SYSDEV",25,"MRPC155",2076)
	quit
^DBTBL("SYSDEV",25,"MRPC155",2077)

^DBTBL("SYSDEV",25,"MRPC155",2078)

^DBTBL("SYSDEV",25,"MRPC155",2079)
template(String url, String pars())	// Process an external and default templates
^DBTBL("SYSDEV",25,"MRPC155",2080)

^DBTBL("SYSDEV",25,"MRPC155",2081)
	/* Templates can recursively reference other templates.  If so, qualfiers will
^DBTBL("SYSDEV",25,"MRPC155",2082)
	   aggregate but later (caller) qualifiers will supercede called template qualifiers.
^DBTBL("SYSDEV",25,"MRPC155",2083)
	*/
^DBTBL("SYSDEV",25,"MRPC155",2084)

^DBTBL("SYSDEV",25,"MRPC155",2085)
	if {List}pars("templates").get().contains(url) quit			// Circular recursion
^DBTBL("SYSDEV",25,"MRPC155",2086)
	set pars("templates") = pars("templates").get() _ url _ "," 		// Add name to list
^DBTBL("SYSDEV",25,"MRPC155",2087)
	
^DBTBL("SYSDEV",25,"MRPC155",2088)
	type Literal String PARMS ="BREAK,CACHE,CAPTION,CODE,COLS,DEBUG,DQMODE,FORMAT,HEADINGS,LAYOUT,MARKUP,MATCH,OUTPUT,PAGE,PLAN,ROWS,STYLE,TEMPLATE,TITLE"
^DBTBL("SYSDEV",25,"MRPC155",2089)

^DBTBL("SYSDEV",25,"MRPC155",2090)
	type Public String %MSKE
^DBTBL("SYSDEV",25,"MRPC155",2091)
	type Public String ER
^DBTBL("SYSDEV",25,"MRPC155",2092)

^DBTBL("SYSDEV",25,"MRPC155",2093)
	type String tpars()
^DBTBL("SYSDEV",25,"MRPC155",2094)

^DBTBL("SYSDEV",25,"MRPC155",2095)
	if url.contains(".") do {
^DBTBL("SYSDEV",25,"MRPC155",2096)

^DBTBL("SYSDEV",25,"MRPC155",2097)
		type String ok,parms,x
^DBTBL("SYSDEV",25,"MRPC155",2098)

^DBTBL("SYSDEV",25,"MRPC155",2099)
		set ok = $$FILE^%ZOPEN(url,"READ")
^DBTBL("SYSDEV",25,"MRPC155",2100)
		if 'ok.piece("|",1) do ERROR(ok.piece("|",2)) quit
^DBTBL("SYSDEV",25,"MRPC155",2101)

^DBTBL("SYSDEV",25,"MRPC155",2102)
		set parms = ""
^DBTBL("SYSDEV",25,"MRPC155",2103)

^DBTBL("SYSDEV",25,"MRPC155",2104)
		use url
^DBTBL("SYSDEV",25,"MRPC155",2105)
		while '$ZEOF read x set parms = parms _ x
^DBTBL("SYSDEV",25,"MRPC155",2106)
		close url
^DBTBL("SYSDEV",25,"MRPC155",2107)

^DBTBL("SYSDEV",25,"MRPC155",2108)
		set parms = parms.translate($c(9,10,13),"   ")			// Translate all whitspace to space
^DBTBL("SYSDEV",25,"MRPC155",2109)

^DBTBL("SYSDEV",25,"MRPC155",2110)
		do parse(parms, .tpars(), "/", "=", true, 0, 1, PARMS)
^DBTBL("SYSDEV",25,"MRPC155",2111)

^DBTBL("SYSDEV",25,"MRPC155",2112)
		if 'tpars("TEMPLATE").get().isNull() do {			// Recursive iteration
^DBTBL("SYSDEV",25,"MRPC155",2113)

^DBTBL("SYSDEV",25,"MRPC155",2114)
			type String n,zpars()
^DBTBL("SYSDEV",25,"MRPC155",2115)

^DBTBL("SYSDEV",25,"MRPC155",2116)
			set n =""
^DBTBL("SYSDEV",25,"MRPC155",2117)
			for  set n = tpars(n).order() quit:n.isNull()  set zpars(n) = tpars(n)
^DBTBL("SYSDEV",25,"MRPC155",2118)
			do template(pars("TEMPLATE"), .zpars()) if ER quit
^DBTBL("SYSDEV",25,"MRPC155",2119)
			for  set n = zpars(n).order() quit:n.isNull()  set tpars(n) = zpars(n)
^DBTBL("SYSDEV",25,"MRPC155",2120)
		}
^DBTBL("SYSDEV",25,"MRPC155",2121)
	}
^DBTBL("SYSDEV",25,"MRPC155",2122)

^DBTBL("SYSDEV",25,"MRPC155",2123)
	// Application hard-coded templates (since these are not parsed, don't use [NO]qualifier syntax)
^DBTBL("SYSDEV",25,"MRPC155",2124)

^DBTBL("SYSDEV",25,"MRPC155",2125)
	else  do {
^DBTBL("SYSDEV",25,"MRPC155",2126)
		set url = url.upperCase()
^DBTBL("SYSDEV",25,"MRPC155",2127)

^DBTBL("SYSDEV",25,"MRPC155",2128)
		if (url = "REPORT") do {
^DBTBL("SYSDEV",25,"MRPC155",2129)

^DBTBL("SYSDEV",25,"MRPC155",2130)
			type String grpsep = %MSKE.get().extract(2)
^DBTBL("SYSDEV",25,"MRPC155",2131)
			if grpsep.isNull() set grpsep = ","
^DBTBL("SYSDEV",25,"MRPC155",2132)

^DBTBL("SYSDEV",25,"MRPC155",2133)
			set tpars("STYLE") = "alt-row-color:default"
^DBTBL("SYSDEV",25,"MRPC155",2134)
			set tpars("TITLE") = "default"
^DBTBL("SYSDEV",25,"MRPC155",2135)
			set tpars("BREAK") = "1"
^DBTBL("SYSDEV",25,"MRPC155",2136)
			set tpars("COLS") = "currency.math=SUM,currency.format=group-separator:""" _ grpsep _""",currency.style=minus-color:red"
^DBTBL("SYSDEV",25,"MRPC155",2137)
		}
^DBTBL("SYSDEV",25,"MRPC155",2138)

^DBTBL("SYSDEV",25,"MRPC155",2139)
		// Include additional hard-coded templates as appropriate
^DBTBL("SYSDEV",25,"MRPC155",2140)

^DBTBL("SYSDEV",25,"MRPC155",2141)
		else  do ERROR("Invalid Template",url)
^DBTBL("SYSDEV",25,"MRPC155",2142)
	}
^DBTBL("SYSDEV",25,"MRPC155",2143)

^DBTBL("SYSDEV",25,"MRPC155",2144)
	// These two add or accumulate properties
^DBTBL("SYSDEV",25,"MRPC155",2145)
	if tpars("STYLE").exists() set pars("STYLE") = tpars("STYLE") _ ";" _ pars("STYLE").get()
^DBTBL("SYSDEV",25,"MRPC155",2146)
	if tpars("COLS").exists() set pars("COLS") = tpars("COLS") _ "," _ pars("COLS").get()	
^DBTBL("SYSDEV",25,"MRPC155",2147)

^DBTBL("SYSDEV",25,"MRPC155",2148)
 	kill tpars("STYLE"), tpars("COLS")				// Remove these to, merged above
^DBTBL("SYSDEV",25,"MRPC155",2149)

^DBTBL("SYSDEV",25,"MRPC155",2150)
	type String n = ""
^DBTBL("SYSDEV",25,"MRPC155",2151)
	for  set n = tpars(n).order() quit:n.isNull()  if 'pars(n).exists()  set pars(n) = tpars(n)
^DBTBL("SYSDEV",25,"MRPC155",2152)
	quit
^DBTBL("SYSDEV",25,"MRPC155",2153)

^DBTBL("SYSDEV",25,"MRPC155",2154)
		
^DBTBL("SYSDEV",25,"MRPC155",2155)
initMath(String parms)	// Initialize internal MATH accumulation structures
^DBTBL("SYSDEV",25,"MRPC155",2156)

^DBTBL("SYSDEV",25,"MRPC155",2157)
	/*
^DBTBL("SYSDEV",25,"MRPC155",2158)
	 Validate: AVG,COUNT,HSTO,LEAST,MAX,MED,MIN,MOST,STD,SUM,UNIQUE
^DBTBL("SYSDEV",25,"MRPC155",2159)

^DBTBL("SYSDEV",25,"MRPC155",2160)
	Sample syntax example, math = count; sum break
^DBTBL("SYSDEV",25,"MRPC155",2161)

^DBTBL("SYSDEV",25,"MRPC155",2162)
	ctl - Accumulation control string
^DBTBL("SYSDEV",25,"MRPC155",2163)
		byte #1 - Count
^DBTBL("SYSDEV",25,"MRPC155",2164)
		byte #2 - Total
^DBTBL("SYSDEV",25,"MRPC155",2165)
		byte #3 - Maximum value
^DBTBL("SYSDEV",25,"MRPC155",2166)
		byte #4 - Minimum value
^DBTBL("SYSDEV",25,"MRPC155",2167)
		byte #5 - Histogram accumulate
^DBTBL("SYSDEV",25,"MRPC155",2168)
	*/
^DBTBL("SYSDEV",25,"MRPC155",2169)
				
^DBTBL("SYSDEV",25,"MRPC155",2170)
	type Number i
^DBTBL("SYSDEV",25,"MRPC155",2171)
	type String func,x
^DBTBL("SYSDEV",25,"MRPC155",2172)
	type String ctl = ""
^DBTBL("SYSDEV",25,"MRPC155",2173)

^DBTBL("SYSDEV",25,"MRPC155",2174)
	for i = 1:1:parms.length(";") do {
^DBTBL("SYSDEV",25,"MRPC155",2175)

^DBTBL("SYSDEV",25,"MRPC155",2176)
		set x = parms.piece(";",i).trim() if x.isNull() quit
^DBTBL("SYSDEV",25,"MRPC155",2177)

^DBTBL("SYSDEV",25,"MRPC155",2178)
		set func = x.piece(" ",1), x = x.piece(" ",2,x.length())
^DBTBL("SYSDEV",25,"MRPC155",2179)
		if func.isNull() do ERROR("Math function expected",x) quit
^DBTBL("SYSDEV",25,"MRPC155",2180)

^DBTBL("SYSDEV",25,"MRPC155",2181)
		if func = "COUNT" set ctl.extract(1) = 1
^DBTBL("SYSDEV",25,"MRPC155",2182)
		else  if func = "SUM" set ctl.extract(2) = 1
^DBTBL("SYSDEV",25,"MRPC155",2183)
		else  if func = "MAX" set ctl.extract(3) = 1
^DBTBL("SYSDEV",25,"MRPC155",2184)
		else  if func = "MIN" set ctl.extract(4) = 1
^DBTBL("SYSDEV",25,"MRPC155",2185)
		else  if func = "AVG" set ctl.extract(1) = 1, ctl.extract(2) = 1
^DBTBL("SYSDEV",25,"MRPC155",2186)
		else  if func = "MED" set ctl.extract(1) = 1, ctl.extract(5) = 1
^DBTBL("SYSDEV",25,"MRPC155",2187)
		else  if {List}"HSTO,LEAST,MOST,STD,UNIQUE,COUNT-LEAST,COUNT-MOST".contains(func) set ctl.extract(5) = 1
^DBTBL("SYSDEV",25,"MRPC155",2188)

^DBTBL("SYSDEV",25,"MRPC155",2189)
		else  do ERROR("Invalid Math function",func) quit
^DBTBL("SYSDEV",25,"MRPC155",2190)

^DBTBL("SYSDEV",25,"MRPC155",2191)
		set parms.piece(";",i) = func
^DBTBL("SYSDEV",25,"MRPC155",2192)

^DBTBL("SYSDEV",25,"MRPC155",2193)
		if x.isNull() quit	// No qualifiers
^DBTBL("SYSDEV",25,"MRPC155",2194)
		if x.isNumber() & {List}"MAX,MIN".contains(func) set ctl.extract(5) = 1
^DBTBL("SYSDEV",25,"MRPC155",2195)
		// Need to add RUNNING / BREAK
^DBTBL("SYSDEV",25,"MRPC155",2196)
	}
^DBTBL("SYSDEV",25,"MRPC155",2197)

^DBTBL("SYSDEV",25,"MRPC155",2198)
	quit ctl
^DBTBL("SYSDEV",25,"MRPC155",2199)

^DBTBL("SYSDEV",25,"MRPC155",2200)

^DBTBL("SYSDEV",25,"MRPC155",2201)
selectWild(String sel, String from, String xcol(), String fsn(), String tok)	// Return Data-QWik default list or keys and description
^DBTBL("SYSDEV",25,"MRPC155",2202)

^DBTBL("SYSDEV",25,"MRPC155",2203)
	type Public Number ER
^DBTBL("SYSDEV",25,"MRPC155",2204)

^DBTBL("SYSDEV",25,"MRPC155",2205)
	type Number fnum,i
^DBTBL("SYSDEV",25,"MRPC155",2206)
	type String keys,more,table,typ
^DBTBL("SYSDEV",25,"MRPC155",2207)
	type String columns = ""
^DBTBL("SYSDEV",25,"MRPC155",2208)

^DBTBL("SYSDEV",25,"MRPC155",2209)
	if tok.get().isNull() set sel = $$TOKEN^%ZS(sel,.tok)
^DBTBL("SYSDEV",25,"MRPC155",2210)

^DBTBL("SYSDEV",25,"MRPC155",2211)
	set typ = sel.piece(",",1).trim(1)
^DBTBL("SYSDEV",25,"MRPC155",2212)
	set sel = sel.piece(",",2,sel.length())
^DBTBL("SYSDEV",25,"MRPC155",2213)

^DBTBL("SYSDEV",25,"MRPC155",2214)
	for fnum = 1:1:from.length(",") do {
^DBTBL("SYSDEV",25,"MRPC155",2215)

^DBTBL("SYSDEV",25,"MRPC155",2216)
		set table = from.piece(",",fnum)
^DBTBL("SYSDEV",25,"MRPC155",2217)
		if 'fsn(table).exists() do fsn^SQLDD(.fsn(),table) if ER quit
^DBTBL("SYSDEV",25,"MRPC155",2218)

^DBTBL("SYSDEV",25,"MRPC155",2219)
		set keys = fsn(table).piece("|",3)
^DBTBL("SYSDEV",25,"MRPC155",2220)

^DBTBL("SYSDEV",25,"MRPC155",2221)
		if fnum > 1 set columns = (columns _ ",")
^DBTBL("SYSDEV",25,"MRPC155",2222)
		set columns = columns _ keys			// Always include primary keys
^DBTBL("SYSDEV",25,"MRPC155",2223)

^DBTBL("SYSDEV",25,"MRPC155",2224)
		if typ = "*LIST" set more = $$selectDefault(table, .tok)
^DBTBL("SYSDEV",25,"MRPC155",2225)
		else  if typ.contains($c(0)) set more = $$selectQuery(table, typ, .tok)
^DBTBL("SYSDEV",25,"MRPC155",2226)
		else  set more = ""
^DBTBL("SYSDEV",25,"MRPC155",2227)

^DBTBL("SYSDEV",25,"MRPC155",2228)
		for i=1:1:more.length(",") if '{List}columns.contains(more.piece(",",i)) set columns = columns _ "," _ more.piece(",",i)
^DBTBL("SYSDEV",25,"MRPC155",2229)
	}
^DBTBL("SYSDEV",25,"MRPC155",2230)

^DBTBL("SYSDEV",25,"MRPC155",2231)
	if sel.isNull() quit columns
^DBTBL("SYSDEV",25,"MRPC155",2232)

^DBTBL("SYSDEV",25,"MRPC155",2233)
	// If additional columns are specified, add them to the list if they aren't already
^DBTBL("SYSDEV",25,"MRPC155",2234)
	//  on it and move the external formatting to new column location if appropriate
^DBTBL("SYSDEV",25,"MRPC155",2235)

^DBTBL("SYSDEV",25,"MRPC155",2236)
	// First move any formatting to an 'illegal' location
^DBTBL("SYSDEV",25,"MRPC155",2237)
	type Number n = ""
^DBTBL("SYSDEV",25,"MRPC155",2238)
	for  set n = xcol(n).order() quit:n.isNull()  set xcol(-n + 1) = xcol(n) kill xcol(n)
^DBTBL("SYSDEV",25,"MRPC155",2239)

^DBTBL("SYSDEV",25,"MRPC155",2240)
	for i = 1:1:sel.length(",") do {
^DBTBL("SYSDEV",25,"MRPC155",2241)
		type String di = sel.piece(",",i).trim()
^DBTBL("SYSDEV",25,"MRPC155",2242)
 		if di.contains($c(0)) set di = $$UNTOK^%ZS(di,.tok).stripQuotes()
^DBTBL("SYSDEV",25,"MRPC155",2243)
		if '{List}columns.contains(di) set columns = (columns _ "," _ di)
^DBTBL("SYSDEV",25,"MRPC155",2244)
		if xcol(-i).exists() set xcol({List}columns.position(di)) = xcol(-i) kill xcol(-i)
^DBTBL("SYSDEV",25,"MRPC155",2245)
	}
^DBTBL("SYSDEV",25,"MRPC155",2246)

^DBTBL("SYSDEV",25,"MRPC155",2247)
	quit columns
^DBTBL("SYSDEV",25,"MRPC155",2248)

^DBTBL("SYSDEV",25,"MRPC155",2249)

^DBTBL("SYSDEV",25,"MRPC155",2250)
selectDefault(String table, String tok)	// Select default list
^DBTBL("SYSDEV",25,"MRPC155",2251)

^DBTBL("SYSDEV",25,"MRPC155",2252)
	type Number i
^DBTBL("SYSDEV",25,"MRPC155",2253)

^DBTBL("SYSDEV",25,"MRPC155",2254)
 	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1","%LIBS = ""SYSDEV"" ,FID=:table")
^DBTBL("SYSDEV",25,"MRPC155",2255)

^DBTBL("SYSDEV",25,"MRPC155",2256)
	type String dftdes = dbtbl1.dftdes
^DBTBL("SYSDEV",25,"MRPC155",2257)
	type String dftord = dbtbl1.dftord			// Solve this later
^DBTBL("SYSDEV",25,"MRPC155",2258)

^DBTBL("SYSDEV",25,"MRPC155",2259)
	if "^,#".contains(dftdes.extract(1)) set dftdes = ""
^DBTBL("SYSDEV",25,"MRPC155",2260)

^DBTBL("SYSDEV",25,"MRPC155",2261)
	if dftdes.isNull() do {
^DBTBL("SYSDEV",25,"MRPC155",2262)

^DBTBL("SYSDEV",25,"MRPC155",2263)
		type String di
^DBTBL("SYSDEV",25,"MRPC155",2264)
		type ResultSet rs = Db.select("DI","DBTBL1D","FID=:table and DI BETWEEN 'D' and 'E'")
^DBTBL("SYSDEV",25,"MRPC155",2265)
		while rs.next() set di = rs.getRow().toString() if "DESCRIPTION".beginsWith(di) set dftdes = di
^DBTBL("SYSDEV",25,"MRPC155",2266)
		}
^DBTBL("SYSDEV",25,"MRPC155",2267)

^DBTBL("SYSDEV",25,"MRPC155",2268)
	else  for i = 1:1:dftdes.length(",") set dftdes.piece(",",i) = dftdes.piece(",",i).piece("/",1)
^DBTBL("SYSDEV",25,"MRPC155",2269)

^DBTBL("SYSDEV",25,"MRPC155",2270)
	quit dftdes
^DBTBL("SYSDEV",25,"MRPC155",2271)

^DBTBL("SYSDEV",25,"MRPC155",2272)

^DBTBL("SYSDEV",25,"MRPC155",2273)
selectQuery(String table, String whr, String tok)	// Select default list
^DBTBL("SYSDEV",25,"MRPC155",2274)

^DBTBL("SYSDEV",25,"MRPC155",2275)
	type Public Number ER
^DBTBL("SYSDEV",25,"MRPC155",2276)
	type String columns = ""
^DBTBL("SYSDEV",25,"MRPC155",2277)

^DBTBL("SYSDEV",25,"MRPC155",2278)
	while whr.contains($c(0)) set whr = $$UNTOK^%ZS(whr, .tok)
^DBTBL("SYSDEV",25,"MRPC155",2279)

^DBTBL("SYSDEV",25,"MRPC155",2280)
	do {
^DBTBL("SYSDEV",25,"MRPC155",2281)
		catch error {
^DBTBL("SYSDEV",25,"MRPC155",2282)
			do ERROR(error.description)
^DBTBL("SYSDEV",25,"MRPC155",2283)
		}
^DBTBL("SYSDEV",25,"MRPC155",2284)

^DBTBL("SYSDEV",25,"MRPC155",2285)
		set whr = whr.extract(2,whr.length()).stripQuotes().trim()
^DBTBL("SYSDEV",25,"MRPC155",2286)
		set whr = "FID ='" _ table _ $s(whr.isNull():"'",1:"' AND " _ whr)
^DBTBL("SYSDEV",25,"MRPC155",2287)

^DBTBL("SYSDEV",25,"MRPC155",2288)
		#ACCEPT DATE=12/04/07; PGM=Frank Sanchez; CR=unknown
^DBTBL("SYSDEV",25,"MRPC155",2289)
		type ResultSet rs = Db.select("DI","DBTBL1D",whr,"NOD,POS,DI")
^DBTBL("SYSDEV",25,"MRPC155",2290)
		while rs.next() set columns = (columns _ rs.getRow().DI _ ",")
^DBTBL("SYSDEV",25,"MRPC155",2291)
	}
^DBTBL("SYSDEV",25,"MRPC155",2292)

^DBTBL("SYSDEV",25,"MRPC155",2293)
	quit columns.extract(1, columns.length() - 1)
^DBTBL("SYSDEV",25,"MRPC155",2294)

^DBTBL("SYSDEV",25,"MRPC155",2295)

^DBTBL("SYSDEV",25,"MRPC155",2296)
testMask(String class, String mask)	// Test format masks
^DBTBL("SYSDEV",25,"MRPC155",2297)

^DBTBL("SYSDEV",25,"MRPC155",2298)
	// Calls format mask and traps GTM errors generated by invalid mask
^DBTBL("SYSDEV",25,"MRPC155",2299)
	// Doesn't seem to coordinate the error trap correctly, doesn't return ER
^DBTBL("SYSDEV",25,"MRPC155",2300)

^DBTBL("SYSDEV",25,"MRPC155",2301)
	type Public Number ER
^DBTBL("SYSDEV",25,"MRPC155",2302)

^DBTBL("SYSDEV",25,"MRPC155",2303)
	do {
^DBTBL("SYSDEV",25,"MRPC155",2304)
		catch error {
^DBTBL("SYSDEV",25,"MRPC155",2305)
			set ER = 1
^DBTBL("SYSDEV",25,"MRPC155",2306)
		}
^DBTBL("SYSDEV",25,"MRPC155",2307)
	
^DBTBL("SYSDEV",25,"MRPC155",2308)
		if (class = "currency") & $$NUM^%ZM(0, 0, mask)
^DBTBL("SYSDEV",25,"MRPC155",2309)
		else  if (class ="number") & $$NUM^%ZM(0, 0, mask)
^DBTBL("SYSDEV",25,"MRPC155",2310)
		else  if (class ="date") & $$DAT^%ZM(0, mask)
^DBTBL("SYSDEV",25,"MRPC155",2311)
		else  if (class ="logical") & $$LOG^%ZM(0, mask)
^DBTBL("SYSDEV",25,"MRPC155",2312)
		else  if (class ="time") & $$TIM^%ZM(0, mask)
^DBTBL("SYSDEV",25,"MRPC155",2313)
	}
^DBTBL("SYSDEV",25,"MRPC155",2314)

^DBTBL("SYSDEV",25,"MRPC155",2315)
	quit
^DBTBL("SYSDEV",25,"MRPC155",2316)

^DBTBL("SYSDEV",25,"MRPC155",2317)

^DBTBL("SYSDEV",25,"MRPC155",2318)
ERROR(String des, String val, String par)	// Output Error message & set ER
^DBTBL("SYSDEV",25,"MRPC155",2319)

^DBTBL("SYSDEV",25,"MRPC155",2320)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",2321)

^DBTBL("SYSDEV",25,"MRPC155",2322)
	type Public Number ER
^DBTBL("SYSDEV",25,"MRPC155",2323)
	set ER = 1
^DBTBL("SYSDEV",25,"MRPC155",2324)

^DBTBL("SYSDEV",25,"MRPC155",2325)
	// Try to patch legacy error description syntax to get consistent display
^DBTBL("SYSDEV",25,"MRPC155",2326)
	if des.contains("-") & val.get().isNull() set val = des.piece("-",2,99).trim(), des = des.piece("-",1).trim()
^DBTBL("SYSDEV",25,"MRPC155",2327)

^DBTBL("SYSDEV",25,"MRPC155",2328)
	if 'val.get().isNull() set des = des _ ": " _ val
^DBTBL("SYSDEV",25,"MRPC155",2329)
	if 'par.get().isNull() set des = "Parameter: " _ par _ " - "_ des
^DBTBL("SYSDEV",25,"MRPC155",2330)

^DBTBL("SYSDEV",25,"MRPC155",2331)
	do writeln(LF _ "%SQL-E-" _ des)
^DBTBL("SYSDEV",25,"MRPC155",2332)
	quit
^DBTBL("SYSDEV",25,"MRPC155",2333)

^DBTBL("SYSDEV",25,"MRPC155",2334)

^DBTBL("SYSDEV",25,"MRPC155",2335)
portrait(String hdg, Boolean isHTML, Boolean altbg, String col(), String pars(), String IO, Number IOSL, Number IORM, Number rows)
^DBTBL("SYSDEV",25,"MRPC155",2336)

^DBTBL("SYSDEV",25,"MRPC155",2337)
	/* Moved portrait mode to its own procedure.  Removed break and totals options since not relevant
^DBTBL("SYSDEV",25,"MRPC155",2338)
	   Left IOSL, IORM and PN IO properties, as these may be implemented later
^DBTBL("SYSDEV",25,"MRPC155",2339)
	*/
^DBTBL("SYSDEV",25,"MRPC155",2340)

^DBTBL("SYSDEV",25,"MRPC155",2341)
	type Literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",2342)
	type Public String exe(), vsql()
^DBTBL("SYSDEV",25,"MRPC155",2343)
	type Number break,line,sqlcnt,PN
^DBTBL("SYSDEV",25,"MRPC155",2344)
	type String d,sqldta,sqlind
^DBTBL("SYSDEV",25,"MRPC155",2345)

^DBTBL("SYSDEV",25,"MRPC155",2346)
	set break = 0, line = 0, PN = 0
^DBTBL("SYSDEV",25,"MRPC155",2347)

^DBTBL("SYSDEV",25,"MRPC155",2348)
	if 'pars("CAPTION").get().isNull() do caption(pars("CAPTION"), "RS", isHTML) set line = (line + pars("CAPTION").length(LF))
^DBTBL("SYSDEV",25,"MRPC155",2349)

^DBTBL("SYSDEV",25,"MRPC155",2350)
	set sqlind = ""
^DBTBL("SYSDEV",25,"MRPC155",2351)
	for sqlcnt = 1:1 do { if (vsql(0) = 100) quit
^DBTBL("SYSDEV",25,"MRPC155",2352)

^DBTBL("SYSDEV",25,"MRPC155",2353)
		set vsql = $$^SQLF(.exe,.sqldta,.sqlind) if (vsql = 0) set sqlcnt = (sqlcnt - 1) quit
^DBTBL("SYSDEV",25,"MRPC155",2354)

^DBTBL("SYSDEV",25,"MRPC155",2355)
		if sqlind.contains(1) set sqldta = $$protect(sqldta,sqlind)
^DBTBL("SYSDEV",25,"MRPC155",2356)
		if (isHTML = true) set sqldta = $$escape(sqldta) 		// Process HTML escapes
^DBTBL("SYSDEV",25,"MRPC155",2357)

^DBTBL("SYSDEV",25,"MRPC155",2358)
		set d = $$bldRow(sqldta, .col(), isHTML, , 0)
^DBTBL("SYSDEV",25,"MRPC155",2359)
		do writeln($$wrtPort(d, hdg, isHTML, .pars(), 0 , .line, altbg, .IOSL, IORM, .PN))
^DBTBL("SYSDEV",25,"MRPC155",2360)
		if 'rows.isNull() set rows = (rows - 1) if (rows = 0) set vsql(0) = 100
^DBTBL("SYSDEV",25,"MRPC155",2361)
		
^DBTBL("SYSDEV",25,"MRPC155",2362)
	}
^DBTBL("SYSDEV",25,"MRPC155",2363)

^DBTBL("SYSDEV",25,"MRPC155",2364)
	do close(0, isHTML, IO, sqlcnt, false)
^DBTBL("SYSDEV",25,"MRPC155",2365)

^DBTBL("SYSDEV",25,"MRPC155",2366)

^DBTBL("SYSDEV",25,"MRPC155",2367)
	quit
^DBTBL("SYSDEV",25,"MRPC155",2368)

^DBTBL("SYSDEV",25,"MRPC155",2369)

^DBTBL("SYSDEV",25,"MRPC155",2370)
wrtPort(String rd, String hdg, Boolean isHTML, String pars(), Number break, Number line, Boolean altbg, Number IOSL, Number IORM, Number PN)	// Output a row
^DBTBL("SYSDEV",25,"MRPC155",2371)

^DBTBL("SYSDEV",25,"MRPC155",2372)
	type literal String LF = $c(10)
^DBTBL("SYSDEV",25,"MRPC155",2373)
	type Number cellNum
^DBTBL("SYSDEV",25,"MRPC155",2374)
	type String page = ""
^DBTBL("SYSDEV",25,"MRPC155",2375)
	
^DBTBL("SYSDEV",25,"MRPC155",2376)
	type String trOpen = "<tr>"
^DBTBL("SYSDEV",25,"MRPC155",2377)
	type String trClose = "</tr>"
^DBTBL("SYSDEV",25,"MRPC155",2378)
	
^DBTBL("SYSDEV",25,"MRPC155",2379)
	if altbg set trOpen = "<tr class=d1>"
^DBTBL("SYSDEV",25,"MRPC155",2380)
	
^DBTBL("SYSDEV",25,"MRPC155",2381)
	set rd = rd.piece("<tr>",2) // remove tr from row data
^DBTBL("SYSDEV",25,"MRPC155",2382)

^DBTBL("SYSDEV",25,"MRPC155",2383)
	set hdg = hdg.replace("<br>"," ")
^DBTBL("SYSDEV",25,"MRPC155",2384)
	//set hdg = $$title(.pars(), isHTML, IORM, PN) _ hdg
^DBTBL("SYSDEV",25,"MRPC155",2385)
	
^DBTBL("SYSDEV",25,"MRPC155",2386)
	for cellNum = 1:1:hdg.length(LF) do {
^DBTBL("SYSDEV",25,"MRPC155",2387)
		
^DBTBL("SYSDEV",25,"MRPC155",2388)
		type String rowh,rowd
^DBTBL("SYSDEV",25,"MRPC155",2389)
		set rowh = hdg.piece(LF,cellNum)
^DBTBL("SYSDEV",25,"MRPC155",2390)
		if rowh="" quit
^DBTBL("SYSDEV",25,"MRPC155",2391)
		set rowd = rd.piece("<td>",cellNum+1)
^DBTBL("SYSDEV",25,"MRPC155",2392)
		
^DBTBL("SYSDEV",25,"MRPC155",2393)
		set page = page _ trOpen _ rowh _ "<td>" _rowd _ "</td>" _ trClose _ LF
^DBTBL("SYSDEV",25,"MRPC155",2394)
		
^DBTBL("SYSDEV",25,"MRPC155",2395)
	}
^DBTBL("SYSDEV",25,"MRPC155",2396)

^DBTBL("SYSDEV",25,"MRPC155",2397)
	quit page _ "<tr><td><hr/></td><td><hr/></td></tr>"
^DBTBL("SYSDEV",25,"MRPC155",2398)

^DBTBL("SYSDEV",25,"MRPC155",2399)

^DBTBL("SYSDEV",25,"MRPC155",2400)
writeln(String lineOfText)	// Concatenate line to outbuffer
^DBTBL("SYSDEV",25,"MRPC155",2401)

^DBTBL("SYSDEV",25,"MRPC155",2402)
	type public String outputBuffer	
^DBTBL("SYSDEV",25,"MRPC155",2403)
	set outputBuffer = outputBuffer _ lineOfText
^DBTBL("SYSDEV",25,"MRPC155",2404)
	quit
^DBTBL("SYSDEV",25,"MRPC155",2405)

^DBTBL("SYSDEV",25,"MRPC155",2406)

^DBTBL("SYSDEV",25,"MRPC155",2407)
getClass(String typ)	// Return the class that corresponds to type
^DBTBL("SYSDEV",25,"MRPC155",2408)

^DBTBL("SYSDEV",25,"MRPC155",2409)
	type Literal String CLASSES = "text,currency,date,number,logical,time,frequency,memo,upper,blob"
^DBTBL("SYSDEV",25,"MRPC155",2410)
	quit CLASSES.piece(",","T$DNLCFMUB".find(typ) - 1)
^DBTBL("SYSDEV",25,"MRPC155",2411)

^DBTBL("SYSDEV",25,"MRPC155",2412)

^DBTBL("SYSDEV",25,"MRPC155",2413)
getType(String class)	// Return the internal type associated with an external type
^DBTBL("SYSDEV",25,"MRPC155",2414)

^DBTBL("SYSDEV",25,"MRPC155",2415)
	type Literal String CLASSES = "text,string,currency,date,number,integer,logical,boolean,time,frequency,memo,upper,blob"
^DBTBL("SYSDEV",25,"MRPC155",2416)

^DBTBL("SYSDEV",25,"MRPC155",2417)
	quit "TT$DNNLLCTMTB".extract({List}CLASSES.position(class))
^DBTBL("SYSDEV",25,"MRPC155",2418)

^DBTBL("SYSDEV",25,"MRPC155",2419)

^DBTBL("SYSDEV",25,"MRPC155",2420)
getColAtts(String class, String gcol(), String input, String tok)	// Build column record 
^DBTBL("SYSDEV",25,"MRPC155",2421)

^DBTBL("SYSDEV",25,"MRPC155",2422)
	type Literal String dl = "|"
^DBTBL("SYSDEV",25,"MRPC155",2423)
	type Number i
^DBTBL("SYSDEV",25,"MRPC155",2424)

^DBTBL("SYSDEV",25,"MRPC155",2425)
	type String classProps = gcol(class).get()
^DBTBL("SYSDEV",25,"MRPC155",2426)
	if classProps.isNull() set classProps = gcol(".").get()
^DBTBL("SYSDEV",25,"MRPC155",2427)

^DBTBL("SYSDEV",25,"MRPC155",2428)
	if classProps.isNull() quit input
^DBTBL("SYSDEV",25,"MRPC155",2429)

^DBTBL("SYSDEV",25,"MRPC155",2430)
	for i = 1:1:classProps.length(dl) set input.piece(dl,i) = $$mergeProperties(classProps.piece(dl,i), input.piece(dl,i) ,.tok)
^DBTBL("SYSDEV",25,"MRPC155",2431)

^DBTBL("SYSDEV",25,"MRPC155",2432)
	quit input
***DONE***

Transferring files on 25-JAN-08 at 3:57 PM
^DBTBL("SYSDEV",25,"TBXINTERP"

^DBTBL("SYSDEV",25,"TBXINTERP")
Interpreter for remote invocation of PSL|TBXINTERP|61003|e0101711|41614||||||||||||||||||1
^DBTBL("SYSDEV",25,"TBXINTERP",1)
TBXINTERP
^DBTBL("SYSDEV",25,"TBXINTERP",2)
	/*
^DBTBL("SYSDEV",25,"TBXINTERP",3)
	 ORIG: Frank Sanchez
^DBTBL("SYSDEV",25,"TBXINTERP",4)
	 DESC: Interperter for PSL and SQL
^DBTBL("SYSDEV",25,"TBXINTERP",5)

^DBTBL("SYSDEV",25,"TBXINTERP",6)
	---- Comments --------------------------------------------------------
^DBTBL("SYSDEV",25,"TBXINTERP",7)

^DBTBL("SYSDEV",25,"TBXINTERP",8)
	---- Revision History ------------------------------------------------
^DBTBL("SYSDEV",25,"TBXINTERP",9)
	11/5/2007 - Jim Joyce
^DBTBL("SYSDEV",25,"TBXINTERP",10)
	Moved code from UCGMINTERP to TBXITERP. Implemented the followinf changes.
^DBTBL("SYSDEV",25,"TBXINTERP",11)
		- seperated SELECT call to not be invoked via zshell switch
^DBTBL("SYSDEV",25,"TBXINTERP",12)

^DBTBL("SYSDEV",25,"TBXINTERP",13)
	*/
^DBTBL("SYSDEV",25,"TBXINTERP",14)

^DBTBL("SYSDEV",25,"TBXINTERP",15)

^DBTBL("SYSDEV",25,"TBXINTERP",16)
	quit
^DBTBL("SYSDEV",25,"TBXINTERP",17)

^DBTBL("SYSDEV",25,"TBXINTERP",18)
PSL(String vinput(),			// PSL input
^DBTBL("SYSDEV",25,"TBXINTERP",19)
	String voutput(),			// Procedure output
^DBTBL("SYSDEV",25,"TBXINTERP",20)
	String vmsrc(),			// Generated M source
^DBTBL("SYSDEV",25,"TBXINTERP",21)
	String vcmperr())			// PSL Compiler errors
^DBTBL("SYSDEV",25,"TBXINTERP",22)

^DBTBL("SYSDEV",25,"TBXINTERP",23)
	/*  PSL Interactive Interpreter
^DBTBL("SYSDEV",25,"TBXINTERP",24)

^DBTBL("SYSDEV",25,"TBXINTERP",25)
	This procedure is PSL source code interpreter.  It is designd to be
^DBTBL("SYSDEV",25,"TBXINTERP",26)
	called from an MRPC network interface to execute a block of PSL code.
^DBTBL("SYSDEV",25,"TBXINTERP",27)

^DBTBL("SYSDEV",25,"TBXINTERP",28)
	The code block is comprised of individual PSL code lines, though it also
^DBTBL("SYSDEV",25,"TBXINTERP",29)
	supports the PSL nested block syntax '{}'.
^DBTBL("SYSDEV",25,"TBXINTERP",30)

^DBTBL("SYSDEV",25,"TBXINTERP",31)
	Under certain conditions (e.g., reference objects, code blocks) this
^DBTBL("SYSDEV",25,"TBXINTERP",32)
	procedure will generate an compile a temporary program which it will
^DBTBL("SYSDEV",25,"TBXINTERP",33)
	immediately execute.
^DBTBL("SYSDEV",25,"TBXINTERP",34)

^DBTBL("SYSDEV",25,"TBXINTERP",35)
	This shell does not accept local 'labels', just as the GTM shell doesn't,
^DBTBL("SYSDEV",25,"TBXINTERP",36)
	though it does support local blocks.
^DBTBL("SYSDEV",25,"TBXINTERP",37)

^DBTBL("SYSDEV",25,"TBXINTERP",38)
	Parameters:
^DBTBL("SYSDEV",25,"TBXINTERP",39)

^DBTBL("SYSDEV",25,"TBXINTERP",40)
	vinput()  -  array of PSL source code lines, representing a PSL local procedure.
^DBTBL("SYSDEV",25,"TBXINTERP",41)
	voutput() -  output from executed code (result of PSL WRITE).
^DBTBL("SYSDEV",25,"TBXINTERP",42)
	vmsrc()   -  M source code generated from PSL.
^DBTBL("SYSDEV",25,"TBXINTERP",43)
        vcmperr() -  PSL compiler errors.
^DBTBL("SYSDEV",25,"TBXINTERP",44)

^DBTBL("SYSDEV",25,"TBXINTERP",45)
	This procedure may generate two temporary files:
^DBTBL("SYSDEV",25,"TBXINTERP",46)
		("zpslwr" _ $J) contains WRITE output, which is copied voutput()
^DBTBL("SYSDEV",25,"TBXINTERP",47)
		("zpsl" _ $J) contains temporary runtines
^DBTBL("SYSDEV",25,"TBXINTERP",48)

^DBTBL("SYSDEV",25,"TBXINTERP",49)
	It may make sense to change the naming convention, and or to delete these files
^DBTBL("SYSDEV",25,"TBXINTERP",50)
	at the end of the procedure.
^DBTBL("SYSDEV",25,"TBXINTERP",51)

^DBTBL("SYSDEV",25,"TBXINTERP",52)
	*FRS I didn't add any code to deal with cleaning up local variables
^DBTBL("SYSDEV",25,"TBXINTERP",53)

^DBTBL("SYSDEV",25,"TBXINTERP",54)
	*/
^DBTBL("SYSDEV",25,"TBXINTERP",55)

^DBTBL("SYSDEV",25,"TBXINTERP",56)
	type Number vstart			// Sart time of code execution, set below
^DBTBL("SYSDEV",25,"TBXINTERP",57)
	type String vopts()			// Shell options
^DBTBL("SYSDEV",25,"TBXINTERP",58)
	set vopts(0) = 1			// Language is PSL(1) or M(0) or SQLm(2) [default PSL]
^DBTBL("SYSDEV",25,"TBXINTERP",59)
	set vopts(1) = 0			// Return M source code [default False]
^DBTBL("SYSDEV",25,"TBXINTERP",60)

^DBTBL("SYSDEV",25,"TBXINTERP",61)
	// Open a local file as a write buffer to accept the M WRITE output
^DBTBL("SYSDEV",25,"TBXINTERP",62)
	type String vwrfile = "zpslwr" _ $J
^DBTBL("SYSDEV",25,"TBXINTERP",63)
	open vwrfile:newv
^DBTBL("SYSDEV",25,"TBXINTERP",64)
	use vwrfile
^DBTBL("SYSDEV",25,"TBXINTERP",65)

^DBTBL("SYSDEV",25,"TBXINTERP",66)
	// Call SHELL if ZSHELL switch detected
^DBTBL("SYSDEV",25,"TBXINTERP",67)
	type Number vn = ""
^DBTBL("SYSDEV",25,"TBXINTERP",68)
	for  set vn = vinput(vn).order() quit:vn.isNull()  do {
^DBTBL("SYSDEV",25,"TBXINTERP",69)
		if vinput(vn).piece(" ",1).upperCase() = "ZSHELL" do SHELL(.vinput(),.vn,.voutput(),.vopts(), vwrfile) set vinput(vn)=" ; " _ vinput(vn) quit
^DBTBL("SYSDEV",25,"TBXINTERP",70)
	}
^DBTBL("SYSDEV",25,"TBXINTERP",71)

^DBTBL("SYSDEV",25,"TBXINTERP",72)
	set vn=""
^DBTBL("SYSDEV",25,"TBXINTERP",73)
	type boolean isDone = false
^DBTBL("SYSDEV",25,"TBXINTERP",74)

^DBTBL("SYSDEV",25,"TBXINTERP",75)
	// SQL
^DBTBL("SYSDEV",25,"TBXINTERP",76)
	if vopts(0)=2 set isDone=true
^DBTBL("SYSDEV",25,"TBXINTERP",77)

^DBTBL("SYSDEV",25,"TBXINTERP",78)
	for  set vn = vinput(vn).order(-1) quit:vn.isNull()  if isDone = false do {
^DBTBL("SYSDEV",25,"TBXINTERP",79)

^DBTBL("SYSDEV",25,"TBXINTERP",80)
		// Make sure the code ends with a quit, if not, add one
^DBTBL("SYSDEV",25,"TBXINTERP",81)
		if vinput(vn).replace($c(9)," ").trim() = "" quit
^DBTBL("SYSDEV",25,"TBXINTERP",82)
		if vinput(vn).replace($c(9)," ").trim().beginsWith("q",true) set isDone = true quit
^DBTBL("SYSDEV",25,"TBXINTERP",83)
		else  set isDone = true,vinput(vn+1)=" quit"
^DBTBL("SYSDEV",25,"TBXINTERP",84)
	}
^DBTBL("SYSDEV",25,"TBXINTERP",85)

^DBTBL("SYSDEV",25,"TBXINTERP",86)
	// Call the PSL code generation utility
^DBTBL("SYSDEV",25,"TBXINTERP",87)
	if (vopts(0) = 1) do main^UCGM(.vinput(),.vmsrc(),,,,,.vcmperr())
^DBTBL("SYSDEV",25,"TBXINTERP",88)

^DBTBL("SYSDEV",25,"TBXINTERP",89)
	// if shell command switches mode to GTM, copy input to source array
^DBTBL("SYSDEV",25,"TBXINTERP",90)
	if (vopts(0) = 0) for  set vn = vinput(vn).order() quit:vn.isNull()  set vmsrc(vn) = vinput(vn)
^DBTBL("SYSDEV",25,"TBXINTERP",91)

^DBTBL("SYSDEV",25,"TBXINTERP",92)
	// If there were compile errors quit
^DBTBL("SYSDEV",25,"TBXINTERP",93)
	if $$hasErrors(.vcmperr()) quit
^DBTBL("SYSDEV",25,"TBXINTERP",94)

^DBTBL("SYSDEV",25,"TBXINTERP",95)
	/*
^DBTBL("SYSDEV",25,"TBXINTERP",96)
	Collate through the M source and look for local procedure references, which
^DBTBL("SYSDEV",25,"TBXINTERP",97)
	will require a temporary program to be generated.
^DBTBL("SYSDEV",25,"TBXINTERP",98)
	*/
^DBTBL("SYSDEV",25,"TBXINTERP",99)

^DBTBL("SYSDEV",25,"TBXINTERP",100)
	type Boolean isTemp = false
^DBTBL("SYSDEV",25,"TBXINTERP",101)
	for  set vn = vmsrc(vn).order() quit:vn.isNull()  quit:isTemp=true  do {
^DBTBL("SYSDEV",25,"TBXINTERP",102)
		// Find first non-whitespace character, if it's the first
^DBTBL("SYSDEV",25,"TBXINTERP",103)
		// character or a '.', must generate a temporary procedure
^DBTBL("SYSDEV",25,"TBXINTERP",104)
		// or a scope command 'new,quit'
^DBTBL("SYSDEV",25,"TBXINTERP",105)

^DBTBL("SYSDEV",25,"TBXINTERP",106)
		type Number i
^DBTBL("SYSDEV",25,"TBXINTERP",107)
		for i=1:1:vmsrc(vn).length() quit:'($C(9,32) [ vmsrc(vn).extract(i))
^DBTBL("SYSDEV",25,"TBXINTERP",108)
		// If it's a Linelabel or New or Quit command or '.' block - Build temporary program
^DBTBL("SYSDEV",25,"TBXINTERP",109)
		if ((i = 1) ! ("NnQq." [ vmsrc(vn).extract(i))) set isTemp = true quit
^DBTBL("SYSDEV",25,"TBXINTERP",110)
	}
^DBTBL("SYSDEV",25,"TBXINTERP",111)

^DBTBL("SYSDEV",25,"TBXINTERP",112)

^DBTBL("SYSDEV",25,"TBXINTERP",113)
	// Execute the code, first compile if it contains local subroutines
^DBTBL("SYSDEV",25,"TBXINTERP",114)
	// **FRS - Need to deal with local variables, clean up scope
^DBTBL("SYSDEV",25,"TBXINTERP",115)

^DBTBL("SYSDEV",25,"TBXINTERP",116)
	// Capture execution error and return (use existing compiler error array)
^DBTBL("SYSDEV",25,"TBXINTERP",117)
	catch error {
^DBTBL("SYSDEV",25,"TBXINTERP",118)

^DBTBL("SYSDEV",25,"TBXINTERP",119)
		type Public String vwrfile, voutput()
^DBTBL("SYSDEV",25,"TBXINTERP",120)

^DBTBL("SYSDEV",25,"TBXINTERP",121)
		do copyOut(vwrfile,.voutput())
^DBTBL("SYSDEV",25,"TBXINTERP",122)

^DBTBL("SYSDEV",25,"TBXINTERP",123)
		set voutput = voutput("").order() + 1
^DBTBL("SYSDEV",25,"TBXINTERP",124)
		set voutput(voutput) = $ZS
^DBTBL("SYSDEV",25,"TBXINTERP",125)
	}
^DBTBL("SYSDEV",25,"TBXINTERP",126)

^DBTBL("SYSDEV",25,"TBXINTERP",127)
	// Compile and call temporary program
^DBTBL("SYSDEV",25,"TBXINTERP",128)
	if isTemp = 1 do {
^DBTBL("SYSDEV",25,"TBXINTERP",129)

^DBTBL("SYSDEV",25,"TBXINTERP",130)
		type String outfile = "zpsl" _ $J
^DBTBL("SYSDEV",25,"TBXINTERP",131)
		do ^%ZRTNCMP(outfile,"vmsrc")
^DBTBL("SYSDEV",25,"TBXINTERP",132)
		use vwrfile
^DBTBL("SYSDEV",25,"TBXINTERP",133)
		set vstart = $$GETTIM^%ZFUNC
^DBTBL("SYSDEV",25,"TBXINTERP",134)
		xecute "do ^" _ outfile
^DBTBL("SYSDEV",25,"TBXINTERP",135)
	}
^DBTBL("SYSDEV",25,"TBXINTERP",136)

^DBTBL("SYSDEV",25,"TBXINTERP",137)

^DBTBL("SYSDEV",25,"TBXINTERP",138)
	// xecute the M source code (remove leading space)
^DBTBL("SYSDEV",25,"TBXINTERP",139)
	else  do {
^DBTBL("SYSDEV",25,"TBXINTERP",140)
		set vn = ""
^DBTBL("SYSDEV",25,"TBXINTERP",141)
		use vwrfile
^DBTBL("SYSDEV",25,"TBXINTERP",142)
		set vstart = $$GETTIM^%ZFUNC
^DBTBL("SYSDEV",25,"TBXINTERP",143)
		for  set vn = vmsrc(vn).order() quit:vn.isNull()  xecute vmsrc(vn).extract(2,9999)
^DBTBL("SYSDEV",25,"TBXINTERP",144)
	}
^DBTBL("SYSDEV",25,"TBXINTERP",145)

^DBTBL("SYSDEV",25,"TBXINTERP",146)
	// Return execution time in microseconds
^DBTBL("SYSDEV",25,"TBXINTERP",147)
	set voutput(1) = "%PSL-Runtime: " _ (($$GETTIM^%ZFUNC - vstart)/1000000) _ " Seconds"
^DBTBL("SYSDEV",25,"TBXINTERP",148)

^DBTBL("SYSDEV",25,"TBXINTERP",149)
	do copyOut(vwrfile,.voutput())		// Copy Write buffer to output
^DBTBL("SYSDEV",25,"TBXINTERP",150)
	if vopts(1) = 0 kill vmsrc		// Don't return M code (delete it)
^DBTBL("SYSDEV",25,"TBXINTERP",151)
	quit
^DBTBL("SYSDEV",25,"TBXINTERP",152)

^DBTBL("SYSDEV",25,"TBXINTERP",153)

^DBTBL("SYSDEV",25,"TBXINTERP",154)
copyOut(String vwrfile, String voutput())	// Copy file into output buffer to return to client
^DBTBL("SYSDEV",25,"TBXINTERP",155)

^DBTBL("SYSDEV",25,"TBXINTERP",156)
	type String x
^DBTBL("SYSDEV",25,"TBXINTERP",157)
	type Number n
^DBTBL("SYSDEV",25,"TBXINTERP",158)

^DBTBL("SYSDEV",25,"TBXINTERP",159)
	close vwrfile open vwrfile:read use vwrfile
^DBTBL("SYSDEV",25,"TBXINTERP",160)
	for n = 2:1 quit:$ZEOF  read x set voutput(n) = x
^DBTBL("SYSDEV",25,"TBXINTERP",161)
	close vwrfile
^DBTBL("SYSDEV",25,"TBXINTERP",162)

^DBTBL("SYSDEV",25,"TBXINTERP",163)
	quit
^DBTBL("SYSDEV",25,"TBXINTERP",164)

^DBTBL("SYSDEV",25,"TBXINTERP",165)

^DBTBL("SYSDEV",25,"TBXINTERP",166)
hasErrors(String vcmperr())
^DBTBL("SYSDEV",25,"TBXINTERP",167)

^DBTBL("SYSDEV",25,"TBXINTERP",168)

^DBTBL("SYSDEV",25,"TBXINTERP",169)
	// No warnings or errors
^DBTBL("SYSDEV",25,"TBXINTERP",170)
	if vcmperr("").order().isNull() quit false
^DBTBL("SYSDEV",25,"TBXINTERP",171)

^DBTBL("SYSDEV",25,"TBXINTERP",172)
	type Boolean hasErrors = false
^DBTBL("SYSDEV",25,"TBXINTERP",173)

^DBTBL("SYSDEV",25,"TBXINTERP",174)
	type Number i = ""
^DBTBL("SYSDEV",25,"TBXINTERP",175)
	for  set i=vcmperr(i).order() quit:hasErrors = true  quit:i'=""  do {
^DBTBL("SYSDEV",25,"TBXINTERP",176)
		if vcmperr(i).beginsWith("PSL-E") set hasErrors = true
^DBTBL("SYSDEV",25,"TBXINTERP",177)
	}
^DBTBL("SYSDEV",25,"TBXINTERP",178)
	quit hasErrors
^DBTBL("SYSDEV",25,"TBXINTERP",179)

^DBTBL("SYSDEV",25,"TBXINTERP",180)

^DBTBL("SYSDEV",25,"TBXINTERP",181)
SHELL(String vinput(), Number vn, String voutput(), String vopts(), String vwrfile)	// Process shell script
^DBTBL("SYSDEV",25,"TBXINTERP",182)

^DBTBL("SYSDEV",25,"TBXINTERP",183)
	type String x = vinput(vn).extract("ZSHELL ".length() + 1,9999).trim().upperCase()
^DBTBL("SYSDEV",25,"TBXINTERP",184)

^DBTBL("SYSDEV",25,"TBXINTERP",185)
	if {List}"M,MUMPS".contains(x) set vopts(0) = 0 quit
^DBTBL("SYSDEV",25,"TBXINTERP",186)
	if x = "SHOW CODE" set vopts(1) = 1 quit
^DBTBL("SYSDEV",25,"TBXINTERP",187)
	
^DBTBL("SYSDEV",25,"TBXINTERP",188)
	if x.trim().piece(" ",1) '= "SELECT" quit 
^DBTBL("SYSDEV",25,"TBXINTERP",189)
	
^DBTBL("SYSDEV",25,"TBXINTERP",190)
	set vopts(0) = 2  
^DBTBL("SYSDEV",25,"TBXINTERP",191)
	use vwrfile 
^DBTBL("SYSDEV",25,"TBXINTERP",192)
	write $$SELECT^MRPC155(vinput(vn).extract("ZSHELL ".length() + 1,9999).trim())
^DBTBL("SYSDEV",25,"TBXINTERP",193)

^DBTBL("SYSDEV",25,"TBXINTERP",194)
	quit
^DBTBL("SYSDEV",25,"TBXINTERP",195)

^DBTBL("SYSDEV",25,"TBXINTERP",196)
	/*
^DBTBL("SYSDEV",25,"TBXINTERP",197)
	 * Run Interactive SQL
^DBTBL("SYSDEV",25,"TBXINTERP",198)
	 * Legacy entry point. Use $$^MRPC155 instead.
^DBTBL("SYSDEV",25,"TBXINTERP",199)
	 *
^DBTBL("SYSDEV",25,"TBXINTERP",200)
	 */
^DBTBL("SYSDEV",25,"TBXINTERP",201)
SQL(String vinput(),			// SELECT statement
^DBTBL("SYSDEV",25,"TBXINTERP",202)
	String voutput())		// output
^DBTBL("SYSDEV",25,"TBXINTERP",203)

^DBTBL("SYSDEV",25,"TBXINTERP",204)
	type Number vstart		// Sart time of code execution, set below
^DBTBL("SYSDEV",25,"TBXINTERP",205)
	type String expr = ""
^DBTBL("SYSDEV",25,"TBXINTERP",206)

^DBTBL("SYSDEV",25,"TBXINTERP",207)
	type Number vn = ""
^DBTBL("SYSDEV",25,"TBXINTERP",208)
	for  set vn = vinput(vn).order() quit:vn.isNull()  set expr=expr_" "_vinput(vn)
^DBTBL("SYSDEV",25,"TBXINTERP",209)
	
^DBTBL("SYSDEV",25,"TBXINTERP",210)
	set vstart = $$GETTIM^%ZFUNC
^DBTBL("SYSDEV",25,"TBXINTERP",211)
	set voutput(2)=$$SELECT^MRPC155(expr)
^DBTBL("SYSDEV",25,"TBXINTERP",212)
	// Return execution time in microseconds
^DBTBL("SYSDEV",25,"TBXINTERP",213)
	set voutput(1) = "%SQL-Runtime: " _ (($$GETTIM^%ZFUNC - vstart)/1000000) _ " Seconds"
^DBTBL("SYSDEV",25,"TBXINTERP",214)

^DBTBL("SYSDEV",25,"TBXINTERP",215)
	quit
***DONE***

Transferring files on 25-JAN-08 at 3:57 PM
^SCATBL(5,155

^SCATBL(5,155)
SQL Reports|$$^MRPC155|PBS|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0
^SCATBL(5,155,"SCA")

***DONE***


<EOD>
<BOF>
<EOF>
<BOP>
Export Routines - TBXPSLI
25-JAN-2008 15:57:38
MRPC121
MRPC121(RET,VERSN,type,CODE,CMPTOK,LOCFILE,OBJTYPE,OBJID,TOK,USER) 
 ;;Copyright(c)2002 Sanchez Computer Associates, Inc.  All Rights Reserved - 06/10/02 09:26:58 - CHEUNGA
 ; ORIG:	CHEUNGA - 06/04/02
 ;
 ; DESC:	MRPC121
 ; This procedure is used to facilitate the sending, receiving, code 
 ; review, and compiling of code on the host system from the 
 ; Sanchez/Profile Java Interface via the Sanchez JDBC Driver. The 
 ; ToolBox program TBXDQSVR is being called from this procedure to 
 ; perform these functions.
 ; 
 ;
 ; ARGUMENTS:
 ;
        ;     . RET   Value of fields requested       /TYP=T/REQ
        ;                                               /MECH=REFNAM:W 
        ;     . VERSN   ^MRPC121 version number         /TYP=N/REQ 
        ;               Current version = 1             /MECH=VAL 
        ; 
 ;     . type	Subsection type			/TYP=T		
 ;
 ;     . CODE	Code from the file		/TYP=T
        ;                                                
 ;     . CMPTOK	Compilation token		/TYP=T
        ;                                                
 ;     . LOCFILE Local file			/TYP=T
        ;                                           
 ;     . OBJID	Object ID			/TYP=T
 ;
 ;     . OBJTYPE	Object Type			/TYP=T
 ;
 ;     . TOK     Token				/TYP=T
 ;
 ;     . USER    User ID				/TYP=T
 ;
 ;
 ; RETURNS:
        ;       . $$            Error Message           /TYP=T 
        ; 
 ;
 ;-------- Revision History ------------------------------------------
 ; 11/05/2007    Jim Joyce
 ;		Added PSLRUN and SELECT functions
 ;
 ;-----------------------------------------------------------------------
 ; Check type here to determent which subsection is being called from
 ; the client
        ;  
 I type="INITOBJ" Q $$INITOBJ^MRPC121(.RET,VERSN,OBJTYPE,OBJID)
 I type="RETOBJ" Q $$RETOBJ^MRPC121(.RET,VERSN,TOK)
 I type="INITCODE" Q $$INITCODE^MRPC121(.RET,VERSN,CODE,CMPTOK)
 I type="CHECKOBJ" Q $$CHECKOBJ^MRPC121(.RET,VERSN,LOCFILE,TOK)
 I type="SAVEOBJ" Q $$SAVEOBJ^MRPC121(.RET,VERSN,LOCFILE,TOK,USER)
 I type="EXECCOMP" Q $$EXECCOMP^MRPC121(.RET,VERSN,LOCFILE,CMPTOK)
 I type="EXECREV" Q $$EXECREV^MRPC121(.RET,VERSN,LOCFILE,CMPTOK)
 I type="PSLRUN" Q $$PSLRUN^MRPC121(.RET,VERSN,CMPTOK)
 I type="SQLRUN" Q $$SQLRUN^MRPC121(.RET,VERSN,CMPTOK)
 ;
 S ER=1,RM="Invalid TBX RPC type: "_type
 Q $$ERRMSG^PBSUTL(RM)
 ;
 ;-----------------------------------------------------------------------
INITOBJ(RET,VERSN,OBJTYPE,OBJID) ;
 ;
 ; DESC: calls INITOBJ^TBXDQSVR MRPC and returns CMPTOK
 ;
 ;-----------------------------------------------------------------------
 ;
        S ER=0 
        S RM="" 
        ; Version number of client message is not compatible with server 
        I $G(VERSN)'=1 S ER=1 Q $$ERRMSG^PBSUTL($$^MSG(2951)) 
        ; 
        ; If an error occurred, save it in the %SVCNTXT variable 
        I $G(ER) D  Q $$ERRMSG^PBSUTL(RM) 
        . S RM=$G(RM) 
        . S %SVCNTXT("ER")=ER ; Save ER error code 
        . S %SVCNTXT=RM ; Save Error Message 
        ; 
        S RET=$$INITOBJ1^TBXDQSVR(OBJTYPE,OBJID) 
        ; 
 ;
        S RET=$$V2LV^MSG(.RET) 
        ; 
 Q ""
 ;
 ;-----------------------------------------------------------------------
RETOBJ(RET,VERSN,TOK) ;
 ;
 ; DES: Calls RETOBJ^TBXDQSVR and returns Object
 ;
 ;-----------------------------------------------------------------------
        ; 
        S ER=0 
        S RM="" 
        ; Version number of client message is not compatible with server 
        I $G(VERSN)'=1 S ER=1 Q $$ERRMSG^PBSUTL($$^MSG(2951)) 
        ; 
        ; If an error occurred, save it in the %SVCNTXT variable 
        I $G(ER) D  Q $$ERRMSG^PBSUTL(RM) 
        . S RM=$G(RM) 
        . S %SVCNTXT("ER")=ER ; Save ER error code 
        . S %SVCNTXT=RM ; Save Error Message 
        ; 
        S RET=$$RETOBJ1^TBXDQSVR(TOK) 
        ; 
 ;
        S RET=$$V2LV^MSG(.RET) 
        ; 
        Q "" 
 ;
 ;-----------------------------------------------------------------------
INITCODE(RET,VERSN,CODE,CMPTOK) ;
 ;
 ; DES: INITCODE^TBXDQSVR and returns CMPTOK
    ;
 ;-----------------------------------------------------------------------
        ; 
 S ER=0
        S RM="" 
        ; Version number of client message is not compatible with server 
        I $G(VERSN)'=1 S ER=1 Q $$ERRMSG^PBSUTL($$^MSG(2951)) 
        ; 
        ; If an error occurred, save it in the %SVCNTXT variable 
        I $G(ER) D  Q $$ERRMSG^PBSUTL(RM) 
        . S RM=$G(RM) 
        . S %SVCNTXT("ER")=ER ; Save ER error code 
        . S %SVCNTXT=RM ; Save Error Message 
        ; 
        S RET=$$INITCOD1^TBXDQSVR(CODE,CMPTOK) 
        ; 
 ;
        S RET=$$V2LV^MSG(.RET) 
        ; 
        Q "" 
 ;
 ;-----------------------------------------------------------------------
CHECKOBJ(RET,VERSN,LOCFILE,TOK) ;
 ;
        ; DESC: Calls CHECKOBJ^TBXDQSVR and returns CHECK 
        ; 
        ;----------------------------------------------------------------------- 
 ;
        S ER=0 
        S RM="" 
        ; Version number of client message is not compatible with server 
        I $G(VERSN)'=1 S ER=1 S RM=$$^MSG(2951) Q 
        ; 
        ; If an error occurred, save it in the %SVCNTXT variable 
        I $G(ER) D  Q $$ERRMSG^PBSUTL(RM) 
        . S RM=$G(RM) 
        . S %SVCNTXT("ER")=ER ; Save ER error code 
        . S %SVCNTXT=RM ; Save Error Message 
        . Q 
        ; 
        S RET=$$CHECKOB1^TBXDQSVR(LOCFILE,TOK) 
        ; 
 ;
        S RET=$$V2LV^MSG(.RET) 
        ; 
        Q "" 
 ;
 ;-----------------------------------------------------------------------
SAVEOBJ(RET,VERSN,LOCFILE,TOK,USER) ;
 ;
 ; DES: Calls SAVEOBJ^TBXDQSVR and returns SAVE
 ;
 ;-----------------------------------------------------------------------
 ;
        S ER=0 
        S RM="" 
        ; Version number of client message is not compatible with server 
        I $G(VERSN)'=1 S ER=1 S RM=$$^MSG(2951) Q 
        ; 
        ; If an error occurred, save it in the %SVCNTXT variable 
        I $G(ER) D  Q $$ERRMSG^PBSUTL(RM) 
        . S RM=$G(RM) 
        . S %SVCNTXT("ER")=ER ; Save ER error code 
        . S %SVCNTXT=RM ; Save Error Message 
        . Q 
        ; 
        S RET=$$SAVEOBJ1^TBXDQSVR(LOCFILE,TOK,USER) 
        ; 
        S RET=$$V2LV^MSG(.RET) 
        ; 
        Q "" 
 ;
 ;-----------------------------------------------------------------------
EXECCOMP(RET,VERSN,LOCFILE,CMPTOK) ;
 ;
 ; DES: calls EXECCOMP^TBXDQSVR and return CMPERR
 ;
 ;-----------------------------------------------------------------------
 ;
        S ER=0 
        S RM="" 
        ; Version number of client message is not compatible with server 
        I $G(VERSN)'=1 S ER=1 S RM=$$^MSG(2951) Q 
        ; 
        ; If an error occurred, save it in the %SVCNTXT variable 
        I $G(ER) D  Q $$ERRMSG^PBSUTL(RM) 
        . S RM=$G(RM) 
        . S %SVCNTXT("ER")=ER ; Save ER error code 
        . S %SVCNTXT=RM ; Save Error Message 
        . Q 
        ; 
        S RET=$$EXECCOM1^TBXDQSVR(LOCFILE,CMPTOK) 
        ; 
        S RET=$$V2LV^MSG(.RET) 
        ; 
        Q "" 
 ;
 ;-----------------------------------------------------------------------
EXECREV(RET,VERSN,LOCFILE,CMPTOK) ;
 ;
 ; DES: calls EXECREV^TBXDQSVR and return LOCFIL and COMTOK
 ;
 ;-----------------------------------------------------------------------
 ;
        S ER=0 
        S RM="" 
        ; Version number of client message is not compatible with server 
        I $G(VERSN)'=1 S ER=1 S RM=$$^MSG(2951) Q 
        ; 
        ; If an error occurred, save it in the %SVCNTXT variable 
        I $G(ER) D  Q $$ERRMSG^PBSUTL(RM) 
        . S RM=$G(RM) 
        . S %SVCNTXT("ER")=ER ; Save ER error code 
        . S %SVCNTXT=RM ; Save Error Message 
        . Q 
        ; 
        S RET=$$EXECREV1^TBXDQSVR(LOCFILE,CMPTOK) 
        ; 
        S RET=$$V2LV^MSG(.RET) 
        ; 
        Q "" 
 ;
 ;-----------------------------------------------------------------------
PSLRUN(RET,VERSN,CMPTOK) 
 ;
 ; DES: RPC entry for remote PSL invocation
 ;
 ;-----------------------------------------------------------------------
 ;
        S ER=0 
        S RM="" 
        ; Version number of client message is not compatible with server 
        I $G(VERSN)'=1 S ER=1 S RM=$$^MSG(2951) Q 
        ; 
        ; If an error occurred, save it in the %SVCNTXT variable 
        I $G(ER) D  Q $$ERRMSG^PBSUTL(RM) 
        . S RM=$G(RM) 
        . S %SVCNTXT("ER")=ER ; Save ER error code 
        . S %SVCNTXT=RM ; Save Error Message 
        . Q 
        ; 
        S RET=$$PSLRUN^TBXDQSVR(CMPTOK) 
        ; 
        S RET=$$V2LV^MSG(.RET) 
        ; 
        Q "" 
        ; 
 ;-----------------------------------------------------------------------
SQLRUN(RET,VERSN,CMPTOK) 
 ;
 ; DES: RPC entry for remote PSL invocation
 ;
 ;-----------------------------------------------------------------------
 ;
        S ER=0 
        S RM="" 
        ; Version number of client message is not compatible with server 
        I $G(VERSN)'=1 S ER=1 S RM=$$^MSG(2951) Q 
        ; 
        ; If an error occurred, save it in the %SVCNTXT variable 
        I $G(ER) D  Q $$ERRMSG^PBSUTL(RM) 
        . S RM=$G(RM) 
        . S %SVCNTXT("ER")=ER ; Save ER error code 
        . S %SVCNTXT=RM ; Save Error Message 
        . Q 
        ; 
        S RET=$$SQLRUN^TBXDQSVR(CMPTOK) 
        ; 
        S RET=$$V2LV^MSG(.RET) 
        ; 
        Q "" 
         

TBXDQSVR
TBXDQSVR ;Private; RPC for developers toolbox
 ;;Copyright(c)2002 Sanchez Computer Associates, Inc.  All Rights Reserved - 06/10/02 15:21:11 - JOYCEJ
 ; ORIG:	JOYCEJ - 10/01/01
 ; DESC:	
 ;
 ;-------- Revision History ------------------------------------------
 ; 11/05/2007    Jim Joyce
 ;		Added PSLRUN and SELECT functions
 ;
 ; 05/02/2007    NOWAKJ
 ;		Added PVB("CR") initialization in section SAVEOBJ1 as
 ;		LOG^TBXFPIN expects it to be initialized
 ;
 ; 04/27/2007	KWANl
 ;		Modified SAVEOBJ1 section to use LOG^TBXFPIN instead of 
 ;		LOG^TBXSPIN
 ;
 ; 04/26/2007	KWANL
 ;		Added additional parameter "FAW" to LOG^TBXSPIN.
 ;
 ; 07/26/2005	JOYCEJ
 ;		Improved error messages in CHECKOBJ1 and SAVEOBJ1
 ;		Added missing line to SAVEOBJ1 to correct save failure
 ;
 ; 07/21/2005	JOYCEJ
 ;		Added lines to suport new data file format: .DAT.
 ;
 ; JOYCEJ - 01/29/03 
 ;		Added call to LOG^TBXSPIN in the SAVEOBJ1 
 ;		section.
 ;
 ;-----------------------------------------------------------------------
GETTOKEN() ; Compute token
 ;-----------------------------------------------------------------------
 Q "TOK"_$J_$P($H,",",2)_$R(100000)
 ;-----------------------------------------------------------------------
INITOBJ1(OBJTYPE,OBJID) ; Initalize source code and return token
 ;-----------------------------------------------------------------------
 ;
 ;	Create a token and place the code in a temporary 
 ;	global for retrieval by a client.
 ;
 N CODE,SEQ,TOK,GET
 S GET=0_$C(13,10)_"Invalid type: "_OBJTYPE
 ;
 I OBJTYPE="Aggregate" S GET=$$GETCODE^TBXAGGR(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Batch" S GET=$$GETCODE^TBXBATCH(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Column" S GET=$$GETCODE^TBXCOL(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Data" S GET=$$GETCODE^TBXDATA(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Executive" S GET=$$GETCODE^TBXEXEC(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Foreign Key" S GET=$$GETCODE^TBXFKEY(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Index" S GET=$$GETCODE^TBXIDX(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Journal" S GET=$$GETCODE^TBXJRNL(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Lookup Doc" S GET=$$GETCODE^TBXLUD(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Pre Post Lib" S GET=$$GETCODE^TBXPPL(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Procedure" S GET=$$GETCODE^TBXPROC(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Query" S GET=$$GETCODE^TBXQRY(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Record Map" S GET=$$GETCODE^TBXRCDM(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Report" S GET=$$GETCODE^TBXRPT(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Screen" S GET=$$GETCODE^TBXSCRN(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Table" S GET=$$GETCODE^TBXTBL(OBJID,.CODE,.FILENAME)
 I OBJTYPE="Trigger" S GET=$$GETCODE^TBXTRIG(OBJID,.CODE,.FILENAME)
 ;
 ; Check for an error 
 I +GET=0 Q GET
 ;
 ; Place the object's contents in a temporary buffer keyed by
 ; TOK for retrieval
 S SEQ=""
 S TOK=$$GETTOKEN()
 F  S SEQ=$O(CODE(SEQ)) Q:SEQ=""  S ^TMP(TOK,SEQ)=CODE(SEQ)
 ;
 ; Return a success code (1), the token and the file name
 Q 1_$C(13,10)_TOK_$C(13,10)_FILENAME
 ;
 ;-----------------------------------------------------------------------
RETOBJ1(TOK) 
 ;-----------------------------------------------------------------------
 ;
 N BLOCK,CNT,MORE,RETURN,REC,SEQ
 ;
 ; BLOCK is the maximum number of rows to return in each call
 S BLOCK=300
 S (SEQ,RETURN,CNT)=""
 ;
 F  S SEQ=$O(^TMP(TOK,SEQ)) Q:SEQ=""!(CNT=BLOCK)  D
 .	S REC=^TMP(TOK,SEQ)
 .	S RETURN=RETURN_REC
 .	I $D(^TMP(TOK,SEQ+1)) S RETURN=RETURN_$C(13,10)
 .	K ^TMP(TOK,SEQ)
 .	S CNT=CNT+1
 ;
 ; Flag to indicate that there are more rows to return
 S MORE=$E($D(^TMP(TOK)))
 ;
 Q MORE_RETURN
 ;
 ;-----------------------------------------------------------------------
INITCOD1(CODE,CMPTOK) ; Store code from client in temporary global on the host 
 ;-----------------------------------------------------------------------
 ;
 I CMPTOK="" S CMPTOK=$$GETTOKEN K ^TMP(CMPTOK)
 ;
 N LINE,SEQ,I,CHR
 ;
 ; Remainder from last call
 S LINE=$G(^TMP(CMPTOK))
 S SEQ=$O(^TMP(CMPTOK,""),-1)+1
 ;
 I CODE="" D  Q CMPTOK
 .	S ^TMP(CMPTOK,SEQ)=LINE 
 .	S ^TMP(CMPTOK)=""
 ;
 ; Jim Joyce - reversed the order for checking characters. 13 is the more common line seperator.
 F I=1:1:($L(CODE,"|")-1) D
 .	S CHR=$P(CODE,"|",I)
 .	I (CHR=13) Q
 .	I (CHR=10) D  Q
 ..		S ^TMP(CMPTOK,SEQ)=LINE
 ..		S SEQ=SEQ+1
 ..		S LINE=""
 .	S LINE=LINE_$C(CHR)
 S ^TMP(CMPTOK)=LINE
 ;
 Q CMPTOK
 ;
 ;-----------------------------------------------------------------------
CHECKOB1(LOCFILE,TOK) ; Check the date and user data
 ;-----------------------------------------------------------------------
 N CHECK,OBJTYPE,OBJID
 ;
 S OBJID=$$UPPER^%ZFUNC($P(LOCFILE,".",1))
 S OBJTYPE=$$UPPER^%ZFUNC($P(LOCFILE,".",2))
 ;
 S CHECK=0_$C(13,10)_"Error saving "_OBJTYPE_"-"_OBJID_" unsupported file type"
 ;
 I OBJTYPE="AGR" S CHECK=$$CHECKOBJ^TBXAGGR(TOK,OBJID)
 I OBJTYPE="BATCH" S CHECK=$$CHECKOBJ^TBXBATCH(TOK,OBJID)
 I OBJTYPE="COL" S CHECK=$$CHECKOBJ^TBXCOL(TOK,OBJID)
 I OBJTYPE="G" S CHECK=$$CHECKOBJ^TBXDATA(TOK,OBJID)
 I OBJTYPE="DAT" S CHECK=$$CHECKOBJ^TBXDATA(TOK,OBJID)	
 I OBJTYPE="EXC" S CHECK=$$CHECKOBJ^TBXEXEC(TOK,OBJID)
 I OBJTYPE="FKY" S CHECK=$$CHECKOBJ^TBXFKEY(TOK,OBJID)
 I OBJTYPE="IDX" S CHECK=$$CHECKOBJ^TBXIDX(TOK,OBJID)
 I OBJTYPE="JFD" S CHECK=$$CHECKOBJ^TBXJRNL(TOK,OBJID)
 I OBJTYPE="LUD" S CHECK=$$CHECKOBJ^TBXLUD(TOK,OBJID)
 I OBJTYPE="PPL" S CHECK=$$CHECKOBJ^TBXPPL(TOK,OBJID)
 I OBJTYPE="PROC" S CHECK=$$CHECKOBJ^TBXPROC(TOK,OBJID)
 I OBJTYPE="QRY" S CHECK=$$CHECKOBJ^TBXQRY(TOK,OBJID)
 I OBJTYPE="RMP" S CHECK=$$CHECKOBJ^TBXRCDM(TOK,OBJID)
 I OBJTYPE="RPT" S CHECK=$$CHECKOBJ^TBXRPT(TOK,OBJID)
 I OBJTYPE="SCR" S CHECK=$$CHECKOBJ^TBXSCRN(TOK,OBJID)
 I OBJTYPE="TBL" S CHECK=$$CHECKOBJ^TBXTBL(TOK,OBJID)
 I OBJTYPE="TRIG" S CHECK=$$CHECKOBJ^TBXTRIG(TOK,OBJID)
 ;
 Q CHECK
 ;-----------------------------------------------------------------------
SAVEOBJ1(LOCFILE,TOK,USER) ; Save object with contents of tmp buffer
 ;-----------------------------------------------------------------------
 N SAVE,OBJTYPE,OBJID,%LOGID,DATA,%FN
 ;
 S OBJTYPE=$$UPPER^%ZFUNC($P(LOCFILE,".",2))
 S OBJID=$$UPPER^%ZFUNC($P(LOCFILE,".",1))
 ;
 S SAVE=0_$C(13,10)_"Error saving "_OBJTYPE_"-"_OBJID_" unsupported file type"
 ;
 ; Set %LOGID to the network user for call to SYSLOG
 S %LOGID=$$LOGID^SCADRV()
 S $P(%LOGID,"|",2)=USER
 S %FN="SAVEOBJ^TBXDQSVR"
 S DATA=$$SYSLOG^SCADRV0()
 ;
 I OBJTYPE="AGR" S SAVE=$$SAVEOBJ^TBXAGGR(TOK,OBJID,USER)
 I OBJTYPE="BATCH" S SAVE=$$SAVEOBJ^TBXBATCH(TOK,OBJID,USER)
 I OBJTYPE="COL" S SAVE=$$SAVEOBJ^TBXCOL(TOK,OBJID,USER)
 I OBJTYPE="DAT" S SAVE=$$SAVEOBJ^TBXDATA(TOK,OBJID,USER)
 I OBJTYPE="G" S SAVE=$$SAVEOBJ^TBXDATA(TOK,OBJID,USER)
 I OBJTYPE="EXC" S SAVE=$$SAVEOBJ^TBXEXEC(TOK,OBJID,USER)
 I OBJTYPE="FKY" S SAVE=$$SAVEOBJ^TBXFKEY(TOK,OBJID,USER)
 I OBJTYPE="IDX" S SAVE=$$SAVEOBJ^TBXIDX(TOK,OBJID,USER)
 I OBJTYPE="JFD" S SAVE=$$SAVEOBJ^TBXJRNL(TOK,OBJID,USER)
 I OBJTYPE="LUD" S SAVE=$$SAVEOBJ^TBXLUD(TOK,OBJID,USER)
 I OBJTYPE="PPL" S SAVE=$$SAVEOBJ^TBXPPL(TOK,OBJID,USER)
 I OBJTYPE="PROC" S SAVE=$$SAVEOBJ^TBXPROC(TOK,OBJID,USER)
 I OBJTYPE="QRY" S SAVE=$$SAVEOBJ^TBXQRY(TOK,OBJID,USER)
 I OBJTYPE="RMP" S SAVE=$$SAVEOBJ^TBXRCDM(TOK,OBJID,USER)
 I OBJTYPE="RPT" S SAVE=$$SAVEOBJ^TBXRPT(TOK,OBJID,USER)
 I OBJTYPE="SCR" S SAVE=$$SAVEOBJ^TBXSCRN(TOK,OBJID,USER)
 I OBJTYPE="TBL" S SAVE=$$SAVEOBJ^TBXTBL(TOK,OBJID,USER)
 I OBJTYPE="TRIG" S SAVE=$$SAVEOBJ^TBXTRIG(TOK,OBJID,USER)
 ;
 ; Log action
 N FOLDER,FILE,PVB,REVISION,DATE,TIME,MSG
 S FOLDER=""
 S FILE=$$UPPER^%ZFUNC(LOCFILE)
 S PVB("PROJECT")=""
 S PVB("VIEW")=""
 S PVB("BUILD")=""
 S PVB("CR")=""
 S REVISION=""
 S DATE=""
 S TIME=""
 S MSG="MRPC:"_$S(+SAVE:"Saved",1:"Failed")
 D LOG^TBXFPIN(FOLDER,FILE,.PVB,REVISION,USER,DATE,TIME,MSG)
 ;
 I +SAVE D SYSLOGXT^SCADRV0(DATA)
 ;
 Q SAVE
 ;
 ;-----------------------------------------------------------------------
EXECCOM1(LOCFILE,CMPTOK) ; Compile PSL source code and return errors 
 ;-----------------------------------------------------------------------
 ;
 N X,CODE,PSLSRC,OUTFILE,CMDARY,CMPERR,SRCFLG,PROCID,MSEC,SEQ
 N $ZT
 S $ZT="ZG "_$ZL_":ZTA^TBXDQSVR"
 ; 
 ; Check for the PSL compiler
 I $TEXT(UCGM^UCGM)'["cmperr" Q "Remote Compile not available in "_$$^CUVAR("%VN")
 S ER=0
 S SRCFLG=0
 S LOCFILE=$$UPPER^%ZFUNC(LOCFILE)
 ;
 I $P(LOCFILE,".",2)'="PROC" Q "Only PSL Procedures can be test compiled"
 S PROCID=$P(LOCFILE,".PROC",1)
 ;
 I $G(PROCID)="" Q "Invalid Procedure"
 ;
 ; Start with line one to skip the header.
 S SEQ=1
 F  S SEQ=$O(^TMP(CMPTOK,SEQ)) Q:SEQ=""  S CODE(SEQ)=^TMP(CMPTOK,SEQ)
 K ^TMP(CMPTOK)
 ;
 S ER=0,RM=""
 ; Do not pass the PGM parameter to UCGM. This is a test compile. 
 ; Passing PGM would trigger a real compile.
 D main^UCGM(.CODE,.MSRC,,,.CMDARY,,.CMPERR)
 I ER Q $G(RM)
        ; 
 N SEQ,RET
 S SEQ=""
        S RET=PROCID_" compiled at "_$$TIME^%ZD()_" on " 
 S RET=RET_$$^%ZD()_" in "_$$^CUVAR("CONAM")_$C(13,10)
 F  S SEQ=$O(CMPERR(SEQ),1) Q:SEQ=""  D
 .	I $L(RET)>30000 Q
 .	I CMPERR(SEQ)="++++++++++++++++++++++" D  Q
 ..		S RET=RET_" "_$C(13,10)_"Source: "_LOCFILE_$C(13,10) Q
 .	S RET=RET_CMPERR(SEQ)_$C(13,10)
 Q RET
        ; 
 ;-----------------------------------------------------------------------
EXECREV1(LOCFILE,CMPTOK) ; Execute code Review 
 ;-----------------------------------------------------------------------
 ;
 N X,CODE,PSLSRC,OUTFILE,CMDARY,CMPERR,SRCFLG,OBJTYPE,MSEC,SEQ,RET
        N $ZT,desc,tdir,hist,i18n,comment,LEVEL,v,v1,id,x,external 
        S $ZT="ZG "_$ZL_":ZTA^TBXDQSVR" 
 ;
 S ER=0
 S SRCFLG=0
 S LOCFILE=$$UPPER^%ZFUNC(LOCFILE)
 ;
 S OBJTYPE=$P(LOCFILE,".",2)
 S OBJID=$P(LOCFILE,".",1)
 S SEQ=""
 F  S SEQ=$O(^TMP(CMPTOK,SEQ)) Q:SEQ=""  S CODE(SEQ)=^TMP(CMPTOK,SEQ)
 K ^TMP(CMPTOK)
 ;
 I ($E(OBJTYPE,1,4)="PROC") Q $$REVCODE(OBJID,.CODE,25)
 I ($E(OBJTYPE,1,4)="TRIG") Q $$REVCODE(OBJID,.CODE,7)
 I (OBJTYPE="BATCH") Q $$REVCODE(OBJID,.CODE,33)
 ;
 Q "Invalid DATA QWIK element type"
 ;
 ;
 ;-----------------------------------------------------------------------
REVCODE(OBJID,CODE,LEVEL) 
 ;-----------------------------------------------------------------------
 ;
 N coderv,SEQ,DBATYPE,RET
 ;
 I LEVEL=7 S DBATYPE=7
 I LEVEL=33 S DBATYPE=7
 I LEVEL=25 S DBATYPE=3
 ;
 S SEQ=""
 ;
        S RET=OBJID_" code reviewed at "_$$TIME^%ZD()_" on " 
 S RET=RET_$$^%ZD()_" in "_$$^CUVAR("CONAM")_$C(13,10)
 I DBATYPE=3 D SETUP3^TBXCKDQ
 I DBATYPE=7 D SETUP7^TBXCKDQ
 ;
 F  S SEQ=$O(CODE(SEQ)) Q:SEQ=""  D
 .	N coderv,ERSEQ
 .	I DBATYPE=3 D EXT3^TBXCKDQ(CODE(SEQ),LEVEL,OBJID,SEQ,1)
 .	I DBATYPE=7 D EXT7^TBXCKDQ(CODE(SEQ),LEVEL,OBJID,SEQ,1)
 .		;
 .	S ERSEQ=""
 .	F  S ERSEQ=$O(coderv(ERSEQ),1) Q:ERSEQ=""  D
 ..		I $L(RET)>30000 Q
 ..		S RET=RET_coderv(ERSEQ)_$C(13,10)
 ;
 S ER=0
 ;
 Q RET
        ; 
 ;
 ;-----------------------------------------------------------------------
PSLRUN(CMPTOK) ; Remote PSL invocation 
 ;-----------------------------------------------------------------------
 ;
 N X,CODE,SYSOUT,MSRC,CMPERR,SRCFLG,PROCID,MSRC,SEQ
 N $ZT
 S $ZT="ZG "_$ZL_":ZTA^TBXDQSVR"
 S ER=0
 ;
 S SEQ=""
 F  S SEQ=$O(^TMP(CMPTOK,SEQ)) Q:SEQ=""  S CODE(SEQ)=^TMP(CMPTOK,SEQ)
 K ^TMP(CMPTOK)
 ;
 S ER=0,RM=""
 D PSL^TBXINTERP(.CODE,.SYSOUT,.MSRC,.CMPERR)
 I ER Q $G(RM)
        ; 
 N SEQ,RET
 S SEQ=1
        S RET="<div id=""Runtime"">"_SYSOUT(SEQ)_"</div>"_$C(13,10) 
        ; 
 F  S SEQ=$O(SYSOUT(SEQ)) Q:SEQ=""  D
 .	I $L(RET)>1000000 Q
 .	S RET=RET_SYSOUT(SEQ)_$C(13,10) 	
 ;    	
 I $D(CMPERR) D
 .	S SEQ=""
 .	S RET=RET_$C(13,10)_"Compile errors> "_$C(13,10)
 .	F  S SEQ=$O(CMPERR(SEQ)) Q:SEQ=""  D
 ..		I $L(RET)>1000000 Q
 ..		S RET=RET_CMPERR(SEQ)_$C(13,10)
 ;
 I $D(MSRC) D
 .	S SEQ=""
 .	S RET=RET_$C(13,10)_"M Source> "_$C(13,10)
 .	F  S SEQ=$O(MSRC(SEQ)) Q:SEQ=""  D
 ..		I $L(RET)>1000000 Q
 ..		S RET=RET_MSRC(SEQ)_$C(13,10)
 ;
 ;
 Q RET
 ;
 ;-----------------------------------------------------------------------
SQLRUN(CMPTOK) ; Remote SQL invocation 
 ;-----------------------------------------------------------------------
 ;
 N X,CODE,SYSOUT,MSRC,CMPERR,SRCFLG,PROCID,MSRC,SEQ
 N $ZT
 S $ZT="ZG "_$ZL_":ZTA^TBXDQSVR"
 ;
 S SEQ=""
 F  S SEQ=$O(^TMP(CMPTOK,SEQ)) Q:SEQ=""  S CODE(SEQ)=^TMP(CMPTOK,SEQ)
 K ^TMP(CMPTOK)
 ;
 S ER=0,RM=""
 D SQL^TBXINTERP(.CODE,.SYSOUT)
 I ER Q $G(RM)
        ; 
 N SEQ,RET
 S SEQ=1
        S RET="<div id=""Runtime"">"_SYSOUT(SEQ)_"</div>"_$C(13,10) 
   ;
 F  S SEQ=$O(SYSOUT(SEQ)) Q:SEQ=""  D
 .	I $L(RET)>1000000 Q
 .	S RET=RET_SYSOUT(SEQ)_$C(13,10) 
 ;
 Q RET
 ;---------------------------------------------------------------------        ;
ZTA     ; 
 ;---------------------------------------------------------------------        ;
 S ER=0
 I $G(RM)="" S RM=$ZS
        Q RM 
 ;
 ;



