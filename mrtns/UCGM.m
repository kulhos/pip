UCGM(srcfile,outfile,sysmap,cmperr,PGM)	;public void; Utility Code Generator (M) 
	;;Copyright(c)2003 Sanchez Computer Associates, Inc.  All Rights Reserved - 10/24/03 10:17:12 - SPIER
	; ORIG: FSANCHEZ - 25 DEC 1998
	; DESC: Interprets PSL script and generates M code
	;
	; I18N=QUIT
	;
	;-------- Comments -----------------------------------------------------
	; The PSL compiler uses the general prefix UC for all its code elements.
	; For historic reasons, this prefix has not been reserved for the PSL
	; compiler. The following Profile element names starting with UC are used
	; for elements that do not belong to the PSL compiler:
	; * UCDC	DQ procedure UCDC
	; * UCIDSCA	DQ procedure UCIDSCA
	; * UCIF	DQ procedure UCIF
	; * UCIFM	DQ procedure UCIFM
	; * UCLOSE	DQ procedure UCLOSE
	; * UCO		DQ procedure UCO
	; * UCOLCDFL	Filer for UTBLCOLCD
	; * UCRCDXFL	Filer for UTBLCRCDX
	; * UCRNOFL	Filer for UTBLCRCDNO
	; * UCSDRV	DQ procedure UCSDRV
	; * UCSMON	DQ procedure UCSMON
	; * UCTEST	DQ procedure UCTEST
	; * UCTFPLFL	Filer for UTBLCTFPLN
	;
	; Three levels of code (and variables) that are distinguished:
	; * Code generated by the PSL compiler itself.
	;	This code will use labels that start with a lowercase "v", and
	;	will contain at least one other lowercase character.
	; * Code generated by "PSL source generators".
	;	This is code generated by "DQ kernel" modules such as the batch
	;	compiler and the report generator. If this code inserts labels,
	;	these labels start with a lowercase "v", and contain only
	;	uppercase characters and digits.
	; * Application code
	;	This code shall not use labels that start with a lowercase "v".
	;
	;-------- Compiler Bootstrap Provisions --------------------------------
	; The compiler uses a number of boot restriction levels to suppress
	; calls to subroutines and functions that may not be available during
	; some of the bootstrap phases. The following matrix describes the
	; restrictionlevel sensitive features. Level 0 indicates a normal
	; compilation. Level 1 corresponds to the Framework completion phase,
	; level 2 corresponds to the PSL compiler completion phase, and level 3
	; corresponds to the UCOPTS creation phase.
	;
	; Feature			lvl3	lvl 2	lvl 1	lvl 0
	; call ^UCSYSMAP()		no	no	no	yes
	; call UCINIT^UCDTAUTL()	no	yes	yes	yes
	; call getSrc^UCLABEL()		no	no	no	yes
	; #XECUTE			no	no	no	yes
	; call ^SCACOPYR()		no	no	no	yes
	; data from			n.a.	.DAT	DB	DB
	; PSL.constant from		default	UCOPTS	UCOPTS	UCOPTS
	;
	; Restrictionlevel 3 is used (exclusively) to generate UCOPTS. This
	; level does not call getBootData^UCDTAUTL(), so elements that are
	; compiled using this level cannot uses System Keywords.
	;
	; Function optimization must be turned off when restrictionlevel=2,
	; because convert^UCGMCONV will call loadFunc^UCDTASYS. It is the
	; callers responsibility to do that.
	;
	;-------- Control Character Usage --------------------------------------
	; The PSL compiler uses control characters during the decomposition of
	; source code, in intermediate code, and in internal structures.
	; The different parts of the compiler shall choose control characters
	; carefully, to prevent ambiguous constructs. The following control
	; characters are used
	; 0	strlit delimiter in code being decomposed.
	;	may occur in intermediate structures
	; 1	used to delimit strlits in tokenlist
	;	boolean predicates returned by the SQL engine use this as
	;	delimiter (UCXDD)
	; 2	used in UCQRYBLD (further analyses needed)
	; 6	used for patched code as returned by $$patch^UCPATCH()
	; 7,8	used as starting and ending value of column occurrence wrap.
	; 	They behave as parenthesis, and can be nested.
	;	All use of these characters is encapsulated in UCREC4OP.
	; 9	used as separator in type(,), dbAcc(,,)
	;	used for patched code as returned by $$patch^UCPATCH()
	;	Note that this prevents storing "patched" code in the structures
	;	that use this character as field delimiter.
	; 10	data returned by DB API may contain this character as (line)
	;	delimiter.
	; 31	accepted and used as placeholder for rightexpr in assignment
	;
	;---------- Revision History -------------------------------------------
	; 06/27/07 - Frans S.C. Witte - CR: 27486
	;	* Fixed bug in toLit()
	;	* Fixed bug with $SELECT() in valFun()
	;	* Modified valExpr() to look at result class of $$ext and $int
	;	* Modified QUIT to turn off optimization of variable in quit-
	;	  argument.
	;	* Modified valFun() to not overwrite lvn class when dealing with
	;	  arguments
	;
	; 04/25/07 - Frans S.C. Witte - CR: 26334
	;	* Added quit to addPslSetting
	;	* Added 'table' to variables that are NEWed in method()
	;	* Modified THROW to provide a DEAD code warning if not at EOL.
	;
	; 03/06/07 - Frans S.C. Witte - CRs: 25759 / 25760 / 25761
	;	Added call to occMark^UCREC4OP() in cmd (for postCond)
	;
	; 03/02/07 - Frans S.C. Witte - CRs: 25185 / 25186 / 25187
	;	Added call to occMark^UCREC4OP() in cmdExpr
	;
	; 01/04/07 - Frans S.C. Witte - CRs: 24902 / 24903 / 24974
	;	* Added 'true' and 'false' as literal variables at level -1.
	;	* use of access modifier no longer required when
	;	  #OPTION ResultClass ON is in effect.
	;	* Subroutines that deal with warnings, errors, and infos no
	;	  longer require lvn subRou.
	;	* Subroutine cmpX2F now catches exceptions thrown by %ZRTNCMP.
	;
	; 10/19/06 - Frans S.C. Witte - CRs: 23841 / 23842
	;	* Added InstMode parameter in call to $$insByOvs^UCREC4OP
	;	* Added addPSLSetting, getPSLSetting and hasPSLSetting
	;
	; 07/16/06 - Frans S.C. Witte - CRs: 22720 / 22274
	;	* Added support for #OPTION ResultClass.
	;	* Added support for source-contained method definitions.
	;	* OBJECT descriptions now cached in pslCls().
	;	* Modified $$property to use pslPrp() and ^UCXOBJ
	;	* Modified $$method to use pslMtd() and ^UCXOBJ, and to mark
	;	  calls to methods of Record descendants as pass-by-value to
	;	  subroutine.
	;	* Introduced pslToken()
	;	* Added warning for assignment to PUBLIC Reference descendant
	;	* Added code to turn off optimization of object that is assigned
	;	  from a PUBLIC Reference descendant
	;	* setInst: do not store expr if newLevel<0
	;	* Corrected p1prepend()
	;	* Added
	;		- private void p1append()
	;		- type exposed String pslP1Ap (in cmdExpr)
	;	  Modified cmdExpr to maintain pslP1Ap
	;	  Modified method and actual to call p1append()
	;	  Modified QUIT to insert pslP1Ap after assignment to vret
	;	* Added $$isNameDQ(), $$isNameFW() and $$isNamePSL()
	;	* fixed toLit() to prevent max line length error on XECUTE.
	;
	; 09/07/06 - Frans S.C. Witte - CRs: 22957 / 22061
	;	* All errors and warnings now start with %PSL (instead of PSL).
	;	* Modified XECUTE so it no longer tries to insert literal values
	;	  as PSL source code.
	;	* Modified $$valFun() to set srcVar to first function argument
	;	  when fset'=0
	;	* Modified procPar to limit scope of reference parameter
	;	  inserted by compiler.
	;	* Added $$isSimple()
	;
	; 07/24/06 - Frans S.C. Witte - CRs: 22273 / 22274
	;	* Added methodDef and methodGen.
	;
	; 07/17/06 - Frans S.C. Witte - CRs: 21397 / 21937
	;	* Corrected actual() to deal with absent actual parameter "in
	;	  the middle" of the list.
	;
	; 06/16/06 - Frans S.C. Witte - CRs: 22060 / 22061
	;	* Replaced $C(255) placeholder by $C(31).
	;	* append() now calls addCode^UCPSLSR().
	;	* Initialization of COMMANDs, FUNCTIONs, and SVNs now done
	;	  through functions tha can be called for other purposes as well
	;	  (e.g. compiler capabilities).
	;	* UCINIT^UCDTAUTL() now called unconditionally (it deals with
	;	  bootrestriction levels itself).
	;
	; 06/15/06 - Frans S.C. Witte - CRs: 21791 / 21792
	;	* Corrected lvn spelling error in BUILDRTN.
	;	* Corrected lvn scope: pslRtns in main() and cmd in line().
	;
	; 05/01/06 - Frans S.C. Witte - CRs: 21394 / 21395
	;	* Modified main() to deal with boot-restrictionlevel 3.
	;	* Modified setScope to report an error for names that are too
	;	  long.
	;	* Modified valExpr() to adjust the way PRECEDENCE warnings are
	;	  generated.
	;
	; 05/01/06 - Frans S.C. Witte - CRs: 21158 / 18164
	;	* Added $$lblPstfx(). Modified $$newLabel and $$findSubr() to
	;	  call $$lblpstfx.
	;	* Modified KILL to deal with KILL array, when array is declared
	;	  as an array of objects.
	;
	; 03/09/06 - Frans S.C. Witte - CRs: 20280 / 18164
	;	* Removed sections labeled "old code", and subroutine procPar()
	;	  (only called from this old code).
	;	* Renamed getPars() to joinFpl() and getParsC() to joinFplC().
	;	  This function is now called in line() before calling subRou()
	;	  to ensure that code following the closing parenthesis of the
	;	  formallist is handled consistently.
	;	* Adapted several subroutines and functions to use updated
	;	  layout of PSLLabelRecord.
	;	* Modified several subroutines to validate parameter mismatches
	;	  as part of the call decomposition. Consequently, UCLABEL is no
	;	  longer called.
	;	* Added log() as functional replacement for WARN(). Rewrote
	;	  INFO(), WARN(), and ERROR() to call log(). Added warnGroup(),
	;	  and modified WARNDEP() to call warnGroup().
	;	* Corrected code block in OPEN (missing dots in block).
	;	* Corrected call to $$decByOvs^UCREC4OP (too many actuals).
	;	* cmpX2F() now also calls $$cmpStamp^UCXDT25()
	;	* Added PSL-I- if SET VAR=VAR is dropped from generated code
	;	* Corrected issues with missing block-ends and missing QUITs
	;	* Added calls to setAssign^UCREC4OP() to distinguish call-by-
	;	  value from call-by-name in actual parameter, and to indicate
	;	  local or public formal parameter (see UCREC4OP).
	;	* Added function $$gtmLevel().
	;
	; 02/24/06 - Frans S.C. Witte - CRs: 19972 / 18164
	;	* SETandTYPE: $$hasWrap() changed to $$isWrap()
	;	* scope change from NEW to PUBLIC downgraded from error to
	;	  warning.
	;
	; 12/27/05 - Frans S.C. Witte - CRs: 18163 / 18164
	;	* Added deprecation warning for NEW in conditional code.
	;	* Added support for dbAcc(,,): calls to ^UCPSLST, ^UCREC4OP,
	;	  subroutine typeDec() to declare new type.
	;	* $$isClass now calls $$isClass^UCGMR()
	;	* removed unused formal/actual parameter .watch from varArr()
	;	  and assign().
	;	* removed unused formal/actual parameters .level and .newLevel
	;	  from assign()
	;	* renamed "varPtr" to "pslVarNr", because "varPtr" is used (and)
	;	  newed in several places.
	;	* removed type as formal parameter from function property() and
	;	  .type as actual parameter in call to $$property.
	;	* Corrected problems with OPEN, USE, and CLOSE
	;	* Added support for commands("Options","nofile")
	;	* (New) DQ signature is now added by cmpX2F().
	;
	; 12/23/05 - Frans S.C. Witte - CRs: 18727 / 18728
	;	* RowSets for bootrap restrictionlevel 2 are now loaded here
	;	  and not by caller, because main NEWs vobj.
	;	* Rewrote ZT to behave like code generated by CATCH statement
	;
	; 11/17/05 - Frans S.C. Witte - CRs: 18247 / 15593
	;	* Modified code that deals with inaccurate method
	;	* Replaced call to $$^CUVAR by call to $$^UCXCUVAR.
	;
	; 08/17/05 - Frans S.C. Witte - CRs: 15592 / 15593
	;	* $$isCompiler^UCDTAUTL() replaced by $$isCompiler^UCGMCU()
	;	* Added support for compiler bootstrap (calls to ^UCDTAUTL and
	;	  to ^UCDTASYS
	;	* Subroutine main(): Modified data passed in sysmap("L"),
	;	  modified call LitInst^UCDB(), rearranged init code and added
	;	  boot support, added "PSL" as reserved pre-instantiated static
	;	  class instance.
	;	* subroutines main() and line(): removed use of lvn debug
	;	* UCLREGEN updates now invoked from cmpX2F()
	;	* calls to CLOSE^SCAIO replaced by M CLOSE command (SCAIO not
	;	  available at boot time).
	;	* $$isSys(): corrected spelling of $ZV ($ZVERSION, not $ZVN)
	;	* explicit obj.prop definition has now higher precedence than
	;	  call to OBJECT.PROPPROC.
	;	* setInst: will no longer overwrite a negative value for
	;	  suppress optimize.
	;	* Added warning when undefined method is replaced by M function.
	;	* Added subroutine resetProps()
	;	* Removed call to $$TIM^%ZM, because that may call routines that
	;	  are not available in bootstrap mode.
	;	* 'pslSchCln' replaced by 'pslCln', and 'pslSchTbl' replaced by
	;	  'pslTbl'.
	;
	; 06/22/05 - Frans S.C. Witte - CR: 16444
	;	* Added function $$findSubr()
	;	* Corrected problem with code generated for TSTART, TCOMMIT and
	;	  TROLLBACK.
	;	* Corrected problem in addXref()
	;	* Corrected problem in move()
	;
	; 06/15/05 - Frans S.C. Witte - CRs: 16339
	;	* Added description of label/variable use.
	;	* Removed commented out code that used 'fif'.
	;	* subroutine WARN: fixed reference to lptr (/NOREQ!)
	;	* subroutine assign(): added code to enhance support for
	;	  type-casting of reference objects.
	;	* Combined code to handle assignments in TYPE and SET into a
	;	  separate subroutine.
	;	* Assignment to $P(cmperr,"|",1) moved to occur as very first
	;	  statement in ERROR().
	;
	; 05/26/05 - RussellDS - CR16079
	;	Modified main section to add documentation related to pieces 11+
	;	of type array.
	;
	; 05/05/05 - RussellDS - CR15379
	;	* Changed name of parameters() array to sysmap() throughout
	;	* Modified WARN section to track number of warnings, errors,
	;	  and informational messages at top of cmperr for display
	;	* Modified ERROR section to change setting of top of cmperr
	;	  to set first piece with error flag
	;	* Modified cmpA2F section to print success/failure message
	;	* Modified cmpA2F section to check procedure signature for
	;	  procedures containing functions used in literals and update
	;	  UCLREGEN, if appropriate
	;	* Modified command section to set isDirctv flag
	;	* Modified cmpA2F and cmpF2F to pass sysmap, cmperr, and
	;	  PGM to cmpX2F
	;	* Modified cmpX2F to accept sysmap, cmperr and PGM parameters
	;	* Modified cmpX2F to set up SYSMAP("RTNNAME") entry
	;	* Modified cmpX2F to call ^UCSYSMAP
	;	* Modified main to replace call to checkCalls^UCGMC with a call
	;	  to chkCalls^UCLABEL; removed passing of sysmap to
	;	  UCINIT^UCDTAUTIL
	;	* Throughout, remove checking on contents of sysmap to
	;	  determine if will set up SYSMAP references since this is now
	;	  always set up.
	;	* Modified callStack to add setting of sysmap("C") info
	;	* Modified main to save labels info to sysmap("L")
	;	* Modified cmdExpr setting of sysmap("T") to switch order of
	;	  subRou and cmd keys to conform to table definition
	;
	; 03/15/05 - Frans S.C. Witte - CRs: 14919 / 14920
	;	* Subroutine killCasc() was modified to add the "doexpr" to the
	;	  patch list, so UCPATCH can access it when optimizing database
	;	  access. The formal parameterlist was modified. All calls to the
	;	  subroutine were modified accordingly.
	;	* Part of the code in subroutine KILL has been commented out.
	;	* Subroutine SET has been extended to handle struct("SETprop").
	;	* Subroutine QUIT has been corrected to handle variables with
	;	  LITERAL scope (must be substituted at compile time).
	;	* Changed access to cmpF2X() from local to private.
	;	* Variables i, n, pslSchCln, and pslSchTbl NEWed in main().
	;	* Removed dead code following BUILDRTN (old version of BUILDRTN).
	;	* Subroutine procPar() modified to support $func() / $$extref()
	;	  / $svn as actual parameter.
	;	* Set general trap handler in main() to ZT^UCGM and added support
	;	  to quit from extrinsic or subroutine using $QUIT in ZT.
	;
	; 02/10/05 - Frans S.C. Witte - CRs: 14569 / 14578
	;	* Removed subroutine keyword() (no subroutine body)
	;	* Added accessibility of private subroutines/functions
	;	* Subroutine main(): %DB is initialized before calling $$^CUVAR,
	;	  and it now NEWs and SETs %LIBS if it is undefined.
	;	* Subroutine cmpF2X() corrected variable name "mdst" to "psrc".
	;	* Created function $$getReTable() that returns the table name of
	;	  a RecordXxx class.
	;	* Subroutines checkInst() and killObj() now call $$patch^UCPATCH()
	;	  unconditionally.
	;	* Function $$toLit() now NEWs ER, and quits the original expression
	;	  when it cannot decompose it.
	;
	; 01/05/05 - Frans S.C. Witte - CRs: 13403 / 13404
	;	* Added extra parameter to function $$toLit(). It indicates the
	;	  highest linenumber that is still valid for literal substitution.
	;	  Currently this parameter is only used within $$toLit() itself.
	;	  This code is copied from an earlier version that was never
	;	  released because an intended shortcut to solve this problem was
	;	  provided. Unfortunately, the shortcut did not work.
	;	* Subroutine method: $$toLit() will only be called if the value
	;	  of OBJECTMET.VALLIT is 1 (true)
	;	* Corrected problems in resetType() and setInst() if scope is
	;	  "LITERAL".
	;	* Removed assignment to cmmds("TABBORT"): there is no TA command.
	;	* Replaced ResetTyp() by ResetType().
	;	* Warning "Variable declared more than once" is now only provided
	;	  if SCOPE warnings are enabled.
	;	* Corrected case where compiler added extra " Q" at end-of-routine
	;	  when last subroutine returned a value (" Q value").
	;
	; 12/16/04 - Frans S.C. Witte - CRs: 11445 / 11446
	;	* All references to primtyp() now call either $$primVar^UCPRIM()
	;	  or $$primDes^UCPRIM() in case of doubt $$primVar is used (and
	;	  doubt noted). Filling primtyp is now handled by init^UCPRIM()
	;	  (called by main()).
	;	* ZLINK of generated routine is now suppressed if the subroutine
	;	  $$isCompiler^UCDTAUTL() returns 1.
	;	* Removed routine name from calls to ^UCGM itself.
	;	* Modified error message for undefined property/method to show
	;	  name of class.
	;	* setVar parameter of $$valObj() will return ObjectName for use
	;	  by caller.
	;	* Subroutine assign() uses setVar parameter returned by $$valObj()
	;	  to clear the instantiation expression.
	;	* Added subroutine INFO() to write an "Informational compiler
	;	  message".
	;	* Added Infomessage when "if argument always false" is detected.
	;	* Subroutine setInst(): Temporarily force assigned value is empty
	;	  for variables ER and RM, because there scope cannot correctly
	;	  be expressed in PSL. Temporarily force assigned value is empty
	;	  for subscripted Primitives.
	;	* label TYPE: temporarily suppress "var declared more than once"
	;	  if the scope is PUBLIC and the type not Primitive.
	;	* labels GO and NEW: added deprecation warning for these commands
	;	* subroutine subRou(): when a new label is detected and the
	;	  previous subroutine has not been terminated with a quit, then
	;	  either an error will be generated (if AllowGOTO=0), or a
	;	  deprecation warning will be supplied (if AllowGOTO=1).
	;	  This check has been moved up in the code so it applies to all
	;	  labels (including those that do not have a parameter list).
	;	  Warnings are printed BEFORE simulating the quits.
	;	* subroutine varExpr(): If indirection is detected in assignment
	;	  values assigned to all Primitives are invalidated.
	;	* subroutine actual(): replaced resetType(.vars) by resetType().
	;	* subroutine toLit(): temporarily disable recursion if element
	;	  is not a variable.
	;	* Added subroutine typeCrea() to insert new entry in type()
	;
	; 10/19/04 - Frans S.C. Witte - CRs: 11441, 9792, 9793 / 11442
	;	* Modified endBlock to allow "// comment ..." after CATCH {
	;	* Modified blockC to tokenize part following '*/'.
	;	* Modified suroutine TYPE to produce a warning when a variable
	;	  is declared more than once in the same scope, and call to
	;	  killObj() suppressed when scope is "FORMAL".
	;	* Changed $$isVar^UCGM():
	;	  replaced $E(expr,2,8) by $E(expr,2,$L(expr))
	;	* Changed $$varExpr^UCGM():
	;	  replaced parameters["V" with parameters["/V/" (2 occurences)
	;	* Fixed getPars() for subroutine that is declared PRIVATE.
	;	* Added subroutine WARNDEP() for deprecation warnings if enabled.
	;	* Modified subroutine method() to supply un-literalized value in
	;	  objectVar (in case method code needs to reference the instance).
	;	* Combined patterns for positive and negative numbers in isInt()
	;	  and isNum(), added $$isFrac(), and redefined $$isNum() and
	;	  $$isExp() to accept insignificant zero's, added isStr() to
	;	  check for stringlitiral, and changed $$isLit().
	;	* Modified subroutine getPars() to accept multi-line comment (this
	;	  uses the new function $$getParsC()).
	;	* Modified subroutine BUILDRTN to use the directory specified in
	;	  the outfile if it contains one, or the SCA default if none not
	;	  included.
	;	* Added subroutines cmpA2A(), cmpA2F(), cmpF2A(), and cmpF2F()
	;	  that have the same signature as main(), but with either a File
	;	  or an Array as the source or the destination. Note that cmpA2A()
	;	  is exactly the same as main(). It is included for symmetry only.
	;	  Added cmpF2X() that reads a source file and produces a source
	;	  array, and cmpX2F() that produces a destination file from a
	;	  destination array.
	;	* The record class prefix shall now be obtained through function
	;	  $$getReCls(). This ensures a consistent value for compile-time
	;	  and runtime access.
	;	* Added support for read-only properties in function $$property().
	;	* Added 5th parameter to calls(,,)/called(,,) that contains the
	;	  source line number. This can be used by postprocessing programs
	;	  (such as UCLABEL) that want to report errors or warnings.
	;	* Removed all occurrences of variable 'fif'
	;	* Modified subroutine THROW to perform better syntax checking.
	;	  The first piece of the constructed $ZS will be either 0 or -1.
	;	  Throw statement does no longer accept a command-postcondition
	;	  (the generated code would be incorrect anyway).
	;
	; 08/16/04 - Frank Sanchez / Frans S.C. Witte - CRs: 11660 / 11661
	;	Modified subroutines FOR and WHILE to increment ifLevel in addition
	;	to forLevel, in order to prevent incorrect use of values assigned
	;	inside the scope of these statements as literals outside the scope
	;	of these statements. The effect of this change is that the scopes
	;	of these statements are treated with the same "unreliability" as
	;	the scope of IF statements.
	;
	; 05/26/04 - RussellDS - CR9172
	;	Added FRS change to toLit section to fix bug in reassignemt
	;	of variable names.
	;
	; 05/12/04 - RussellDS - CR9676
	;	Move Profile04 version to Profile01 to support single code
	;	base for PSL.
	;
	; 03/29/04 - RussellDS - CR9172
	;	Integrate changes as part of move of filers to PSL,
	;	including solved unary operator / whitespace problem.
	;
	;	Modified valFun section to prevent $C(254) from getting
	;	converted to literal, which ends up invalid in M code.
	;
	;	Remove use of SQLPARS - obsoleted with changes for filers.
	;
	;	Added support for AllowGOTO and $GetEFD options for versions
	;	prior to Profile04.
	;
	; 02/02/04 - FSANCHEZ/KELLYP - 7813
	;	Fixed the following problems in the valExpr section:
	;		- Operator precedence checking error
	;		- Incorrect error response on missing quote
	;		- Improved expression parsing/operator handling
	;	Fixed undefined error in the property section.
	;	Fixed return errors in the subRou and getPars sections.
	;	Modified isNum to accept valid decimals.
	;	Modified TYPE to fix memory leak when reinstantiating an object.
	;
	; 12/11/03 - spier 7240
	;	added $ZTEXIT to issys
	;	added additional paramater to BUILDRTN label (PGM)
	;
	; 09/05/03 - Spier- cr6031,6032,6034  ARQ 51640
	;	New retrofit to Profile01, copied original code from
	;	Profile03 and modified locations where Profile03 changes
	;	were indicated
	;
	; 08/18/03 - Sanchez 51640
	;       Relaxed PRECEDENCE warning and derivitive errors
	;	Fixed instantiation bug with nested method syntax
	;
	; 08/18/03 - SPIER - 51423
	;	Corrected an error with conditional commands
	;	they potentially backed off too much or too little
	;	of the code.
	;	Added ZMESSAGE line tag.
	;
	; 08/14/03 - Sanchez
	;       Added PRECEDENCE warning, merged condRel into valExpr
	;
	; 07/30/03 - Sanchez/Spier- 51423
	;	Modifications to correct issue with conditional sets
	;
	; 07/14/03 - SPIER - 51423
	;       Removed ^&RTCHR call in favor of %ZFUNC call to
	;	enable operating system independence
	;
	; 07/10/03 - Spier CR5085
	;	Modified QUIT section to correct undefined error that
	;	would occur when exrinsic contained object in call and
	;	that object was instantiated in the label
	;
	; 06/19/03 - Sanchez  51423
	;       Public scope object GC.  Property value tracking.
	;	Tighten syntax checking on READ & FOR
	;
	;	Object memory leak, casting bug, repair whitespace
	;	& capitization source errors, read command,
	;	remove logically dead code, optimize $SELECT
	;
	; 02/14/03- 2/25/03 - Sanchez/SPIER - 51423
	;	Bug fixes
	;
	; 11/20/02 - CHENARDP - 45497
	;	Added setting of %DB system variable in main().
	;
	; 11/14/02 -Sanchez/Spier 51089
	;	Release 7.0 Checkpoint
	;
	;----------------------------------------------------------------------
	;
	new commands,line,m2src,msrc,OK,rec
	;
	set OK=$$FILE^%ZOPEN(srcfile,"READ")
	if 'OK set ER=1,RM=$P(OK,"|",2)
	;
	use srcfile
	for line=1:1 quit:$ZEOF  read rec set m2src(line)=rec
	close srcfile
	;
	do main(.m2src,.msrc,,,.commands,.sysmap,.cmperr)
	;
	;;if $G(outfile)'="" do ^%ZRTNCMP(outfile,"msrc")
	if $G(outfile)'="" do cmpX2F(outfile,.msrc,,.commands,.sysmap,.cmperr,$G(PGM))
	quit
	;
	;----------------------------------------------------------------------
BUILDRTN(m2src,outfile,cmperr,PGM)	;public void;Build a routine from an array of PSL code 
	;----------------------------------------------------------------------
	; This label is used to generate a routine from an array of PSL code.
	;
	; KEYWORDS:	Compiler
	;
	; ARGUMENTS:
	;	. m2src 	array of PSL code		/TYP=T/REQ/MECH=REF
	;	. outfile 	M program name to be created	/TYP=T/REQ/MECH=REF
	;	. cmperr	array of compile errors		/TYP=T
	;	. PGM		unit name for SYSMAP		/TYP=T/NOREQ/MECH=REF:RW
	; RETURNS:
	;	. cmperr	compiler errors			/TYP=T
	;-----------------------------------------------------------------------
	;
	if outfile="" do cmpA2A(.m2src,,,,,,.cmperr,.PGM) quit
	do cmpA2F(.m2src,outfile,,,,,.cmperr,.PGM)
	quit
	;-----------------------------------------------------------------------
cmpA2A(src,dst,labels,methods,commands,sysmap,cmperr,PGM)	;public void; Array to Array 
	;-----------------------------------------------------------------------
	; This subroutine is a substitute for main(). It contains exactly the same
	; parameters, and in exactly the same order as main()
	;
	; ARGUMENTS:
	; . String src() = PSL source code in array (single subscript)
	; . String dst() = compiled M code in array (single subscript)
	; . labels,methods,commands,sysmap,cmperr,PGM
	;	See main()
	;
	do main(.src,.dst,.labels,.methods,.commands,.sysmap,.cmperr)
	quit
	;-----------------------------------------------------------------------
cmpA2F(src,dst,labels,methods,commands,sysmap,cmperr,PGM)	;public void; Array to File 
	;-----------------------------------------------------------------------
	; Compile PSL code in array and produce a .psl file from the input, and
	; a .m file for the output.
	;
	; ARGUMENTS:
	; . String src() = PSL source code in array (single subscript)
	; . String dst = routinename for output files
	;	If dst includes a directory specification, then the .psl file
	;	will be placed in the specified directory.
	;	If dst does not include a directory specification, the .psl file
	;	will be placed in the directory specified by the environment
	;	variable SCA_CRTNS (that will also be used for the .m file)
	;	The target directory for the .m file is determined by ^%ZRTNCMP().
	; . labels,methods,commands,sysmap,cmperr,PGM
	;	See main()
	;
	new cnt,element,elemtype,i,mdst,m2src,oldsig,rtnname
	;
	kill cmperr
	;
	merge m2src=src
	do main(.m2src,.mdst,.labels,.methods,.commands,.sysmap,.cmperr)
	;
	; pass ORIGINAL PSL source
	if '$g(cmperr) do cmpX2F(dst,.mdst,.src,.commands,.sysmap,.cmperr,$G(PGM))
	;
	; Write success/fail message and counts for info/warnings/errors
	use $P
	write !,">>> "
	set element=$p($g(PGM),"~",1),elemtype=$p($g(PGM),"~",2)
	if elemtype'="" write elemtype," "
	if element'="" write element
	if '((elemtype="")&(element="")) write " - "
	write "Routine ",dst
	if '$g(cmperr) write " - successful compile ... ",!
	else  write " - compile failed ... ",!
	;
	for i=1:1:3 set cnt(i)=$p($g(cmperr),"|",i+1)
	if cnt(1) write ?5,cnt(1)," informational message" write:cnt(1)'=1 "s" write !
	if cnt(2) write ?5,cnt(2)," warning" write:cnt(2)'=1 "s" write !
	if cnt(3) write ?5,cnt(3)," error" write:cnt(3)'=1 "s" write !
	quit
	;-----------------------------------------------------------------------
cmpF2A(src,dst,labels,methods,commands,sysmap,cmperr,PGM)	;public void; File to Array 
	;-----------------------------------------------------------------------
	; Compile PSL code in (.psl) file, and return the M code in an array.
	;
	; ARGUMENTS:
	; . String src = name of file that contains the PSL source code
	;	If src includes a directory specification, then the source is
	;	read from the specified file.
	;	If src does not include a directory, then the file shall reside
	;	in the directory specified by the environment variable SCA_CRTNS.
	; . String dst() = compiled M code in array (single subscript)
	; . labels,methods,commands,sysmap,cmperr,PGM
	;	See main()
	;
	new psrc
	do cmpF2X(src,.psrc) quit:'$D(psrc)
	do main(.psrc,.dst,.labels,.methods,.commands,.sysmap,.cmperr)
	quit
	;-----------------------------------------------------------------------
cmpF2F(src,dst,labels,methods,commands,sysmap,cmperr,PGM)	;public void; File to File 
	;-----------------------------------------------------------------------
	; Compile PSL code in (.psl) file, and produce a .m file for the output.
	; This subroutine will not (re)produce the .psl file.
	;
	; ARGUMENTS:
	; . String src = name of file that contains the PSL source code
	;	If src includes a directory specification, then the source is
	;	read from the specified file.
	;	If src does not include a directory, then the file shall reside
	;	in the directory specified by the environment variable SCA_CRTNS.
	; . String dst = routinename for .m file
	;	The target directory for the .m file is determined by ^%ZRTNCMP().
	; . labels,methods,commands,sysmap,cmperr,PGM
	;	See main()
	;
	new mdst,psrc
	do cmpF2X(src,.psrc) quit:'$D(psrc)
	do main(.psrc,.mdst,.labels,.methods,.commands,.sysmap,.cmperr)
	;
	; don't pass the PSL source
	if '$g(cmperr) do cmpX2F(dst,.mdst,,.commands,.sysmap,.cmperr,$g(PGM))
	quit
	;
	;-----------------------------------------------------------------------
cmpF2X(src,psrc)	;private void; read source file into source array 
	;-----------------------------------------------------------------------
	; This subroutine is also called by $$equal^UCGMCU() to read the M code
	; from the standard CRTNS directory.
	;
	new ER,IO,sub
	set IO=$$FILE^%TRNLNM(src,$$SCAU^%TRNLNM("CRTNS"))
	if '$$FILE^%ZOPEN(IO,"READ",0,32767) quit
	use IO
	;
	for sub=1:1 set psrc(sub)=$$^%ZREAD(IO,.ER) quit:ER
	;;do CLOSE^SCAIO
	close IO
	;
	; Remove trailing empty lines
	for sub=sub:-1:1 quit:psrc(sub)'=""  kill psrc(sub)
	quit
	;
	;-----------------------------------------------------------------------
cmpX2F(dst,mdst,psrc,commands,sysmap,cmperr,PGM)	;local void; write input to .psl file and output to .m file 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String dst = name of M routine (and of .psl file)
	;	May include target directory specification.
	;	Will be passed to ^%ZRTNCMP.
	;	The routinename will be extracted from this value.
	;	If a target directory is present the routine will not be ZLINKED
	; . String mdst() = M code
	;	will end up in dst.m
	; . String psrc() = (original) PSL sourcecode		/NOREQ
	;	will end up in dst.psl
	; . String commands() = PSL compile options		/MECH=REFARR:R
	;	This function will look at commands("boot","restrictionlevel") and
	;	commands("Options,"nolink")
	; . String sysmap() = SYSMAP data
	; . String cmperr() = error array
	; . String PGM = element name ~ element type
	;
	; Quit if filing is prohibited.
	; By inserting this check here, callers to cmpX2F will not have to worry
	; about this option.
	quit:$G(commands("Options","nofile"))
	;
	new IO,name,oldsig,sub
	;
	new rtnname set rtnname=$$PARSE^%ZFUNC(dst,"NAME")
	set sysmap("RTNNAME")=rtnname
	;
	if $G(commands("boot","restrictionlevel"))<1 do
	.	if $$VALID^%ZRTNS("UCSYSMAP") do ^UCSYSMAP(PGM,.mdst,.sysmap,.cmperr)
	.	;
	.	; Get old signature, if available, before link new version
	.	; Update UCLREGEN, if appropriate, for all literal function labels in
	.	; routine.
	.	; Note that the call to $$vSIG^@rtnname may fail under several
	.	; conditions. The value of $ZT ensures that the nested DO terminates
	.	; silently. Because the first DO-block may throw the exception, which
	.	; shall result in an update of UCLREGEN, a second IF+DO is needed to
	.	; update the table.
	.	;
	.	set oldsig=""
	.	if $P(PGM,"~",2)="Procedure" do
	..		new $ZTRAP
	..		set $ZTRAP="Q"
	..		set oldsig=$$vSIG^@rtnname
	.	if $P(PGM,"~",2)="Procedure",oldsig'=$P(PGM,"~",3) do SETRTN^UCLREGEN(rtnname)
	;
	quit:+$g(cmperr)
	;
	; Insert reference to soure element (if present), and compilation stamp
	; Assume all lines need to be inserted
	new inc,ln0,ln1
	set ln0=$o(mdst("")),ln1=$o(mdst(ln0))
	set:ln1="" ln1=ln0+6
	set inc=ln1-ln0/6
	set ln0=ln0+inc,mdst(ln0)=" ;"
	if $p(PGM,"~",2)'="" do  	; add the "this is generated ..." text
	.	set ln0=ln0+inc,mdst(ln0)=" ; **** Routine compiled from DATA-QWIK "_$P(PGM,"~",2)_" "_$P(PGM,"~")_" ****"
	.	set ln0=ln0+inc,mdst(ln0)=" ;"
	set ln0=ln0+inc,mdst(ln0)=" ; "_$$cmpStamp^UCXDT25()
	set ln0=ln0+inc,mdst(ln0)=" ;"
	;
	; Overwrite "nolink" for PSL compiler routines, or if target direcory
	; explicitly specified
	new dstdir set dstdir=""
	new nolink set nolink=$G(commands("Options","nolink"))
	if dst'=rtnname set nolink=1,dstdir=$$PARSE^%ZFUNC(dst,"DIR")
	if 'nolink,$$isCompiler^UCGMCU(rtnname) set nolink=1
	;
	; Now compile the routine. If %ZRTNCMP throws an exception other than
	; a ZLINK exception, treat it as a compiler exception, and no NOT create
	; the .psl file.
	do
	.	new $ZTRAP
	.	set $ZTRAP="ZGOTO "_$ZLEVEL_":cmpX2FX^"_$TEXT(+0)
	.	do ^%ZRTNCMP(dst,"mdst",nolink,dstdir)
	quit:+$g(cmperr)
	;
	; OK to create .psl file
	if $d(psrc) do		; .psl only if input supplied
	.	set sub=$l($$PARSE^%ZFUNC(dst,"TYPE"))
	.	set name=$e(dst,1,$l(dst)-sub)
	.	set IO=$$FILE^%TRNLNM(name_".psl",$$SCAU^%TRNLNM("CRTNS"))
	.	if $$FILE^%ZOPEN(IO,"NEWVERSION",0,32767) do
	..		use IO
	..		set sub=""
	..		for  set sub=$O(psrc(sub)) quit:sub=""  write psrc(sub),!
	..		close IO
	quit
	;
	;-----------------------------------------------------------------------
cmpX2FX	; exception handler for cmpX2F 
	;-----------------------------------------------------------------------
	; If the error is related to ZLINK, report a warning, else report an
	; error.
	;
	if $ZSTATUS["%GTM-E-LOADRUNNING" d warnGroup("DYNAMIC","Cannot load "_dst_" dynamically; Compile with #OPTION NoLink ON") quit
	do ERROR("TARGET: failed to produce taget code "_dst)
	quit
	;-----------------------------------------------------------------------
main(m2src,msrc,labels,methods,commands,sysmap,cmperr)	;local void; main label 
	;-----------------------------------------------------------------------
	; About level, ifLevel/ifStack, forLevel/forStack, doStack, and pslSt.
	; The compiler's main loop maintains a couple of variables that are
	; stored in type(,), and copied into patch() and dbAcc().
	; - level = current M line level
	;	Starts at 0
	;	incremented in initBLock, and decremented in endblock
	; - ifLevel = number of IFs/ELSEs encountered on current line
	;	This variable is initiated to zero for each line.
	;	It is incremented for each IF or ELSE statement encountered on
	;	the line.
	; - ifStack = stacked ifLevels from outer DO levels
	;	This variable is initiated to "" in main().
	;	It is reset to "" in endBlock if level reaches zero.
	;	The current value of ifLevel is appended in initBlock.
	;	The value at position 'level' is popped in endBlock.
	; - forLevel = number of FOR statements encountered on the line
	;	Behaves like ifLevel, but only used in UCGM itself (i.e. not
	;	stored in type(,) etc.).
	; - forStack = stacked forLevels from outer DO levels
	;	Behaves like ifStack, but only used in UCGM itself (i.e. not
	;	stored in type(,) etc.).
	; - doStack = stacked DO code blocks
	;	Initiated to "" in main() and in endBlock when reaching level 0
	;	Filled with (msrc+1) in initBlock when level=1
	;	Piece #level incremented in initBlock when level>1
	;	Note that the behavior of the first piece of doStack differs
	;	from the behavior of the other pieces of doStack. This may
	;	impact code generation for example when a DO-level is added or
	;	removed.
	;	FSCW CR18163: There is no documentation as to the reason of this
	;	difference. Neither did I find evidence that differences in
	;	generated code (depending on level) is intended.
	; - pslSt = PSL State
	;	This variable is introduced by CR18163. See UCPSLST.proc for
	;	details.
	;	subRou calls set^UCPSLST(.pslSt,$$getDcLnr,0,0)
	;	IF and ELSE will call push^UCPSLST(.pslSt,$$getDcLnr,1,0) for the
	;	first conditional statement on the line
	;	FOR and WHILE will call push^UCPSLST(.pslSt,$$getDcLnr,1,1) for the
	;	first iterative statement on the line
	;	initblock will call push^UCPSLST(.pslSt,$$getDcLnr,0,0)
	;	endblock will call pop^UCPSLST(.pslSt,,.ifLevel,.forLevel)
	;	line will check if the FOR-top is set, and if so will call pop,
	;	then it will check if the IF-top is set, and if so it will call
	;	pop.
	;
	; Other variables with "compiler wide" scope:
	; . type Number fCompile and type String fCompile()
	;	This traditional M array is used to manage #IF and #WHILE scope
	;	See IF^UCGMC.proc for a complete description.
	; . type PSLLabelRecord labels()
	;	Each label detected by the compiler or inserted by method
	;	generating code will be added to labels(). See OBJECTPROP for
	;	the definitions of the individual properties.
	;	labels(label).codeLine.isNull() indicates that the label has
	;	been inserted by method generating code, and is still to be
	;	compiled (or has been inserted as M code).
	;	labels(label).comment is used by method generating code to look
	;	for a matching subroutine (eg for Db.select()).
	; . type PSLColumn pslCln()
	;	This is the PSLColumn cache. Its single subscript is
	;	table.column. Many compiler units will pass this cache to
	;		$$caPslCln^UCXDD( .pslCln(), table.column)
	;	There are no subroutines that remove entries from this cache, so
	;	it grows during compilation.
	; . type String pslCls()
	;	Contains the PSL object class descriptors
	;	pslCls(className) = class descriptor
	;	Each node can be converted to a Row instance using the following
	;	constructor:
	;		type Row rwCls = pslCls(cls).toRow("#$$ocRowDef^UCXOBJ")
	; . type String pslLong()
	;	Contains the "long" names that are used in a subroutine.
	;	The first PSL.maxNameLength characters will be used in the nam
	;	subscript. The node will contain the (first) declaration to be
	;	able to show the conflicting names. The tree is killed in subRou
	;	and filled by trackNam().
	;	pslLong(nam) = var
	; . type List pslNew()
	;	This array is subscripted by subRou, and contains the list of
	;	lvns that need to be newed at the beginning of the subroutine
	;	pslNew(subRou) is set to "" in function $$subRou(). Compiler
	;	units that allocate variables with subroutine scope can add the
	;	name of the variable to pslNew(subRou). The list will be
	;	inserted into the code after pass 2, so optimization code and
	;	incremental load code can use this feature.
	; . type String pslP1Ap
	;	Code to APpend to the current pass 1 command being constructed
	;	Code generating methods may use this variable to add code that
	;	needs to be inserted after the "current command" such as cleanup
	;	of temporary variables. Code appended to this variable shall
	;	contain complete "pass 1 code" (such as a leading space for M
	;	code).
	; . type List pslRtns
	;	This list contains all routines for which label records have
	;	been added to labels().
	; . type PSLTable pslTbl()
	;	This is the PSLTable cache. Its single subscript is table. This
	;	array effectively replaces the fsn() array. Many compiler units
	;	will pass this cache to
	;		$$caPslTbl^UCXDD( .pslTbl(), table)
	;	There are no subroutines that remove entries from this cache, so
	;	it grows during compilation.
	; . type String pslToken()
	;	pslToken( number) = original value
	;	This array is used as a stack of nested tokens by PSL.mExpr()
	;	See mExpr^UCMETHOD for an explanation.
	;	The entries are maintained by tokenPush^UCPATCH() and
	;	$$tokenPop^UCPATCH().
	; . type String type(newLevel,var) =
	;	01	Class
	;	02	msrc where scoped
	;	03	scope (NEW,FORMAL,PUBLIC,LITERAL)
	;	04	msrc where instantiated
	;	05	Instantiation expression
	;	06	Stack level at instantiation
	;	07	If level at instantiation
	;	08	If stack at instantiation
	;	09 	Do stack at instantiation
	;	10	Object optimization switch (any number = off)
	;	11+	Class specific information
	;
	new append,called,calls,class,cmmds,cmp,dbLoad,dbAcc,del,doStack
	new ER,errTrap,fCompile,fline,forLevel,forStack,fsn,funcs,i,ifLevel
	new ifStack,label,level,line,load,lptr,keywords,mcode,n,newInst
	new oLvn,objectName,parlist,patch,postCond,postProc,primtyp
	;
	new pslCln,pslCls,pslLong,pslMtd,pslNew,pslPrp,pslRtns,pslSt,pslTbl
	new pslToken,pslVarNr
	;
	new rec,reClass,reset,RM,scope,struct,subLine,subRou,tab,type,xindex
	new xref,xtype,vdd,vobj
	;
	; set general catch-all exception handler
	new $ZTRAP set $ZTRAP="DO ZT^"_$text(+0)_"("_$ZLEVEL_")"
	;
	; cmmds(cmd)=Abbrv.|Argumentless|noPostCond
	;
	do initCmds(.cmmds)
	;
	set funcs=","_$$initFcts()_","
	;
	; Ensure DATA from TABLES accessed by the compiler is available when the
	; boot restriction level requires RowSets
	if $G(commands("boot","restrictionlevel"))=2 do getBootData^UCGMCU(.commands)
	;
	; Ensure %LIBS is set
	if '$D(%LIBS) new %LIBS set %LIBS="SYSDEV"
	;
	if '$D(%DB) set %DB=$$TRNLNM^%ZFUNC("SCAU$DB")
	if '$D(%VN) set %VN=$$^UCXCUVAR("%VN")
	;
	; Build keywords array from STBLKEYWORDS table.
	; Get the commands("mask",*) values
	; Initiate commands() settings that depend on SCAU_UCOPTS and UCOPTS.m
	do keywords^UCDTAUTL(.keywords)
	do masks^UCDTAUTL(.commands)
	do UCINIT^UCDTAUTL(.commands)
	;
	set reClass=$$getReClass()		; Record Class Sentinal
	do init^UCPRIM()			; reClass needed by init^UCPRIM()
	;
	set tab=$C(9)
	set append=0,pslVarNr=0,fline=0,ifLevel=0
	set doStack="",ifStack="",forStack=""
	set pslSt="" do set^UCPSLST(.pslSt,0,0,0)
	set fCompile=0,lptr="",oLvn="vobj",subRou=" ",subLine=1
	;
	; Get all PSLLabelRecords for the source array, but do not validate the
	; declarations. Initiate pslRtns.
	do getLblRec^UCPSLLR(.m2src,"",0,.labels)
	set labels(subRou)=1
	set pslRtns=","
	;
	; Intrinsic default classes and identifiers for PSL
	set level=-1,msrc=-1,mcode=""
	for objectName="Db","Class","Object","PSL","Runtime","Schema" do
	.	;
	.	;;do setScop(objectName,-1,0,"NEW")
	.	;;do setType(objectName,objectName,-1)
	.	do setScope(objectName,"","","NEW",objectName)
	.	do setInst(objectName,-1,"")
	.	do setOpti(objectName,-1,-1)
	;
	; Intrinsic default "literals" false and true
	do typeCrea("false","Boolean",-1,"LITERAL",0,0)
	do typeCrea("true","Boolean",-1,"LITERAL",0,1)
	;
	new return					; returned by LitInst^UCDB
	do LitInst^UCDB("CUVAR","CUVAR","","",level)	; Instantiate CUVAR
	;
	set level=0,level(level)=""
	;
	for i=1:1 quit:'$D(commands("execute",i))  X commands("execute",i)
	;
	set msrc=$O(msrc(""),-1)+0			; Point to the end
	;
	for line=1:1 set lptr=$O(m2src(lptr)) quit:lptr=""  do line(m2src(lptr)) quit:lptr=""
	;
	if level for i=level:-1:0 do impQuit(i)		; Clean up the stack
	else  do
	.	;
	.	; FSCW CR13403: The two lines below do not recognize "QUIT expr"
	.	; Replace by condition: subRou'="" (will be set by QUIT)
	.	;;set msrc=$O(msrc(""),-1),mcode=msrc(msrc)
	.	;;if $TR($$subEnd($$rtb(mcode),1),$C(9)," ")'=" Q" do impQuit(0)
	.	if " "'[subRou do impQuit(0)
	;
	set n=""
	for  set n=$O(postProc(n)) quit:n=""  do @postProc(n)	; Method post processor
	;
	; FSCW CR18163: The order of the calls is important! The call to UCPATCH
	; will ensure that all occurrences that go through patch^UCPATCH() have
	; been translated before the call to optNload^UCREC4OP().
	;
	; FSCW CR22719: Because the decision to use vobj() or voxn for certain
	; cases is postponed until optNload^UCREC4OP(), ^UCPATCH must be called
	; after optNload^UCREC4OP() has made the final decisions.
	if $D(dbAcc) do optNload^UCREC4OP(.msrc,''$G(commands("OPTIMIZE","OBJECTS")),0)
	if $D(patch) do ^UCPATCH
	if $D(dbLoad) do warnGroup("INTERNAL","dbLoad exists")
	;
	; Add NEW of pslNew() variables to all subroutines
	set subRou=""
	for  set subRou=$o(pslNew(subRou)) quit:subRou=""  do
	.	if pslNew(subRou)="" quit
	.	set msrc($P(labels(subRou),tab)+1E-5)=" N "_pslNew(subRou)
	;
	set label=""
	for  set label=$O(append(label)) quit:label=""  do
	.	;
	.	set n=0
	.	for  set n=$O(append(label,n)) quit:n=""  set mcode=append(label,n) do ADD(mcode)
	.	;
	.	new record
	.	set record=$G(append(label))
	.	if $P(record,tab,3) do move(label,record,.msrc)
	;
	; Save labels info for sysmap
	set label=""
	for  set label=$O(labels(label)) quit:label=""  if label'["^" set $P(sysmap("L",label),tab,4)=$TR($P(labels(label),tab,5),";",",")
	;
	; FSCW CR20280: no longer needed here
	; If not in boot mode, check calls to external routines for
	; parameter mismatches.
	;;if $G(commands("boot","restrictionlevel"))<1 do chkCalls^UCLABEL(.called,.commands,.labels,$C(9),5)
	;
	quit
	;
	;-----------------------------------------------------------------------
line(rec)	;private void; Parse the line of Script code 
	;-----------------------------------------------------------------------
	;
	set ER=0
	;
	new cmd,cmdNum,ifLevel,forLevel,mcode,ptr,tok,z	;FSCW CR11445: added mcode
	;
	set ifLevel=0,forLevel=0,mcode=""
	;
	set rec=$$RTCHR^%ZFUNC($TR(rec,$C(9)," ")," ")
	if rec="" do addComment quit
	;
	set ptr=0,rec=$$TOKEN^%ZS(rec,.tok,"") if ER set ER=0
	;
	; set exception handler for exceptions during single line compile
	new $ZTRAP set $ZTRAP="DO ZT^"_$text(+0)_"("_$ZLEVEL_")"
	;
	if $E(rec,1)=" " set mcode=$$initLine(level)
	else  do  if ptr=0 do ADD(mcode_";") quit
	.	;
	.	; If opening parenthesis and closing parenthesis not on same
	.	; line, join lines until a complete formal list is present
	.	set z=$$stripCmt^UCPSLLR(rec,0)
	.	if $L(z,"(")'=$L(z,")") set rec=$$joinFpl(.lptr,.tok)
	.	;
	.	set (mcode,z)=$$ATOM^%ZS(rec,.ptr,"",tok)
	.	if $$CONTAIN("LOCAL,PRIVATE,PUBLIC",$$UPCASE(z)) set mcode=$$ATOM^%ZS(rec,.ptr,"",tok),z=z_" "_mcode
	.	if $G(commands("Options","ResultClass")),mcode="void"!$$clsIsClass^UCGMR(mcode) set z=z_" "_$$ATOM^%ZS(rec,.ptr,"",tok)
	.	set mcode=$$subRou(z,.subRou,.labels,.type)_" "
	.	;
	.	; Check to see if line that starts subroutine does contain code
	.	; If so split the line. 'ptr' is passed to $$atom by value to
	.	; prevent that it is changed (we effectively perform a
	.	; look-ahead).
	.	if ptr=0 quit
	.	set z=$$ATOM^%ZS(rec,ptr,":;,",tok)
	.	if $E(z)=";" quit
	.	if $E(z,1,2)="//" quit
	.	do ADD(mcode_";")
	.	set rec=$E(rec,ptr+1,$L(rec)),ptr=1,mcode=" "
	;
	if $$ATOM^%ZS(rec,0,".",tok)="." do ERROR("MUMPS structured block syntax is not supported") quit
	;
	for cmdNum=1:1 do command(.rec,.ptr) quit:ptr=0!ER
	do ADD(mcode)
	;
	; pop levels pushed by this line. The order is important:
	; - a FOR/WHILE always sets ifLevel, so no IF/ELSE will be pushed AFTER
	;	a FOR/WHILE
	; - an IF/ELSE that preceded the FOR/WHILE will be uncovered by the pop,
	;	and must be popped itself. The 'public' ilLevel cannot be used,
	;	because FOR/WHILE will have set it to a non-zero value.
	; The code cannot refer to  forLevel and doLevel because DO { may have
	;	pushed a value that cannot be popped until the end of that block
	;	is detected.
	if $$topFor^UCPSLST(pslSt) do pop^UCPSLST(.pslSt,,.ifLevel,.forLevel)
	if $$topIf^UCPSLST(pslSt) do pop^UCPSLST(.pslSt,,.ifLevel,.forLevel)
	quit
	;
	;-----------------------------------------------------------------------
command(str,ptr)	;local void; Next 'M' command 
	;-----------------------------------------------------------------------
	;
	new atom,cmdDel,isDirctv
	set atom=$$ATOM^%ZS(str,.ptr,":;,",tok)
	set isDirctv=0
	;
	if ":,"[atom,$E(str,ptr+1)=" " for ptr=ptr+1:1 quit:'($E(str,ptr+1)=" ")
	;
	if atom="," do  quit				; Command continuation
	.	;
	.	if cmdNum=1!(ptr=0) do ERROR("SYNTAX: Expression expected") quit
	.	set cmdDel=","
	.	do cmdExpr
	;
	set cmdDel=" "
	if cmdNum>1 set mcode=mcode_cmdDel		; Command separator
	;
	if atom=";" set mcode=mcode_";"_$$COMMENT(str,.ptr,.tok) quit
	;
	if $E(atom)="/" do  quit			; C style comments
	.	;
	.	if ptr=0 set ptr=$L(str)
	.	set ptr=ptr-$L(atom)+2
	.	if $E(atom,2)="/" set mcode=mcode_";"_$$COMMENT(str,.ptr,.tok) quit
	.	if $E(atom,2)="*" do blockC quit
	;
	if subRou="",fCompile=0,$E($$UPCASE(atom))'="#" do  quit
	.	;
	.	set ptr=0
	.	if '$d(struct(7)) do warnGroup("DEAD","Dead code")
	;
	if atom="{" set:ptr=0 ptr=$L(str) set atom="D",ptr=ptr-2	; default DO
	if atom="}" do endBlock quit
	;
	if fline=0 set fline=1,$P(level(level),tab,2)=msrc	; 1st non-comment ptr
	;
	set cmd=$$UPCASE(atom)
	;;if $E(cmd)="#" set isDirctv=1 do ^UCGMC quit
	if $E(cmd)="#",cmdNum>1 do ERROR("#COMMAND must occur as first command on the line") quit
	if $E(cmd)="#" set isDirctv=1,mcode=mcode_$$^UCGMC(cmd,.m2src,.lptr,str,.ptr,tok) quit
	;
	if '$D(cmmds(cmd)) set cmd=$$getCommand(.cmmds,cmd) if cmd="" do ERROR("Invalid command: "_atom) quit
	;
	set postCond=""
	;
	if ptr=0 do cmdExpr quit
	set ptr=ptr+1,del=$E(str,ptr)
	;
	if del=":" do  quit:ER
	.	;
	.	do occMark^UCREC4OP()	; mark occurrence position for postCond
	.	set postCond=$$condRel($$nextExpr(str,.ptr,.tok,1))
	.	if ER do ERROR($g(RM)) quit
	.	if $P(cmmds(cmd),"|",3) do ERROR("Command does not support a post-conditional expression: "_cmd) quit
	.	;
	.	if $$isLit(postCond),$$QSUB^%ZS(postCond) set postCond="",struct(7,subRou)=""
	.	else  set postCond=":"_postCond
	.	;
	.	if ptr=0 set del="" quit:$$CONTAIN("QUIT,TROLLBACK,TCOMMIT",cmd)
	.	else  set ptr=ptr+1,del=$E(str,ptr)
	.
	.	if del'=" " do ERROR("Expression Expected")
	;
	do cmdExpr
	quit
	;
	;-----------------------------------------------------------------------
blockC	;local void; Process block comment
	;-----------------------------------------------------------------------
	;
	new z
	set z=$E(str,ptr,$L(str)),str=$E(str,1,ptr-3),ptr=$L(str)
	for  quit:z["*/"  set lptr=$O(m2src(lptr)) quit:lptr=""  set z=$$getLine(lptr)
	if lptr="" do warnGroup("SYNTAX","Multi-line comment terminator expected: */")
	;
	; FSCW CR 9792: str is tokenized, so appended code must be tokenized too
	;;set str=str_$P(z,"*/",2,$L(z))
	set str=str_$$TOKEN^%ZS($P(z,"*/",2,$L(z)),.tok,"")
	if ptr=$L(str) set ptr=0
	quit
	;
	;-----------------------------------------------------------------------
cmdExpr	;local void; Process a command expression e.g. Set abc="string" 
	;-----------------------------------------------------------------------
	;
	; type public String cmd
	; type public String cmdDel
	; type public String cmmds()
	; type public String mcode
	; type public Number ptr
	; type public String str
	; type public String subRou
	; type public String sysmap(,,)
	;
	new expr	; type exposed String
	new pslP1Ap	; type exposed String
	set expr=$$getOpand(str,.ptr),pslP1Ap=""
	;
	if expr="",'$P(cmmds(cmd),"|",2) do ERROR("Expression expected") quit
	;
	set sysmap("T",subRou,cmd)=$G(sysmap("T",subRou,cmd))+1
	do occMark^UCREC4OP(),@cmd	; mark occurrence position
	if pslP1Ap'="" set mcode=mcode_pslP1Ap,cmdDel=" "
	quit
	;
	;-----------------------------------------------------------------------
getCommand(cmmds,expr)	;local String; Return command from command table 
	;-----------------------------------------------------------------------
	;
	if $D(cmmds(expr)) quit expr
	;
	new z
	set z=expr
	for  set z=$O(cmmds(z)) quit:$E(z,1,$L(expr))'=expr  if $P(cmmds(z),"|",1)=expr quit
	;
	else  set z=""
	quit z
	;
	;-----------------------------------------------------------------------
getOpand(str,ptr)	;local String; Return expression after command 
	;-----------------------------------------------------------------------
	;
	new return
	;
	if ptr=0 quit ""
	if $E(str,ptr+1)=" " quit ""			; Argumentless command
	if $E(str,ptr+1)=";" quit ""			; M style comment
	if $E(str,ptr+1)="/","/*"[$E(str,ptr+2) quit "" ; Comment
	quit $$nextExpr(str,.ptr,.tok,1)
	;
	;-----------------------------------------------------------------------
nextExpr(str,ptr,tok,cvt,more)	;private String; Return the next expression 
	;-----------------------------------------------------------------------
	;
	; NOTES:
	; . also called by akey2apl^UCDB, mapKeys^UCDB, sql2akey^UCDB, and
	;	insCod^UCREC4OP
	;
	new return
	set return=$$ATOM^%ZS(str,.ptr,",",tok,cvt)
	if ER do ERROR($g(RM))
	if ptr=0!(return=",") quit return
	;
	; allow only Unary tokens ('+-) as expression continuation
	if '$D(more),"*/\#_=><[]&!?,"[$E(return) quit return  ; First token
	;
	; Advance to the next non-white space character
	new i for i=ptr+1:1 if '($E(str,i)=" ") quit
	if $E(str,i)="," quit return			; Command delimiter
	if $E(str,i)="?",'(return="") quit return	; M column - FRS 06/11/03
	if $E(str,i)="/","/*"[$E(str,i+1) quit return	; Comment
	; 02/05/04 require balanced whitespace on unary operator (except on "'")
	if "+-"[$E(str,i),$E(str,i-1)=" ",'($E(str,i+1)=" "),'("+-*/\#_=><[]&!"[$E(return,$L(return))) quit return
	;
	; if string ends with a delimiter or next token is one, read ahead
	new dels
	set dels="+-*/\#_=><[]?'&!"
	if dels[$E(return,$L(return))!(dels[$E(str,i)) set return=return_$$nextExpr(str,.ptr,.tok,cvt,1)
	quit return
	;
	;-----------------------------------------------------------------------
valExpr(str,class,setVar)	; Process a value expression e.g. set a= |1*3+5| 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . str = rightexpr					/REQ/MECH=VAL
	; . class = datatype of result				/NOREQ/MECH=REF:W
	; . setVar = ???
	;	passed along to $$valCast(), $$valObj(), and recursive calls to
	;	$$valExpr().
	;
	; INPUTS:
	; . cmd = current command
	;
	; LOCALS:
	; . cbin = binary operator under construction
	; . cexpr = compound expression
	;	This lvn will contain an abstact version of the expression of
	;	the form:
	;		Class1 SP binop1 SP unop Class2 SP binop2 SP Class3 ...
	;	It is used to derive the Primitive descendant of the result, and
	;	to check for possible PRECEDENCE misconceptions
	; . cun = unary operator(s) under construction
	;
	if str="" do ERROR("Expression Expected") quit ""
	;
	new atom,cbin,cexpr,cun,dels,fc,i,ptr,return
	;
	set dels="+-*/\#_'=><[]&!?",ptr=0
	set (cbin,cexpr,cun,class,return)=""
	;
	for  do  if ptr=0!ER quit
	.	;
	.	set atom=$$ATOM^%ZS(str,.ptr,dels,tok,1) if ER quit
	.	if atom="?" set return=return_atom_$$UNTOK^%ZS($$ATOM^%ZS(str,.ptr,"&!",.tok,1),.tok),cexpr=cexpr_class_" ? PATTERN",(class,cbin,cun)="" quit
	.	if dels[atom do  quit
	..		;
	..		if ptr=0 set ER=1 quit		; ends with operator
	..		;
	..		if '("+-'"[atom) do		; binary operator
	...			;
	...			; binary operator at start is error, except if
	...			; '*' as first char in WRITE *
	...			; set fc = the last character previous expratom
	...			if cmd'="WRITE",return="" set ER=1 quit
	...			set fc=$E(return,$L(return))
	...			if cmd="WRITE",atom="*",fc="" quit
	...			;
	...			; append this binop to cbin
	...			; done if previous not a binary operator
	...			set cbin=cbin_atom
	...			if '($TR(dels,"+-'")[fc) quit
	...			;
	...			; do not accept 3 adjacent binary operators
	...			if $TR(dels,"+-'")[$E(str,ptr+1) set ER=1 quit
	...			;
	...			; Standard M "double binary"
	...			if "*]"[atom,atom=fc quit	; ]] or **
	...			;
	...			; PSL "double binary": ==, =>, =<, <>, <=, >=
	...			; All may be preceeded by a single unary not
	...			; Strip off the last binop from return (it will
	...			; be combined with the current binop in atom).
	...			; Force numeric interpretation of both sides.
	...			set return=$E(return,1,$L(return)-1)
	...			;
	...			; If logical expr, insert + just after the logop
	...			; that delimits the right-most logical factor.
	...			; NOTE FSCW:
	...			; This behavior seems disputable for the
	...			; following reasons:
	...			; 1) Looking backward for & and ! assumes that
	...			;	the programmer observed precedence, and
	...			; 	when precedence is observed, this case
	...			;	would never occur
	...			; 2) If the programmer did NOT observe
	...			;	precedence, then the + may be inserted
	...			;	at an incorrect place, because the
	...			;	rightmost ! or & in return may be in
	...			;	a parenthesized expression.
	...			; For the above reasons, the safest way to force
	...			; the numeric interpretation of the left operand
	...			; is appending "+0" to return.
	...			; In fact, this observation applies to the ELSE
	...			; part as well: if return contains any binary
	...			; operation, prepending "+" to the result will
	...			; only force the numeric interpretation of the
	...			; first operand, not of the entire expr.
	...			;
	...			;;if cexpr[" ! "!(cexpr[" & ") do
	...			;;.	if return["""" set return=$$TOKEN^%ZS(return,.tok)
	...			;;.	for i=$L(return):-1:0 quit:"&!"[$E(return,i)
	...			;;.	set return=$E(return,1,i)_"+"_$E(return,i+1,$L(return))
	...			;;.	if return[$C(0) set return=$$UNTOK^%ZS(return,tok)
	...			;;;
	...			;;else  set return="+"_$E(return,1,$L(return))
	...			if cexpr'[" " set return="+"_return
	...			else  set return=return_"+0"
	...			set str=$E(str,1,ptr)_"+"_$E(str,ptr+1,$L(str))
	...			;
	...			; use single cbin value to repesent all cases
	...			set cbin="=="
	...			if fc="=",atom="=" quit
	...			;
	...			; All others will reverse the "M meaning"
	...			new not
	...			if $E(return,$L(return))="'" set not=0,return=$E(return,1,$L(return)-1)
	...			else  set not=1
	...			;
	...			if fc="<",atom=">"  set atom="="
	...			else  if fc="=","<>"[atom set atom=$TR(atom,"<>","><")
	...			else  if atom="=","<>"[fc set atom=$TR(fc,"<>","><")
	...			else  set ER=1 quit
	...			;
	...			if not set return=return_"'"
	..		else  do	; unary operator
	...			;
	...			; If binops still empty, then this is (the first
	...			; part) of a binary operator, except if cexpr=""
	...			; and class="" (beginning of the expr).
	...			if cbin="",cexpr_class'="" set cbin=atom quit
	...			;
	...			; Combine multiple unops into one (it will only
	...			; be used to derive the resulting data type and
	...			; PRECEDENCE problems.
	...			; First unop determins the result
	...			if cun="" set cun=atom quit
	..		;
	..		set return=return_atom
	.	;
	.	; non-delimiter atoms.
	.	; Update cexpr. Note that cun is tied to the atom we are about
	.	; to handle
	.	if cbin'="" set cexpr=cexpr_class_" "_cbin_" "
	.	set cexpr=cexpr_cun,(cbin,cun)=""
	.	set fc=$E(atom)
	.	if fc="{" set return=return_$$valCast(atom,0,.setVar,.class) quit
	.	if fc="""" do ERROR("Literal delimiter ("") expected") quit
	.	if $$isObj(atom) set return=return_$$valObj(atom,0,.setVar,.class) quit
	.	;
	.	if "0123456789."[fc set return=return_atom,class="Number" quit
	.	;
	.	; tokenized string literal
	.	if fc=$C(0) do  quit			; String
	..		if '($F(atom,$C(0),2)>$L(atom)) do ERROR("Space or operator expected after: "_$$UNTOK^%ZS($P(atom,$C(0),1,2)_$C(0),tok)) quit
	..		set atom=$$UNTOK^%ZS(atom,tok)
	..		set return=return_atom
	..		set class=$$getClass(atom)
	..		if class="" set class="String"
	.	;
	.	if fc="(" do  quit
	..		new y
	..		set y=$F(atom,")")
	..		if $L($E(atom,1,y-1),"(")=$L($E(atom,1,y-1),")")	; Match
	..		else  for  set y=$F(atom,")",y) quit:y=0  if $L($E(atom,1,y-1),"(")=$L($E(atom,1,y-1),")") quit
	..		if '($L(atom)+1=y) do ERROR("Unexpected character: "_$E(atom,y)) quit
	..		set return=return_"("_$$valExpr($E(atom,2,$L(atom)-1),.class,.setVar)_")"
	.	;
	.	if fc="$" do  quit
	..		;
	..		if $$isFun(atom) set return=return_$$valFun(atom,0,,.class) quit
	..		if $$isExt(atom) set return=return_$$valFun(atom,0,,.class) quit
	..		set class="String"		; for now
	..		if $$isSys(atom) set return=return_atom quit
	..		set ER=1
	.	;
	.	; Other special cases:
	.	; - PATCHCHAR patch PATCH
	.	; - purpose variable wrap
	.	if $$isPatch^UCPATCH(atom) set return=return_atom,class="String" quit
	.	if $$isWrap^UCREC4OP(atom) set return=return_atom,class="String" quit
	.	if fc=")" set ER=1 quit
	.	;
	.	new newLevel,scope
	.	if fc="@" set atom=$E(atom,2,$L(atom))	; @var
	.	;
	.	set atom=$$varExpr(atom,0,.class,.newLevel,.scope) if ER quit
	.	if scope="LITERAL",$$primVar^UCPRIM(class) set atom=$$getExpr(atom,.newLevel)
	.	if fc="@" do
	..		if '$$isLit(atom) set atom=$$toLit(atom,.tok)
	..		if '$$isLit(atom) set atom="@"_atom
	..		else  set atom=$$valExpr($$QSUB^%ZS(atom),.class,.setVar)
	.	if class="" set ER=1
	.	;
	.	; FSCW CR11445:
	.	; The statements below use $$primVar^UCPRIM() to accept values.
	.	; This implies that PSL programmers are allowed to use constructs
	.	; that imply knowledge of the implementation of the object.
	.	; The cleaner solution would be to use $$primDes^UCPRIM().
	.	; However, much of the PSL code generated to implement methods
	.	; (like PSL.mExpr(), and PSLBuffer) is sloppy with respect to
	.	; proper object typing, so only a warning will be generated.
	.	if return'="",class'="" do
	..		i '$$primVar^UCPRIM(class) set ER=1 quit
	..		i '$$primDes^UCPRIM(class) do warnGroup("MISMATCH","Cast expression to primitive class: "_class)
	.	set return=return_atom
	;
	if ER set return="" do ERROR("Invalid expression: "_$$UNTOK^%ZS(atom,.tok))
	;
	; Resolve the class of a compound expression
	if '(cexpr="") set class=$$compClass(cexpr_class)
	quit return
	;
	;-----------------------------------------------------------------------
compClass(cexpr)	; Resolve the class of a compound expression 
	;-----------------------------------------------------------------------
	; Resolve the class of a compound expression based on the operators and
	; look for possible PRECEDENCE misconceptions.
	; Since we use the binops and unops only for precedence,
	; certain simplifications can be made:
	; - a unary NOT in combination with OR, AND, or any of the COMPARISON
	;	operators can be ignored (it does not change the precedence),
	;	except if the unary NOT occurs in a string expression or numeric
	;	expression.
	; - "double binaries" == and ]] can be reduced to a single character.
	; - the ** operator will be replaced by ^, because it has a different
	;	precedence as *.
	;
	; The "normal" (hieararchical) precedence rules distinguish the
	; following syntax decomposition tree
	; 1) boolexpr = boolterm ! boolterm
	; 2) boolterm = boolfact & boolfact
	; 3) boolfact = strgexpr compop strgexpr ( < = > [ ? ])
	; 4) strgexpr = aritexpr _ aritexpr
	; 5) aritexpr = aritterm + aritterm (+ -)
	; 6) aritterm = aritfact * aritfact (* / \ #)
	; 7) aritfact = aritexpo ^ aritexpo (exponent, M/PSL **)
	; Unambiguous expression evaluation will occur as long as the precedence
	; values of the binops are non-increasing from left-to-right (each next
	; precedence value is equal to or less than the previous value).
	;
	; By putting the concatenation operator in a separate group, with lower
	; precedence as any arithmetic operator, a warning will be supplied if
	; a numeric operator follows a conatenation, whereas numeric operators
	; that preceed the concatenation are deemed OK.
	;
	; The code below contains the following statement that maps the reduced
	; binop to its precedence value:
	; set precval = $E( "x1233333345566667",	values corrected for $F
	;               $F(  "!&<=>[?]_+-*/\#^",	derived binary operators
	;		opm))				modified binary operand
	;
	if cexpr="" quit ""
	;
	new class,class1,class2,lop,op,opm,pv0,pv1
	set cexpr=cexpr,class=$p(cexpr," "),lop="",pv0=9
	;
	for  do  if '(cexpr[" ") quit
	.	;
	.	set class1=$P(cexpr," ",1),op=$P(cexpr," ",2),class2=$P(cexpr," ",3)
	.	set cexpr=$P(cexpr," ",4,$L(cexpr))
	.	;
	.	; construct modified binop (see intro)
	.	set opm=$TR(op,"'")
	.	if $L(opm)>1 set opm=$S(opm="**":"^",1:$E(opm))
	.	;
	.	; convert binop to precedence value (see intro)
	.	set pv1=$E("x1233333345566667",$F("!&<=>[?]_+-*/\#^",opm))
	. 	;
	.	; if new value greater than previous, we may have a problem
	.	if pv1>pv0 do warnGroup("PRECEDENCE","Ambiguous operator precedence: ("_lop_") ("_op_")")
	.	;
	.	; if unary NOT in strgexpr or aritexpr we may have a problem
	.	if pv1>3 do
	..		if $E(class1)="'" do warnGroup("PRECEDENCE","Ambiguous operator precedence: (') ("_op_")")
	..		if $E(class2)="'" do warnGroup("PRECEDENCE","Ambiguous operator precedence: ("_op_") (')")
	.	set lop=op,pv0=pv1
	.	;
	.	; derive result class
	.	if "[]=><&!?"[opm set class="Boolean"
	.	else  if "+-*/\#^"[opm set class="Number"
	.	else  set class="String"
	.	;
	.	; Before checking for combinations, take care of unary
	.	; operator preceeding the class name:
	.	if $E(class1)="'" set class1="Boolean"
	.	else  if "+-"[$E(class1) set class1="Number"
	.	if $E(class2)="'" set class2="Boolean"
	.	else  if "+-"[$E(class2) set class2="Number"
	.	;
	.	; Check for combinations with known different result
	.	if '(class1=""),'(class2="") do
	..		;
	..		; FSCW CR11445: accepted use of primttyp() array
	..		if $D(primtyp(class1,op,class2)) set class=primtyp(class1,op,class2)
	..		else  if $D(primtyp(class2,op,class1)) set class=primtyp(class2,op,class1)
	.	;
	.	if '(cexpr="") set cexpr=class_" "_cexpr
	;
	quit class
	;
	;-----------------------------------------------------------------------
valFun(expr,fset,srcVar,class)	; Process Function Logic 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String expr = intrinsic or extrinsic function	/REQ/MECH=VAL
	; . Boolean fset = function target of assignment?	/NOREQ/MECH=VAL
	;	If 1, then the function occurs as leftexpr (on the left side of
	;	an assigment), else it occurs as rightexpr (on the right side of
	;	an assigment.
	; . String srcVar = source variable			/NOREC/MECH=REF:W
	;	Optional parameter that receives the source object (the first
	;	function argument), if the function call is converted to an
	;	object method, or if fset'=0.
	;	For extrinsic functions and intrinsic functions with fset=0 the
	;	empty string will be returned.
	; . String class = datatype of return value		/NOREQ/MECH=REF:W
	;	If an intrinsic function is translated to an object method, then
	;	the datatype returned by that method, else "String".
	;
	; NOTES:
	; . From an OO perspective it would be preferable to set
	;	class="Primitive" rather than class="String". However, this will
	;	require explicit casts to the "known" return type if a method is
	;	subsequently invoked on the return value (e.g. $$fun().find()).
	;
	if $G(commands("OPTIMIZE","FUNCTIONS")) set expr=$$convert^UCGMCONV(expr,.funcs,.tok,.commands) if $$isObj(expr) quit $$valObj(expr,.fset,.srcVar,.class)
	;
	new atom,cls,del,farg,fnam,islit,isvar,ptr,return,undef
	;
	; NOTE: $$actual() will ALWAYS set class
	set srcVar=""
	if $E(expr,1,2)="$$" set return=$$actual(expr,.called,.class) set:class="" class="String" quit return
	;
	set class="String",return=""
	;
	set ptr=0
	;
	set fnam=$P(expr,"(",1)
	set farg=$P(expr,"(",2,999)
	set farg=$E(farg,1,$L(farg)-1)			; Strip Params
	;
	set fnam=$$UPCASE(fnam)
	if $F(funcs,(","_fnam))=0 do ERROR("Invalid function") quit ""
	;
	set return=fnam_"("
	;
	set islit=1,isvar=0,undef=0
	;
	if $G(fset) do  if ER quit ""			; Allow set $piece(
	.	;
	.	if $E("$PIECE",1,$L(fnam))'=fnam do ERROR("Invalid assignment function: "_fnam) quit
	.	set islit=0,isvar=1,undef=-1
	;
	if $E("$GET",1,$L(fnam))=fnam set isvar=1,islit=0,undef=-1
	if $E("$DATA",1,$L(fnam))=fnam set isvar=1,islit=0,undef=-1
	if $E("$ORDER",1,$L(fnam))=fnam set isvar=1,islit=0,undef=-1
	if $E("$RANDOM",1,$L(fnam))=fnam set isvar=0,islit=0
	if $E("$SELECT",1,$L(fnam))=fnam do
	.	;
	.	new exprBool,exprVal
	.	for  set atom=$$nextExpr(farg,.ptr,.tok,1) do  quit:ptr=0!ER
	..		if atom="," set return=return_atom quit
	..		;
	..		new ptr set ptr=0
	..		set exprBool=$$ATOM^%ZS(atom,.ptr,":",.tok,1)
	..		set exprVal=$E(atom,ptr+2,999)
	..		if exprBool=""!(exprVal="")!(ptr=0) do ERROR("Invalid $SELECT syntax") quit
	..		set exprBool=$$condRel(exprBool)
	..		set exprVal=$$valExpr(exprVal,.cls,.setVar)
	..		if islit set islit=$$isLit(exprBool)
	..		if islit set islit=$$isLit(exprVal)
	..		set return=return_exprBool_":"_exprVal
	;
	else  for  set atom=$$nextExpr(farg,.ptr,.tok,'isvar) do  quit:ptr=0!ER
	.	;
	.	if atom="," set return=return_atom quit
	.	if atom="" quit
	.	;
	.	if $E(atom)=".",'($E(atom,2)?1N) set atom=$E(atom,2,$L(atom))	; White noise
	.	; FRS - 06/17/03
	.	if isvar set atom=$$varExpr(atom,undef,.cls)	; fset=0
	.	else  set atom=$$valExpr(atom,.cls,.setvar)
	.	;
	.	if islit set islit=$$isLit(atom)
	.	set return=return_atom
	.	;
	.	if isvar set isvar=0,undef=0 if fset set srcVar=atom
	.	else  if '$$primDes^UCPRIM(cls) do ERROR("Object is invalid function argument")
	;
	set return=return_")"
	;
	if islit do	; Optimize - If all parameters are literal, execute the function now!
	.	;
	.	new literal
	.	xecute "set literal="_return
	.	; Don't change if results contain control characters or $C(254) since won't
	.	; be valid string in M code
	.	if literal'?.e1c.e,literal'[$C(254) set return=literal if return'=+return set return=$$QADD^%ZS(return)
	;
	quit return
	;
	;-----------------------------------------------------------------------
valObj(atom,fset,setVar,class,new)	; Process an object expression 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String atom = the object expression			/REQ/MECH=VAL
	;	(object.property or object.method())
	; . Number fset = SET or GET indicator			/REQ/MECH=VAL
	;	fset = 0 indicates the object expression is referenced
	;	fset = 1 indicates the object occurs as leftexpr (assignment
	;		target
	;	fset = -1 indicates the object expression occurs as actual
	;		pass-by-reference parameter. This is important for
	;		record.column expressions because $$curVal^UCCOLUMN
	;		must treat the access both as a retrieval and as a
	;		modification.
	; . String setVar = assignment target			/NOREQ/MECH=REF:RW
	;	If fset=0, then this is considered an INPUT variable, that will
	;	be passed to $$property and $$method (and to $$valExpr???)
	;	If fset=1, this is considered an OUTPUT variable, that will
	;	receive the value of objectName (the object instance variable)
	;	The caller can use this value to change characteristics of the
	;	instance (e.g. its optimizability), or provide "late" warnings
	;	or errors.
	; . class = data type of return value			/NOREQ/MECH=REF:W
	; . new = ???
	;
	; INPUTS:
	; . tok = tokenized literals
	;	This variable is passed to $$ATOM^%ZS()
	;
	; LOCALS:
	; . pslTmpLvn = temporary lvn for nested references
	;	If the property or method is nested, then the handler may have
	;	allocated a symbol that describes the nested entity as if an
	;	intermediate assignment has occurred. For example:
	;		set colval = rs.getRow().colname
	;	can be broken down as
	;		type Row plsTmpLvn = class.new("Row", ...)
	;		set colval = pslTmpLvn.colname
	;	The handler shall return the name of the symbol that it
	;	allocated in pslTmpLvn. If no symbol is returned, the compiler
	;	will allocate a temporary symbol.
	;
	; NOTES:
	; . The use of pslTmpLvn is not very nice, but it is better as the old
	;	practice where handlers would manipulate pslVarNr directly.
	;
	new newLevel,objectName,pslTmpLvn,ptr,ref,return
	;
	set ptr=0
	for  set ptr=$F(atom,".",ptr) quit:ptr=0  if '($E(atom,ptr)?1N),$L($E(atom,1,ptr-2),"(")=$L($E(atom,1,ptr-2),")") quit
	;
	set ptr=ptr-1
	set objectName=$E(atom,1,ptr-1),ref=$$ATOM^%ZS(atom,.ptr,".",tok,1)
	set objectName=$$valExpr(objectName,.class,.setVar) if ER quit ""
	;
	if '($$isVar(objectName)!$$isArr(objectName)) do
	.	;
	.	set newLevel=level,objectName=$$toLit(objectName)
	.	;
	.	; FSCW 27486: do NOT create entries for literals
	.	quit:$$isLit(objectName)
	.	set type(newLevel,objectName)=class_tab_(msrc+1)_tab_"NEW"_tab_(msrc+1)_tab_objectName
	;
	else  if '$$getInst(objectName,.newLevel) do
	.	;
	.	if $$primDes^UCPRIM(class) do setInst(objectName,$P(labels(subRou),tab,1),"") quit
	;
	if ER quit ""
	;
	if ref["(" set return=$$method(objectName,newLevel,ref,.type,.class,.setVar)
	else  set return=$$property(objectName,newLevel,ref,.class,.setVar)
	;
	if ptr do  if ER quit ""				; Nested Expression
	.	;
	.	if class="" do ERROR("Invalid void method in nested syntax: "_atom) quit
	.	;
	.	; FSCW CR11445: check on primitive already included in $$isClass
	.	;if '$$primVar^UCPRIM(class),'$$isClass(.class) do ERROR("Undefined class: "_class) quit
	.	if '$$isClass(.class) do ERROR("Undefined class: "_class) quit
	.	;
	.	; FSCW CR 27486: The code below has been commented out because
	.	; the recursive call to valObj(lit) will change the class of
	.	; 'return' to either Number or String, which may be incorrect.
	.	; To still be able to use literal suibstitution, a literal
	.	; return is added as a temporary literal var instead of as a
	.	; temporary new variable
	.	;;if $$isLit(return) do  quit
	.	;;.	;
	.	;;.	set atom=$$TOKEN^%ZS(return,.tok)_$E(atom,ptr+1,$L(atom))
	.	;;.	set return=$$valObj(atom,.fset,.setVar,.class)
	.	;
	.	new expr,lvn,scope
	.	if $$isLit(return) set lvn=$$nxtSym,scope="LITERAL"
	.	else  if $DATA(pslTmpLvn) set lvn=pslTmpLvn,scope="NEW"
	.	else  set lvn=$$nxtSym,scope="NEW"
	.	;
	.	; NOTE: HARD CODED use of UCPATCH.PATCHCHAR = $C(6)
	.	if return[$C(6) set return=$TR(return,$C(6),$C(0))
	.	;
	.	set type(level,lvn)=class_tab_(msrc+1)_tab_scope_tab_(msrc+1)_tab_return
	.	;
	.	set atom=lvn_$E(atom,ptr+1,$L(atom))
	.	set return=$$valObj(atom,.fset,.setVar,.class)
	.	set expr=$$getExpr(lvn)
	.	if expr[$C(0) set expr=$TR(expr,$C(0),$C(6))
	.	set return=$$varSub^UCPATCH(return,lvn,expr)
	;
	; If fset=1, use setVar to return the name of object variable
	if fset set setVar=objectName
	quit return
	;
	;-----------------------------------------------------------------------
valCast(atom,fset,setVar,class,new)	; Process a cast expression 
	;-----------------------------------------------------------------------
	;
	new cast,expr,ptr,newLevel
	set ptr=1,cast=$$ATOM^%ZS(atom,.ptr,"}",.tok,1)
	;
	if ptr=0 do ERROR("Casting terminator expected") quit ""
	set expr=$E(atom,ptr+2,$L(atom))
	;
	if '$$isClass(.cast) do ERROR("Undefined class: "_cast) quit ""
	;
	if $$isObj(expr) do  quit expr 		; Save the original class to restore later
	.	;
	.	new atom,i,sclass
	.	for i=1:1:$L(expr,".") set atom=$P(expr,".",1,i) if $L(atom,"(")=$L(atom,")") quit
	.	;
	.	if $E(atom)="(" do  if ER quit
	..		;
	..		for  set atom=$E(atom,2,$L(atom)-1) if '($E(atom)="(") quit
	..		set atom=$$valExpr(atom,.sclass,.setVar)
	..		set expr=atom_"."_$P(expr,".",i+1,$L(expr))
	.	;
	.	if '($$isVar(atom)!$$isArr(atom)) do
	..		;
	..		set atom=$$toLit(atom,.tok),sclass="String"
	..		set type(level,atom)=cast_tab_(msrc+1)_tab_"NEW"_tab_(msrc+1)_tab_atom
	.	;
	.	else  set sclass=$$getClass(atom) do setType(atom,cast)
	.	;
	.	set expr=$$valExpr(expr,.class,.setVar) if ER quit
	.	do setType(atom,sclass)
	;
	if ER quit ""
	set expr=$$valExpr(expr,.class,.setVar)
	;
	if class=cast quit expr
	;
	; FSCW CR11445: potentially dangerous use of $$primVar^UCPRIM(cast)
	; encourages use of knowledge of OBJECT.ISNOPOINTER.
	;
	; Do not implicitly convert primitive classes (at least for now)
	if $$primVar^UCPRIM(cast),$$primVar^UCPRIM(class) set class=cast quit expr
	;
	if ifLevel!(postCond'="") do ERROR("Object cast cannot be conditionally executed") quit expr
	;
	if '$$isAncestor(class,cast),'$$isAncestor(cast,class) do ERROR("Invalid cast - Class: "_class_" can not be cast as: "_cast) quit expr
	;
	set class=cast if '$D(var) quit expr
	set newLevel=$$getLevel(var)
	;
	if '(level=newLevel) do
	.	;
	.	; Assign cast type and PUBLIC scope to avoid kill
	.	set type(level,var)=type(newLevel,var)
	.	set $P(type(level,var),tab,3)="PUBLIC"
	;
	do setType(var,class)
	quit expr
	;
	;-----------------------------------------------------------------------
property(objectName,objectLevel,ref,class,setVar)	;private String; 
	;-----------------------------------------------------------------------
	; Decompose object.property
	;
	; ARGUMENTS:
	; . objectName = object variable (may be subscripted)
	; . objectLevel = DO level where objectName is declared
	; . ref = property name
	; . class = name of class			/MECH=REFNAM:RW
	;	On INPUT this contains the class of objectName
	;	On OUTPUT this is supposed to contain the class of the property.
	; . setVar = ?
	;
	; INPUTS:
	; . atom = complete object expression as passed to $$objVal()
	;	This value will be passed to $$curVal^UCCOLUMN()
	; . ptr = character pointer into atom
	;	This value will be passed-by-reference to $$curVal^UCCOLUMN()
	;
	; NOTES:
	; . Passing atom and .ptr to $$curVal is questionable behavior, because
	;	neither variable has "PSL scope". They are from this function's
	;	only local caller ($$objVal()).
	; . This function is also called by colProp^UCCOLUMN
	;	That caller will pass a class="Column"
	;
	if ref="" do ERROR("Property name expected") quit ""
	;
	set fset=+$G(fset)
	;
	new litexpr
	if 'fset,'ptr do  if '(litexpr="") quit litexpr	; Return Literal if possible
	.	;
	.	set litexpr=$$toLit(objectName_"."_ref)
	.	if $$isLit(litexpr) set class=$$getClass(objectName_"."_ref,objectLevel)
	.	else  set litexpr=""
	;
	if $$isRecord(class) quit $$curVal^UCCOLUMN(objectName,ref,fset,atom,.ptr)
	;
	new aclass,del,idx,nod,pgm,pos,return,y,yz,z
	;
	set y=$F(ref,"{")
	;
	if y=0 set idx=""
	else   do  if yz=0 do ERROR("Right Index delimiter '}' Expected: "_ref) quit ""
	.	;
	.	new class
	.	set yz=$F(ref,"}",y) if yz=0 quit
	.	for  set idx=$E(ref,y,yz-2) quit:$L(idx,"{")=$L(idx,"}")!'yz  set yz=$F(ref,"}",yz)
	.	set idx=$$valExpr(idx,.class)
	.	set ref=$E(ref,1,y-2)_$E(ref,yz,$L(ref))
	set z=$$opGet^UCXOBJ(.pslPrp,class,ref,0)
	if z="" set z=$$opGet^UCXOBJ(.pslPrp,class,ref,1)
	;
	; Property not found, if there is a property handler on the original
	; class, call it, otherwise we have an error
	; NOTE: hard-coded positions for OBJECTROW: PROPDELIM=8, PROPPROC=9
	if z="" do  quit return
	.	set return=""
	.	set z=$$ocGet^UCXOBJ(.pslCls,class,0)
	.	set del=$P(z,"|",8),pgm=$P(z,"|",9) if del="" set del=124
	.	set del=$S(del>31&(del<127):""""_$C(del)_"""",1:"$C("_del_")")
	.	if pgm="" do ERROR("Undefined property: "_class_"."_ref) quit
	.	do @pgm
	;
	; NOTE: hard-coded positions for OBJECTPROPROW:
	;	CLASS,PROPERTY,RETURN,NOD,POS,ROUTINE,ISREADONLY,ARRAY
	;
	; Get the delimiter from the (ancestor) class that contains the property
	set aclass=$P(z,"|",1)
	set del=$P($$ocGet^UCXOBJ(.pslCls,aclass,0),"|",8) if del="" set del=124
	set del=$S(del>31&(del<127):""""_$C(del)_"""",1:"$C("_del_")")
	;
	; FSCW CR11441: check isReadOnly
	if fset,$piece(z,"|",7) do ERROR("Property is read-only: "_class_"."_ref) quit ""
	;
	set ref=$P(z,"|",2),nod=$P(z,"|",4),pos=$P(z,"|",5),class=$P(z,"|",3),pgm=$P(z,"|",6)
	;
	if pgm'="" do @pgm quit $G(return)
	;
	; FSCW CR11445: replaced lines below
	; If class has primitive representation use objectName
	if $$primVar^UCPRIM(aclass) set return=objectName
	;
	else  do
	.	set return=oLvn_"("_objectName
	.	;
	.	if nod'="" S:nod'=+nod nod=""""_nod_"""" set return=return_","_nod
	.	if idx'="" set return=return_","_idx
	.	set return=return_")"
	;
	if pos set return="$P("_return_","_del_","_pos_")"
	;
	quit return
	;
	;-----------------------------------------------------------------------
method(objectName,objectLevel,ref,type,class,var)	; Object method syntax 
	;-----------------------------------------------------------------------
	;
	; INPUTS:
	; . %VN = Profile version number
	; . fset = assignment indicator
	; . fsn() = array of table descriptors for SQL*
	; . funcs = list of PSL functions
	; . msrc = The last line in the code output buffer
	; . methods(,,) = "finalize" code
	; . pslPrsr(,) = Parser instance
	; . pslTbl() = PSLTable cache
	; . reClass = Record class prefix
	; . subRou = current subroutine
	; . tab = TAB character
	;
	; OUTPUTS:
	; . fsn(TABLE) - created if RecordTABLE instance detected
	; . pslTbl(TABLE) - created if RecordTABLE instance detected
	; . methods(,,) - entries may have been added by code generators
	;
	; Variables passed to methods:		eg. set abc=rs.getCol("bal")
	;
	; actual(1-n) = Actual parameters passed                 eg. actual(1)=""bal"")
	; attrib(p,0) = Attributes of parameters vptr<tab>class<tab>byref
	; attrib(p,1) = ...
	; attrib(p,2) = ...
	; var         = Variable return assigned to unless void  eg. abc
	; varLevel    = Stack level where var was scoped         eg. 2
	; objectName  = Name of the object identifier            eg. rs
	; objectLevel = Stack level where identifier was scoped  eg. 1
	; objectScope = Scope of identifier (FORMAL,NEW,PUBLIC,LITERAL)
	; objectVar   = value of objectName before objectName.toLiteral()
	;
	; class       = Expected return class of this method     eg. String
	; fset        = Flag var within assignment scope         eg. set abc
	; oLvn        = Object storage array name                eg. vobj
	; mclass      = name of the class			 eg. ResultSet
	; mcode       = Current M generated code for this line
	; method      = name of the method			 eg. getCol
	; msrc        = The last line in the code output buffer
	; reClass     = Record<class> Prefix                     eg. Record
	;
	; Expected return:
	;
	; return      = Legal M expression or Null (Void)        eg: $P(vobj(rs),$C(9),2))
	;
	new actual,attrib,expr,formal,litPars,mclass,method,newPtr
	new objectScope,objectVar,rclass,res,return,routine,rwMtd,table,varLevel,z
	;
	new nPrimDes set nPrimDes=$$primDes^UCPRIM(class)
	;
	set method=$P(ref,"(",1),mclass=class
	do addXref("M",class_"."_method,objectName)
	;
	;;set isPrimtyp=$D(primtyp(class))
	set newPtr=$$getNew(objectName,objectLevel)
	;;if $$isRecord(class) set table=$E(class,$L(reClass)+1,$L(class))
	if $$isRecord(class) do
	.	set table=$$getReTable(class) if table="" quit
	.	if '$D(pslTbl(table)) set pslTbl(table)=$$getPslTbl^UCXDD(table,0)
	.	if '$D(fsn(table)) do fsn^SQLDD(.fsn,table)
	;
	; find the method:
	; 1) case sensitive
	; 2) as method syntax for supported M intrinsic
	;    provided class.isPrimitive(), and versionID<7
	;    Number.char() for versionID<7 is ALWAYS translated through mintrnsc
	;    if it contains actuals (Number.char(v2,v3,v4,...))
	; 3) case insensitve
	; 4) in another Primitive class (if class.isPrimitive())
	set rwMtd=$$omGet^UCXOBJ(.pslMtd,class,method,0,.pslCls)
	if %VN<7,(rwMtd="")!((method="char")&(ref'="char()")),nPrimDes=2,$F(funcs,(",$"_$$UPCASE(method))) quit $$mintrnsc(ref,objectName,.class)
	if rwMtd="" set rwMtd=$$omGet^UCXOBJ(.pslMtd,class,method,1,.pslCls)
	if rwMtd="",nPrimDes=2 set rwMtd=$$omTryPrim^UCXOBJ(.pslMtd,class,method,.pslCls)
	if rwMtd="" do ERROR("Undefined method: "_class_"."_method) quit ""
	;
	; NOTE: Hard-coded OBEJECTMETROW references:
	;	CLASS,METHOD,RETURN,PARAMETERS,ROU,VALLIT
	set method=$P(rwMtd,"|",2),rclass=$P(rwMtd,"|",3),formal=$P(rwMtd,"|",4),routine=$P(rwMtd,"|",5)
	;
	; FSCW CR11441:
	; has been generalized to: don't change if the resultclass is ancestor
	;set mclass=class if '(rclass="Object") set class=rclass
	set mclass=class if '$$isAncestor(rclass,class) set class=rclass
	;
	; Switch off object optimization (can switch back on in method)
	if newPtr,'nPrimDes,'$$getOpti(objectName,objectLevel) do setOpti(objectName,objectLevel,msrc+1)
	;
	set objectScope=$$getScope(objectName,.objectLevel)
	;
	; NOTE: Hard-coded OBEJECTMETROW references: VALLIT=6
	if objectScope="LITERAL",nPrimDes=0,'$P(rwMtd,"|",6) do ERROR("Unsupported method under literal scope: "_mclass_"."_method)
	;
	if $D(var) set varLevel=$$getLevel(var)
	;
	; Must distinguish objectVar (shall always by the instancevariable of the object),
	; and its VALUE, which, in case of primitive values, may be optimized at compile time
	set objectVar=objectName
	;
	; NOTE: Hard-coded OBEJECTMETROW references: VALLIT=6
	if nPrimDes>0,$P(rwMtd,"|",6),'fset,'$$isLit(objectName) set objectName=$$toLit(objectName)
	;
	set expr=$E(ref,$L(method)+2,$L(ref)-1),litPars=""
	do valParams(formal,expr,.actual,.attrib,.res,.litPars)
	if ER quit ""
	;
	; FSCW CR18163: The code below is rather tricky, because the value
	; returned in litPars (by valParams()) depends on which parameters are
	; declared LITERAL in OBJECTMET. For example Db.getRecord() requires a
	; literal tablename and a literal keyExpr. However, if keyExpr were
	; declared litral in OBJECTMET, then DB.getRecord("LN","CID=:CID1") and
	; Db.getRecord("LN","CID=:CID2") would end up as different litPars, and
	; thus in different vDb() subroutines.
	if litPars="" set return=""
	else  set return=$G(methods(mclass,method,litPars))	; Default return
	;
	; if the method lives in a Record descendant, then mark this
	; occurrence as a pass-by-value to subroutine
	;
	; NOTE: Hard-coded OBEJECTMETROW.CLASS (=1)
	set z=$P(rwMtd,"|",1)
	if $$isRecord(z),z'=reClass new dummy set dummy=$$insByOvs^UCREC4OP(subRou,objectName,"","U")
	;
	; If no method generation routine specified, generate call based on
	; method declaration
	if routine="" do
	.	;
	.	; return can be derived from method signature
	.	; first get class where method actually lives
	.	;
	.	; NOTE: Hard-coded OBJECTROW.CONSTRUCTOR (=3)
	.	do methodGen($P(pslCls(z),"|",3),rclass'="void")
	.	set litPars=""
	;
	else  do @routine if ER do ERROR($g(RM)) quit ""
	;
	; Reset all property values of this object because they may have been
	; affected by the method call
	do resetProps(objectName)
	;
	if return="" set mcode=$E(mcode,1,$L(mcode)-3) quit ""
	;
	if $E(return,1,2)="$$" do			; Increment use count
	.	;
	.	if litPars'="" set methods(mclass,method,litPars)=$P(return,"(",1)
	.	do incrLabel(return)
	;
	; If valParams() returned result assignments, append the assignments
	; Note that this is very dangerous code, because it assumes that the
	; method is not used as part of an expression
	;;if $G(res)'="" set return=return_res		; Assign to object
	if $G(res)'="" do p1append(res)			; Assign to object
	;
	quit return
	;
	;-----------------------------------------------------------------------
methodDef(rtn,ref,objectName,actual)	; return default runtime call 
	;-----------------------------------------------------------------------
	; Returns ref^rtn(objectName,actual(1),actual(2),...)
	;
	; NOTES:
	; . The caller will have to decide if this is a subroutine call or a
	;	function call (in which case "$$" must be added).
	new na,return
	;
	; Object instance is first parameter, followed by all actuals
	set return=ref_"^"_rtn_"("_objectName
	for na=1:1:$o(actual(""),-1) set return=return_","_actual(na)
	quit return_")"
	;
	;-----------------------------------------------------------------------
methodGen(rtn,bFun)	; private void ; generate default method call 
	;-----------------------------------------------------------------------
	; This subroutine can be specified as method generator in OBJECTMET.ROU
	; when the method follows the default pattern
	;
	; ARGUMENTS:
	; . rtn = name of runtime routine
	; . bFun = 0 (void method) or 1 (method that returns a value)
	;
	; INPUTS:
	; . method = current method
	; . objectName = object instance
	; OUTPUTS:
	; . return
	;	if bFun=0, then $$methodDef(rtn,method,objectName,.actual)
	;	else "$$"_$$methodDef(rtn,method,objectName,.actual)
	;
	set return=$$methodDef(rtn,method,objectName,.actual)
	if bFun set return="$$"_return
	quit
	;
	;-----------------------------------------------------------------------
incrLabel(return)	;private void; Increment reference 
	;-----------------------------------------------------------------------
	; Also called by propRef^UCDBSET
	;
	new label
	set label=$E($P(return,"(",1),3,$L(return))
	if $D(append(label)) set append(label)=$G(append(label))+1
	quit
	;
	;-----------------------------------------------------------------------
decrLabel(call)	;private void; Decrement reference 
	;-----------------------------------------------------------------------
	; Decrement reference to generated label.
	; Optimizing code that replaces a call to subroutine generated in pass 1
	; with a call to a different subroutine, shall call this subroutine.
	; It will decrement the reference count, and delete the append(call,)
	; array if the count reaches zero.
	; The label(call) entry will not be deleted, so labels cannot be re-used
	;
	; ARGUMENTS:
	; . call = label or function call
	;	The supplied value may contain a paramater list and/or the
	;	leading "$$". This function will extract the label.
	;
	new label
	set label=$piece(call,"(")
	if $extract(label,1,2)="$$" set label=$extract(label,3,$length(label))
	;;if $D(append(label)) set append(label)=$get(append(label))-1 if append(label)<1 kill append(label),labels(label)
	if $D(append(label)) set append(label)=$get(append(label))-1 if append(label)<1 kill append(label)
	quit
	;
	;-----------------------------------------------------------------------
ancestor(class)	;private String; Return the immediate ancestor of this class 
	;-----------------------------------------------------------------------
	; INPUTS:
	; . reClass = record class prefix
	; . pslCls() = class descriptor cache
	;
	if class="Object" quit ""			; End of the food-chain
	;
	new return
	;
	if $$isRecord(class),'(class=reClass) do
	.	;
	.	set return=$$getReTable(class)
	.	set return=reClass_$P($G(^DBTBL("SYSDEV",1,return,10)),"|",4)
	;
	; NOTE: hard-coded OBJECTROW.SUPERTYPE (=2) reference
	else  set return=$P($$ocGet^UCXOBJ(.pslCls,class,0),"|",2)
	;
	if return="" set return="Object"		; Ancestor to all
	quit return
	;
	;-----------------------------------------------------------------------
isAncestor(a,b)	;private Boolean; Return a is an ancestor of b 
	;-----------------------------------------------------------------------
	;
	if b="Object" quit 0
	;
	for  set b=$$ancestor(b) quit:(b="")  if (a=b) quit
	quit $T
	;
	;-----------------------------------------------------------------------
mintrnsc(ref,var,cls)	; Intrinsic Primitive methods 
	;-----------------------------------------------------------------------
	; Intrinsic M function, that is not in class hierarchy is entered as
	; method syntax.
	;
	; Provide a warning, except for Number.char() without actuals.
	;
	if $$UPCASE($P(ref,"(",1))="SELECT" do ERROR("Undefined method: "_cls_"."_ref) quit ""
	if (ref'="char")!($P(ref,"(",2)'=")") do warnGroup("FUNCTION","Undefined method: "_cls_"."_ref_", replaced by M $"_method_"() function")
	;
	new return
	;
	set var=$$TOKEN^%ZS(var,.tok)
	set return="$"_$P(ref,"(",1)_"("_var
	if $P(ref,"(",2)'=")" set return=return_","
	set return=return_$P(ref,"(",2,$L(ref))
	;
	quit $$valFun(return,0,,.cls)
	;
	;-----------------------------------------------------------------------
valParams(formal,expr,actual,attrib,res,litpars)	; Validate parameter syntax 
	;-----------------------------------------------------------------------
	; Called by THROW to decompose the Class.new()
	; Called by $$method() to decompose the method's actuallist
	;
	; ARGUMENTS:
	; . String formal = formal parameter declaration list.
	;	This is a comma separated list of formal parameter specifications.
	;	Each specification has one of the following forms:
	;	* var
	;	* type var
	;	* any of the above preceeded by one of the keywords 'literal'
	;		'public' or 'local'
	;	If type is absent, String will be used.
	;	No leading or trailing spaces are allowed.
	;	keyword, type and variable shall be separated by a single space
	; . String expr = expression containing all actual parameters
	; . String actual() = array to receive the individaul actual parameters
	; . String attrib(,) = array to receive actual parameter attributes
	; . String res =					/NOREQ/MECH=REF:W
	; . String litpars = list of literal values		/NOREQ/MECH=REF:W
	;	When supplied the variable will contain a comma separated list
	;	of the actual values of parameters that are declared LITERAL in
	;	the formallist.
	;
	; PUBLICS:
	; . ER = Error indicator, shall be zero on entry, will contain non-zero
	;	value when error encountered during decomposition
	; . tab = TAB character, referenced
	;
	; NOTES:
	; . The use of the keyword LITERAL in the formallist (i.e. as speficied
	;	in OBJECTMET), will impact the behavior of the compiler:
	;	The value of litpars returned by valParams() is used in
	;	$$method() to propose the return value of the method call.
	;
	new atom,bpar,count,ptr
	;
	set bpar=0,count=1,ptr=0,litpars="",res=""
	;
	; Special trick to deal with comma in first position. The trick is
	; needed because
	; - a missing actual will decrement ptr (resulting in ptr=0)
	; - ptr=0 is interpreted as end-of-string
	; By prepending a space, and incrementing ptr, prt=ptr-1 will never end
	; up as ptr=0.
	if $e(expr)="," set expr=" "_expr,ptr=1
	;
	for  set atom=$$nextExpr(expr,.ptr,.tok,1) do  quit:ptr=0!ER
	.	;
	.	; If missing parameter, force call to procPar() and side-effects
	.	; by backing up ptr, and passing atom=""
	.	if 'bpar,atom="," set atom="" set:ptr>0 ptr=ptr-1
	.	;
	.	if atom="," set count=count+1,bpar=0 quit
	.	;
	.	if bpar do ERROR("comma expected") quit
	.	set bpar=1
	.	do procPar(count,$P(formal,",",count),atom,.actual,.attrib)
	.	if ER quit
	.	if $P(attrib(count,0),tab,4)="LITERAL" do
	..		;
	..		new v set v=actual(count)
	..		;;if v="" set v=""""""
	..		if $$isLit(v)!(v="") set litpars=$$addList(.litpars,v)
	..		else  do ERROR("Literal parameter expected: "_$p(formal,",",count))
	.	else  if $D(attrib(count,1)) do
	..		do p1prepend(attrib(count,1))
	..		set res=res_attrib(count,2)
	;
	if ER quit
	;
	; NOTE FSCW:
	; As long as it is impossible to pass-by-reference to methods, the code
	; below is OK. If that is ever going to change, code similar to the code
	; in $$actual() must be used.
	;
	; All parameters are handled, check total number, and provide empty
	; values for all missing parameters.
	set actual=$S(formal="":0,1:$L(formal,","))
	if count=1,actual(1)="" kill actual(1),attrib(1) set count=0
	if count>actual do ERROR("More actual parameters ("_count_") than formal parameters ("_actual_")") quit
	for count=1:1:actual set actual(count)=$G(actual(count))
	quit
	;
	;-----------------------------------------------------------------------
valArr(str,fset)	; Process an array expression 
	;-----------------------------------------------------------------------
	;
	new atom,class,lvn,ptr,return
	;
	set ptr=0
	set lvn=$P(str,"(",1),return=lvn_"("
	set str=$E(str,$L(return)+1,$L(str)-1)
	;
	for  set atom=$$nextExpr(str,.ptr,.tok,1) do  if ptr=0!ER quit
	.	;
	.	if atom="," set return=return_atom quit
	.	if atom[oLvn set return=return_$$UNTOK^%ZS(atom,tok) quit
	.	set atom=$$valExpr(atom,.class,.setVar)
	.	if $$isVar(atom) set atom=$$toLit(atom) ;;if fset=1,$$isVar(atom) do
	.	;;.	;
	.	;;.	new newLevel
	.	;;.	set newLevel=$$getLevel(atom)
	.	;;.	set watch(newLevel,atom,lvn)=""
	.	;
	.	set return=return_atom
	;
	quit return_")"
	;
	;-----------------------------------------------------------------------
condBool(expr)	;private String; Legacy function 
	;-----------------------------------------------------------------------
	; Also called by IF^UCGMC (#IF) and WHILE^UCGMC (#WHILE)
	;
	quit $$condRel(expr)
	;
	;-----------------------------------------------------------------------
condRel(expr)	;local String; Parse relational clauses 
	;-----------------------------------------------------------------------
	quit $$toLit($$valExpr(expr,,.setVar))
	;
	;-----------------------------------------------------------------------
TYPE	; PSL  Command ; Type a variable
	;-----------------------------------------------------------------------
	; The variables scope and type hang around for multiple assignments
	; I don't like it but it's the only way to spread attributes
	; type Public String var1,var2 both get Public String (FRS)
	;
	if ifLevel do ERROR("Type command cannot be conditionally executed") quit
	;
	new atom,curScope,doExpr,killExpr,lvn,varScope
	;
	if '(cmdDel=",") do  if ER do ERROR($g(RM)) quit
	.	;
	.	set type=expr,expr=$$nextExpr(str,.ptr,.tok,1) if ER quit
	.	;
	.	set scope=$$UPCASE(type)
	.	if scope="PUBLIC"!(scope="LITERAL") set type=expr,expr=$$nextExpr(str,.ptr,.tok,1)
	.	else  set scope="NEW"			; Default scope
	;
	if '(type="*"),'$$isClass(.type) do ERROR("Undefined class: "_type) quit
	;
	set atom=$P(expr,"=",1),expr=$P(expr,"=",2,999)
	if $E(atom)="%",$D(keywords(atom)) set atom=$p(keywords(atom),"|",1)
	;
	if cmdDel="," set mcode=mcode_" ",cmdDel=" "
	;
	if '(atom["."),'($$objPtr(atom)=atom) do ERROR("Invalid Object identifier: "_atom) quit
	;
	set lvn=$P(atom,"(",1)
	;
	set curScope=$$getScope(atom,level)		; Get previous scope
	;
	; FSCW CR20280: vosc scope no longer used
	;;if curScope="vosc" set curScope="FORMAL"	; back to original ...
	set varScope=scope				; assume OK
	;
	; The variable is alread defined (???)
	if curScope'="" do  quit:ER
	.	;
	.	; Exclude the following transitions:
	.	; - any to LITERAL
	.	; - LITERAL to any
	.	; - LOCAL to PUBLIC
	.	if (scope="LITERAL")!(curScope="LITERAL"),scope'=curScope do ERROR("SCOPE: cannot change "_atom_" from "_curScope_" to "_scope) quit
	.	if curScope="NEW",scope="PUBLIC" do  quit
	.	.	;
	.	.	; Give a warning that the scope was not changed.
	.	.	; Unfortunately, there are programs out in the field
	.	.	; that use the following code pattern:
	.	.	;	new var
	.	.	;	type public Object var
	.	.	; In this case the class field will be empty (NEW does
	.	.	; not set it). Use that as the indicator.
	.	.	; Because UCREC4OP assumes that the declaration position
	.	.	; matches the current destination line, treat this as a
	.	.	; complete new declaration.
	.	.	; If the class has already been defined, ignore this
	.	.	; redeclaration.
	.	.	do warnGroup("SCOPE","ignored change of "_atom_" from "_curScope_" to "_scope)
	.	.	if $P(type(level,atom),tab)="" set varScope="NEW" quit
	.	.	set varScope="--ignore--"
	.	;
	.	; The variable has already been instantiated (UGH!)
	.	; killObj() may (!) remove type(level,atom), so set curScope=""
	.	; to ensure a new type(,) entry will be created
	.	if curScope'="FORMAL",$$getInst(atom,level) do killObj(atom,.doExpr,.killExpr,level) set curScope=""
	.	;
	.	; FSCW CR11445:
	.	; Temporarily suppress warning when first declaration is FORMAL,
	.	; and second declaration is PUBLIC. The generated code for
	.	; Reference objects, differs with or without the additional
	.	; PUBLIC. This needs to be investigated first
	.	if curScope="FORMAL",scope="PUBLIC",'$$primDes^UCPRIM(type) set $P(type(level,atom),tab,3)="PUBLIC" quit
	.	do warnGroup("SCOPE","Variable declared more than once: "_atom)
	;
	; Check long names (except for LITERALs
	if scope'="LITERAL" do trackNam(atom)
	;
	; If first declaration, or varScope is NEW, create entry in type(,)
	; If scope is NEW, insert NEW statement
	; Note that varScope="--ignore--" can occur here
	if (curScope="")!(varScope="NEW") do
	.	do setScope(atom,"","",varScope,type)
	.	if varScope="NEW" do scope("N",lvn,.doExpr,.killExpr)
	if varScope="PUBLIC" do setInst(atom,"","")
	;
	; No assignment on type statement: done
	if expr="" quit
	;
	; type class identifier=expression
	if '(lvn=atom) do ERROR("Invalid assignment on array: "_expr) quit
	;
	set mcode=mcode_" "
	do SETandTYPE(atom,expr)
	quit
	;
	;-----------------------------------------------------------------------
CATCH	; M++ Command ; Catch a runtime error
	;-----------------------------------------------------------------------
	;
	new class,label,objectName,errType,z
	;
	set class="Error"				; Only supported class
	;;set primtyp(class)=""				; handled by UCPRIM
	;
	set label=$$errTrap(level)
	;
	set mcode=mcode_"N $ZT S $ZT=""D ZX^UCGMR(""_+$O(vobj(""""),-1)_"",""_$ZL_"","""""_label_"^""_$T(+0)_"""""")"""
	;
	set objectName=$P(expr,":",1)
	if objectName="" do ERROR("Object identifier required") quit
	if '$$isVar(objectName) do ERROR("Object identifier must be name") quit
	;
	set errType=$P(expr,":",2,$L(expr))
	;
	if errType'="" do
	.	;
	.	do stackErr(level,.level)
	.	do append(tab_"I $P($ZS,"","",3)'="""_errType_""" X voZT Q",label)
	;
	do append(tab_"N "_objectName_" S "_objectName_"=$ZS",label)
	;
	if expr'=""
	set ptr=ptr+1
	;
	if $E(str,ptr)'=" " do ERROR("Command delimiter expected") quit
	set expr=$$getOpand(str,.ptr)
	;
	if expr'="{" do ERROR("Block initiator expected") quit
	;
	do initBlock
	;
	set ifLevel=0,forLevel=0
	;
	;;do setScop($$objPtr(objectName),level,msrc,"NEW",class)
	;;do setType(objectName,class,level)
	;;do setInst(objectName,msrc,"Class.new")
	do setScope(objectName,"","","NEW",class)
	do setInst(objectName,msrc+1,"Class.new")
	do setOpti(objectName,level,1)
	quit
	;
	;-----------------------------------------------------------------------
stackErr(z,level)	; Save the previous error on the stack 
	;-----------------------------------------------------------------------
	;
	if $P($G(level(z)),tab,3) quit
	set $P(level(z),tab,3)=1			; Already done
	do newLine("N voZT set voZT=$ZT",$P(level(z),tab,2),z)
	quit
	;
	;-----------------------------------------------------------------------
THROW	; PSL Command - Throw a runtime error
	;-----------------------------------------------------------------------
	;
	new i
	;
	; FSCW CR9792: the if-command and its associated code block accept a
	; lot of garbage as valid argument: As long as it looks like method
	; syntax and has 2 actual parameters, the first of which equals the
	; literal "ERROR", it is accepted (e.g. yabba.dabba.doo("Error","blooper"))
	;
	if $$isObj(expr) do
	.	;
	.	new actual,formal,msgnr
	.	;
	.	set expr=$P(expr,"(",2,99),expr=$E(expr,1,$L(expr)-1)
	.	set formal="literal String class,String init"
	.	;
	.	do valParams(formal,expr,.actual) if ER quit
	.	if $$QSUB^%ZS(actual(1))'="Error" do ERROR("Thrown object must be class Error")
	.	;
	.	;;set expr="$ZS=""0,""_$zpos_"",""_"
	.	;
	.	if actual(2)="" do ERROR("Error type parameter is required")
	.	;
	.	; If the Error.type part ($piece(actual(2),",",1)) conforms to
	.	; the layout Error.source_"-"_Error.severity_"-"_Error.ident
	.	; (validated as $length(Error.type,"-")=3), then the
	.	; "messagenumber" piece of $ZS ($P($ZS,",",1)) will be set to
	.	; -1, else it will be set to 0. If actual(2) is not literal,
	.	; code is generated to set the value at runtime. In this case a
	.	; new symbol is allocated to obtain the runtime value of
	.	; actual(2) only once, and the symbol is used in the expression
	.	; that constructs $ZS.
	.	set msgnr=""
	.	if $$isLit(actual(2)) do
	..		if $l($p($$toLit(actual(2)),","),"-")=3 set msgnr=-1
	..		else  set msgnr=0
	.	else  if $e(actual(2))="""" do
	..		;
	..		; Not completely literal. However, if it starts with a
	..		; literal, and the literal part contains a comma, that
	..		; part is sufficient to decide.
	..		new pos
	..		for pos=2:0 set pos=$f(actual(2),"""",pos) quit:'pos  quit:$e(actual(2),pos)'=""""  set pos=pos+1
	..		quit:'pos  quit:$e(actual(2),1,pos-1)'[","
	..		;
	..		; we are lucky, literal part contains a comma
	..		if $l($p($e(actual(2),1,pos-1),","),"-")=3 set msgnr=-1
	..		else  set msgnr=0
	.	if msgnr'="" set expr="$ZS="""_msgnr_",""_$ZPOS_"",""_"_actual(2) quit
	.	new sym set sym=$$nxtSym()
	.	set mcode=mcode_"N "_sym_" "
	.	set expr=sym_"="_actual(2)_",$ZS=($L($P("_sym_","",""),""-"")=3*-1)_"",""_$ZPOS_"",""_"_sym
	;
	else  do
	.	;
	.	if $$getClass(expr)'="Error" do ERROR("Thrown object must be class Error")
	.	; [FRS] Changed class from reference to primitive
	.	set expr="$ZS="_expr
	;
	if ER quit
	;
	; FSCW CR 26334: modified because
	; a) THROW does not accept a post-condition
	; b) Ignoring the remainder of the line is OK, but should be reported
	;;if postCond="" set mcode=mcode_"S "_expr,ptr=0
	;;else  do mapPost set mcode=mcode_"S"_postCond_" "_expr,postCond=""
	if $$checkDead(rec,.ptr) do warnGroup("DEAD","code following throw-statement will never execute")
	set mcode=mcode_"S "_expr
	;
	set mcode=mcode_" X "
	;
	; If the THROW occurs in a CATCH block, generate code that XECUTEs voZT
	; (i.e. previous exception handler), else generate code that XECUTEs $ZT
	for i=level:-1:0 if $P($G(level(i)),tab,1)="CATCH" quit
	set mcode=mcode_$S($T:"vo",1:"$")_"ZT"
	if $T do stackErr(i-1,.level)
	quit
	;
	;-----------------------------------------------------------------------
DO	; M command ; Call a subroutine or block
	;-----------------------------------------------------------------------
	; DO entryref
	;
	if cmdDel="," set mcode=mcode_" "			; For now
	set mcode=mcode_"D"
	;
	new argcond,entref,ep
	set ep=0,argcond=""
	if expr[":" set entref=$$ATOM^%ZS(expr,.ep,":",,1) if ep>0 set argcond=$E(expr,ep+2,$L(expr))
	else  set entref=expr
	;
	if $E(entref)="@" do
	.	;
	.	set entref=$E(entref,2,$L(entref))
	.	set entref=$$valExpr(entref) if ER quit
	.	if $$isLit(entref) set entref=$$QSUB^%ZS(entref)
	.	else  set entref="@"_entref
	;
	if entref="{" do initBlock,ERROR("SYNTAX: Argumentconditional cannot be applied to block"):argcond'="" quit
	;
	set mcode=mcode_postCond_" " if entref="" do ERROR("SYNTAX: Argumentless DO not supported; use DO {") quit
	;
	if $$isObj(entref) do  quit
	.	;
	.	set mcode=mcode_$$valObj(entref,0,"",.class)
	.	if class'="void" do ERROR("MISMATCH: void method expected")
	.	if argcond'="" do ERROR("SYNTAX: Argumentconditional cannot be applied to method call")
	;
	set mcode=mcode_$$actual(entref,.called)
	if argcond'="" set mcode=mcode_":"_$$valExpr(argcond)
	quit
	;
	;-----------------------------------------------------------------------
actual(expr,called,rclass)	;local String; Process actual parameters 
	;-----------------------------------------------------------------------
	;
	new actual,atom,attrib,bpar,byref,cls,count,countmx,lblRec,lvl,lvn,ptr
	new res,return,tag,vars,vsig,z
	;
	if $E(expr)="@" set (return,vsig)=expr,expr=""
	else  set (return,vsig)=$P(expr,"(",1),expr=$E(expr,$L(return)+1,$L(expr))
	;
	if "^"[return do ERROR("Label Expected: "_return_expr) quit ""
	;
	; If the call is to a routine, get its labels
	if $E(vsig,1,2)="$$" set vsig=$E(vsig,3,$L(vsig))
	if $E(vsig)="^" set $P(vsig,"^")=$P(vsig,"^",2)
	set lvl=$$getLabels(.labels,vsig)
	if lvl<2,'$d(labels(vsig)) do
	.	if lvl=0 set lvl=1	; turn off class checking
	.	;
	.	; Don't complain about generated calls / callers
	.	if $$isNamePSL(vsig) quit
	.	if $$isNamePSL(subRou) quit
	.	if return["^" do warnGroup("ACCESS","Subroutine "_return_" not found") quit
	.	do ERROR("Label referenced but not defined: "_return)
	set lblRec=$G(labels(vsig)),countmx=$$getFpCount^UCPSLLR(lblRec),rclass=$p(lblRec,tab,3)
	if lvl=0,return["^",$P(lblRec,tab,2)'>0 do warnGroup("ACCESS","Subroutine "_return_" not accessible")
	;;if lvl>0 do warnGroup("MISMATCH","Unable to validate parameters to "_return)
	;
	; No parameters are passed, so all local variables can be redefined by
	; the called function, invalidate their values.
	if $E(return,1,2)'="$$",expr="",countmx>-1,lvl<2 do warnGroup("MISMATCH","Missing actual parameter list")
	if expr="" do resetType(),callStack(return,subRou) quit return
	;
	if '($E(expr)="("&($E(expr,$L(expr))=")")) do ERROR("Parenthesis expected") quit ""
	;
	set expr=$E(expr,2,$L(expr)-1),return=return_"(",tag=vsig_"("
	;
	set bpar=0,count=$S(expr="":0,1:1),ptr=0,res=""
	;
	; Special trick to deal with comma in first position. The trick is
	; needed because
	; - a missing actual will decrement ptr (resulting in ptr=0)
	; - ptr=0 is interpreted as end-of-string
	; By prepending a space, and incrementing ptr, prt=ptr-1 will never end
	; up as ptr=0.
	if $e(expr)="," set expr=" "_expr,ptr=1
	;
	for  set atom=$$nextExpr(expr,.ptr,.tok,1) do  quit:ptr=0!ER
	.	;
	.	; If missing parameter, force call to procPar() and side-effects
	.	; by backing up ptr, and passing atom=""
	.	if 'bpar,atom="," set atom="" set:ptr>0 ptr=ptr-1
	.	;
	.	if atom="," set bpar=0,count=count+1,return=return_",",tag=tag_"," quit
	.	;
	.	if bpar do ERROR("comma expected") quit
	.	set bpar=1
	.	do procPar(count,$$getFp^UCPSLLR(lblRec,count),atom,.actual,.attrib)
	.	if ER quit
	.	;
	.	if $D(attrib(count,1)) do	; call-by-name remapping
	..		do p1prepend(attrib(count,1))
	..		set res=res_attrib(count,2)
	.	;
	.	set z=$g(attrib(count,0)),vsig=$P(z,tab),cls=$p(z,tab,2),byref=$p(z,tab,3)
	.	set lvn=$p(vsig,"(")
	.	if byref do
	..		; Warn if this reference is duplicate
	..		if $G(vars(lvn)) do warnGroup("MISMATCH","actual parameter already passed-by-name: "_lvn)
	..		set return=return_actual(count)
	.	else  set return=return_actual(count)
	.	if cls'="" set tag=tag_cls_" "_vsig
	.	if lvn'="" set vars(lvn)=byref
	;
	if ER quit ""
	if lvl<2,count>countmx do warnGroup("MISMATCH","More actual parameters ("_count_") than formal parameters ("_countmx_"): "_$P($$toM^UCPSLLR(lblRec)," ;"))
	;
	; Process missing parameters at the end of the list
	; - Step 1: call procPar() to add the parameters
	; - Step 2: strip trailing comma's
	; Note that both steps are needed, because the call to procPar() may add
	; dummies for Reference descendants
	if countmx>count for count=count+1:1:countmx do
	.	do procPar(count,$$getFp^UCPSLLR(lblRec,count),"",.actual,.attrib)
	.	if count>1 set return=return_","
	.	set return=return_actual(count)
	.	set z=$g(attrib(count,0)),vsig=$P(z,tab),cls=$p(z,tab,2)
	.	if cls'="" set vsig=cls_" "_vsig
	.	set tag=tag_","_vsig
	.	if $D(attrib(count,1)) do	; call-by-name remapping
	..		do p1prepend(attrib(count,1))
	..		set res=res_attrib(count,2)
	set return=$$RTCHR^%ZFUNC(return,",")_")",tag=$$RTCHR^%ZFUNC(tag,",")_")"
	if res'="" do p1append(res)
	;
	; FSCW CR13403: Invalidate values assigned to ALL Primitives.
	; Called subroutine may re-use ANY name, even it caller uses pass-by-value!
	; All called parameters are passed with vars(var)=1. This ensures that
	; occurrences of Object.property will be invalidated if Object occurs as
	; actual parameter (either by-reference or by-value!)
	do resetType(.vars),callStack(tag,subRou)
	quit return
	;
	;-----------------------------------------------------------------------
resetType(vars)	; Reset values assigned to Primitives 
	;-----------------------------------------------------------------------
	; This subroutine resets the value of PSLIdentifier.InstExpr for all
	; Primitives, except some passed in vars(), (see below)
	; The vars() array is used to pass names that are to be excluded from the
	; reset, such as actual parameters that are passed by value.
	;
	; Since non-parameter local variables can be redefined by the
	; called function, get all the ones in scope and  set the
	; expression to null (unknown).  Reference identifiers are OK.
	;
	; ARGUMENTS:
	; . Boolean vars() = array of names			/NOREQ/MECH=REF:RW
	;	The subscripts are leftexprs (variables, properties)
	;	vars(leftexpr)=0 if the leftexpr is passed by value
	;	vars(leftexpr)=1 if the leftexpr is passed by reference
	;	This procedure will add all leftexprs that where either reset or
	;	recognized as LITERAL to the array as:
	;	vars(leftexpr)=-1
	;
	; INPUTS:
	; . Number level = current DO level
	; . Number msrc = linenumber of last line of generated code
	; . type(,) = datatype array
	;
	; OUTPUTS:
	; . type(ml,lvn).instExpr = "" for:
	;	* each "primitive" lvn in type(,) that is not LITERAL.
	;	* each property of each object named in vars()
	;	ml = highest NEW-level where lvn was declared (i.e. only the
	;	innermost declaration is affected).
	;
	new class,lvn,scope
	;
	set lvn=""
	for i=level:-1:0 for  set lvn=$O(type(i,lvn)) quit:lvn=""  do
	.	;
	.	if $G(vars(lvn))=-1 quit	; Seen this one before
	.	if lvn[".",'$D(vars($P(lvn,".",1))) quit
	.	set class=$$getClass(lvn,i)
	.	if '(class=""),'$$primVar^UCPRIM(class) quit	; FSCW CR11445: prefer $$primDes
	.	set vars(lvn)=-1		; Protect higher scope (for LITERALS too!)
	.	if $$getScope(lvn,i)="LITERAL" quit
	.	do setInst(lvn,msrc+1,"",i)
	;
	quit
	;
	;-----------------------------------------------------------------------
resetProps(var)	;private void; Reset values assigned to Properties of var 
	;-----------------------------------------------------------------------
	; This subroutine resets the value of PSLIdentifier.InstExpr for all
	; Primitive properties of var.
	;
	; ARGUMENTS:
	; . PSLIdentifier var = object instance name
	;
	; INPUTS:
	; . Number level = current DO level
	; . Number msrc = linenumber of last line of generated code
	; . type(,) = datatype array
	;
	; OUTPUTS:
	; . type(ml,lvn).instExpr = "" for:
	;	* each "primitive" lvn in type(,) that is a property of var, and
	;	  is not LITERAL.
	;
	if '$$isVar(var) quit
	;
	new class,lvl,lvn,scope
	;
	set lvn=var,lvl=$$getLevel(var)
	for  set lvn=$O(type(lvl,lvn)) quit:lvn=""!($P(lvn,".")'=var)  do
	.	;
	.	set class=$$getClass(lvn,lvl)
	.	if '(class=""),'$$primVar^UCPRIM(class) quit	; FSCW CR11445: prefer $$primDes
	.	if $$getScope(lvn,lvl)="LITERAL" quit
	.	do setInst(lvn,msrc+1,"",lvl)
	quit
	;
	;-----------------------------------------------------------------------
procPar(parnum,fpdef,expr,actual,attrib)	; Process a parameter 
	;-----------------------------------------------------------------------
	; Process an actual parameter
	;
	; ARGUMENTS:
	; . Number parnum = parameter number
	;	used as subscript in actual() and attrib(,)
	; . String fpdef = formal parameter definition
	;	If not empty it specifies the access, class, and name of the
	;	formal parameter that maps to the supplied actual parameter
	; . PSLExpression expr = actual parameter
	;	As found in the PSL source code
	; . PSLExpression actual() = individual parameters	/MECH=REFARR:W
	;	Each actual parameter will end up in a separate entry
	;	actual(parnum) = pass 1 expr
	; . String attrib(,) = parameter attributes		/MECH=REFARR:W
	; 	- attrib(parnum,0)=vptr<tab>class<tab>byref<tab>fpscope
	;		This node will exist for each parameter.
	;		If the actual parameter is absent (expr.isNull()), then
	;		the following values will be inserted:
	;		- vptr = ""
	;		- class = class of formal parameter
	;		- byref = 1
	;		- fpscope as usual
	;	- attrib(parnum,1)=pre-call code
	;	- attrib(parnum,2)=post-call code
	;		The nodes will only exist when there is pre-call code
	;		The nodes will contain a complete pass 1 statement,
	;		starting with a space
	;
	new apcls,apsig,apexp,byref,fpcls,fpscope,fpsig,newLevel,z
	;
	; Handle formal parameter specification
	; Assume PUBLIC scope
	set z=$$TRIM^%ZS(fpdef),fpscope="PUBLIC",fpcls="String"
	if $l(z," ")=3 set fpscope=$$UPCASE($p(z," ")),fpcls=$p(z," ",2),fpsig=$p(z," ",3)
	else  do
	.	if z[" " set fpcls=$P(z," ",1),z=$P(z," ",2)
	.	if $$UPCASE(fpcls)="LITERAL" set fpscope="LITERAL",fpcls="String"
	.	if $$UPCASE(fpcls)="LOCAL"   set fpscope="LOCAL",fpcls="String"
	.	if $$UPCASE(fpcls)="PRIVATE" set fpscope="PRIVATE",fpcls="String"
	.	if $$UPCASE(fpcls)="PUBLIC"  set fpscope="PUBLIC",fpcls="String"
	.	set fpsig=$S(z="":"var",1:z)
	;
	; If expr.isNull(), see if this needs a dummy
	; Formally, this is tied to being a Reference descendant. However, the
	; only reason to insert a dummy is to manage vobj(), which reduces the
	; case to '$$primVar^UCPRIM().
	; To limit the scope of the inserted dummy (call may occur in FOR loop!)
	; DECLARE and DISPOSE it on the same line as the call.
	; Insert it as a PUBLIC declaration in type(,) to prevent SCOPE and
	; MISMATCH warnings, but to suppress additional vobj() memory management
	if expr="",'$$primVar^UCPRIM(fpcls),"PRIVATE,PUBLIC"[fpscope do
	.	do warnGroup("MISMATCH","Parameter "_count_": inserted dummy variable for Reference descendant "_fpcls_" "_fpsig)
	.	set expr=$$nxtSym			; allocate symbol
	.	;;set pslNew(subRou)=$$addList(pslNew(subRou),expr)
	.	do setScope(expr,0,"","PUBLIC",fpcls)
	.	set attrib(parnum,1)=" N "_expr
	.	set attrib(parnum,2)=" K vobj(+$G("_expr_"))"
	.	set expr="."_expr			; pass-by-name
	;
	; If still empty, we're done
	if expr="" set actual(parnum)="",attrib(parnum,0)=tab_fpcls_tab_1_tab_fpscope quit
	;
	; Now process the actual parameter
	if $E(expr)=".",$E(expr,2)'?1N set byref=1,expr=$E(expr,2,$L(expr))
	else  set byref=0
	;
	; Validate that byref is allowed, else reset byref
	if byref,fpscope'="PUBLIC" set byref=0 do warnGroup("SCOPE","Reference parameter ."_expr_" not accepted for "_fpscope_" "_fpcls_" "_fpsig)
	;
	; Array syntax - e.g., a(), a(,)
	; but filter lvn.func(), $func(), $$extref and $svn
	;;if $P(expr,".")["(",$E(expr)'="$",$$objPtr($P(expr,"."))=expr do
	if $TR(expr,"%","A")?1A.AN1"(".","1")" do
	.	;
	.	set apexp=$P(expr,"(",1)		; apexp = name
	.	set apcls=$$getClass(expr)
	.	if apcls="" do
	..		set apcls=$$getClass(apexp)	; try unsubscr.
	..		if apcls="" set apcls="String" do setType(expr,apcls)
	.	;
	.	; if byref, then the dot will be added further down anyway
	.	; else we need to force it here because M needs it
	.	; Note that this ensures that the value of byref consistently
	.	; refers to what was specified in the PSL code.
	.	if 'byref set apexp="."_apexp		; force pass-by-name
	else  if byref do				; Passed by reference
	.	;
	.	new instPtr
	.	if $$isObj(expr) do
	..		;
	..		; object.property passed-by-name
	..		; generate new lvn that will be used as actual param.
	..		; generate pre-call code:  SET apexp=<leftval>
	..		; generate post-call code: SET <rightval>=apexp
	..		if postCond'="" do ERROR("Pass-by-name is not supported in post conditional expression: "_expr) quit
	..		set apexp=$$nxtSym
	..		set pslNew(subRou)=$$addList(pslNew(subRou),apexp)
	..		set z=$$valExpr(expr,.apcls)
	..		do setScope(apexp,0,"","NEW",apcls)
	..		set attrib(parnum,1)=" S "_apexp_"="_z
	..		;;do setScope(apexp,0,"","NEW",apcls)
	..		;;do setInst(apexp,msrc+1,z)
	..		set z=$$valObj(expr,1)
	..		if z[$C(31) set attrib(parnum,2)=$P(z,$C(31))_apexp_$p(z,$C(31),2)
	..		else  set attrib(parnum,2)=" S "_z_"="_apexp
	.	else  do
	..		;
	..		; var or var() passed by name
	..		; call varExpr() to deal with subscripts
	..		set apexp=$$varExpr(expr,-1,.apcls)
	..		;
	..		; FSCW CR20280: changed to: "if variable, don't remap"
	..		; if a variable, don't remap if class is primitive
	..		; or if already instantiated
	..		;;if $$isVar(apexp),(instPtr!$$primVar^UCPRIM(apcls)) quit
	..		set instPtr=$$getInst(expr)
	..		;;if $$isVar(apexp),(instPtr!$$primVar^UCPRIM(apcls)) quit
	..		if $$isVar(apexp) quit
	..		if postCond'="" do ERROR("Pass-by-name is not supported in post conditional expression: "_expr) quit
	..		set z=apexp,apexp=$$nxtSym
	..		set pslNew(subRou)=$$addList(pslNew(subRou),apexp)
	..		do setScope(apexp,0,"","NEW",apcls)
	..		set attrib(parnum,1)=" S "_apexp_"=$G("_z_")"
	..		set attrib(parnum,2)=" S "_z_"="_apexp
	.	do setInst(expr,msrc+1,"")		; set to unknown value
	else  do
	.	set apexp=$$valExpr(expr,.apcls)
	.	if apexp'="",'$$isLit(apexp) set apexp=$$toLit(apexp)
	;
	; apexp contains the value to pass as actual parameter (without the dot
	; in case of pass-by-name).
	; apcls contains the class of the actual parameter
	;
	; check if apcls and fpcls are compatible (except if fpdef.isNull())
	set z=$$clsRel^UCCLASS(fpcls,apcls)
	if z=0,fpdef'="" do warnGroup("MISMATCH","Parameter type mismatch- parameter "_parnum_": actual "_apcls_" "_apexp_", formal "_fpcls_" "_fpsig)
	;
	; byref tells if the parameter is passed by value (0) or by name (1)
	if byref set apexp="."_apexp
	set actual(parnum)=apexp
	set attrib(parnum,0)=$$objPtr(expr)_tab_apcls_tab_byref_tab_fpscope
	;
	; For Reference descendants, turn off optimize
	; This is done for subscripted vars as well, even though these are
	; never optimized
	if $$isVar(expr)!$$isArr(expr),'$$primVar^UCPRIM(apcls) do
	.	;
	.	do setOpti(expr,$$getLevel(expr),1) ; Optimize off
	.	;
	.	; OLD: If this is a record object and it hasn't been saved in dbLoad
	.	; NEW: If this is a record object, then
	.	;	if it is passed-by-value insert as INSTANTIATION with
	.	;		empty instExpr (i.e. a "record reference")
	.	;	else note as "instantiated" (setInst() has already been
	.	;		called for byref=1)
	.	;;if $$isRecord(class),'$$getInst(atom,newLevel) do setDb^UCCOLUMN(subRou,atom,,.newLevel)
	.	if $$isRecord(apcls) do
	..		if 'byref new dummy set dummy=$$insByOvs^UCREC4OP(subRou,$$objPtr(expr),"","U")
	..		else  do setAssign^UCREC4OP(subRou,$$objPtr(expr),0)
	quit
	;
	;-----------------------------------------------------------------------
callStack(tag,subRou)	;local void; Build Call stack structure 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . tag = called tag, with label and all actual typed parameters
	; . subRou = calling subroutine
	;
	; INPUTS:
	; . level = current line level
	; . ifLevel = current IF level
	; . lptr = psl source line number
	; . msrc = m source line number
	; . tab = TAB character
	; . ifStack, and doStack (only used if level>0)
	;
	; OUTPUTS:
	; . called(tag,subRou,msrcLineNr) = level, ifLevel, ifStack, doStack, m2srcLineNr
	; . calls(subRou,msrcLineNr,tag) = level, ifLevel, ifStack, doStack, m2srcLineNr
	; . sysmap("C",subRou,msrcLineNr,tag) = parameters
	new params,tagrtn,z
	set z=level_tab_ifLevel
	if level set z=z_tab_ifStack_tab_$P(doStack,".",1,level)
	;
	set $p(z,tab,5)=lptr
	set called(tag,subRou,msrc+1)=z
	set calls(subRou,msrc+1,tag)=z
	;
	set tagrtn=$P(tag,"(",1)
	set params=$P(tag,"(",2)
	set params=$E(params,1,$L(params)-1)
	set sysmap("C",subRou,msrc+1,tagrtn)=params
	quit
	;
	;-----------------------------------------------------------------------
ELSE	; M command ; Process boolean else
	;-----------------------------------------------------------------------
	; The ELSE command is argumentless by definition.
	; So whatever ended up in expr is wrong (our mistake).
	; Complaining about the number of spaces here is MUMPSish.
	;
	;;if '(expr=""),$$isVar(expr),$$isNxtCmd(cmd,expr,.ptr) set expr=""
	if '(expr="") set ptr=ptr-$L(expr),expr=""
	;
	if ifLevel=0 do push^UCPSLST(.pslSt,$$getDcLnr,1,0)
	set ifLevel=ifLevel+1,mcode=mcode_"E "		; Always argumentless
	quit
	;
	;-----------------------------------------------------------------------
WHILE	; M++ command ; While expression
	;-----------------------------------------------------------------------
	;
	new xptr
	;
	; Need to set iterative code indicators first, because all arguments
	; operate under iterative scope.
	if forLevel=0 do push^UCPSLST(.pslSt,$$getDcLnr,1,1)
	set forLevel=forLevel+1
	set ifLevel=ifLevel+1		; FSCW CR11660 - treat similar to IF
	;
	set xptr=ptr
	for  quit:$$nextExpr(str,.ptr,.tok,1)'=","  set expr=expr_"&("_$$nextExpr(str,.ptr,.tok,.1)_")",xptr=ptr
	set ptr=xptr
	;
	set mcode=mcode_"F  "
	set cmd="QUIT"
	set postCond=$$condRel("'("_expr_")")
	set mcode=mcode_"Q:"_postCond_" "
	quit
	;
	;-----------------------------------------------------------------------
FOR	; M command ; For loop
	;-----------------------------------------------------------------------
	;
	if cmdDel="," set mcode=mcode_cmdDel_$$forRange(expr) quit
	;
	if forLevel=0 do push^UCPSLST(.pslSt,$$getDcLnr,1,1)
	set forLevel=forLevel+1
	set ifLevel=ifLevel+1		; FSCW CR11660 - treat similar to IF
	;
	if '(expr=""),$$isVar(expr),$$isNxtCmd(cmd,expr,.ptr) set expr=""
	;
	set mcode=mcode_"F "
	if expr="" quit				; Argumentless
	;
	new newLevel,ptr,var
	;
	set ptr=0
	set var=$$ATOM^%ZS(expr,.ptr,"=",.tok)
	if $E(expr,ptr+1)'="=" do ERROR("Equal sign expected") quit
	;
	set var=$$varExpr(var,1,,.newLevel) if ER quit
	do setInst(var,msrc+1,"",newLevel)
	;
	set expr=$E(expr,ptr+2,$L(expr))
	set mcode=mcode_var_"="_$$forRange(expr)
	quit
	;
	;-----------------------------------------------------------------------
forRange(expr)	;local String; for var=init:increment:end 
	;-----------------------------------------------------------------------
	;
	new atom,argNum,class,ptr,return
	;
	set argNum=0,ptr=0,return=""
	;
	for  set atom=$$ATOM^%ZS(expr,.ptr,":",.tok,1) do  quit:ptr=0!ER
	.	;
	.	if atom=":" set return=return_atom,argNum=argNum+1 quit
	.	if argNum=3 do ERROR("Space character expected") quit
	.	set return=return_$$valExpr(atom,.class)
	.	if '$$primDes^UCPRIM(class) do ERROR("Object invalid in FOR expression") quit
	;
	quit return
	;
	;-----------------------------------------------------------------------
GO	; M command ; GO
	;-----------------------------------------------------------------------
	;
	if level do ERROR("Invalid inside nested structures") quit
	;
	new i,j,z
	;
	for i=level:-1:0 do  quit:ER
	.	;
	.	set j=""
	.	for  set j=$O(type(i,j)) quit:j=""  do
	..		;
	..		set z=$$getClass(j,i)
	..		if $$primDes^UCPRIM(z) quit
	..		if '$G(commands("Options","AllowGOTO")) do ERROR("Goto command is invalid in object scope")
	;
	do warnGroup("DEPRECATED","GO command - use subroutine call")
	set mcode=mcode_"G"_postCond_" "_expr
	quit
	;-----------------------------------------------------------------------
IF	; M command ; If
	;-----------------------------------------------------------------------
	;
	if cmdDel="," set mcode=mcode_cmdDel
	else  set mcode=mcode_"I "
	;
	;mas 7/1/03
	if '(expr="") set expr=$$condRel(expr) if expr=1 set struct(7,subRou)=lptr
	set mcode=mcode_$S(expr="":" ",1:expr)
	; FRS - 06/17/03			; Don't increment ifLevel if Literal
	if '(expr=""),$$isLit(expr) do:'$$QSUB^%ZS(expr) deadCode quit
	if ifLevel=0 do push^UCPSLST(.pslSt,$$getDcLnr,1,0)
	set ifLevel=ifLevel+1
	quit
	;
	;-----------------------------------------------------------------------
deadCode	;local void; Logic test resolved & failed, remove rest of line & code block 
	;-----------------------------------------------------------------------
	;
	do INFO("DEAD","if argument always false; code block not translated")
	do ADD(mcode_" ;*"_$$UNTOK^%ZS(rec,.tok))
	set mcode=""
	;
	new atom,dead
	for  set atom=$$ATOM^%ZS(str,.ptr,";",tok) do  if ptr=0 quit
	.	;
	.	if atom="{"!(atom=";")!($E(atom,1,2)="//") set ptr=0 quit
	.	if $E(atom,1,2)="/*" do blockC 		; Block comment
	;
	if '(atom="{") quit				; No block initiator
	;
	; Read through the source code to find a matching block terminator
	;
	set dead=1					; 'current' level
	;
	for  set lptr=$O(m2src(lptr)) quit:lptr=""  do  if dead=0 quit
	.	;
	.	new tok
	.	set str=$$getLine(lptr),ptr=0
	.	do ADD($$initLine(level)_";*"_str)	; Store as comment
	.	set str=$$TOKEN^%ZS(str,.tok)
	.	for  set atom=$$ATOM^%ZS(str,.ptr,";",tok) do  if ptr=0 quit
	..		;
	..		if atom="}" set dead=dead-1,ptr=0 quit
	..		if atom="{" set dead=dead+1,ptr=0 quit
	..		if (atom=";")!($E(atom,1,2)="//") set ptr=0 quit
	..		if $E(atom,1,2)="/*" do blockC 	; Block comment
	;
	quit
	;
	;
	;-----------------------------------------------------------------------
KILL	; M command ; Kill a variable
	;-----------------------------------------------------------------------
	; NOTES:
	; . Killing part of an array when the array contains Reference objects
	;	will generate incorrect code (a single KILL of the sub-tree, and
	;	no code to delete the affteced vobj() entries).
	;
	if expr="" do ERROR("Argumentless Kill is not supported") quit
	;
	new class,doExpr,killExpr,newLevel
	;
	; FSCW CR14919: 6 lines removed
	; The IF statement below is probably incorrect. It causes a statement like
	;	KILL ARRAY(object.property)
	; to be treated differently from SET var=object.property KILL ARRAY(var).
	; Presumably, the correct phrase is something like
	;	if $$isObj(expr)
	; This suggests that it would be valid to "kill" a property (most likely a
	; property that contains an object). However, the semantics of such a kill
	; are not specified anywhere, and are not obvious (to me).
	;;if expr["." do  quit
	;;.	;
	;;.	set expr=$$valExpr(expr,.class)
	;;.	do killCasc(expr,.doExpr,.killExpr,,class)
	;;.	if $D(doExpr) set mcode=mcode_"D"_postCond_" "_doExpr_" "
	;;.	set mcode=mcode_"K"_postCond_" "_expr
	;
	if "(@"[$E(expr) do  quit	; Good luck
	.	do warnGroup("SCOPE","Reference object scope cannot be maintained for this KILL-argument")
	.	if $E(expr)="@" set mcode=mcode_"K"_postCond_" @"_$$varExpr($E(expr,2,$L(expr)),0) quit
	.	set mcode=mcode_"K"_postCond_" "_$$varExpr(expr,0) quit
	;
	; FSCW CR21158:
	; Calling $$varExpr(,-1,.class) will cause this function to take into
	; consideration that expr may be an unsubscripted variable that is
	; declared as an array of objects. In that case it will return the class
	; of expr() (or whatever the dimension of expr is).
	; Similarly, if the returned class is a Reference descendant that uses
	; vobj(), then KILL expr must behave as if the object goes out of scope,
	; and expr() must be passed to killObj() to achieve this.
	set expr=$$varExpr(expr,-1,.class,.newLevel)
	;
	if '$$primVar^UCPRIM(class) do
	.	new exprSig
	.	set exprSig=expr
	.	if $$isVar(expr) do
	.	.	new sig2
	.	.	set sig2=$O(type(newLevel,expr))
	.	.	if $p(sig2,"(")=expr set exprSig=sig2
	.	do killObj(exprSig,.doExpr,.killExpr,newLevel)
	do scope("K",expr,.doExpr,.killExpr)
	quit
ZBREAK	;
	set mcode=mcode_" ZBREAK "_$$UNTOK^%ZS(expr,.tok)
	quit
ZPRINT	;
	set mcode=mcode_" ZPRINT "_$$UNTOK^%ZS(expr,.tok)
	quit
ZSHOW	;
	set mcode=mcode_" zshow "_$$UNTOK^%ZS(expr,.tok)
	quit
BREAK	;
HANG	;
HALT	;
JOB	;
VIEW	;
ZWITHDRAW	; 
ZWRITE	;
ZMESSAGE	; 
	;
	if expr'="" set expr=$$valExpr(expr) if ER quit
	do buildExpr
	quit
	;
	;-----------------------------------------------------------------------
OPEN	; local ; M command: OPEN device:(par1=val1,par2):timeout
	;-----------------------------------------------------------------------
	;
	; no parameters or timeout
	if expr'[":" set expr=$$valExpr(expr) do buildExpr quit
	;
	new arg,atom,ptr
	set arg=expr
	set ptr=0,atom=$$ATOM^%ZS(arg,.ptr,":",,1)
	;
	; device
	set expr=$$valExpr(atom) if ER quit
	;
	; Looking for device parameters
	if ptr do
	.	set atom=$$ATOM^%ZS(arg,.ptr,":",,1)
	.	if atom'=":" do ERROR("colon expected") quit
	.	set expr=expr_":",atom=$$ATOM^%ZS(arg,.ptr,":",,1)
	.	;
	.	; if not "::", then device paramters are present
	.	if atom'=":" set expr=expr_$$devPars(atom) quit:'ptr  set atom=$$ATOM^%ZS(arg,.ptr,":",,1)
	.	;
	.	; Looking for timeout
	.	if atom'=":" do ERROR("Open timeout expected") quit
	.	set expr=expr_":"_$$valExpr($E(arg,ptr+1,$L(arg)))
	do buildExpr
	quit
	;
	;-----------------------------------------------------------------------
USE	; local ; M command: USE device:(par1=val1:par2)
	;-----------------------------------------------------------------------
CLOSE	; local ; M command: CLOSE device:(par1=val1:par2)
	;-----------------------------------------------------------------------
	;
	if expr'[":" set expr=$$valExpr(expr) do buildExpr quit
	;
	new arg,atom,ptr
	set arg=expr
	set ptr=0,atom=$$ATOM^%ZS(arg,.ptr,":",,1)
	set expr=$$valExpr(atom) if ER quit
	if ptr do
	.	;
	.	; Looking for device parameters
	.	set atom=$$ATOM^%ZS(arg,.ptr,":",,1)
	.	if atom'=":" do ERROR("colon expected") quit
	.	set expr=expr_":"_$$devPars($E(arg,ptr+1,$L(arg)))
	do buildExpr
	quit
	; ======== dead code below
	new atom,newLevel,ptr,var
	if expr'="",expr'[":" do  quit
	.	set expr=$$valExpr(expr) quit:ER
	.	do buildExpr
	set ptr=0
	set mcode=mcode_cmd_postCond_" "
	;
	if "!#?"[$E(expr) set mcode=mcode_expr quit
	;
	set atom=$$ATOM^%ZS(expr,.ptr,":",tok)
	;
	if atom?.N set mcode=mcode_atom
	else  do
	.	do assign(.atom,0,.xtype,postCond) if ER quit
	.	do setInst(atom,msrc+1,"",newLevel)		; Unknown
	.	set mcode=mcode_atom
	;
	if ptr do			; Looking for read x#length:timeout
	.	;
	.	set atom=$$ATOM^%ZS(expr,.ptr,":#",tok)
	.	if '(":#"[atom) do ERROR("Write length or timeout expected") quit
	.	set mcode=mcode_atom
	.	set atom=$$ATOM^%ZS(expr,.ptr,":#",tok)
	.	set mcode=mcode_atom
	;
	if ptr do			; Looking for read x:timeput
	.	;
	.	set atom=$$ATOM^%ZS(expr,.ptr,":",tok)
	.	if '(":"[atom) do ERROR("Write timeout expected") quit
	.	set mcode=mcode_atom
	.	set atom=$$ATOM^%ZS(expr,.ptr,":",tok)
	.	set mcode=mcode_$$valExpr(atom)
	;
	quit
	;
	;-----------------------------------------------------------------------
devPars(expr)	; local ; Parse device parameters: (par1=val1:par2) 
	;-----------------------------------------------------------------------
	;
	new atom,par,ptr,return
	if $E(expr)="(",$E(expr,$L(expr))=")" quit "("_$$devPars($E(expr,2,$L(expr)-1))_")"
	;
	set ptr=0,return=""
	for  set atom=$$ATOM^%ZS(expr,.ptr,":",,1) do   quit:'ptr
	.	if atom=":" set return=return_atom quit
	.	set par=$p(atom,"="),return=return_par
	.	if atom["=" set return=return_"="_$$valExpr($E(atom,$F(atom,"="),$L(atom)))
	quit return
	;
	;-----------------------------------------------------------------------
WRITE	; M command ; Write a String
	;-----------------------------------------------------------------------
	if expr["?" set expr=$P(expr,"?",1)_"?"_$$valExpr($P(expr,"?",2,$L(expr)))
	else  if '(expr=""),'("!#?"[$E(expr)) set expr=$$valExpr(expr)
	do buildExpr
	quit
	;
	;-----------------------------------------------------------------------
READ	; M command ; Read A string
	;-----------------------------------------------------------------------
	;
	do warnGroup("READ","Restricted command")
	;
	new atom,newLevel,ptr,var
	set ptr=0
	;
	if cmdDel'=" " set mcode=mcode_cmdDel
	else  set mcode=mcode_cmd_postCond_" "
	;
	if "!#?"[$E(expr) set mcode=mcode_expr quit
	;
	if $E(expr,1)="*" set mcode=mcode_"*",expr=$e(expr,2,$L(expr))
	;
	set atom=$$ATOM^%ZS(expr,.ptr,":#",tok)
	;
	if $$isLit(atom) set mcode=mcode_atom quit
	;
	set atom=$$varExpr(atom,1,,.newLevel) if ER quit
	do setInst(atom,msrc+1,"",newLevel)		; Unknown
	;
	set mcode=mcode_atom
	;
	if ptr do			; Looking for read x#length:timeout
	.	;
	.	set atom=$$ATOM^%ZS(expr,.ptr,":#",tok)
	.	if '(":#"[atom) do ERROR("Read length or timeout expected") quit
	.	set mcode=mcode_atom
	.	set atom=$$ATOM^%ZS(expr,.ptr,":#",tok)
	.	set mcode=mcode_$$valExpr(atom)
	if ptr do			; Looking for read x:timeput
	.	;
	.	set atom=$$ATOM^%ZS(expr,.ptr,":",tok)
	.	if '(":"[atom) do ERROR("Read timeout expected") quit
	.	set mcode=mcode_atom
	.	set atom=$$ATOM^%ZS(expr,.ptr,":",tok)
	.	set mcode=mcode_$$valExpr(atom)
	;
	quit
	;
	;-----------------------------------------------------------------------
XECUTE	; M command ; Execute a string
	;-----------------------------------------------------------------------
	;
	new nexpr
	set nexpr=$$valExpr(expr) if ER quit
	set nexpr=$$toLit(nexpr)
	;
	; FSCW CR22957:
	; The code below is questionable, because it inserts the
	; contents of the XECUTE statement into the PSL source line,
	; instead of in the M target code (mcode). As a result, the
	; contents of the XECUTE argument will be interpreted as PSL
	; code, whereas the programmer anticipated M code.
	; In addition it assumes that PSL is a superset of M, which is
	; not true either.
	; Furthermore, if the programmer went through all the hasle of coding
	; a PSL XECUTE statement, including the #ACCEPT, that turns out to be a
	; literal, then there is probably a good reason to do so.
	;;if $$isLit(nexpr),postCond="" do  quit
	;;.	if ptr=0 set ptr=$L(rec)		; Only command on line
	;;.	set nexpr=$$QSUB^%ZS(nexpr)
	;;.	set nexpr=$$TOKEN^%ZS(nexpr,.tok)
	;;.	;
	;;.	new eptr
	;;.	set eptr=ptr
	;;.	for ptr=ptr-$L(expr)-1:-1:1 quit:$E(rec,ptr)=" "
	;;.	set rec=$E(rec,1,ptr)_nexpr_$E(rec,eptr+1,$L(rec))
	;;.	if cmdNum>1 set mcode=$E(mcode,1,$L(mcode)-1)
	;;.	set cmdNum=cmdNum-1
	;
	set expr=$$UNTOK^%ZS(nexpr,tok)
	do buildExpr,resetType()
	do warnGroup("XECUTE","Restricted command - runtime Xecute")
	quit
	;
	;-----------------------------------------------------------------------
buildExpr	;local void; Build command expression 
	;-----------------------------------------------------------------------
	;
	if '(cmdDel=",") do
	.	;;if $e(mcode,$l(mcode)-2,$L(mcode)-1)=(" "_$E(cmd)) set mcode=$E(mcode,1,$l(mcode)-2)
	.	set mcode=mcode_cmd_postCond
	set mcode=mcode_cmdDel_expr
	quit
	;
	;-----------------------------------------------------------------------
TSTART	; M command ; Start a transaction
	;-----------------------------------------------------------------------
	;
	do warnGroup("DEPRECATED","TSTART command - use Runtime.start")
	set expr=$$UNTOK^%ZS(expr,.tok)		; Take it like it is
	new actual,data
	set actual(1)=$p($p(expr,":",2),"=",2)
	if actual(1)="" set actual(1)="""CS"""
	set actual(2)=$P($P($p(expr,":",1),")",1),"(",2)
	set actual(3)=""
	set mcode=mcode_" D "
	do start^UCRUNTIM
	set mcode=mcode_return
	quit
	;
TCOMMIT	; 
	do warnGroup("DEPRECATED","TCOMMIT command - use Runtime.commit")
	new actual
	set actual(1)=""
	set mcode=mcode_" D "
	do commit^UCRUNTIM
	set mcode=mcode_return
	quit
TROLLBACK	; 
	do warnGroup("DEPRECATED","TROLLBACK command - use Runtime.rollback")
	new actual
	set actual(1)=""
	set actual(2)=""
	set mcode=mcode_" D "
	do rollback^UCRUNTIM
	set mcode=mcode_return
	quit
	;
	;-----------------------------------------------------------------------
LOCK	; M command ; Lock a reference
	;-----------------------------------------------------------------------
	;
	new ptr
	set ptr=0
	set mcode=mcode_cmd_postCond_" "
	if expr="" quit				; Argumentless Lock
	if "+-"[$E(expr) set mcode=mcode_$E(expr),expr=$E(expr,2,$L(expr))
	set mcode=mcode_$$varExpr($$ATOM^%ZS(expr,.ptr,":",tok),0)
	if ptr set mcode=mcode_":"_$$valExpr($E(expr,ptr+2,$L(expr)))
	quit
	;
	;-----------------------------------------------------------------------
NEW	; M command ; Scope local variable
	;-----------------------------------------------------------------------
	;
	if $E(expr)="(" do ERROR("Exclusive new's are not allowed: "_expr) quit
	if $E(expr)="%",$D(keywords(expr)) set expr=$p(keywords(expr),"|",1)
	;
	if $$isVar(expr)
	else  if $$UPCASE(expr)="$ZT"
	else  do ERROR("Variable expected: "_expr) quit
	;
	if ifLevel do warnGroup("DEPRECATED",": NEW in conditional code cannot be upgraded to TYPE")
	;
	new class,doExpr,killExpr
	;
	set class=$$getClass(expr)
	if '(class=""),'$$primVar^UCPRIM(class) do
	.	;
	.	if $$getScope(expr,level)="NEW" do killObj(expr,.doExpr,.killExpr,.level)
	.	kill type(level,expr)
	;
	;;do setScop(expr,level,msrc+1,"NEW")
	do setScope(expr,"","","NEW","")
	do scope("N",expr,.doExpr,.killExpr)
	;
	quit
	;
	;-----------------------------------------------------------------------
QUIT	; M command ; Quit from current block
	;-----------------------------------------------------------------------
	;
	if forLevel do  quit
	.	;
	.	if expr'="" do ERROR("Unexpected return expression in for loop") quit
	.	set mcode=mcode_"Q"_postCond_" "
	;
	if expr'="" do
	.	;
	.	if $$isVar(expr)!($$isArr(expr)) do
	..		;
	..		; If varname matches command word, and is not declared,
	..		; treat is as the next command instead of the quitarg.
	..		new newLevel,newScope
	..		set newScope=$$getScope(expr,.newLevel)
	..		if newScope="",$$isNxtCmd(cmd,expr,.ptr) set expr="" quit
	..		set expr=$$varExpr(expr,0,,.newLevel)
	..		;
	..		; turn off optimization
	..		do setOpti(expr,newLevel,-1)
	..		;
	..		; If LITERAL, need to substitute here
	..		if newScope="LITERAL" set expr=$$getExpr(expr,newLevel)
	.	;
	.	else  set expr=$$condRel(expr)
	.	;
	.	if expr[oLvn!$$hasPatch^UCPATCH(expr)!$$hasWrap^UCREC4OP(expr) do	; Object in expr
	..		set pslNew(subRou)=$$addList(pslNew(subRou),"vret")
	..		set mcode=mcode_"S vret="_expr_" "
	..		set expr="vret"
	.	;
	.	; if quit is extrinsic call and it has object in the call
	.	; wait until after the call to kill the object.
	.	; FSCW CR22719:
	.	; The above is an underestimation of the potential cases: The
	.	; extrinsic can be part of the epression (eg $$EXT(P1,P2)+V), or
	.	; the object reference may be hidden in a nested value
	.	; expression (eg. $$EXT(P1,$$VAL(O2))
	.	if $$isExt(expr) do
	..              new atom,class,params,ptr
	..		set ptr=0,params=$P($E(expr,1,$L(expr)-1),"(",2,999) if params="" quit
	..		for  set atom=$$ATOM^%ZS(params,.ptr,",",tok) do  if ptr<1 quit
	...			if $e(atom)="." set atom=$e(atom,2,$L(atom))
	...			if $$getScope(atom,level)'="NEW" quit
	...			if $$isVar(atom),'$$primVar^UCPRIM($$getClass(atom)) set ptr=-1
	..              ;
	..              if ptr=-1 set pslNew(subRou)=$$addList(pslNew(subRou),"vret"),mcode=mcode_"S vret="_expr_" ",expr="vret"
	.	;
	.	; If there is code to append to the command, make sure it occurs
	.	; after the argument evaluation, but before the QUIT.
	.	if pslP1Ap'="" do
	..		if expr'="vret" set pslNew(subRou)=$$addList(pslNew(subRou),"vret"),mcode=mcode_"S vret="_expr_" ",expr="vret"
	..		set mcode=$E(mcode,1,$L(mcode)-1)_pslP1Ap_" ",pslP1Ap=""
	;
	new doExpr,except,fpKill,killExpr,mask,scope,var
	;
	set (mask,var)=""
	;
	set except=$S($$isVar(expr):expr,$$isArr(expr):expr,1:"")
	;
	for  set var=$O(type(level,var)) quit:var=""  do
	.	;
	.	set scope=$$getScope(var,level)
	.	if var["(",var'=$$objPtr(var) quit	; skip individual nodes
	.	if var["." quit				; skip individual props
	.	if (scope="NEW") do killObj(var,.doExpr,.killExpr,.level,.except,.mask,.scope) quit
	.	;
	.	; FSCW CR20280: vosc scope no longer used
	.	;;if (scope?1"vosc".N) do		; Logic for formal>actual
	.	;;.	;
	.	;;.	new xd,xk
	.	;;.	do killObj(var,.xd,.xk,.level,.except,.mask,.scope)
	.	;;.	if $D(xk) set fpKill("K",scope)=xk
	.	;;.	else  if $D(xd) set fpKill("D",scope)=xd
	;
	if $D(fpKill) do			; Add formal parameter conditional kill
	.	;
	.	if '(postCond="") do mapPost	; FRS - 06/13/03
	.	;
	.	new cmd,var,expr
	.	set (cmd,var)=""
	.	for  set cmd=$O(fpKill(cmd)) quit:cmd=""  for  set var=$O(fpKill(cmd,var)) quit:var=""  do
	..		;
	..		if postCond="" set expr=cmd_":"_var
	..		else   set expr=cmd_postCond_"&"_var
	..		set mcode=mcode_expr_" "_fpKill(cmd,var)_" "
	;
	if ifLevel=0,postCond="" do
	.	;
	.	kill type(level),errTrap(level),reset(level)
	.	if level=0 set subRou=""
	;
	do scope("Q",expr,.doExpr,.killExpr)
	quit
	;
	;-----------------------------------------------------------------------
scope(cmd,expr,doExpr,killExpr)	; Add object scope management logic 
	;-----------------------------------------------------------------------
	;
	if '$D(doExpr),'$D(killExpr) do buildExpr quit
	;
	set cmdDel=" "
	;
	if postCond'="" do mapPost
	;
	if $D(doExpr) set mcode=mcode_"D"_postCond_" "_doExpr_" "
	;
	if $D(killExpr) set mcode=mcode_"K"_postCond_" "_killExpr_" "
	;
	do buildExpr
	quit
	;
	;-----------------------------------------------------------------------
impQuit(level)	;local void; Implied Quit at end of routine do stack reduction 
	;-----------------------------------------------------------------------
	;
	new cmd,cmdDel,expr,forLevel,ifLevel,mcode,postCond
	set cmd="",cmdDel="",expr="",mcode="",postCond=""
	set forLevel=0,ifLevel=0
	if level>0 do warnGroup("SYNTAX","Missing block terminator at end of: "_subRou)
	if level=0 do warnGroup("SYNTAX","Added quit from "_subRou)
	;
	do QUIT
	;
	if $TR(mcode,$C(9,32))'="" do ADD($$initLine(level)_mcode)
	quit
	;
	;-----------------------------------------------------------------------
SET	; M command ; Process the set command
	;-----------------------------------------------------------------------
	; The generated code will contain a separate SET command for each SET
	; argument. This is essentially used to support property-assignment
	; methods.
	;	;
	if cmdDel="," set mcode=mcode_" "
	;;set mcode=mcode_"S"_postCond_" "
	;
	new ptr
	set ptr=0
	set atom=$$ATOM^%ZS(expr,.ptr,"=",tok)
	if ER do ERROR($g(RM)) quit
	;
	if $E(expr,ptr+1)'="=" do ERROR("Equal sign expected") quit
	set expr=$E(expr,ptr+2,$L(expr))
	do SETandTYPE(atom,expr)
	quit
	;
	;-----------------------------------------------------------------------
SETandTYPE(atom,expr)	;local void ; generate code for assignment in SET / TYPE 
	;-----------------------------------------------------------------------
	; The generated code will contain a separate SET command for each SET
	; argument. This is essentially used to support property-assignment
	; methods.
	;
	; ARGUMENTS:
	; . atom = leftexpr
	;	Every construct that is allowed in an M assignment is allowed:
	;	single variable, variable indirection, function, list of vars.
	;	If any of these possibiliites is invalid in the context of the
	;	call, it is the callers responsibility to check this.
	; . expr = rightexpr
	;	Arbitrary PSL expression
	;
	; INPUTS:
	; . mcode = line of mcode under construction
	;	The M command word "S" will be appended directly to the supplied
	;	value, so it shall contain the space that separates it from the
	;	previous command (or the label, or linestart).
	; . postCond = postcondition to be appended to command word
	;	passed to assign(), and appended to DO when struct("setProperty")
	;	transforms SET into DO.
	; . xtype = ?
	;	Not used, passed to assign().
	;
	; VARIABLES:
	; . struct("setProperty") = property assignment procedure
	;	When this variable is defined after returning from assign(), then
	;	the assignent will be generated as a DO setProp(atom,expr)
	;	instead of a SET atom=expr. No assumptions are made with repect
	;	to the 'atom' that will occur as the first argument in the call.
	;	In particular, object optimization shall be handled by the code
	;	that created the struct("setProperty") node.
	;	The variable will be killed before assign() is called to ensure
	;	there are no leftovers from previous calls.
	;
	; NOTES:
	; . The setProperty logic cannot be used in group sets.
	;
	new cmd set cmd="S"
	set mcode=mcode_"S"_postCond_" "
	kill struct("setProperty")
	;
	if $E(atom)="@" do
	.	;
	.	new expr
	.	set atom=$E(atom,2,$L(atom))
	.	set expr=$$toLit(atom,.tok)
	.	if $$isLit(expr) set atom=$$QSUB^%ZS(expr)
	.	;
	.	; FSCW CR11445: If assignment through indirection,
	.	; invalidate previous assignments to Primitives
	.	; Doing the invalidate here is slightly too early. A better
	.	; Place would be in assign() or varExpr(), but that does not
	.	; work because the indrection character is already stripped.
	.	else  set mcode=mcode_"@" do resetType()
	;
	if $E(atom)="(" do  quit			; set (v1,v2,vn)=val
	.	;
	.	if $E(atom,$L(atom))'=")" do ERROR("Parenthesis expected") quit
	.	;
	.	new atoms,ptr,savatom,savexpr
	.	set atoms=$E(atom,2,$L(atom)-1),ptr=0
	.	if atoms="" do ERROR("Expression expected") quit
	.	set mcode=mcode_"(",savexpr=""
	.	;
	.	for  set atom=$$ATOM^%ZS(atoms,.ptr,",",.tok) do  quit:ptr=0!ER
	..		;
	..		if atom="," set mcode=mcode_atom quit
	..		;
	..		set savatom=atom
	..		do assign(.atom,.expr,.xtype,postCond)
	..		;
	..		if $$getScope(atom)="LITERAL" do ERROR("Literal scope not allowed in group set: "_atom) quit
	..		if $E(atom)="$" do ERROR("Expression not allowed in group set: "_savatom) quit
	..		if $D(struct("setProperty")) do ERROR("Property cannot be assigned in group set: "_savatom) quit
	..		if $$isWrap^UCREC4OP(atom) do ERROR("Column cannot be assigned in group set: "_savatom) quit
	..		;
	..		if savexpr="" set savexpr=expr		; Save first one
	..		else  do setInst(atom,msrc+1,savexpr)
	..		;
	..		set mcode=mcode_atom
	..		set expr=savatom			; Assign to prior
	.	;
	.	set mcode=mcode_")="_savexpr
	;
	do assign(.atom,.expr,.xtype,postCond)
	if atom[$C(31) set mcode=$$backup(mcode)_$P(atom,$C(31))_expr_$p(atom,$C(31),2) quit
	;
	if $$getScope(atom)="LITERAL" set mcode=$$SetLit^UCGMC(mcode,atom,expr)
	else  if atom=expr do
	.	set mcode=$$backup(mcode) do INFO("DEAD","no code generated for SET "_$$UNTOK^%ZS(atom_"="_expr,tok))
	else  if $D(struct("setProperty")) do
	.	;
	.	set mcode=$$backup^UCGM(mcode)_" D"_postCond_" "_struct("setProperty")_"("_atom_","_expr_")"
	.	kill struct("setProperty")
	else  set mcode=mcode_atom_"="_expr
	quit
	;
	;-----------------------------------------------------------------------
assign(var,expr,xtype,postCond)	;local void; Return M assignment expression 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . var = leftexpr (variable, property, or setpiece)	/REQ/MECH=REF:RW
	; . expr = rightexpr (value to be assigned)		/REQ/MECH=REF:RW
	; . xtype = ???
	; . postCond = ???
	;
	new class,eclass,i,ifFlag,newLevel,objVar,pslexpr,pslvar,scope
	;
	set pslexpr=expr,pslvar=var
	;
	; If the assignment is to an object property of a Primitive class (or
	; to the "object method" String.piece(sep,from,to)), then the value of
	; the instantiation expression of that variable (setVar) must be cleared.
	if $$isObj(var) do
	.	set var=$$valObj(var,1,.objVar,.class)
	.	if pslvar'=objVar,$$primDes^UCPRIM($$getClass(objVar)) do setInst(objVar,msrc+1,"")
	.	set newLevel=$$getLevel(var)
	.	do setType(pslvar,class)
	;
	else  if $$isFun(var) do
	.	set var=$$valFun(var,1,.objVar,.class)
	.	if var'=objVar,$$isVar(objVar)!$$isArr(objVar),$$primDes^UCPRIM(class) do setInst(objVar,msrc+1,"")
	else  set var=$$varExpr(var,1,.class,.newLevel)
	;
	if ER quit
	;
	if expr["%EffectiveDate",$G(commands("Options","$GetEFD")) set expr=$$CVTEFD(expr)
	;
	set expr=$$valExpr(pslexpr,.eclass,var)
	if expr="" do setInst(pslvar,msrc+1,"") quit
	;
	if eclass="" do ERROR("Expression must return a class: "_pslexpr) quit
	if class="*" set class=eclass do setType(pslvar,class)
	;
	; Note that the code below will NOT catch rec.col=rec.col because the
	; var on the left will be a wrapped column assignment expression with
	; $C(31) as placeholder for expr.
	;
	if var=expr quit			; Symmetrical: a=a or a={}a
	;
	if '$$primVar^UCPRIM(class) do
	.	;
	.	set scope=$$getScope(pslvar,.newLevel)
	.	if forLevel
	.	else  if '(scope="NEW"!(scope="LITERAL"))
	.	else  if $$getInst(pslvar,.newLevel)
	.	else  if newLevel<level,$E(forStack,newLevel,level)
	.	;
	.	if  do checkInst(pslvar,class,.newLevel)
	.	;
	.	; FSCW CR22274: Warn if leftexpr has PUBLIC scope
	.	if scope="PUBLIC" do warnGroup("SCOPE","Assignment to PUBLIC variable: "_pslvar)
	.	;
	.	; FSCW CR16339:
	.	; If assignment is to typecasted other object, treat the leftexpr
	.	; as a PUBLIC variable so it will not delete the object when it
	.	; goes out-of-scope, and turn off optimization of the rightexpr
	.	; so both "views" of the object will be in sync.
	.	; NB: One could argue that this shall apply to ALL assignments
	.	; that follow the pattern: obj2=obj1 (for non-primitive objects).
	.	; However by that time it may be worth to introduce a new scope
	.	; type for this (eg CAST).
	.	; NB2: An additional requirement might be that the scope of the
	.	; leftvar is "narrower" than the scope of the rightvar (assuming
	.	; the order PUBLIC>FORMAL>NEW:0>NEW:lvl).
	.	new expLevel
	.	if $E(pslexpr)="{",scope="NEW" do
	..		new cast set cast=$E(pslexpr,$f(pslexpr,"}"),$l(pslexpr))
	..		if '$$isVar(cast) quit
	..		if cast=pslvar quit
	..		;;do updScope(pslvar,"PUBLIC")
	..		do setOpti(cast,$$getLevel(cast),1)
	..		do setOpti(pslvar,newLevel,1)
	.	;
	.	if '$$isVar(expr),'$$isArr(expr) quit
	.	;
	.	; FSCW CR22274
	.	; If scope of rightvar is PUBLIC, then turn off optimization of
	.	; leftvar.
	.	if $$getScope(expr,.expLevel)="PUBLIC" do setOpti(pslvar,newLevel,1)
	.	if $$getInst(expr,expLevel) do		; Multiple identifiers
	..		;
	..		if $$isArr(pslvar) do ERROR("Multiple identifier not supported: "_pslvar) quit
	..		set xtype(newLevel,pslvar,expr)="",xtype(expLevel,expr,pslvar)=""
	;
	if ER quit
	;
	if '(expr=pslexpr) do
	.	;
	.	if $$isLit(expr) set pslexpr=expr quit
	.	if pslexpr[$C(0) set pslexpr=$$UNTOK^%ZS(pslexpr,tok)
	;
	if '(postCond="") set pslexpr=""
	do setInst(pslvar,msrc+1,pslexpr,,expr)
	if $$isArr(pslvar) do setInst($$objPtr(pslvar),msrc+1,"")
	;
	if class=eclass quit
	if $$primDes^UCPRIM(class),$$primDes^UCPRIM(eclass) quit	; Primitives are compatible for now
	if $$isAncestor(class,eclass) quit		; Class is ancestor OK
	if $$isAncestor(eclass,class) quit		; Needs error checking
	;
	; If types are different, try an implicit RightClass.toLeftClass() method
	if $$isRecord(class) set class="Record"
	new fset set fset=0
	new mthd set mthd="to"_class_"()"
	new des set des=$$omGet^UCXOBJ(.pslMtd,eclass,mthd,0)
	if des="",$$primDes^UCPRIM(class) set mthd="toString()"
	set class=eclass
	set expr=$$method(expr,$$getLevel(expr),mthd,.type,.class,pslvar)
	do warnGroup("MISMATCH","Type: ."_mthd_" appended for assignment of "_eclass_" to "_class)
	quit
	;
	;-----------------------------------------------------------------------
autoERRM()	; private void;  simulate ER/RM declaration in type(,) 
	;-----------------------------------------------------------------------
	;
	; INPUTS:
	; - level = current DO-level
	; - type(,) = type array
	;
	; OUTPUTS:
	; - if type(,"ER") of type(,"RM") defined, the instExpr will have been
	;	reset to ""
	;
	if '$GET(commands("Options","AutoPublicERRM")) quit
	new j,lvn
	for lvn="ER","RM" for j=level:-1:0 if $DATA(type(j,lvn)) do setInst(lvn,msrc+1,"",j) quit
	quit
	;
	;-----------------------------------------------------------------------
checkDead(code,ptr)	;local Boolean; check if code contains dead code 
	;-----------------------------------------------------------------------
	; Check if code contains dead code to the left of ptr.
	;
	; INPUTS:
	; - code = PSL source code
	; - ptr = rightmost character that has already been interpreted
	;
	; RETURNS
	; . if $$ = 1, then ptr = 0
	;
	if ptr new tail set tail=$EXTRACT(code,ptr+1,$LENGTH(code)) if $PIECE(tail,"//")?." "'!($PIECE(tail,"/*")?." ") set ptr=0 quit 1
	quit 0
	;
	;-----------------------------------------------------------------------
checkInst(atom,class,newLevel)	;local void; Delete existing object if instantiated 
	;-----------------------------------------------------------------------
	;
	; INPUTS:
	; - mcode = M code under construction
	; - pslvar
	;	used to check if line already contains IF '$GET(pslvar)
	; - tok = String literals
	;	Note that this assumes that the lirerals are always in tok.
	;	The call to $$UNTOK^%ZS is needed because atom may be a
	;	subscripted variable with string literals in the subscripts.
	;
	if mcode["I '$G("_pslvar_")" quit
	;
	new doExpr,expr,killExpr
	;
	do killCasc(atom,.doExpr,.killExpr,newLevel,class)
	;
	set mcode=$$backup(mcode)_" "
	;
	if $D(doExpr) set mcode=mcode_"D "_doExpr_" "
	;
	set expr=oLvn_"(+$G("_$$UNTOK^%ZS(atom,.tok)_"))"
	;
	; FSCW CR14569: $$patch^UCPATCH() called independent of $$getOpti
	; FSCW CR18163: and independent of $$getInst() because all KILLs shall
	;	be replaced if the instance is optimized.
	;;if $$getInst(atom,newLevel),'$$getOpti(atom,newLevel) set expr=$$patch^UCPATCH(subRou,atom,newLevel,expr)
	set expr=$$patch^UCPATCH(subRou,atom,newLevel,expr)
	set mcode=mcode_"K "_expr_" "
	;
	if $D(killExpr) set mcode=mcode_"K "_killExpr_" "
	set mcode=mcode_"S "
	quit
	;
	;-----------------------------------------------------------------------
setOpti(var,newLevel,integer)	;private void; Set the optimization of an object 
	;-----------------------------------------------------------------------
	; Note that a non-zero value prevents optimization.
	;
	new vptr
	set vptr=var if vptr["(" set vptr=$$objPtr(vptr)
	;
	set $P(type(newLevel,vptr),tab,10)=integer
	set patch(0,subRou,vptr,$$getNew(vptr))=type(newLevel,vptr)
	if $$isRecord($P(type(newLevel,vptr),tab)) do setNeedVobj^UCREC4OP(subRou,vptr,''integer)
	quit
	;
	;-----------------------------------------------------------------------
setScope(var,decLvl,decPos,scope,class)	;private void; Declare an object 
	;-----------------------------------------------------------------------
	; Each declaration in the type(,) array requires a scope and a class.
	; Both will be assigned once per declaration.
	; This subroutine will unconditionally assign type(decLvl,var). It is
	; the caller's responsibility to ensure that duplicate declarations are
	; acceptable or prevented.
	;
	; ARGUMENTS:
	; . var = variable signature
	;	Either name (for unsubscripted variables) or name(,,,) for the
	;	declaration of an array.
	; . decLvl = declaration level, one of:
	;	- "" to indicate the current code block level
	;	- 0 to indicate at the outermost level (in case of a reference
	;		to un undeclared variable). In that case the position
	;		value will be forced to zero as well.
	;	Callers should in general not be concerned with the declaration
	;	level. The compiler will issue a warning when a different value
	;	is supplied.
	; . decPos = declaration position or "" for current position
	;	Callers should in general not be concerned with the declaration
	;	position (as noted in the internal structures).
	;	This subroutine supports non-integer values of decPos, although
	;	only the integer part will currently be stored in type(,).
	; . scope = variable's scope ("FORMAL", "LITERAL", "PUBLIC", or "NEW")
	;	The supplied value is not validated
	; . class = variable's datatype
	;	The supplied value is not validated
	;
	; OUTPUTS:
	; . type(decLvl,var) = class TAB decPos TAB scope
	;	This node is always created.
	; . type(decLvl,name) = TAB decPos TAB scope
	;	This node will only be created if var is subscripted
	; . dbAcc()
	;	If the class is a record class, decByOvs^UCREC4OP() will have
	;	been called to mark the declaration in dbAcc().
	;
	; NOTES:
	; . the creation of type(decLvl,name) serves as an "anchor" for the
	;	variable name. It is a louzy way do deal with arrays that are
	;	accessed at multiple subscript levels.
	;
	new lvl,pos
	if $D(type(-1,var)) do warnGroup("MISMATCH","Modifying a PSL intrinsic variable: "_var)
	;
	if decLvl=0 set pos=0
	else  if decPos="" set pos=$$getDcLnr()
	else  set pos=decPos do warnGroup("INTERNAL",$$getCaller(0)_" explicit position '"_decPos_"' for declaration of "_class_" "_var)
	;
	if decLvl="" set lvl=level
	else  set lvl=decLvl if decLvl'=0 do warnGroup("INTERNAL:",$$getCaller(0)_" explicit DO level '"_decLvl_"' for declaration of "_class_" "_var)
	;
	; Use derived lvl and pos in assignments, but the original decLvl and
	; decPos in the call to setScope() for the unsubscripted node
	set type(lvl,var)=class_tab_(pos\1)_tab_scope
	if var["(" do
	.	new lvn,lvnScope
	.	set lvn=$P(var,"(",1)
	.	if '$D(type(lvl,lvn)) do setScope(lvn,decLvl,decPos,scope,"") quit
	.	if scope'=$$getScope(lvn,lvl) do ERROR("Scope mismatch between: "_var_" and: "_lvn)
	;
	if $$isRecord(class) do
	.	new dummy
	.	set dummy=$$decByOvs^UCREC4OP(subRou,var)
	else  do initClass(class)
	quit
	;
	;-----------------------------------------------------------------------
setType(var,class)	;private void; Set TYPE of object 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . var = variable, possibly subscripted or property
	;	In general, everything that is acceptable as leftexpr can have
	;	a separate type. However, only the following leftexprs are
	;	meaningful:
	;	- object
	;		the class applies to the variable itself
	;	- object(,)
	;		the class applies to the signature of the variable
	;	- object.property
	;		the class applies to the property
	;	- object(,).property
	;		the class applies to the property of the signature of
	;		variable
	; . class = class to be assigned
	;
	new vsig,newLevel
	set vsig=var if vsig["(" set vsig=$$objPtr(vsig)
	;
	set newLevel=$$getLevel($P(vsig,".",1))
	;
	if var["." set vsig=var
	;
	if '$D(type(newLevel,vsig)) do  quit
	.	;
	.	new lvn
	.	set lvn=$P(vsig,"(",1)
	.	if lvn["." set lvn=$P(lvn,".",1)
	.	;FRS 06/21/03			; Fixed problem w/ this.*
	.	if $$getNew(lvn,newLevel)'="" do setScope(vsig,newLevel,$$getNew(lvn),$$getScope(lvn),class) quit
	.	do setScope(vsig,0,"","PUBLIC",class)
	.	if $$isSys(vsig)!(vsig["vobj") quit
	.	do warnGroup("SCOPE","Unscoped variable: "_vsig)
	;
	do initClass(class)
	set $P(type(newLevel,vsig),tab,1)=class
	quit
	;
	;-----------------------------------------------------------------------
setInst(var,line,expr,newLevel,call)	;private void; Set instantiation value of object 
	;-----------------------------------------------------------------------
	; expr is not tokenized
	;
	; INPUTS:
	; . level = M do-level of current target line
	; . type() = type array
	; . tok = tokenized literals
	;
	; OUTPUTS:
	; . type(newLevel,var) = type record (as documented in subroutine main())
	;
	new class,noOpti,record,vptr
	;
	if line="" set line=msrc+1
	if '$D(newLevel) set newLevel=$$getLevel(var)
	;
	set vptr=$S(var["(":$$objPtr(var),1:var)
	;
	; Prevent tokenized literals in type(,) if possible
	; If on current line (line=(msrc+1)), then tok is likely to contain the
	; correct definitions.
	if var[$C(0) do
	.	if line=(msrc+1) set var=$$UNTOK^%ZS(var,.tok)
	.	if var[$C(0) do warnGroup("INTERNAL","setInst^UCGM(): literal token in "_vptr)
	set record=$G(type(newLevel,var))
	;
	if record="" set record=$G(type(newLevel,vptr))
	;
	; FSCW CR11445:
	; Temporarily: ER and RM will behave as public variables even if they
	; have NEW scope. Some methods, like Record.save() (may call a filer)
	; will return ER (and possibly RM), without explicitly passing them.
	; So if var="ER" or var="RM" force expr=""
	;
	; FSCW CR22720:
	; Assignments to PSL.xyz and other pre-instantiated static objects (with
	; newLevel<0) shall not end up in the instantiation expression either.
	if (var="ER")!(var="RM")!(newLevel<0) set expr=""
	;
	if expr="" set noOpti=1
	;
	; FSCW CR11441:
	; If instantiation due to TranSet method, turn off
	; Note that this is hardcoded here, and should at some point in time
	; be part of the OBJECT structures (OBJECT and/or OBJECTMET)
	;
	;;else  set noOpti=0 if '$$isLit(expr) set expr=$$toLit(expr)
	else  do
	.	set noOpti=0
	.	if '$$isLit(expr) set expr=$$toLit(expr)
	.	;;set noOpti='$g(commands("OPTIMIZE","OBJECTS")) quit:noOpti
	.	new icls,iexp,imet
	.	set iexp=$p(expr,"("),icls=$p(iexp,"."),imet=$p(iexp,".",2)
	.	quit:imet=""  quit:icls=""
	.	set icls=$$getClass(icls),iexp=icls_"."_imet
	.	if icls="TranSet" set noOpti=-1 quit
	;
	set class=$P(record,tab,1)
	;
	; If assignment is to an array element with primitive datatype, discard
	; the expr, as long as we do not have a mechanism that can distinguish
	; literal subscripts from variable subscripts and selectively invalidate
	; entries with literals when a value with variables is detected.
	; E.g. if ARR(0)is stored with "ABC", and ARR(SUB) is passed with "DEF"
	; it may "overwrite" ARR(0) depending on the value of SUB.
	; However, if the entry has LITERAL scope, trust the programmer.
	if var["(",'(class=""),$$primVar^UCPRIM(class),$p(record,tab,3)'="LITERAL" set expr="",noOpti=1
	;
	set $P(record,tab,4)=line
	set $P(record,tab,5)=expr
	set $P(record,tab,6)=level
	set $P(record,tab,7)=ifLevel
	set $P(record,tab,8)=ifStack
	set $P(record,tab,9)=$P(doStack,".",1,level)
	if $P(record,tab,10)'<0 set $P(record,tab,10)=noOpti
	;
	set type(newLevel,var)=record
	;
	if '(class=""),'$$primVar^UCPRIM(class) do
	.	set patch(0,subRou,vptr,$P(record,tab,2))=type(newLevel,var)
	.	if $$isRecord(class) do
	.	.	;;do setDb^UCCOLUMN(subRou,var,,newLevel)
	.	.	if line'=$$getDcLnr do warnGroup("INTERNAL","setInst("_var_") at line "_line_" of "_$$getDcLnr)
	.	.	new insPos set insPos=$$insByOvs^UCREC4OP(subRou,var,expr,"") ; instMode = unknown
	.	.	if $GET(call)'="" do setInsCall^UCREC4OP(subRou,var,insPos,call)
	.	.	if noOpti<0 do setNeedVobj^UCREC4OP(subRou,var,1)
	quit
	;
	;-----------------------------------------------------------------------
trackNam(var)	;local void; insert new entry in type() 
	;-----------------------------------------------------------------------
	; Track use of long names
	; This subroutine will maintain the array pslLong() that tracks the
	; declaration of long variable names.
	; The array is killed by subRou().
	; TYPE and formal parameter declarations will call this subroutine to
	; add the name to the array (if needed)
	;
	; ARGUMENTS:
	; . nam = declaration argument
	;	i.e subscripts are accepted, dots are not accepted.
	;
	; OUTPUTS:
	; pslLong(nam)=var
	;	if and only if $L(nam)'< PSL.maxNameLength
	;
	; NOTES:
	; . This procedure will be called for every declaration, including the
	;	declarations in UCOPTS when it is generated at boot
	;	restrictionlevel = 3. Because UCOPTS may be unavailable at that
	;	time, the subroutine quits in that case. Thus, the Framework
	;	maintainers are responsible for the length of the naes of vars
	;	declared in UCOPTS.
	;
	quit:$G(commands("boot","restrictionlevel"))'<3
	new nam,mxl
	set nam=$P(var,"("),mxl=$$getPslValue^UCOPTS("maxNameLength")
	if $L(nam)<mxl quit
	;
	; If name too long, give the warning.
	if $L(nam)>mxl do INFO("LENGTH","long variable name "_var)
	;
	; length greater than or equal to maximum ==> possible conflict
	; If already in use, this is an error (except if names are identical)
	set nam=$E(nam,1,mxl)
	if $D(pslLong(nam)),$P(var,"(")'=$P(pslLong(nam),"(") do warnGroup("LENGTH","duplicate long names "_var_" and "_pslLong(nam)) quit
	set pslLong(nam)=var
	quit
	;
	;-----------------------------------------------------------------------
typeCrea(leftexpr,class,newPtr,scope,asgnPtr,val)	;private void; insert new entry in type() 
	;-----------------------------------------------------------------------
	; This subroutine creates a complete new variable in the type() array.
	; It will be inserted at the current level.
	; This subroutine calls setScope() and setInst() to ensure that all
	; side-effects are taken care of.
	;
	; ARGUMENTS:
	; . leftexpr = the leftexpr (variable / property) to be inserted
	; . class = the class of the leftexpr
	; . newPtr = msrc where scoped
	; . scope = scope of leftexpr
	; . asgnPtr = msrc where assigned
	; . val = value assigned
	;
	; INPUTS:
	; . level = current DO-level
	;
	;;do setScop(leftexpr,level,newPtr,scope)
	;;do setType(leftexpr,class,level)
	do setScope(leftexpr,"",newPtr,scope,class)
	do setInst(leftexpr,asgnPtr,val,level)
	if level<0,val'="" set $p(type(level,leftexpr),tab,5)=val	; force val for level<0
	quit
	;
	;-----------------------------------------------------------------------
typeDec(leftexpr,class,scope)	;private void; insert new entry in type() 
	;-----------------------------------------------------------------------
	; This subroutine creates a complete new decalaration in the type()
	; array at the current level, using the current value of msrc as the
	; declaration line (and empty instantiation line).
	; This subroutine calls typeCrea(leftexpr,class,msrc+1,scope,msrc+1,"")
	; and it calls decByOvs^UCREC4OP(subrou,$$objPtr(leftexpr))
	;
	; ARGUMENTS:
	; . leftexpr = the leftexpr (variable / property) to be inserted
	; . class = the class of the leftexpr
	; . scope = scope of leftexpr
	;
	; INPUTS:
	; . level = current DO-level
	; . msrc = line number of last target M line
	;
	new tarPtr set tarPtr=msrc+1
	do typeCrea(leftexpr,class,tarPtr,scope,tarPtr,"")
	if $$isRecord(class) do decByOvs^UCREC4OP(subRou,$$objPtr(leftexpr))
	quit
	;
	;-----------------------------------------------------------------------
typeFldSet(leftexpr,field,val)	;private void; set field in type() 
	;-----------------------------------------------------------------------
	; This subroutine stores the speficied val in piece field of the current
	; type entry of the leftexpr.
	;
	; ARGUMENTS:
	; . leftexpr = the leftexpr (variable / property) to be inserted
	; . field = field number
	; . val = value assigned
	;
	; INPUTS:
	; . type(,leftexpr) exists
	;
	new lvl set lvl=$$getNew(leftexpr)
	if lvl="" do ERROR("INTERNAL: "_leftexpr_" not defined in type()") quit
	set $P(type(lvl,leftexpr),tab,field)=val
	quit
	;
	;-----------------------------------------------------------------------
toLit(expr,tok,noLit,vars,mxInst)	;private void; try to make expr literal 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . expr = the expression to translate		/TYP=T/REQ/MECH=VAL
	; . tok = the token string			/TYP=T/NOREQ/MECH=REF:RW
	; . noLit = not-literal indicator		/TYP=N/NOREQ/MECH=REF:RW
	;	0 = might be literal
	;	1 = cannot determine (e.g. due to IF or DO)
	;	2 = definitely not literal
	; . vars() = excluded variables			/TYP=T/NOREQ/MECH=REF:RW
	;	variables occuring in this array
	;	are to be treated as not literal
	; . mxInst = the highest var.instLine value	/TYP=T/NOREQ/MECH=VAL
	;	When the instantiation line of an atom is higher than this value,
	;	it is instantiated "later" than the supplied 'expr'. This is
	;	treated as an "unknown" value (noLit=1).
	;
	; NOTES:
	; * The recursive substitution explicitely terminates if the line at
	;   which the resursive atom is instantiated is greater than OR EQUAL
	;   TO mxInst. This implies that instantiations on the same line are
	;   considered not good enough for literal substitution. This is due to
	;   the fact that the type() array only stores the line number, not the
	;   position within the line where the instantiation occurred. So there
	;   is no way to detect if the nested atom is instantiated before or
	;   after the current expression.
	; * The algorithm assumes that the value stored in the .instExpr field
	;   of each atom can be used unconditionally. It is up to setInst() to
	;   ensure this (e.g. for assignments to subscripted variables)
	;
	new ER,RM set ER=0
	;
	if expr=""!($E(expr,1,2)="$$") set noLit=1 quit expr
	;
	if $G(tok)="" set tok="" if expr["""" set expr=$$TOKEN^%ZS(expr,.tok)
	;
	new atom,dels,origExpr,ptr
	;
	if '$D(noLit) set noLit=0		; FRS - 06/11/03
	;
	set dels="+-*/\#_=><[]'&!",origExpr=expr,ptr=0
	set mxInst=$g(mxInst,msrc+1)		; FSCW CR13403
	;
	for  do  quit:ptr=0!(noLit=2)
	.	;
	.	set atom=$$ATOM^%ZS(expr,.ptr,dels,tok)
	.	;
	.	if atom="" set noLit=1 quit
	.	;
	.	if noLit<2,"!&"[atom do  quit
	..		;
	..		; BOOLEAN operators can be handled with tri-state
	..		; logic (along the lines outlined in the SQL standard):
	..		; UNKNOWN ! TRUE    yields TRUE
	..		; UNKNOWN ! FALSE   yields UNKNOWN
	..		; UNKNOWN ! UNKNOWN yields UNKNOWN
	..		; UNKNOWN & TRUE    yields UNKNOWN
	..		; UNKNOWN & FALSE   yields FALSE
	..		; UNKNOWN & UNKNOWN yields UNKNOWN
	..		;
	..		new isLatom,isNatom,latom,natom,z
	..		;
	..		; FSCW CR18163: the part to the left of the logical operator
	..		; has already been "literalized". The current value of
	..		; noLit tells how successfull that was:
	..		; - if noLit = 0, then it can be literalized
	..		; - if noLit = 1, then it cannot be literalized
	..		;;set latom=$$toLit($E(expr,1,ptr-1),.tok,.noLit,.vars,mxInst)	; FSCW CR13403 added mxInst
	..		if noLit=0 do
	...			set latom=$$toLit($E(expr,1,ptr-1),.tok,.noLit,.vars,mxInst)	; FSCW CR13403 added mxInst
	...			set isLatom=$S($$isLit(latom):+$$QSUB^%ZS(latom),1:"")
	..		else  set isLatom=""
	..		;
	..		;;if '$$isLit(latom),'$$isVar(latom) quit
	..		;
	..		set natom=$$ATOM^%ZS(expr,.ptr,dels,tok)
	..		;if expression starts with unary operator,append more
	..		if "+-'"[natom for  set natom=natom_$$ATOM^%ZS(expr,.ptr,dels,tok) quit:ptr=0!("+-'"'[$E(natom,$L(natom)))
	..		;
	..		set natom=$$toLit(natom,.tok,.noLit,.vars,mxInst) if noLit=2 quit	; FSCW CR13403 added mxInst
	..		set isNatom=$S($$isLit(natom):+$$QSUB^%ZS(natom),1:"")
	..		;
	..		if atom="!",isLatom!isNatom set atom=1
	..		else  if atom="!",isLatom=0&(isNatom=0) set atom=0
	..		else  if atom="&",isLatom&isNatom set atom=1
	..		else  if atom="&",isLatom=0!(isNatom=0) set atom=0
	..		else  set noLit=1 quit
	..		;
	..		set noLit=0
	..		if ptr=0 set expr=atom
	..		else  set expr=atom_$E(expr,ptr+1,$L(expr)),ptr=1
	.
	.	if dels[atom quit
	.	if $$isLit(atom) quit
	.	if $E(atom)="(" do  quit
	..		;
	..		if $E(atom,$L(atom))=")" do
	...			;
	...			; NOTE: x already tokenized so pass .tok to recursive call
	...			set x=$E(atom,2,$L(atom)-1)
	...			if '$$isLit(x) set x=$$toLit(x,.tok,.noLit,.vars,mxInst) if noLit quit	; FSCW CR13403 added mxInst
	...			if ptr=0 set expr=$E(expr,1,$L(expr)-$L(atom))_x quit
	...			set expr=$E(expr,1,ptr-$L(atom))_x_$E(expr,ptr+1,$L(expr))
	...			set ptr=ptr+$L(x)-$L(atom)
	..		;
	..		else  set noLit=1
	.	;
	.	if $D(vars(atom)) set noLit=1 quit	; Self reference
	.	;if '$$isVar(atom) set noLit=2 quit	; Not a variable
	.	;
	.	new class,instLine,instStak,ifLevel,ifStack,doLevel,newLevel,x
	.	;
	.	set class=$$getClass(atom,.newLevel)
	.	if class="" set noLit=2 quit
	.	if '$$primVar^UCPRIM(class) set noLit=2 quit
	.	;
	.	if $G(forLevel) set noLit=1 quit
	.	;
	.	set instLine=$$getAtt(atom,newLevel,4)
	.	set instStak=$$getAtt(atom,newLevel,6)
	.	set ifLevel=$$getAtt(atom,newLevel,7)
	.	set ifStack=$$getAtt(atom,newLevel,8)
	.	set doLevel=$$getAtt(atom,newLevel,9)
	.	;
	.	if ifLevel,instLine<(msrc+1)
	.	;else  if doLevel>level			; FRS 06/17/03
	.	else  if level<instStak,$E(ifStack,level+1,instStak)
	.	else  if ifStack!doLevel,'$$isDoScope(doLevel,doStack)
	.	else  if $E(forStack,instStak+1,level)
	.	;
	.	if  set noLit=1 quit			; a test failed
	.	;
	.	if instLine'<mxInst s noLit=1 quit	; FSCW CR13403
	.	;
	.	set x=$$getExpr(atom,newLevel)
	.	if x="" set noLit=1 quit		; NULL expression
	.	;
	.	; this x is from $$getExpr() and thus not tokenized, pass ""
	.	if '$$isLit(x) set vars(atom)="",x=$$toLit(x,"",.noLit,.vars,instLine) if noLit quit	; FSCW CR13403 added instLine
	.	;;if '$$isLit(x) do
	.	;;.              ;
	.	;;.		; FSCW CR11445: The $$getInst() will only work if x is
	.	;;.		; a variable (or an array). Arrays are tricky anyway,
	.	;;.		; because an assignment to array(var) could overwrite an
	.	;;.		; entry in type(,) with a constant subscript.
	.	;;.		; So for now: stop if not a variable.
	.	;;.		if '$$isVar(x) set noLit=1 quit
	.	;;.		;
	.	;;.		; Stop if last assignment not before instLine of atom
	.	;;.              if '($$getInst(x)<instLine) set noLit=1 quit
	.	;;.              set vars(atom)=""
	.	;;.              set x=$$toLit(x,"",.noLit,.vars)
	.	;
	.	if ptr=0 set expr=$E(expr,1,$L(expr)-$L(atom))_x quit
	.	set expr=$E(expr,1,ptr-$L(atom))_x_$E(expr,ptr+1,$L(expr))
	.	set ptr=ptr+$L(x)-$L(atom)
	;
	; FSCW CR14185: If an error occurred return the original expression
	if ER quit origExpr
	;
	if expr[$C(0) set expr=$$UNTOK^%ZS(expr,tok)
	;
	if noLit!$$isLit(expr) quit expr
	;
	; If too long to literalize, return the original expr
	; The 1023 is more or less arbitrary. The correct way to deal with this
	; is through PSLExpression.fitsLineLength(). Unfortunately there is no
	; runtime entry to call this method from an M routine. So this wiull be
	; postponed until UCVGM is converted to PSL.
	if $L(expr)>1023 set noLit=2 quit origExpr
	;
	new $ZTRAP set $ZTRAP="D XERROR^UCGMC(""Invalid expression: ""_expr) ZG "_($ZLEVEL-1)
	;
	XECUTE "S expr="_expr
	;
	if '(expr=+expr) set expr=$$QADD^%ZS(expr)
	quit expr
	;
	;-----------------------------------------------------------------------
updScope(var,scope)	;void; Modify the scope of an object 
	;-----------------------------------------------------------------------
	; The scope will only be updated in the type(,) array, because scope
	; changes only impact object clean-up.
	;
	new cls,newLevel
	set newLevel=$$getLevel(var)
	if var["(",$D(type(newLevel,var))#2=0 set var=$$objPtr(var)    ; FRS - 06/13/03
	set $P(type(newLevel,var),tab,3)=scope
	quit
	;
	;-----------------------------------------------------------------------
varExpr(atom,fset,class,newLevel,scope)	; Return a variable expression 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String atom = subscripted or unsubscripted variable	/REQ/MECH=VAL
	; . Number fset = atom occurs as leftexpr		/REQ/MECH=VAL
	;	If 0, atom occurs as rightexpr
	;	If 1, atom occurs as leftexpr
	;	If -1, meaning unknown. This value is passed by subroutine KILL,
	;	when decomposing a KILL-argument.
	; . String class = datatype of atom			/NOREQ/MECH=REF:W
	;	Will receive the datatype of atom as stored in type()
	; . Number newLevel = ???
	; . String scope = scope of atom			/NOREQ/MECH=REF:W
	;	Will receive the scope of the variable.
	;	Current values are: FORMAL, LITERAL, NEW, and PUBLIC
	;
	if $E(atom)="%" set z=$G(keywords(atom)) if '(z="") do  quit atom
	.	;
	.	set scope=$P(z,"|",2)
	.	if fset=1,scope=1 do warnGroup("SYSVAR","Assigning system variable: "_atom)
	.	if fset=1,scope=-1 do ERROR("Assigning a value to a read-only system variable: "_atom)
	.	;
	.	set atom=$p(z,"|",1),class=$P(z,"|",3)
	.
	.	if 'fset,atom="EFD",$G(commands("Options","$GetEFD")) set atom="$G(EFD)"
	.	;
	.	set scope="PUBLIC"
	.	if class="" set class="String"
	.	if $$isFun(atom) quit
	.	;
	.	set newLevel=0
	.	;;if $$getScope(atom)="" do setScop(atom,newLevel,0,scope),setType(atom,class,0)
	.	if $$getScope(atom)="" do setScope(atom,0,"",scope,class)
	.	do addXref("V"_+$G(fset),$P(atom,"(",1),scope_$C(9)_class)
	;
	if $E(atom)="^" do  quit atom			; Global variable
	.	;
	.	set class="String",scope="PUBLIC"
	.	do warnGroup("GLOBAL","M Global Reference: "_atom)
	.	if atom["(" set atom=$$valArr(atom,fset)
	.	do addXref("G"_+$G(fset),$P(atom,"(",1),scope_$C(9)_class)
	;
	; FSCW CR18163: if atom is a subscripted variable the next statements
	; will return "", because only the signature occurs in type(,).
	; So use signature to get scope and class
	; If fset=-1 (KILL), and unsubscripted var, look for the next var at
	; that level. If it is a subscripted version of the var, use that to
	; obtain the class.
	; Example: type recordTTX ttx() ... kill ttx
	; shall use class of ttx(), not class of ttx.
	;
	;;set scope=$$getScope(atom,.newLevel)
	;;set class=$$getClass(atom,.newLevel)		; Default to String
	;;if class="" set class="String" do setType(atom,class)
	new atomSig set atomSig=$$objPtr(atom)
	set scope=$$getScope(atomSig,.newLevel)
	if fset=-1,$$isVar(atom) do
	.	new sig2
	.	set sig2=$O(type(newLevel,atom))
	.	if $p(sig2,"(")=atom set atomSig=sig2
	set class=$$getClass(atomSig,.newLevel)		; Default to String
	if class="" set class="String" do setType(atomSig,class)
	;
	; FSCW CR11445: 'fset' is /REQ
	;;do addXref("V"_+$G(fset),$P(atom,"(",1),scope_$C(9)_class)
	do addXref("V"_+fset,$P(atom,"(",1),scope_$C(9)_class)
	;
	if $$isArr(atom) quit $$valArr(atom,fset)
	if $$isVar(atom) do  quit atom
	.	;
	.	if 'fset,'$$getInst(atom,.newLevel),scope="NEW" do warnGroup("SCOPE","Undefined Variable: "_atom),setInst(atom,msrc,"")
	.	;
	.	; FSCW CR20280: vosc scope no longer used
	.	;;if fset=1,scope="FORMAL",'$$primVar^UCPRIM(class) do
	.	;;.	;
	.	;;.	new code,line,var
	.	;;.	set line=$P(labels(subRou),tab,1)
	.	;;.	set var=$$getSym^UCPATCH(subRou,"vosc")
	.	;;.	;;do setScop(atom,newLevel,line,var)
	.	;;.	;;do setType(atom,class,newLevel)
	.	;;.	;;do setInst(atom,line,"")	; FRS - 06/11/03
	.	;;.	;;do setOpti(atom,newLevel,1)
	.	;;.	;
	.	;;.	; FSCW CR18163: vars with FORMAL scope always occur at
	.	;;.	; level zero. The generated code line will be inserted
	.	;;.	; after 'line' (i.e. at the beginning of the subroutine)
	.	;;.	set $P(type(0,atom),tab,3)=var	; change scope to "vosc"
	.	;;.	set code="N "_var_" S "_var_"='$D("_atom_")"
	.	;;.	do newLine(code,line,0)
	;
	if $$isSys(atom) quit atom
	;
	do ERROR("Variable expected: "_atom)
	quit ""
	;
	;-----------------------------------------------------------------------
ADD(code,line)	;private void; Add a line of code to the output buffer 
	;-----------------------------------------------------------------------
	;
	if ER=2 quit
	;
	if $TR(code,$c(9,32,46))="" quit
	;
	if $G(line)="" set msrc=msrc+1,line=msrc
	if $e(code,1)=tab set $e(code,1)=" "
	set msrc(line)=code
	quit
	;
isArr(expr)	;private Boolean; is expr an array (subscripted local variable) 
	if '$$isVar($P(expr,"(",1)) quit 0	; Not legal variable
	new y
	set y=$F(expr,"(") if y=0 quit 0		; No )
	set y=y+1					; Reject ()
	for  set y=$F(expr,")",y)  quit:y=0!($L($E(expr,1,y-1),"(")=$L($E(expr,1,y-1),")"))
	quit $L(expr)+1=y
	;-----------------------------------------------------------------------
isVar(expr)	;private Boolean; is expr a variable 
	quit expr?1A.AN!(expr?1"%".AN)!($E(expr)="@"&$$isVar($E(expr,2,$l(expr))))
	;-----------------------------------------------------------------------
isObj(expr)	; Return is a valid object.method/property syntax 
	;
	new y set y=0
	for  set y=$F(expr,".",y) quit:y=0  if $E(expr,y)'?1N,$L($E(expr,1,y-2),"(")=$L($E(expr,1,y-2),")") quit
	quit (y>2)
	;
	;-----------------------------------------------------------------------
isFun(expr)	;local Boolean; 
	quit expr?1"$"1A.AN1"(".E1")"!(expr?1"$$"1A.E)
	;
	; FSCW CR11441: replaced by single patterns for positive and negative values
	;;isExp(expr)	quit $P(expr,"E",1)=+$P(expr,"E",1)&$$isInt($P(expr,"E",2,999))
	;;isInt(expr)	quit expr?1N.N!(expr?1"-"1N.N)
	;;isNum(expr)	quit expr=+expr!(expr?.N1".".1N.N)!(expr?1"-".N1".".1N.N)!$$isExp(expr)
	;-----------------------------------------------------------------------
isExp(expr)	;local Boolean; 
	quit $$isFrac($P(expr,"E"))&$$isInt($P(expr,"E",2,999))
	;-----------------------------------------------------------------------
isInt(expr)	quit expr?.1"-"1.N 
	;-----------------------------------------------------------------------
isNameDQ(name)	;private Boolean; Name is reserved for PSL source code generators 
	quit name?1"v"1.UN
	;-----------------------------------------------------------------------
isNameFW(name)	;private Boolean; Name is reserved for Framework (DQ + PSL) 
	quit name?1"v".AN
	;-----------------------------------------------------------------------
isNamePSL(name)	;private Boolean; Name is reserved for PSL compiler 
	quit name?1"v".AN1L.AN
	;-----------------------------------------------------------------------
isNum(expr)	;private Boolean; 
	; Also called by parsecmp^UCCOLUMN
	;
	quit $$isFrac(expr)!$$isExp(expr)
	;-----------------------------------------------------------------------
isFrac(expr)	quit expr=+expr!(expr?.1"-".N.1"."1.N) 
	;-----------------------------------------------------------------------
isExt(expr)	;local Boolean; 
	quit expr?1"$$"1E.E!(expr?1"$$^"1E.E)!(expr?1"$$"1E1"^"1E.E)
	;-----------------------------------------------------------------------
isSimple(expr)	;private Boolean; 
	;-----------------------------------------------------------------------
	; Helper function that returns if expr represents a "simple" expression
	; that can be used multiple times in a single method return expression.
	;
	; NOTES:
	; . This function explicitly excludes variables voN (N=1, 2, ...) from
	;	being considered simple. This is due to the fact that constructs
	;	like x.method1().method2() will show up in the method generating
	;	code for method2() as voN.method2(). method^UCGM will then
	;	replace voN by the code generated for x.method1(), which may not
	;	be simple.
	;
	quit (expr'?1"vo"1.N&$$isVar(expr))!$$isArr(expr)!$$isSys(expr)!$$isLit(expr)
	;-----------------------------------------------------------------------
isSys(expr)	quit $$CONTAIN($$initSvns(),$$UPCASE(expr)) 
	;-----------------------------------------------------------------------
isIdx(expr)	;local Boolean; 
	quit $$isVar($P(expr,"{",1))&($P(expr,"{",2)?1e.e)&($E(expr,$L(expr))="}")
	;-----------------------------------------------------------------------
isRecord(expr)	;private Boolean; is expr the name of a Record class? 
	quit ($E(expr,1,$L(reClass))=reClass)
	;-----------------------------------------------------------------------
isLit(expr)	;private Boolean; is expr a literal (numeric or string) 
	quit $$isNum(expr)!$$isStr(expr)
	;-----------------------------------------------------------------------
isStr(expr)	;local Boolean; Returns whether this string is a literal 
	;
	if '(expr?1"""".E1"""") quit 0			; Must begin/end quote
	if $L(expr,"""")=3 quit 1			; Two quotes are OK
	;
	new y set y=2
	for  set y=$F(expr,"""",y) quit:y=0!(y>$L(expr))  quit:'($E(expr,y)="""")  set y=y+1
	quit (y>$L(expr))
	;
	;-----------------------------------------------------------------------
isClass(expr)	;private void; Return expr is a class 
	;-----------------------------------------------------------------------
	; This function will also be called at runtime by $$clsIsAnc^UCGMR(),
	; and $$clsIsClass^UCGMR().
	;
	; NOTES:
	; . This function causes side effects that should be restricted to the
	;	compiler itself:
	;	* pslTbl(table) will be created for RecordXXX classes
	;	* fsn(table) will be created for RecordXXX classes
	;	* initClass(class) will be created for other classes
	;	This function, shall not be called at runtime.
	;
	new ER,z
	set z=$$ocClassName^UCXOBJ(expr) if z="" quit 0
	;
	set expr=z
	if $$isRecord(expr),'(expr=reClass) do
	.	;
	.	; cache table descriptors
	.	new table
	.	set table=$$getReTable(expr)
	.	if '$D(pslTbl(table)) set pslTbl(table)=$$getPslTbl^UCXDD(table,0)
	.	if '$D(fsn(table)) do fsn^SQLDD(.fsn,table)
	else  do initClass(expr)
	quit 1
	;
	;-----------------------------------------------------------------------
objPtr(expr)	; private String; Return object pointer 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . expr = source expression
	;	Because the function looks for parenthesis and comma, the
	;	supplied value shall be tokenized.
	;
	; Examples:
	; X		returns X
	; X.Y		returns X.Y
	; X(S1)		returns X()
	; X(S1,S2)	returns X(,)
	; X(S1,S2).Y	returns X(,).Y
	; X(S1,A(B),S3)	returns X(,,)
	;
	if expr["(" do			; subscripted
	.	if $L(expr,"(")=2 do	; simple case: no nested subscripts
	.	.	;
	.	.	new levels,tail
	.	.	set levels=$L($P(expr,"(",2),",")-1
	.	.	set tail=$P(expr,")",2)
	.	.	set expr=$P(expr,"(",1)_"("
	.	.	if levels set expr=expr_$$ADDCHR(",",levels)
	.	.	set expr=expr_")"_tail
	.	else  do		; complex case: nested subscripts
	.	.	new a,p,ptr,z
	.	.	set z=expr,ptr=$F(z,"(")-1,expr=$E(z,1,ptr),p=0
	.	.	;
	.	.	; p<0 indicates that the closing parenthesis is found
	.	.	for  set a=$$ATOM^%ZS(z,.ptr,"(,)",,1) do  quit:'ptr  quit:p<0
	.	.	.	if a="(" set p=p+1 quit
	.	.	.	if a=")" set p=p-1 quit
	.	.	.	if p>0 quit	; inside nested parenthesis
	.	.	.	if a="," set expr=expr_","
	.	.	set expr=expr_")"
	.	.	;
	.	.	; if ptr>0, then expr is a property reference, and the
	.	.	; property must be appended as well
	.	.	if ptr>0 set expr=expr_$E(z,ptr+1,$L(z))
	;
	quit expr
	;
	;-----------------------------------------------------------------------
mapPost	; Map post conditional into a variable 
	;-----------------------------------------------------------------------
	; FRS - 06/13/03
	new atom
	set atom=$E(postCond,2,$L(postCond))
	if $$isVar(atom)!$$isLit(atom) quit
	;
	set pslNew(subRou)=$$addList(pslNew(subRou),"vpc")
	set mcode=mcode_"S vpc=("_$E(postCond,2,$L(postCond))_") "
	set postCond=":vpc"
	quit
	;
	;-----------------------------------------------------------------------
killObj(expr,doExpr,killExpr,level,except,mask,scope)	; Kill an object 
	;-----------------------------------------------------------------------
	;
	new atom,class,newPtr,optim
	;
	if $$getInst(expr,level)!(expr["(") do
	.	;
	.	if expr=$G(except) quit
	.	set class=$$getClass(expr,level) if class="" quit
	.	if $$primVar^UCPRIM(class) quit
	.	;
	.	set optim='$$getOpti(expr,level)
	.	set newPtr=$$getNew(expr,level)
	.	;
	.	if $D(xtype(level,expr)) do:ifLevel=0 remPtr(expr,.xtype) quit
	.	;
	.	if expr["(",$$objPtr(expr)=expr do killArray(expr,level) set mask=$$addList(.mask,expr) quit
	.	;
	.	set atom=oLvn_"(+$G("_expr_"))"
	.	if expr["(",$$CONTAIN($G(mask),$$objPtr(expr)) quit
	.	;
	.	; FSCW CR14569: $$patch^UCPATCH() called independent of optim
	.	;;if optim set atom=$$patch^UCPATCH(subRou,expr,level,atom)
	.	set atom=$$patch^UCPATCH(subRou,expr,level,atom)
	.	set killExpr=$$addList(.killExpr,atom)
	.	do killCasc(expr,.doExpr,.killExpr,level,class)
	.	if postCond="",ifLevel=0 do		; Delete symbol & properties
	..		;
	..		kill type(level,expr)
	..		set expr=expr_".",atom=expr
	..		for  set atom=$order(type(level,atom)) quit:'($E(atom,1,$L(expr))=expr)  kill type(level,atom)
	;
	else  if ifLevel=0,postCond="",$E(expr)'="v" do
	.	;
	.	new z
	.	set z=expr_"(",z=$O(type(level,z))
	.	if $E(z,1,$L(expr))=expr,$$getInst(z,level)
	.	else  do warnGroup("SCOPE","Unreferenced variable: "_expr)
	quit
	;
	;-----------------------------------------------------------------------
killArray(expr,level)	; Delete all objects in an array 
	;-----------------------------------------------------------------------
	;
	; This can be optimized to deal with literal only (e.g., a(1))
	;
	do killCasc(expr,.doExpr,.killExpr,level,class)
	;
	new label,i,lvn,n,nodes,param,varlist
	set lvn=$P(expr,"(",1)
	set nodes=$l($P(expr,"(",2),",")
	set varlist=""
	set parlist=""
	set killcond=""
	for i=1:1:nodes set varlist=varlist_",n"_i,parlist=parlist_",ex"_i,killcond=killcond_")&(n"_i_"=ex"_i
	set varlist=$e(varlist,2,99)
	set parlist=$e(parlist,2,99)
	set killcond="("_$e(killcond,3,99)_"))"
	set label=$G(methods("Object","kill",expr))
	if label="" do
	.	;
	.	set label=$$newLabel("Kill",.labels)
	.	set methods("Object","kill",expr)=label
	.	;
	.	new code,level,var
	.	do addSubr(label,"("_parlist_")","Delete objects "_expr)
	.	set code="N "_varlist_" S ("_varlist_")="""""
	.	do append(tab_code,label)
	.	set code=""
	.	for i=1:1:nodes do
	..		set var=$p(varlist,",",i)
	..		set code=code_"  F  S "_var_"=$O("_lvn_"("_$p(varlist,",",1,i)_")) Q:"_var_"="""""
	.	set code=$e(code,3,999)
	.	set code=code_"  K:'"_killcond_" "_oLvn_"("_lvn_"("_varlist_"))"
	.	do append(tab_code,label)
	.	do append(tab_"Q",label)
	;
	set except=$P($E($G(except),1,$L($G(except))-1),"(",2)
	if except="" do
	.	for i=1:1:nodes set except=except_","_""""""
	.	set except=$e(except,2,999)
	set param="("_except_")"
	set doExpr=$$addList(.doExpr,label_param)
	;
	quit
	;
	;-----------------------------------------------------------------------
killCasc(expr,doExpr,killExpr,level,class)	;local void; Kill cascading objects 
	;-----------------------------------------------------------------------
	;
	if $$isRecord(class) quit		; No Objects in Record
	;
	new code,idx,label,lvn,next,nod,pos,rclass,n,z
	;
	set label=$G(methods("Object","killCasc",class))
	;;if label'="" set doExpr=$$addList(.doExpr,label_"(+$G("_expr_"))") quit
	if label'="" do  quit
	.	;
	.	; if expr="", this is a nested call for a property inside an object
	.	; and such an occurence cannot be patched
	.	set label=label_"(+$G("_expr_"))"
	.	if expr'="" set label=$$patch^UCPATCH(subRou,expr,level,label)
	.	set doExpr=$$addList(.doExpr,label) quit
	;
	; If object of this class contain properties that are not implemented as
	; primitives, code is needed to get rid of these objects as well. Include
	; a vKill() procedure to do this.
	set n=""
	for  set n=$O(^OBJECT(class,0,n)) quit:n=""  do
	.	;
	.	set z=^(n)
	.	set nod=$P(z,"|",1),pos=$P(z,"|",2),rclass=$P(z,"|",3),idx=$P(z,"|",6)
	.	if rclass=""!$$primVar^UCPRIM(rclass) quit
	.	;
	.	if label="" do
	..		;
	..		set label=$$newLabel("Kill",.labels)
	..		set methods("Object","killCasc",class)=label
	..		do addSubr(label,"(n)","Delete nested objects "_class)
	.	;
	.	new doExpr,killExpr
	.	;
	.	; calling killCasc("",...) and methods("Object","killCasc",rclass)
	.	; exists will cause doExpr to contain "+$G()"
	.	if (class=rclass) set doExpr=$$addList(.doExpr,label_"()")
	.	else  do killCasc("",.doExpr,.killExpr,level,rclass)
	.	;
	.	set lvn=oLvn_"(n",code=""
	.	if nod'="" set lvn=lvn_","_$S(nod=+nod:nod,1:""""_nod_"""")
	.	if idx="" set lvn=lvn_")"
	.	else  set lvn=lvn_",m)",code="N m set m="""" for  set m=$O("_lvn_") quit:m=""""  "
	.	;
	.	if $D(doExpr) do
	..		;
	..		; Replace all "()" by "this property"
	..		for  quit:'(doExpr["()")  set doExpr=$P(doExpr,"()",1)_"("_lvn_")"_$P(doExpr,"()",2,999)
	..		set code=code_" do "_doExpr_" "
	..		;
	.	set code=code_"K "_oLvn_"(+$G("_lvn_"))"
	.	do append(tab_code,label)
	;
	; A new vKill() procedure has been created, and its name is in label
	; Again we need to take care of nested calls (with epr="")
	if label'="" do
	.	;
	.	do append(tab_"Q",label)
	.	set label=label_"(+$G("_expr_"))"
	.	if expr'="" set label=$$patch^UCPATCH(subRou,expr,level,label)
	.	set doExpr=$$addList(.doExpr,label)
	quit
	;
	;-----------------------------------------------------------------------
subRou(expr,subRou,labels,type)	; Set up a subroutine 
	;-----------------------------------------------------------------------
	; This subroutine:
	; . resets pslSt to the current source line number (lptr), no IF, no FOR
	;	It uses a call to set^UCPSLST(.pslSt,) to do this, which will
	;	replace the current top. This relies on the fact that endBlock
	;	has been called iteratively to ensure the current level=0.
	;
	set fline=0
	;
	new cls,cmdDel,fpn,lblRec,p,ptr,return,var
	;
	set ptr=0,cmdDel=" "
	;
	kill struct(7),pslLong		;7/11/03
	;
	; Missing block terminator
	; Note: The code that decrements level is carefully crafted to ensure
	; that level=0 when the FOR-loop quits, but impQuit(0) will NOT have
	; been called (may or may not be called later).
	if level for  do impQuit(level) set level=level-1 if level=0 quit
	;
	; Decompose and validate.
	; The label may have been decomposed before, but labels that are sneaked
	; in by method generating code will be seen here for the first time.
	; Validation of parameters will be done here for the first time.
	set lblRec=$$fromSubrou^UCPSLLR(expr,3,$G(commands("Options","ResultClass"),0))
	set return=$p(lblRec,tab,4)
	if '$d(labels(return)) set labels(return)=lblRec
	;
	if $P(labels(return),tab)'="" do ERROR("Label already exists: "_return) quit ""
	set $P(labels(return),tab,1)=msrc+1
	set level(level)=""
	;
	; If the previous subroutine has not been terminated by an explicit
	; quit, then this is treated as an implicit GOTO from the previous
	; subroutine to this subroutine. This version of the compiler will just
	; supply a deprecation warning. Future versions shall throw an error if
	; GOTO is not allowed.
	; If GOTO is allowed, resetTyp() will be called to invalidate all
	; previous assignements to Primitives.
	; If this is just a label inside a subroutine, quit here
	if " "'[subRou do  quit:return=expr return
	.	;
	.	if $P(labels(return),tab,5)'="" do impQuit(0) quit	; has params, so new subroutine
	.	;
	.	; No parameters, so "continuation" (=implicit GOTO)
	.	; Later: If no declarations have been made yet, be forgiving ...
	.	; Now: just give a warning ...
	.	;;if '$G(commands("Options","AllowGOTO")),$O(type(-1))'="" do ERROR("Missing quit from: "_subRou) quit
	.	do warnGroup("DEPRECATED","Label inside subroutine - use single entrypoint: "_subRou_" or "_return)
	.	do resetType()
	;
	; new subroutine, initialize subroutine related structures (in order!)
	; - new value of pslSt
	; - implied declarations of all Record class instances with global
	;   scope in type(-1,)
	set subRou=return
	set pslNew(subRou)=""
	do set^UCPSLST(.pslSt,$$getDcLnr,0,0)
	set var=""
	for  set var=$o(type(-1,var)) quit:var=""  if $$isRecord($$getClass(var,-1)) set ptr=$$decByOvs^UCREC4OP(subRou,var)
	;
	; add formal parameters to type(,)
	for fpn=1:1:$$getFpCount^UCPSLLR(lblRec) do
	.	set cls=$$getFpClass^UCPSLLR(lblRec,fpn)
	.	set var=$$getFpVsig^UCPSLLR(lblRec,fpn)
	.	if $D(p($P(var,"("))) do ERROR("Parameter "_var_" is multiply defined") quit
	.	;
	.	do setScope(var,"","","FORMAL",cls),trackNam(var)
	.	if $$isRecord(cls),$$getFpAccess^UCPSLLR(lblRec,fpn)=0 do setAssign^UCREC4OP(subRou,var,-1)
	.	do setInst(var,$$getDcLnr,"")
	.	if var["(" set var=$P(var,"(",1) do setScope(var,"","","FORMAL","")
	.	set p(var)=""
	;
	; Return the M version of the declaration, but strip the comment
	quit $P($$toM^UCPSLLR(lblRec)," ;")
	;
	; ======== OLD CODE BELOW ========
	set public=$$UPCASE(expr)
	if $$CONTAIN("PUBLIC,PRIVATE",public) set public=1,expr=$$ATOM^%ZS(rec,.ptr,"",tok)
	else  if public="LOCAL" set public=0,expr=$$ATOM^%ZS(rec,.ptr,"",tok)
	else  set public=""
	;
	;;if expr="" set expr=$$getPars(.m2src,.lptr,public'="")	; Multiple lines
	;
	set return=$P(expr,"(",1)
	;
	if return="" do ERROR("Missing label name") quit ""
	if $D(labels(return)),$P(labels(return),tab)'="" do ERROR("Label already exists: "_return) quit ""
	;
	new class,fArray,p,ptr,tag,var
	;
	set ptr=0,cmdDel=" "
	;
	if level do				; Missing block terminator
	.	;
	.	do warnGroup("SYNTAX","Missing block terminator and quit from: "_subRou)
	.	new expr,postCond
	.	for  do endBlock if level=0 quit
	.	set (expr,postCond)=""
	.	do QUIT,ADD(tab_"Q")
	;
	set $P(labels(return),tab,1,2)=(msrc+1)_tab_public
	set level(level)=""
	;
	; If the previous subroutine has not been terminated by an explicit
	; quit, then this is treated of an implicit GOTO from the previous
	; subroutine to this subroutine. This version of the compiler will just
	; supply a deprecation warning. Future versions shall throw an error if
	; GOTO is not allowed.
	; If GOTO is allowed, resetTyp() will be called to invalidate all
	; previous assignements to Primitives.
	; If this is just a label inside a subroutine, quit here
	;;if '($O(type(-1))="")&(" "[subRou) do		; Missing quit
	if " "'[subRou do  quit:return=expr return
	.	;
	.	if return'=expr do  quit	; has params, so new subroutine
	..		do warnGroup("SYNTAX","Added and quit from: "_subRou)
	..		new expr,postCond
	..		set (expr,postCond)=""
	..		do QUIT,ADD(tab_"Q")
	.	;
	.	; No parameters, so "continuation" (=implicit GOTO)
	.	; Later: If no declarations have been made yet, be forgiving ...
	.	; Now: just give a warning ...
	.	;;if '$G(commands("Options","AllowGOTO")),$O(type(-1))'="" do ERROR("Missing quit from: "_subRou) quit
	.	do warnGroup("DEPRECATED","Label inside subroutine - use single entrypoint: "_subRou_" or "_return)
	.	do resetType()
	;
	; new subroutine, initialize subroutine related structures (in order!)
	; - new value of pslSt
	; - implied declarations of all Record class instances with global
	;   scope in type(-1,)
	set subRou=return
	set pslNew(subRou)=""
	do set^UCPSLST(.pslSt,$$getDcLnr,0,0)
	set var=""
	for  set var=$o(type(-1,var)) quit:var=""  if $$isRecord($$getClass(var,-1)) set ptr=$$decByOvs^UCREC4OP(subRou,var)
	;
	; done if no formal parameters
	if return=expr quit return
	;
	set subRou=return,expr=$P($E(expr,1,$L(expr)-1),"(",2,999),subLine=line,ptr=0
	;
	set return=return_"(",tag=""
	;
	if '(expr="") for  set var=$$ATOM^%ZS(expr,.ptr,",",tok) do  if ptr=0!ER quit
	.	;
	.	if var=",",'(","[$E(tag,$L(tag))) set return=return_",",tag=tag_"," quit
	.	;
	.	set fArray=0
	.	;
	.	if ptr,$E(expr,ptr+1)=" " do  quit:ER
	..		;
	..		set class=var
	..		if '$$isClass(.class) do ERROR("Undefined class: "_class) quit
	..		set var=$$ATOM^%ZS(expr,.ptr,",",tok)
	..		if var?.e1"(".",".1")" set fArray=1	; var()
	..		else  if '$$isVar(var) do ERROR("Variable expected: "_var) quit
	.	;
	.	else  set class="String"
	.	;
	.	set tag=tag_class_" "_var
	.	;
	.	;;do setScop(var,level,msrc+1,"FORMAL")
	.	;;do setType(var,class)
	.	do setScope(var,"","","FORMAL",class)
	.	do setInst(var,$$getDcLnr,"")
	.	;
	.	if fArray set var=$P(var,"(",1) do setScope(var,"","","FORMAL","")
	.	;
	.	if $D(p(var)) do ERROR("Parameter "_var_" is multiply defined") quit
	.	;
	.	;;if fArray,'$$getNew(var) do setScop(var,level,msrc+1,"FORMAL")
	.	set return=return_$$varExpr(var,0),p(var)=""
	;
	set $P(labels(subRou),tab,3)=tag
	set return=return_")"
	;
	quit return
	; ======== OLD CODE ABOVE ========
	;
	;-----------------------------------------------------------------------
getCaller(nOff)	;private String; return caller-of-caller 
	;-----------------------------------------------------------------------
	; Debug support function that returns the caller of the caller
	;
	; ARGUMENTS:
	; . nOff = additional number of stack levels to add to the standard
	;	value 3 that identifies the caller of the caller
	;
	new zshow
	zshow "S":zshow
	quit zshow("S",$g(nOff)+3)
	;-----------------------------------------------------------------------
getDcCod()	quit mcode ;private String; Destination code line 
	;-----------------------------------------------------------------------
	;
	;-----------------------------------------------------------------------
getDcLnr()	quit msrc+1 ;private Number; Destination code 'linenumber' 
	;-----------------------------------------------------------------------
	;
	;-----------------------------------------------------------------------
getLabels(lblRec,lblref)	;local Number; Add labels to lblRec() 
	;-----------------------------------------------------------------------
	; Add the labels of the routine specified by lblref to lblRec() and
	; return an error indicator.
	;
	; OUTPUT:
	; . $$ = error level
	;	0 = no error, labels are present.
	;		This value will also be returned when lblref does not
	;		specify a routinename.
	;	1 = no source found
	;		This value indicates that a routine with this name was
	;		found, but that it was impossible to trace the routine
	;		back to a PSL source.
	;		lblRec() will contain the PSLLabelRecords, but the
	;		declarations are based on the M routine.
	;	2 = no routine found
	;		This value will be returned when no M file could be
	;		found.
	;		lblRec() will not have been modified.
	;		This value will also be returned when the (implied)
	;		boot-restrictionlevel is greater than zero, or when
	;		lblref contains indirection
	;
	if lblref["@" quit 2
	if lblref'["^" quit 0
	if $G(commands("boot","restrictionlevel"))>0 quit 2
	new rtn set rtn=$P(lblref,"^",2)
	;
	; Routine exists, check if it is already present
	if pslRtns[(","_rtn_":") quit +$P(pslRtns,","_rtn_":",2)
	new ret
	if '$$VALID^%ZRTNS(rtn) do
	.	do warnGroup("MISMATCH","Routine "_rtn_" not found")
	.	set ret=2
	else  do
	.	new src
	.	set ret=$$getSrc^UCLABEL(rtn,.src)
	.	do getLblRec^UCPSLLR(.src,rtn,0,.lblRec)
	set pslRtns=pslRtns_","_rtn_":"_ret
	quit ret
	;
	;-----------------------------------------------------------------------
getScCod()	quit m2src($$getScLnr) ;private String; Source code line 
	;-----------------------------------------------------------------------
	;
	;-----------------------------------------------------------------------
getScLnr()	quit +$G(lptr) ;private Number; Source code 'linenumber' 
	;-----------------------------------------------------------------------
	;
	;-----------------------------------------------------------------------
joinFpl(lptr,tok)	;local String; Get subroutine parameters 
	;-----------------------------------------------------------------------
	;
	new expr,rec
	;
	set expr=$$getLine(lptr)
	;
	; FSCW CR11441: $L("PUBLIC")=6, $L("PRIVATE")=7 !!
	;;if public set expr=$$LTRIM^%ZS($E(expr,7,$L(expr)))
	;;if public set expr=$$LTRIM^%ZS($E(expr,$F(expr," "),$L(expr)))
	;
	if '(expr[",") do ERROR("Invalid Subroutine name: "_expr) quit ""
	;
	if expr[";" set expr=$P(expr,";",1)
	if expr["//" set expr=$P(expr,"//",1)
	if expr["/*" set expr=$$joinFplC(.lptr,expr)	; FSCW CR11441: accept multiline comment
	;
	if '(expr[",") do ERROR("Comma (,) expected: "_expr) quit ""
	set expr=$P(expr,",",1,$L(expr,",")-1)_","
	;
	for  set lptr=$O(m2src(lptr)) quit:lptr=""  do  quit:($L(expr,"(")=$L(expr,")"))!ER
	.	;
	.	set rec=$$getLine(lptr)
	.	set rec=$$TOKEN^%ZS(rec,.tok,"")
	.	;
	.	; FSCW CR11441: handle comment BEFORE quit on ")"
	.	if rec[";" set rec=$P(rec,";",1)
	.	if rec["/*" set rec=$$joinFplC(.lptr,rec)
	.	if rec["//" set rec=$P(rec,"//",1)
	.	;
	.	; FSCW CR20280: statement below only works if M code following
	.	; the close-parenthesis does not contain parenthesis.
	.	;;if $L(rec,")")>$L(rec,"(") set expr=expr_$P(rec,")",1,$L(rec,")")-1)_")" quit
	.	if $L(rec,")")>$L(rec,"(") set expr=expr_$$RTCHR^%ZFUNC(rec," ") quit
	.	;
	.	if '(rec[",") do ERROR("Comma (,) expected: "_rec) quit
	.	set expr=expr_$P(rec,",",1,$L(rec,",")-1)_","
	.	;
	.	if $L(expr)>1024 do ERROR("Parameter list is too long: "_expr) quit
	;
	quit:ER ""
	;
	quit expr
	;
	; FSCW CR11441: accept multiline comment
	;-----------------------------------------------------------------------
joinFplC(lptr,str)	;local String; Strip blockcomment from formal parameter list 
	;-----------------------------------------------------------------------
	;
	; ARGUMENTS:
	; . Number lptr		line pointer		/REQ/MECH=REF:RW
	; . String str		line containing "/*"	/REQ/MECH=VAL
	;
	; INPUTS:
	; . String m2src()	source code (used by blockC)
	;
	new ptr
	set ptr=$find(str,"/*")
	do blockC
	quit str
	;
	; FSCW CR11441: (runtime) function that returns value of reClass
getReClass()	;private String; 
	quit "Record"
	;
	;-----------------------------------------------------------------------
getReTable(class)	;private String; return table name of Record class 
	;-----------------------------------------------------------------------
	; NOTE: assumes that table name does not contain the sequence "Record".
	;
	quit $P(class,"Record",2)
	;
getClass(var,newLevel)	;private String; 
	quit $$getAtt(.var,.newLevel,1)
getNew(var,newLevel)	;private Number; 
	quit $$getAtt(.var,.newLevel,2)
getScope(var,newLevel)	;private Number; 
	quit $$getAtt(.var,.newLevel,3)
getInst(var,newLevel)	;private Number; 
	quit $$getAtt(.var,.newLevel,4)
getExpr(var,newLevel)	;private String; 
	quit $$getAtt(.var,.newLevel,5)
getIf(var,newLevel)	;local Number; NOT CALLED 
	quit $$getAtt(.var,.newLevel,7)
getOpti(var,newLevel)	;private Number; 
	quit $$getAtt(.var,.newLevel,10)
	;
	;-----------------------------------------------------------------------
getAtt(var,newLevel,field)	;private String; Return object attributes 
	;-----------------------------------------------------------------------
	;
	if '$D(newLevel) set newLevel=$$getLevel(var)
	if var["(",$D(type(newLevel,var))#2=0 set var=$$objPtr(var)    ; FRS - 06/13/03
	;
	quit $P($G(type(newLevel,var)),tab,field)
	;
	;-----------------------------------------------------------------------
getLevel(var)	;private Number; Return the level that var was scoped at 
	;-----------------------------------------------------------------------
	new return
	for return=level:-1:0 if $D(type(return,$P(var,"(",1))) quit
	else  if $D(type(-1,var)) set return=-1
	quit return
	;
	;-----------------------------------------------------------------------
remPtr(ref,xtype)	; Test and remove multiple reference pointers 
	;-----------------------------------------------------------------------
	;
	new n set n=""
	for  set n=$O(xtype(level,ref,n)) quit:n=""  kill xtype(level,n,ref)
	kill xtype(level,ref)
	quit
	;
	;-----------------------------------------------------------------------
isNxtCmd(cmd,expr,ptr)	; Function to repair white space syntax ambiguity 
	;-----------------------------------------------------------------------
	; if expr is a command, move ptr back and warn about whitespace
	;
	if $$getCommand(.cmmds,$$UPCASE(expr))="" quit 0
	do warnGroup("SYNTAX","Two spaces expected after command: "_cmd)
	set ptr=ptr-$L(expr)
	quit 1
	;
	;-----------------------------------------------------------------------
addComment	;local void; Add a comment line if prior isn't a comment 
	;-----------------------------------------------------------------------
	;
	set mcode=$$initLine(level)_";"
	;
	if $TR($G(msrc(msrc)),$C(9)," ")'=$TR(mcode,$C(9)," ") do ADD(mcode)
	quit
	;
	;-----------------------------------------------------------------------
lblPstfx(num)	; Return the lable postfix associated with the supplied number 
	;-----------------------------------------------------------------------
	;
	if num<100 quit num
	set num=num-100
	if num<676 quit $E("ABCDEFGHIJKLMNOPQRSTUVWXYZ",num\26+1)_$E("ABCDEFGHIJKLMNOPQRSTUVWXYZ",num#26+1)
	do ERROR("maximim number of labels exceeded")
	quit num
	;
	;-----------------------------------------------------------------------
newLabel(name,labels,ref)	; Return a new tag 
	;-----------------------------------------------------------------------
	;
	new i,z
	f i=1:1 set z="v"_$G(name)_$$lblPstfx(i) if '$D(labels(z)) set labels(z)=$G(ref) quit
	quit z
	;
	;-----------------------------------------------------------------------
newLine(code,line,level)	; Insert a line at the current block level 
	;-----------------------------------------------------------------------
	;
	; Move past comment lines before insert
	;
	set z=$O(msrc(line))
	if z,$E($G(msrc(z)),1,2)=" ;" for  set line=z,z=$O(msrc(line)) quit:'z!'($E(msrc(z),1,2)=" ;")
	;
	new mcode
	set mcode=$$initLine(level)_code
	for  set line=line+.001 quit:'$D(msrc(line))
	do ADD(mcode,.line)
	quit
	;
	;-----------------------------------------------------------------------
nxtSym()	;private String; Generate a new variable 
	;-----------------------------------------------------------------------
	;
	set pslVarNr=pslVarNr+1
	quit "vo"_pslVarNr
	;
	;-----------------------------------------------------------------------
addList(list,item)	;local List; Add item to list 
	;-----------------------------------------------------------------------
	;
	if $G(list)="" quit item
	if $$CONTAIN(list,item) quit list
	quit list_","_item
	;
	;-----------------------------------------------------------------------
addSubr(label,params,comment)	;private void; Add a subroutine 
	;-----------------------------------------------------------------------
	;
	do append(tab_";",label)
	do append(label_params_tab_"; "_comment,.label)
	do append(tab_";",label)
	set $P(labels(label),tab,4)=label
	set $P(labels(label),tab,6)=comment
	set labels(label)=$$setFormalList^UCPSLLR(labels(label),params,0)
	quit
	;
	;-----------------------------------------------------------------------
findSubr(label,comment)	;public String; Find a subroutine 
	;-----------------------------------------------------------------------
	; Find a subroutine in append() that matches label followed by 1.N,
	; and a comment as specified
	;
	; ARGUMENTS:
	; . label = label prefix
	;	The function fill try label1, label2, etc until labelN either
	;	matches or is undefined.
	; . comment = comment string
	;	The comment is looked for in labels(label).comment
	;	Only an exact match will pass
	;
	; OUTPUTS:
	; . $$ = label to be used
	;	This will be either the label found in append() or the next
	;	available label in append() that satisfies the pattern.
	;
	new i,z
	for i=1:1 set z=label_$$lblPstfx(i) quit:'$DATA(labels(z))  quit:$PIECE(labels(z),tab,6)=comment
	quit z
	;
	;-----------------------------------------------------------------------
append(code,label)	do addCode^UCPSLSR(label,code) quit ;deprecated private void; Add code to append() 
	;-----------------------------------------------------------------------
	;
	;-----------------------------------------------------------------------
move(label,record,msrc)	;local void; Move codeblock out of inline code into label 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . label = name of destination subroutine
	;	If empty, the code block will be removed completely
	; . record = code block descriptor record: level TAB start TAB end
	;	level = DO level (zero-based)
	;	start = line number in msrc() of first line of block (inclusive)
	;	end   = line number in mscr() of last line of block (inclusive)
	; . msrc() = M code array
	;
	; NOTES:
	; . To make the algorithm independent of whitespace (TAB, SPACE, empty),
	;	the algoritm removes 'level' DOTs from the beginning of the line.
	;
	new dotpos,end,i,level,mcode,start
	;
	set level=$P(record,tab,2)
	set start=$P(record,tab,3)
	set end=$P(record,tab,4)
	;
	;;set doSyn="."_tab
	set start=$O(msrc(start),-1)
	for  set start=$O(msrc(start)) quit:start=""!(start>end)  do
	.	;
	.	set mcode=msrc(start)
	.	kill msrc(start)
	.	;
	.	if label="" quit				; no need
	.	; Now -- remove the original stack level
	.	;
	.	;;for i=1:1:(level+1) set mcode=$P(mcode,doSyn,1)_$P(mcode,doSyn,2,999)
	.	set dotpos=0
	.	for i=0:1:level set dotpos=$F(mcode,".",dotpos)
	.	for dotpos=dotpos:1 quit:$C(32,9)'[$E(mcode,dotpos)
	.	do ADD(" "_$E(mcode,dotpos,$L(mcode)))
	quit
	;
	;-----------------------------------------------------------------------
endBlock	;local void; End a code block } 
	;-----------------------------------------------------------------------
	;
	if level=0 do ERROR("Invalid block termination") quit
	;
	set (cmd,expr,postCond)="" do QUIT
	;
	set z=level(level) kill level(level)
	;
	new xcmd,xmsrc,xrec
	set xcmd=$P(z,tab,1),xmsrc=$P(z,tab,2),xrec=$P(z,tab,4),forLevel=$P(z,tab,5)
	;
	; pop pslSt: discard doVal, use ifLevel and forLevel
	do pop^UCPSLST(.pslSt,,.ifLevel,.forLevel)
	;
	set ifLevel=$E(ifStack,level)
	set forLevel=$E(forStack,level)
	set level=level-1
	;
	if level=0 set doStack="",ifStack="",forStack=""
	else  set ifStack=$E(ifStack,1,level),forStack=$E(forStack,1,level)
	;
	if ptr=0 S:$TR(mcode,tab_".")="" mcode=$$initLine(level)_";"
	;
	if xcmd="CATCH" do  if ER quit
	.	;
	.	; FSCW CR9792 changed line below
	.	;if xrec'="" do ERROR("Unexpected expression after catch block: "_xrec) quit
	.	if $$checkDead(xrec,-1) do ERROR("Unexpected expression after catch block: "_xrec) quit
	.	do ADD(mcode)
	.	set mcode=""
	.	;
	.	new label,record
	.	set label=$G(errTrap(level))
	.	set record=$G(append(label))
	.	set $P(record,tab,2)=level
	.	set $P(record,tab,3)=xmsrc+1
	.	set $P(record,tab,4)=msrc
	.	set append(label)=record
	;
	; Code following the '}' will be dead
	if $$checkDead(rec,.ptr) do warnGroup("DEAD","code following '}' will never execute")
	;
	if '(xrec="") do				; There is trailer code
	.	;
	.	new ptr,mcode,rec,tok,zmsrc
	.	set ptr=0,zmsrc=msrc,msrc=xmsrc-1	; set msrc to block
	.	set mcode=msrc(xmsrc)_" "
	.	set rec=$$TOKEN^%ZS(xrec,.tok)
	.	for cmdNum=2:1 do command(rec,.ptr) quit:ptr=0!ER
	.	set msrc(xmsrc)=mcode
	.	set msrc=zmsrc				; Reset msrc
	;
	quit
	;
	;-----------------------------------------------------------------------
initBlock	;local void; start a block level { 
	;-----------------------------------------------------------------------
	;
	set level=level+1
	do push^UCPSLST(.pslSt,$$getDcLnr,0,0)
	;
	if level=1 set doStack=(msrc\1+1),ifStack=ifLevel,forStack=forLevel
	else  set $P(doStack,".",level)=$P(doStack,".",level)+1,ifStack=ifStack_ifLevel,forStack=forStack_forLevel
	;
	set level(level)=cmd_tab_(msrc+1)
	;
	; FSCW CR9792: 1 line replaced by 3
	; M contains operator ('[') is save because 'str' has been tokenized
	;if ptr set $P(level(level),tab,4)=$$UNTOK^%ZS($E(str,ptr+1,$L(str)),tok) set ptr=0
	if ptr do
	.	if $E(str,ptr+1,$L(str))["/*" d ERROR("Multi-line comment cannot start here") quit
	.	set $P(level(level),tab,4)=$$UNTOK^%ZS($E(str,ptr+1,$L(str)),tok) set ptr=0
	quit
	;
	;-----------------------------------------------------------------------
initClass(class)	;local void; Cache class, classmethods, and classproperties 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String class = class name
	;	character case as used in OBJECT* tables.
	;
	quit:class=""  if $$isRecord(class),class'=reClass quit
	new rwCls
	set rwCls=$$ocGet^UCXOBJ(.pslCls,class,1),class=$P(rwCls,"|")
	if $O(pslMtd(class,""))="" do omAll^UCXOBJ(.pslMtd,class,.pslCls)
	if $O(pslPrp(class,""))="" do opAll^UCXOBJ(.pslPrp,class)
	;;;
	;;; TEMP until methods() no longer used externally:
	;;if $O(methods(class,""))="" do omAll^UCXOBJ(.methods,class,.pslCls)
	quit
	;
	;-----------------------------------------------------------------------
initCmds(cmds)	;private void; Initialize array of commands supported by PSL 
	;-----------------------------------------------------------------------
	; cmds(cmd)=Abbrv.|Argumentless|noPostCond
	;
	set cmds("BREAK")="B|1"
	set cmds("CATCH")="|1|1"
	set cmds("CLOSE")="C"
	set cmds("DO")="D"
	set cmds("ELSE")="E|1|1"
	set cmds("FOR")="F|1|1"
	set cmds("GO")="G"
	set cmds("HANG")="H|1"
	set cmds("HALT")="H|1"
	set cmds("IF")="I|1|1"
	set cmds("JOB")="J"
	set cmds("KILL")="K|1"
	set cmds("LOCK")="L|1"
	set cmds("NEW")="N||1"
	set cmds("OPEN")="O"
	set cmds("QUIT")="Q|1"
	set cmds("READ")="R"
	set cmds("SET")="S"
	;;set cmds("TABBORT")="TA|1"
	set cmds("TCOMMIT")="TC|1"
	set cmds("THROW")="||1"
	set cmds("TROLLBACK")="TR|1"
	set cmds("TSTART")="TS|1"
	set cmds("TYPE")="||1"
	set cmds("USE")="U"
	set cmds("VIEW")="V"
	set cmds("WHILE")="||1"
	set cmds("WRITE")="W"
	set cmds("XECUTE")="X"
	set cmds("ZBREAK")="ZB|1"
	set cmds("ZMESSAGE")="ZME|1"
	set cmds("ZPRINT")="ZPR|1"
	set cmds("ZSHOW")="ZSH|1"
	set cmds("ZWITHDRAW")="ZWI|1"
	set cmds("ZWRITE")="ZWR|1"
	quit
	;
	;-----------------------------------------------------------------------
initFcts()	;private List; Return list of M functions that are still valid 
	;-----------------------------------------------------------------------
	;
	quit "$ASCII,$CHAR,$DATA,$EXTRACT,$FIND,$FNUMBER,$GET,$JUSTIFY,$LENGTH,$ORDER,$PIECE,$QUERY,$TRANSLATE,$RANDOM,$SELECT,$ZDATE,$ZININTERRUPT,$ZINTERRUPT,$ZJOBEXAM"
	;
	;-----------------------------------------------------------------------
initSvns()	;private List; Return list of M svns that are still valid 
	;-----------------------------------------------------------------------
	;
	quit "$H,$I,$J,$P,$REFERENCE,$T,$X,$Y,$TL,$TLEVEL,$TR,$TRESTART,$ZA,$ZB,$ZGBLDIR,$ZEOF,$ZININTERRUPT,$ZINTERRUPT,$ZJOB,$ZJOBEXAM,$ZL,$ZLEVEL,$ZPOSITION,$ZS,$ZSTEP,$ZT,$ZTEXIT,$ZVERSION"
	;-----------------------------------------------------------------------
initLine(level)	;private String; Initialize a line at this block level 
	;-----------------------------------------------------------------------
	; All compiler subroutines that insert M code directly into the target
	; stream shall call this function to ensure that the correct number of
	; dots will be prepended to the line.
	;
	new return
	set return=" "
	if level set return=return_$$ADDCHR(".",level)_$$ADDCHR(tab,level)
	quit return
	;
	;-----------------------------------------------------------------------
errTrap(level)	;local String; Add method error trapping code 
	;-----------------------------------------------------------------------
	;
	new i,label,return
	;
	; If an error trap exists and the catch statement was processed, add
	; a new trap and link the old one and this error to it.
	;
	set label=$G(errTrap(level))
	if label'="",$O(append(label,""),-1)>errTrap(level,1) do addLink(level)
	;
	if '$D(errTrap(level)) do addTrap(level)	; Create an error trap
	;
	quit errTrap(level)
	;
	;-----------------------------------------------------------------------
addLink(level)	;local void; Add an error trap and link to it 
	;-----------------------------------------------------------------------
	;
	new label,trapExpr,xlabel,xline
	set xlabel=errTrap(level)
	set xline=errTrap(level,1)
	;
	set trapExpr=$G(append(xlabel,xline+1))		; Get the trap list
	;
	do addTrap(level)
	;
	if trapExpr="" quit
	;
	new label
	set label=errTrap(level)
	;
	set trapExpr=trapExpr_" G "_label
	set append(xlabel,xline+1)=trapExpr
	quit
	;
	;-----------------------------------------------------------------------
addTrap(level)	;local void; Add another error trap subr at this level 
	;-----------------------------------------------------------------------
	;
	new label
	set label=$$newLabel("trap",.labels)
	do addSubr(label,"","Error trap")
	set errTrap(level)=label
	set errTrap(level,1)=$O(append(label,""),-1)
	quit
	;
	;-----------------------------------------------------------------------
isDoScope(a,b)	;private Boolean; Is b in the scope of a 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String a = "outer" do block
	; . String b = "inner" do block
	;	If absent, doStack will be used
	;
	; OUTPUTS:
	; . 1 if and only if a is a proper head of b
	;
	; NOTES:
	; . This function is slightly dangerous because it uses $EXTRACT to pick
	;	the head, whereas doStack is a dot-separated list. This could
	;	lead to incorrect results for example if a=1 and b=10.
	;	The alternative is: $PIECE(b,".",1,$LENGTH(a,"."))=a
	;
	if '$D(b) set b=doStack
	quit ($E(b,1,$L(a))=a)
	;
CONTAIN(X,Y)	;local String; 
	quit ","_X_","[(","_Y_",")
	;
ADDCHR(chr,length)	;local String; 
	quit $TR($J("",length)," ",chr)
	;
	;-----------------------------------------------------------------------
	;;keyword(expr) ;Return expr look-up
	;-----------------------------------------------------------------------
	;
	;-----------------------------------------------------------------------
rtb(string,chr)	; Remove trailing characters 
	;-----------------------------------------------------------------------
	;
	if $G(chr)="" set chr=" "
	;
	for  quit:$E(string,$L(string))'=chr  set string=$E(string,1,$L(string)-1)
	quit string
	;
UPCASE(string)	;private String; Translate to uppercase (simple ASCII only) 
	quit $TR(string,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
	;
subEnd(string,ofset)	; Return Subset from ofset 
	;
	quit $E(string,$L(string)-ofset,$L(string))
	;
	;-----------------------------------------------------------------------
COMMENT(str,ptr,tok)	;local void; Rest of line is a comment 
	;-----------------------------------------------------------------------
	;
	new return
	set return=""
	if ptr set return=return_$$UNTOK^%ZS($E(str,ptr+1,$L(str)),.tok),ptr=0
	quit return
	;
	;-----------------------------------------------------------------------
log(src,lnr,srn,lvl,msg,tsl)	;private void; Output message 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String src()
	;	the source array.
	; . Number lnr
	;	The source line number. The line at src(+lnr) will be displayed.
	;	TAB, CR, LF, FF will be replaced by SPACE, all other control
	;	characters will be removed.
	; . String srn
	;	Subroutine name to display
	; . Number lvl
	;	The logging level
	;	1 - information
	;	2 - warning
	;	3 - error
	; . String msg
	;	The warning message to be printed
	; . String tsl						/NOREQ
	;	Tokenized string literals.
	;	Required when msg contains literal tokens (flagged by $C(0))
	;
	; INPUTS:
	; . cmperr() = accumulated logtext			/NOREQ/WRITE
	;
	; OUTPUTS:
	; . cmperr(): warning text lines as printed added to cmperr()
	;
	;
	use $P
	new erline1,erline2,erline3,piece
	;
	if msg[$c(0) set msg=$$UNTOK^%ZS(msg,tsl)
	;
	set erline1=$TR($G(src(+lnr)),$C(9,10,12,13,1,2,3,4,5,6,7,8,11,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31),$J("",4))
	set erline2="%PSL-"_$E("IWE",lvl)_"-"_msg
	set erline3="At source code line: "_+lnr_" in subroutine: "_$P(srn,"(")
	;
	write !,erline1,!
	write erline2,!
	write erline3,!
	;
	set cmperr($O(cmperr(""),-1)+1)="++++++++++++++++++++++"
	set cmperr($O(cmperr(""),-1)+1)=erline1
	set cmperr($O(cmperr(""),-1)+1)=erline2
	set cmperr($O(cmperr(""),-1)+1)=erline3
	;
	; Update info/warning/error counts
	set piece=lvl+1			; info = 2, warning = 3, error = 4
	set $P(cmperr,"|",piece)=$P($G(cmperr),"|",piece)+1
	;
	quit
	;
	;-----------------------------------------------------------------------
WARN(message)	;private void; Output message - DEPRECATED: use warnGroup^UCGM() 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String message		/REQ/MECH=VAL
	;	The warning message to be printed
	;
	; INPUTS:
	; . cmperr() = accumulated warnings			/NOREQ/WRITE
	; . commands("ACCEPT",lptr) to suppress warning		/NOREQ/READ
	; . ERRTYPE = error type				/NOREQ/READ
	;	if defined and non-zero, the "warning" is reported as an "error"
	;	if defined and zero, the "warning" is reported as "information"
	; . lptr = line number in sourcecode			/NOREQ/READ
	; . m2src(lptr) = sourceline that causes the warning	/NOREQ/READ
	; . subRou = name of subroutine in which warning occurs	/NOREQ/READ
	; . tok = string literals (to "untokenize" message)	/NOREQ/READ
	;
	; OUTPUTS:
	; . cmperr(): warning text lines as printed added to cmperr()
	;
	if $G(lptr)'="",$D(commands("ACCEPT",lptr)),'$G(ER) quit
	;
	do log(.m2src,+$G(lptr),$G(subRou),2,message,$G(tok))
	quit
	;
	;-----------------------------------------------------------------------
WARNDEP(feature)	;private void; give deprecation warning 
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String feature		/REQ/MECH=VAL
	;	The deprecated feature that is detected.
	;
	; INPUTS:
	; . commands("WARN","DEPRECATED")	/NOREQ/MECH=VAL
	;	If defined, and non-zero deprecation warnings are enabled
	;
	;;if $G(commands("WARN","DEPRECATED")) do WARN("Deprecated feature "_feature)
	do warnGroup("DEPRECATED",feature)
	quit
	;
	;-----------------------------------------------------------------------
warnGroup(grp,msg)	;private void; Provide warning 
	;-----------------------------------------------------------------------
	; Supply a warning, provided:
	; - warnings for the specified group are enabled
	; - warnings for the current line are not generally #ACCEPTED
	; - warnings for the current line and specified group are not #ACCEPTed
	;
	if '$G(commands("WARN",grp)) quit
	if $G(lptr)'="" quit:$D(commands("ACCEPT",lptr))#2  quit:$D(commands("ACCEPT",lptr,grp))
	do log(.m2src,+$G(lptr),$G(subRou),2,grp_": "_msg,$G(tok))
	quit
	;
	;-----------------------------------------------------------------------
ERROR(message)	;private void;Compiler Error 
	;-----------------------------------------------------------------------
	;
	set $P(cmperr,"|",1)=1
	;
	if $G(ER)=2 quit
	set ER=2
	;
	do log(.m2src,+$G(lptr),$G(subRou),3,message,$G(tok))
	;
	if '$D(level)!'$D(tab) quit
	;
	do ADD($$initLine(level)_$$UNTOK^%ZS($G(rec),$G(tok)))
	do ADD($$initLine(level)_"; *Compile Error* "_message)
	set ptr=0
	quit
	;
	;-----------------------------------------------------------------------
INFO(grp,msg)	;private void;Informational compiler message 
	;-----------------------------------------------------------------------
	; Supply an informational message, provided:
	; - info for the specified group is enabled
	; - info for the current line is not generally #ACCEPTED
	; - info for the current line and specified group is not #ACCEPTed
	;
	; NOTES:
	; . The use of #ACCEPT assumes that INFO groups are a subset of the WARN
	;	groups, because UCGMC will validate groups based on $$allWarn.
	;
	if '$G(commands("INFO",grp)) quit
	if $G(lptr)'="" quit:$D(commands("ACCEPT",lptr))#2  quit:$D(commands("ACCEPT",lptr,grp))
	;
	do log(.m2src,+$G(lptr),$G(subRou),1,grp_": "_msg,$G(tok))
	quit
	;
	;-----------------------------------------------------------------------
getLine(lptr)	;local String; 
	quit $$RTCHR^%ZFUNC($TR(m2src(lptr),$C(9)," ")," ")
	;
	;-----------------------------------------------------------------------
gtmLevel(lvl)	;private Boolean; Is GT.M version at least as requested 
	;-----------------------------------------------------------------------
	; Validate supplied lvl against $ZVERSION (or its override).
	;
	; ARGUMENTS:
	; . lvl = minimum GT.M level needed. Can be either
	;	- M.m If only the version number is relevant.
	;		In this case strict numeric comparison will be used in
	;		which both the supplied level and the GT.M version are
	;		interpreted as M numeric.
	;	- M.m-bbbB If version number and build are both relevant.
	;		In this case, if the version numbers are different, then
	;		strict numeric interpetation is used. If the numeric
	;		interpreation of lvl and the GT.M version are equal,
	;		then the string interpretations (!) of the build values
	;		determine the result (using the "follows" operator).
	;
	; INPUTS:
	; . commands("boot","gtmlevel") = $ZVERSION override
	;	If this lvn is defined, it will be used instead of $ZVERSION to
	;	compare against lvl.
	;	The value in commands("boot","gtmlevel") has the same layout as
	;	the lvl argument.
	;
	; OUTPUTS:
	; . 1 if and only if the GT.M version is greater than or equal to the
	;	supplied lvl.
	;
	new v
	set v=$G(commands("boot","gtmlevel"),$P($P($ZVERSION,"GT.M V",2)," "))
	if v>lvl quit 1
	if v<lvl quit 0
	;
	; v and lvl are numerically equal, check second piece (if requested)
	if lvl'["-" quit 1
	quit $p(lvl,"-",2)']$p(v,"-",2)
	;
	;-----------------------------------------------------------------------
addXref(topic,ref,data)	;private void; Add to sysmap 
	;-----------------------------------------------------------------------
	;
	new c,z
	set z=$P(subRou,"(",1)_"+"_(line-subLine)
	set c=$O(sysmap(topic,z,ref,""),-1)+1
	set sysmap(topic,z,ref,c)=data
	quit
	;
	;-----------------------------------------------------------------------
addM2src(data)	;private void; Add a line to the end of m2src 
	;-----------------------------------------------------------------------
	;
	new seq
	set seq=$o(m2src(""),-1)+1
	set m2src(seq)=data
	quit
	;
	;-----------------------------------------------------------------------
	; xxxPSLSetting
	;	Compiler setting interface.
	;	These functions and procedures are used to obtain values from
	;	and assign values to commands(,). Having a separate interface
	;	ensures that the implementation (currently the public array
	;	commands(,)) can be hidden from the callers.
	; COMMON ARGUMENTS:
	; . sec = section
	;	This value corresponds to the first subscript in commands(,)
	; . id = identifier
	;	This value corresponds to the second subscript in commands(,)
	; . val = new value
	;	This parameter is only used in addPSLSetting(,,). It provides
	;	the (new) value for the setting.
	;
	;	The following getters / setters are available:
	;-----------------------------------------------------------------------
	; Assign (new) value
addPSLSetting(sec,id,val)	set commands(sec,id)=val quit  ; public void; assign value 
	;-----------------------------------------------------------------------
	; Obtain setting or "" if setting does not exist
getPSLSetting(sec,id)	quit $get(commands(sec,id)) ; public Primitive; obtain setting 
	;-----------------------------------------------------------------------
	; Does setting exist?
hasPSLSetting(sec,id)	quit $data(commands(sec,id))#2 ; public Boolean; does it exist 
	;
	;-----------------------------------------------------------------------
backup(expr)	;private String; Remove the last command or command delimiter 
	;-----------------------------------------------------------------------
	;
	new i
	for i=$L(expr):-1:0 if '($E(expr,i)=" ") quit
	if $E(expr,i)="," quit $E(expr,1,i-1)		; command delimiter
	;
	for i=i-1:-1:0 quit:$c(9,32)[$E(expr,i)
	quit $E(expr,1,i-1)
	;
	;-----------------------------------------------------------------------
p1append(code)	;private void; Append code after the current command 
	;-----------------------------------------------------------------------
	; Append pass 1 code after the current command on the line that is being
	; constructed.
	;
	; ARGUMENTS:
	; . code = code to insert
	;	The code shall be valid pass 1 code, starting with the SPACE
	;	that preceeds the command word.
	;	If the inserted code ends with an argumentless command, then
	;	code shall end with a single space.
	;
	; INPUTS:
	; type public String pslP1Ap
	;
	set pslP1Ap=pslP1Ap_code
	quit
	;
	;-----------------------------------------------------------------------
p1prepend(code)	;private void; Prepend code before the last command 
	;-----------------------------------------------------------------------
	; Prepend pass 1 code to the current command on the line that is being
	; constructed.
	;
	; ARGUMENTS:
	; . code = code to insert
	;	The code shall be valid pass 1 code, starting with the SPACE
	;	that preceeds the command word.
	;	If the inserted code ends with an argumentless command, then
	;	code shall end with a single space.
	;
	; INPUTS:
	; cmd = current command
	;	Note that cmd contains the full command word, but most command
	;	handlers only insert the abbreviation.
	; mcode = current pass 1 line
	;	The line shall contain the command word and the postconditional
	; postCond = postconditional to current command
	;
	; NOTES:
	; . Earlier versions of the procedure also inserted the code at the
	;	position of the COMMA. This will lead to incorrect results
	;	unless the current command and its postconditional are repeated
	;	(which may be incorrect as well, because it is unknown if the
	;	postconditoinal is repeatable).
	; . The code that uses $REVERSE to locate the command at the end of
	;	mcode is dangerous too:
	;	- it works only for the M standard non-Z commands ($E(cmd)!)
	;	- Constructs in whcih the command argument and the command word
	;		are identical are likely to fail: The PSL construct
	;			if I set X=3
	;		will translate to
	;			space I space I space
	;		So the wrong position will be returned in this case.
	;	As long as p1prepend is called in a limited number of places
	;	(currently only during labelref argument processing) this is OK.
	;	When the compiler is rewritten to support 2 pass constructions,
	;	the commnad word and its postconditional shall not be added to
	;	the "current line" until the entire command has been decomposed.
	;	This will ensure that code can be inserted at well-defined
	;	places in the pass 1 structure.
	;
	; type public String cmd
	; type public String mcode
	; type public String postCond
	;
	new i			; iterator
	;
	; Easy way: try to locate command+postcond from the end
	set i=$FIND($REVERSE($tr(mcode,$C(9)," "))," "_$REVERSE($EXTRACT(cmd)_postCond)_" ")
	if i>0 set i=$LENGTH(mcode)-i+2
	else  do		; Need to try the hard way ...
	.	;
	.	; strip trailing spaces
	.	for i=$L(mcode):-1:0 if '($E(mcode,i)=" ") quit
	.	;
	.	; Back up until the SPACE preceeding the current command
	.	for i=i-1:-1:0 if $c(9,32)[$E(mcode,i) quit
	;
	; Insert the code at the position of the delimiter (SPACE or TAB)
	; and insert a SPACE between the code and the last command
	set mcode=$e(mcode,1,i-1)_code_" "_$E(mcode,i+1,$l(mcode))
	quit
	;
	;-----------------------------------------------------------------------
CVTEFD(expr)	;local String; convert EffectiveDate to use $G 
	;-----------------------------------------------------------------------
	new string
	if expr["%EffectiveDate"  f i=1:1:$l(expr,"%EffectiveDate")-1 do
	.	set string=$P(expr,"%EffectiveDate",1,i)
	.	i $E(string,$L(string)-2,$L(string))="$G(" quit
	.	set expr=$P(expr,"%EffectiveDate",1,i)_"$G(%EffectiveDate)"_$P(expr,"%EffectiveDate",i+1,99)
	quit expr
	;
ET	;
	do ERROR($$ETLOC^%ZT)
	quit
	;
	;-----------------------------------------------------------------------
ZT(vGoto)	;private void; 
	;-----------------------------------------------------------------------
	; General exception handler of PSL compiler. Catches all unhandled
	; exceptions. It calls ERROR() to simulate an ordinary compiler error.
	; Then it will ZGOTO to the $ZLEVEL vGoto-1.
	;
	; Note that this more or less corresponds to the behavior in ZX^UCGMR(),
	; that implements the runtime handling of the CATCH statement.
	;
	new $ZTRAP set $ZTRAP="W ""%PSL-E-FATAL: Unrecoverable fatal error in compiler - QUIT"",! ZGOTO "_(vGoto-1)
	set ER=1
	if $ZSTATUS["%PSL-E-" do ERROR($E($ZSTATUS,$F($ZSTATUS,"%PSL-E-"),$L($ZSTATUS))) if 1
	else  do ERROR($ZSTATUS)
	zgoto vGoto-1
