UCSTAT	;wittef;2008-01-20 22:19:00; Utility Code SYSMAP Statistics for M Routines
	;;Copyright(c)2003 Sanchez Computer Associates, Inc.  All Rights Reserved - 11/05/03 15:11:05 - SPIER
	; ORIG: SPIER - 26 DEC 2002
	; DESC: Generates PSL or M parsed information
	;
	; This program is used to review M routines and generate information
	; about them. This information is stored in the SYSMAP tables, similar
	; to the information gathered for PSL source units.
	;
	; The parser in this routine deals exclusively with M routines.
	; All PSL sources will be processed by the appropriate version of the
	; PSL compiler. Note that this re-compilation will create a new version
	; of the M routine.
	;
	; I18N=QUIT
	;---------- Revision History -------------------------------------------
	; 2009-06-05, Frans S.C. Witte, CR 41003/41004
	;	* corrected spelling errors in label names.
	;
	; 2009-03-02, Frans S.C. Witte, CRs  35741/38252/38491
	;	* Added TRESTART, ZCOMPILE, ZEDIT, ZKILL, ZTSTART, ZTCOMMIT
	;	* Corrected TCOMMIT (must be argless)
	;
	; 2008-10-23, Frans S.C. Witte, CRs 35741/35918
	;	init now instantiates a PSLParser (instead of a PSLCC).
	;
	; 06/14/07 - Frans S.C. Witte - CR: 27800
	;	* Rewrote code that prevents gathering of SYSMAP info for
	;	  routines that were generated from DQ sources (to get rid of
	;	  call to $$isDQsig^UCLABEL())
	;	* Copied addXref from UCGM to work locally on sysmap(,,), and
	;	  modified assignments to sysmap(,,) to confrom to new layout.
	;	* Message.component is now "%M" (was "M").
	;
	; 11/10/06 - Frans S.C. Witte - CRs: 22719 / 20613
	;	* modified init to call UCINIT^UCDTAUTL().
	;	* added labels for ZALLOCATE, ZDEALLOCATE, and ZPRINT
	;
	; 07/11/06 - Frans S.C. Witte - CRs: 22720 / 22274
	;	Added parameter to call of fromSubrou^UCPSLLR().
	;
	; 03/29/06 - Frans S.C. Witte - CRs: 20465 / 18164
	;	* Subroutine MASS: Added call to delAll^UCSYSMAP()
	;	* Subroutine RTNS: Now analyzes all .m files in PRTNS, SRTNS,
	;	  MRTNS, and CRTNS.
	;	* Added subrtoutine msg() and modified ERROR() and WARN() to use
	;	  a group parameter.
	;
	; 06/24/05 - Frans S.C. Witte - CRs: 15592 / 15593
	;	* After consulting with the "SYSMAP owners", it has been decided
	;	  that gathering and storing SYSMAP data is the responsibility
	;	  of the PSL compiler. DQ Procedure UCSYSMAP has been created to
	;	  store the data. This routine creates the same structures as
	;	  the PSL compiler.
	;	* Only the subroutines MASS, RTNS, and rtnInfo are publicly
	;	  accessible.
	;	  The calling sequences and signatures of many of the other
	;	  subroutines have been cleaned (removed unused parameters,
	;	  removed call-levels that did not add functionality).
	;	  All local subroutines that were not called inside UCSTAT have
	;	  been removed.
	;	* Subroutine rtn() now uses $$isDQsig^UCLABEL() to detect if the
	;	  routine is generated by DATA-QWIK. This subroutine is called
	;	  before recompiling DQ Sources. If rtn() erroneously created
	;	  SYSMAP info for a DQ source, this will be corrected when that
	;	  DQ source is recompiled.
	;	* Removed references to primtyp()
	;	* Removed assignment to pslPrsr() nodes that are not M commands.
	;	  Modified pslPrsr() to allow argumentless DO
	;	* Removed code that handles CATCH, THROW, TYPE, WHILE.
	;	* Added public subroutine rtnInfo() to analyze any M routine.
	;
	; 05/12/04 - RussellDS - CR9676
	;	Move Profile04 version to Profile01 to support single code
	;	base for PSL.
	;
	; 05/06/04 - RussellDS - 9172
	;	     Remove use of SQLPARS - obsoleted with changes for filers.
	;
	; 03/11/04 - giridharanb - 8507
	;	     Modified section PSLMAP to correct a typo 'crtns'
	;
	;-----------------------------------------------------------------------
	quit
	;
	;=======================================================================
	; PART 1: Public subroutines and logic that calls main()
	;
	;-----------------------------------------------------------------------
batch(UNIT) ; local ; compile specified DQ Batch unit
	;-----------------------------------------------------------------------
	;
	new AUDIT,$ZTRAP
	set $ZTRAP="ZGOTO "_$ZLEVEL_":batchZT^"_$T(+0)
	set AUDIT=$piece(^DBTBL("SYSDEV",33,UNIT),"|",3,4)
	write !,UNIT,?20,$ZDATE($piece(AUDIT,"|",1)),?40,$piece(AUDIT,"|",2)
	do COMPILE^DBSBCH(UNIT)
	quit
batchZT ; local ; Fatal M error while compiling batch unit
	use $principal if $get(UNIT)'="" write !,UNIT," batch error checking" quit
	write !,$get(LINE)," error checking"
	quit
	;
	;-----------------------------------------------------------------------
file2rtn(FILE) ; public ; extract routine name from file name
	;-----------------------------------------------------------------------
	; This function returns $$PARSE^%ZFUNC(FILE), and translates "_" to "%"
	;
	quit $translate($$PARSE^%ZFUNC(FILE,"NAME"),"_","%")
	;
	;-----------------------------------------------------------------------
MASS	; public ; Mass compile of all DQ and M units, rebuilds all SYSMAP info
	;-----------------------------------------------------------------------
	; This subroutine can be executed from the M direct mode prompt, or be
	; called as a DATA-QWIK function. This subroutine will:
	; * Delete all SYSMAP information
	; * Call public subroutine RTNS^UCSTAT to analyze M routines
	; * Call the DQ Procedure compiler (COMPILE^DBSPROC) for each unit
	;   in DBTBL25, except for procedure names starting with a "Z".
	; * Call the DQ Batch compiler (COMPILE^DBSBCH) for each unit
	;   in DBTBL33, except for batch names starting with a "Z".
	; * Call the DQ Filer compiler (COMPILE^DBSFILB) for each table
	;   in DBTBL7, except for table names starting with a "Z".
	;
	; NOTES:
	; * Because this subroutine calls the compiler entries, new versions of
	;   all Procedures, Batches, and Filers will be generated, and stored.
	;   This will lead to new timestamps and usernames on all underlying M
	;   routines.
	;
	new UNIT
	use $principal write !
	do delAll^UCSYSMAP()
	;
	; Do routines first. All "false negatives" will be corrected when the DQ
	; sources are recompiled: ^UCSYSMAP will rewrite the SYSMAP info.
	do RTNS
	set UNIT=""
	for  set UNIT=$order(^DBTBL("SYSDEV",25,UNIT)) quit:UNIT=""!($extract(UNIT)="Z")  do proc(UNIT)
	set UNIT=""
	for  set UNIT=$order(^DBTBL("SYSDEV",33,UNIT)) quit:UNIT=""!($extract(UNIT)="Z")  do batch(UNIT)
	set UNIT=""
	for  set UNIT=$order(^DBTBL("SYSDEV",7,UNIT)) quit:UNIT=""!($extract(UNIT)="Z")  do table(UNIT)
	quit
	;
	;----------------------------------------------------------------------
proc(UNIT) ; local ; compile specified DQ Procedure unit
	;----------------------------------------------------------------------
	;
	new AUDIT,$ZTRAP
	set $ZTRAP="ZGOTO "_$ZLEVEL_":procZT^"_$T(+0)
	set AUDIT=$piece(^DBTBL("SYSDEV",25,UNIT),"|",2,4)
	write !,UNIT,?20,$ZDATE($piece(AUDIT,"|",2)),?40,$piece(AUDIT,"|",3)
	do COMPILE^DBSPROC(UNIT)
	quit
	;
procZT	; local ; Fatal M error	while compiling DQ Procedure
	use $principal if $get(UNIT)'="" write !,UNIT," procedure error checking" quit
	write !,$get(LINE)," error checking"
	quit
	;
	;----------------------------------------------------------------------
RTNS	; public ; analyze all M routines
	;----------------------------------------------------------------------
	; This subroutine can be executed from the M direct mode prompt, or be
	; called as a DATA-QWIK function. This subroutine will analyze all
	; files with a ".m" extension in the directories named in
	; - $SCAU_MRTNS
	; - $SCAU_SRTNS
	; - $SCAU_PRTNS
	;
	; NOTES:
	; * This subroutine will also analyze M routines that contain the
	;   signature of a DATA-QWIK generated routine, which will overwrite any
	;   information gathered by the PSL compiler. For this reason, the files
	;   in $SCAU_CRTNS will no longer be anaylzed by this subroutine.
	; * The order of the directories is the reverse of the order in which
	;   they occur in $ZROUTINES. This ensures that if a routine exists in
	;   more than one directory, the version that GT.M will invoke will be
	;   analyzed last. So the information in SYSMAP represents the actual
	;   application behavior.
	;
	new DIR,ROUT,UNIT
	use $principal write !,"Routines",!
	;
	for DIR=$$SCAU^%TRNLNM("MRTNS"),$$SCAU^%TRNLNM("SRTNS"),$$SCAU^%TRNLNM("PRTNS") do
	.	if DIR="" quit
	.	set ROUT=$$FILE^%TRNLNM("*.m",DIR)
	.	for  set UNIT=$$SEARCH^%ZFUNC(ROUT,127) quit:UNIT=""  do rtn(UNIT)
	quit
	;
	;----------------------------------------------------------------------
rtn(FILE) ; local ; analyze specified M routine
	;----------------------------------------------------------------------
	;
	new isDQ,src,$ZTRAP
	set $ZTRAP="ZGOTO "_$ZLEVEL_":rtnZT^"_$T(+0)
	use $principal write !,FILE
	set isDQ=$$rtnLoad(FILE,.src)
	if isDQ<0 write !,"PSL-E-ACCESS:",$piece(isDQ,"|",2),! quit
	if isDQ write !,"PSL-I-ACCESS: DATA-QWIK generated routine",!
	;
	; This seems to be a hand-made M routine, analyze it
	do main($$file2rtn(FILE),.src,$$file2rtn(FILE)_"~Routine")
	quit
rtnZT	; local ; Fatal M error while compiling M routine
	use $principal write $get(FILE)," routine error checking",!,$ZSTATUS
	quit
	;
	;----------------------------------------------------------------------
rtn2file(rtn) ; public String ; return default routine file
	;----------------------------------------------------------------------
	;
	new %ZI,%ZR
	set %ZI(rtn)=""
	do INT^%RSEL
	if $data(%ZR(rtn)) quit %ZR(rtn)_$translate(rtn,"%","_")_".m"
	quit ""
	;
	;----------------------------------------------------------------------
rtnInfo(file,info,cco) ; public ; analyze M routine into local info() array
	;----------------------------------------------------------------------
	; Analyze single M source file, and report errors and warnings.
	; Do not generate SYSMAP info, but instead return information in the
	; specified local variable. This subroutine will analyze any M routine
	; (including DQ generated routines).
	;
	; ARGUMENTS:
	; . String file = source file to analyze		/MECH=VAL
	;	including path and extension
	; . String info() = structure to receive results	/NOREQ/MECH=REF:W
	;	On return the info structure will contain the following data:
	;	* info("MSG",rtn,seqnr) = message text
	;		In the same format as cmperr() of main()
	;	* info("LAB",rtn,*) = lab(*)
	;		As produced by main
	;	* info("CAL",rtnCalled,lblCalled,rtn,lbl,at) = actuallist
	;		This information is derived from called() as returned
	;		by main.
	; . Boolean cco() = compiler command options		/NOREQ/MECH=REF:RW
	;	cco("WARN",group) can specify warning groups that need to be
	;	included or ignored. Will be completed by UCINIT^UCDTASYS()
	;
	new cal,isDQ,lab,mes,rtn,src,$ZTRAP
	set $ZTRAP="ZSHOW ""S"" BREAK"
	;;set $ZTRAP="ZGOTO "_$ZLEVEL_":rtnZT^"_$t(+0)
	set isDQ=$$rtnLoad(file,.src)
	if isDQ<0 write !,"PSL-E-ACCESS:",$piece(isDQ,"|",2),! quit
	if isDQ write !,"PSL-I-ACCESS: DATA-QWIK generated routine",!
	set rtn=$$file2rtn(file)
	do main(rtn,.src,.cco,.mes,.lab,.cal)
	;
	; merge results into info
	new act,at,lbl,lblCal,rtnCal
	;
	merge info("MSG",rtn)=mes
	merge info("LAB",rtn)=lab
	;
	; Derive info("CAL") from cal() on a per routine basis.
	set cal=""
	for  set cal=$order(cal(cal)) quit:cal=""  do
	.	set lblCal=$piece(cal,"(")
	.	set act=$extract(cal,$length(lblCal)+1,$length(cal))
	.	set rtnCal=$piece(lblCal,"^",2)
	.	set lblCal=$piece(lblCal,"^")
	.	if rtnCal="" set rtnCal=rtn
	.	if lblCal="" set lblCal=rtnCal
	.	set (lbl,at)=""
	.	for  set lbl=$order(cal(cal,lbl)) quit:lbl=""  do
	..		for  set at=$order(cal(cal,lbl,at)) quit:at=""  do
	...			set info("CAL",rtnCal,lblCal,rtn,lbl,at)=act
	quit
	;
	;----------------------------------------------------------------------
rtnLoad(FILE,into) ; local ; load M routine into array
	;----------------------------------------------------------------------
	; Load M routine (from specified directory) into a local array.
	;
	; ARGUMENTS:
	; . String FILE = name of sourcefile			/MECH=VAL
	;	 including directory and extension
	; . String into() = name of source array		/MECH=REF:W
	;
	; OUTPUTS:
	; $$ -1 If open failed
	;     0 If the element type returned by $$getElement^UCSYSMAP() is
	;	empty, or if it is "routine"
	;     1 if the elementtype is anything else
	; . into() = M source code
	;	lines will be numbered sequentially. TAB will have been converted
	;	to SPACE. CR and LF will have been removed.
	;
	new curIO,elem,line,rec
	set curIO=$io,rec=$$FILE^%ZOPEN(FILE,"READ",,32767)
	if 'rec quit "-1|"_$piece(rec,"|",2)
	;
	use FILE
	for line=1:1 quit:$ZEOF  read rec set into(line)=$translate(rec,$char(9,10,13)," ")
	use curIO close FILE
	set elem=$$getElement^UCSYSMAP($$PARSE^%ZFUNC(FILE))
	if elem=""!($piece(elem,"~",2)="Routine") quit 0
	quit 1
	;
	;----------------------------------------------------------------------
table(UNIT) ; local ; compile specified DQ filer unit
	;----------------------------------------------------------------------
	;
	new %LIBS,PGM,$ZTRAP
	set $ZTRAP="ZGOTO "_$ZLEVEL_":tableZT^"_$T(+0)
	set PGM=$piece($get(^DBTBL("SYSDEV",1,UNIT,99)),"|",2)
	if PGM="" quit
	set %LIBS="SYSDEV"
	do COMPILE^DBSFILB(UNIT)
	quit
tableZT ; local ; Fatal M error while compiling DQ Filer unit
	use $principal if $get(UNIT)'="" write !,UNIT," filer error checking" quit
	write !,$get(LINE)," error checking"
	quit
	;
	;=======================================================================
	; PART 2: cmd(), init(), line(), and main()
	;
	;-----------------------------------------------------------------------
cmd(str,ptr,cmd) ; local ; Next M command
	;-----------------------------------------------------------------------
	; Handles a single argument of a single M command.
	;
	; ARGUMENTS:
	; . String str = line of M code				/MECH=VAL
	; . Number ptr = character pointer			/MECH=REF:RW
	;	Points to character within 'str' where decomposition has to
	;	start. Will be updated by this subroutine to indicate which
	;	part of 'str' has been handled.
	;
	; INPUTS:
	; . String mTSL = tokenized string literals
	; . Number cmdNum = number of command arguments ???
	; . String cmmds() = M command descriptions
	;
	; OUTPUTS:
	; . ER/RM
	;
	new atom,cmdDel,del,postCond
	set atom=$$ATOM^%ZS(str,.ptr,":;,",mTSL)
	;
	if atom=";" set ptr=0 quit			; comment ==> done
	if atom="," do  quit				; Command continuation
	.	;
	.	if cmdNum=1!(ptr=0) do ERROR("SYNTAX","Expression expected") quit
	.	set cmdDel=","
	.	do cmdExpr(str,.ptr,cmd)
	;
	set cmdDel=" "
	;
	set cmd=atom
	if '$$isKwd(.cmmds,.cmd) do ERROR("SYNTAX","Invalid command: "_atom) quit
	;
	set postCond=0
	;
	; Argumentless commmand at end of line
	if ptr=0 do cmdExpr(str,.ptr,cmd) quit
	set ptr=ptr+1,del=$extract(str,ptr)
	;
	if del=":" do  quit:ER
	.	;
	.	if $piece(cmmds(cmd),"|",3) do ERROR("SYNTAX","Invalid post-conditional expression") quit
	.	do condBool($$ATOM^%ZS(str,.ptr,"",,1))
	.	if ER do ERROR("SYNTAX",.RM) quit
	.	set postCond=1
	.	if ptr=0 set del="" quit:$piece(cmmds(cmd),"|",2)
	.	else  set ptr=ptr+1,del=$extract(str,ptr)
	.	if del'=" " do ERROR("SYNTAX","Expression Expected")
	;
	do cmdExpr(str,.ptr,cmd)
	quit
	;
	;-----------------------------------------------------------------------
cmdArg(str,ptr) ; local ; Return command argument expression
	;-----------------------------------------------------------------------
	;
	; ARGUMENTS:
	; . String str = line to be decomposed			/MECH=VAL
	; . Number ptr = character pointer			/MECH=REF:RW
	;
	; OUTPUTS:
	; . $$	= "" if at end-of-line (or when ";" is detected)
	;	= "" if argementless command
	;	= next comma (or space) delimited argument
	;
	new return
	;
	if ptr=0 quit ""
	set return=$extract(str,ptr+1)
	if return=" " set ptr=ptr+1 quit ""     	; Argumentless command
	if return=";" quit ""                   	; M style comment
	set return=$$ATOM^%ZS(str,.ptr,",",,1)
	if ER do ERROR("SYNTAX",.RM)
	quit return
	;
	;-----------------------------------------------------------------------
cmdExpr(str,ptr,cmd) ; local ; Process a command expression e.g. Set abc="string"
	;-----------------------------------------------------------------------
	;
	; ARGUMENTS:
	; . String str = line to be decomposed			/MECH=VAL
	; . Number ptr = character pointer			/MECH=REF:RW
	; . String cmt = nam of M command (full name)		/MECH=VAL
	;
	; PUBLIC:
	; . Number sysmap("T",,) = count of command occurrences
	; . subRou to set sysmap("T",cmd,subRou)
	;
	new indexp,expr
	set expr=$$cmdArg(str,.ptr)
	;
	if expr="",'$piece(cmmds(cmd),"|",2) do ERROR("SYNTAX","Expression expected") quit
	set sysmap("T",subRou,cmd)=$get(sysmap("T",subRou,cmd))+1
	;
	; Command level indirection will be handled here for all commands
	; If any of the test succeeds, we have a case of commandlevel indirection
	; If all fail, indexp is reset to indicate this
	if $extract(expr="@") do  quit:indexp'=""
	.	set indexp=$extract(expr,2,$length(expr))
	.	if $$isGlvn(indexp)
	.	else  if $$isExtr(indexp)
	.	else  if indexp?1"(".E1")"
	.	else  if $$isKwd(.funcs,$piece(indexp,"("))
	.	else  if $$isKwd(.svars,$piece(indexp,"("))
	.	else  set indexp="" quit
	.	do valExpr(indexp,.class)
	;
	do @cmd
	quit
	;
	;-----------------------------------------------------------------------
init(rtn) ; local ; Initialize local structures with module scope
	;-----------------------------------------------------------------------
	; OUTPUTS:
	; . literal String cmmds() = M commands that are recognized
	;	cmmds(fullname) = Abbreviation | Argumentless? | noPostCond?
	; . PSLParser pslPrsr = parser instance
	;	Only the "WARN" subtree is used by this program.
	; . literal String funcs() = M functions that are recognized
	;	funcs(fullname) = Abbreviation | Class | Functiontype
	;	Functiontype has the following meaning:
	;	0 - can only occur in rightexpr, first argument any expression
	;	1 - can only occur in rightexpr, first argument must be M glvn
	;	2 - can occur as 'leftexpr' (i.e. set func(glvn,...)=val is OK)
	; . literal String svars() = M intrinsic special variables that are
	;	recognized
	;	svars(fullname) = Abbreviation | Class | Svntype
	;	Svntype has the following meaning:
	;	0 - svn can only occur in rightexpr (i.e. SET not allowed)
	;	1 - svn can occur as 'leftexpr' (i.e. SET is allowed)
	;	2 - NEW of svn and SET of svn are allowed
	; . literal String tab = TAB-character
	;	Constant used as separator in several structures (e.g. type(,),
	;	and to standardize the whitespace of an M line.
	;
	; NOTES:
	; . This subroutine simulates a Class.new("PSLParser", rtn) by calling
	;	the generated vcdmNew() subroutine, which makes the code
	;	vulnarable to changes to implementation of the Class.new()
	;	method.
	;
	; initialize variables required from DB
	new dummy
	do vcdmNew^PSLParser(.pslPrsr,"PSLParser",rtn)	; !!!!
	do setUcopts^PSLCC(.pslPrsr,"")
	;
	; Adjust warnings for GLOBALs
	do addSetting^PSLCC(.pslPrsr,"WARN","GLOBAL",0)
	;
	; cmmds(full)=abbrev|argless?|nopostcond?
	set cmmds("BREAK")="B|1"
	set cmmds("CLOSE")="C"
	set cmmds("DO")="D|1"
	set cmmds("ELSE")="E|1|1"
	set cmmds("FOR")="F|1|1"
	set cmmds("GOTO")="G"
	set cmmds("HANG")="H|1"
	set cmmds("HALT")="H|1"
	set cmmds("IF")="I|1|1"
	set cmmds("JOB")="J"
	set cmmds("KILL")="K|1"
	set cmmds("LOCK")="L|1"
	set cmmds("MERGE")="M"
	set cmmds("NEW")="N||1"
	set cmmds("OPEN")="O"
	set cmmds("QUIT")="Q|1"
	set cmmds("READ")="R"
	set cmmds("SET")="S"
	set cmmds("TCOMMIT")="TC|1"
	set cmmds("TRESTART")="TRE|1"
	set cmmds("TROLLBACK")="TRO|1"
	set cmmds("TSTART")="TS|1"
	set cmmds("USE")="U"
	set cmmds("VIEW")="V"
	set cmmds("WRITE")="W"
	set cmmds("XECUTE")="X"
	set cmmds("ZALLOCATE")="ZA"
	set cmmds("ZBREAK")="ZB|1"
	set cmmds("ZCOMPILE")="ZCOM"
	set cmmds("ZDEALLOCATE")="ZD"
	set cmmds("ZEDIT")="ZED"
	set cmmds("ZGOTO")="ZG|1"
	set cmmds("ZLINK")="ZL"
	set cmmds("ZKILL")="ZK"
	set cmmds("ZMESSAGE")="ZME"
	set cmmds("ZPRINT")="ZPR|1"
	set cmmds("ZSHOW")="ZSH|1"
	set cmmds("ZSYSTEM")="ZSY"
	set cmmds("ZTCOMMIT")="ZTC|1"
	set cmmds("ZTSTART")="ZTS|1"
	set cmmds("ZWITHDRAW")="ZWI"
	set cmmds("ZWRITE")="ZWR|1"
	;
	; funcs(full)=abbrev|datatype|varAndAssign
	set funcs("$ASCII")="$A|Number|0"
	set funcs("$CHAR")="$C|String|0"
	set funcs("$DATA")="$D|Number|1"
	set funcs("$EXTRACT")="$E|String|2"
	set funcs("$FIND")="$F|Number|0"
	set funcs("$FNUMBER")="$FN|String|0"
	set funcs("$GET")="$G|String|1"
	set funcs("$JUSTIFY")="$J|String|0"
	set funcs("$LENGTH")="$L|Number|0"
	set funcs("$NAME")="$NA|String|1"
	set funcs("$NEXT")="$N|String|1"
	set funcs("$ORDER")="$O|String|1"
	set funcs("$PIECE")="$P|String|2"
	set funcs("$QLENGTH")="$QL|Number|1"
	set funcs("$QSUBSCRIPT")="$QS|String|1"
	set funcs("$QUERY")="$Q|String|1"
	set funcs("$RANDOM")="$R|Number|0"
	set funcs("$REVERSE")="$RE|String|0"
	set funcs("$TEXT")="$T|String|0"
	set funcs("$TRANSLATE")="$TR|String|0"
	set funcs("$RANDOM")="$R|Number|0"
	set funcs("$REVERSE")="$RE|String|0"
	set funcs("$SELECT")="$S|String|0"
	set funcs("$STACK")="$ST|String|0"
	set funcs("$TEXT")="$T|String|0"
	set funcs("$TRANSLATE")="$TR|String|0"
	set funcs("$VIEW")="$V|String|0"
	set funcs("$ZDATE")="$ZD|String|0"
	set funcs("$ZJOBEXAM")="$ZJOBEXAM|String|0"
	set funcs("$ZMESSAGE")="$ZM|String|0"
	set funcs("$ZPARSE")="$ZPARSE|String|0"
	set funcs("$ZQGBLMOD")="$ZQGBLMOD|Boolean|1"
	set funcs("$ZSEARCH")="$ZSEARCH|String|0"
	set funcs("$ZTRNLNM")="$ZTRNLNM|String|0"
	;
	; svars(full)=abbrev|datatype|assignAndNew
	set svars("$DEVICE")="$D|String|0"
	set svars("$ECODE")="$EC|String|1"
	set svars("$ESTACK")="$ES|Number|0"
	set svars("$ETRAP")="$ET|String|1"
	set svars("$HOROLOG")="$H|String|0"
	set svars("$IO")="$I|String|0"
	set svars("$JOB")="$J|Number|0"
	set svars("$KEY")="$K|String|0"
	set svars("$PRINCIPAL")="$P|String|0"
	set svars("$QUIT")="$Q|Boolean|0"
	set svars("$STACK")="$ST|Number|0"
	set svars("$STORAGE")="$S|Number|0"
	set svars("$SYSTEM")="$SY|String|0"
	set svars("$TEST")="$T|Boolean|0"
	set svars("$TLEVEL")="$TL|Number|0"
	set svars("$TRESTART")="$TR|Number|0"
	set svars("$X")="$X|Number|1"
	set svars("$Y")="$Y|Number|1"
	set svars("$ZA")="$ZA|Number|0"
	set svars("$ZB")="$ZB|String|0"
	set svars("$ZCMDLINE")="$ZCMD|String|0"
	set svars("$ZCOMPILE")="$ZCMO|String|1"
	set svars("$ZCSTATUS")="$ZC|Number|0"
	set svars("$ZDATEFORM")="$ZDA|Number|1"
	set svars("$ZDIRECTORY")="$ZDIR|String|1"
	set svars("$ZEDIT")="$ZED|Number|0"
	set svars("$ZEOF")="$ZEOF|Number|0"
	set svars("$ZERROR")="$ZER|String|1"
	set svars("$ZGBLDIR")="$ZG|String|1"
	set svars("$ZININTERRUPT")="$ZINI|Boolean|0"
	set svars("$ZINTERRUPT")="$ZINT|String|1"
	set svars("$ZIO")="$ZIO|String|0"
	set svars("$ZJOB")="$ZJ|Number|0"
	set svars("$ZLEVEL")="$ZL|Number|0"
	set svars("$ZMAXTPTIME")="$ZMAXTPTI|Number|1"
	set svars("$ZMODE")="$ZMO|String|0"
	set svars("$ZPOSITION")="$ZPOS|String|0"
	set svars("$ZPROMPT")="$ZPROM|String|1"
	set svars("$ZROUTINES")="$ZRO|String|1"
	set svars("$ZSOURCE")="$ZSO|String|0"
	set svars("$ZSTATUS")="$ZS|String|1"
	set svars("$ZSTEP")="$ZSTEP|String|1"
	set svars("$ZSYSTEM")="$ZSY|String|0"
	set svars("$ZTEXIT")="$ZTE|Boolean|1"
	set svars("$ZTRAP")="$ZT|String|2"
	set svars("$ZVERSION")="$ZV|String|0"
	set svars("$ZYERROR")="$ZYER|String|1"
	;
	set tab=$char(9)
	quit
	;
	;-----------------------------------------------------------------------
line(rec) ; local ; Parse a line of M code
	;-----------------------------------------------------------------------
	;
	new atom,cmd,cmdNum,dot,ifLevel,forLevel,ptr,mTSL
	;
	set ER=0,ifLevel=0,forLevel=0
	set rec=$$RTRIM^%ZS($translate(rec,tab," "))	; Turn tab's into spaces, trim
	if rec="" quit
	;
	set ptr=0,rec=$$TOKEN^%ZS(rec,.mTSL,"")
	;
	if $extract(rec,1)'=" " do
	.	do subRou($$ATOM^%ZS(rec,.ptr,""),.subRou,.labels,.type)
	.	set (labels(subRou,line),dot)=0
	.	;
	.	; Derive subroutine access from first "word" of comment
	.	new access set access=$$UPCASE($piece($$TRIM^%ZS($piece(rec,";",2))," "))
	.	if access="PUBLIC" set $piece(labels(subRou),tab,2)=2 quit
	.	if access="PRIVATE" set $piece(labels(subRou),tab,2)=1 quit
	.	set $piece(labels(subRou),tab,2)=0
	;
	; Find level of this line, and backup to position ptr at the beginning of
	; the first command.
	else  do
	.	; force comment on dot-only line
	.	if $translate(rec,".")?." " set rec=rec_" ;"
	.	for dot=0:1 set atom=$$ATOM^%ZS(rec,.ptr,".",mTSL) quit:atom'="."!'ptr
	.	set ptr=ptr-$length(atom)
	.	if ptr<0 set rec=" "_atom,ptr=1
	if ptr=0 quit
	;
	; Check for dead code. Suppress warning if line starts with comment
	if subRou="" do:$translate(rec,".")'?1." "1";".E WARN("DEAD","Dead code") quit
	;
	; dot = level of this line,
	; level = level of previous line.
	; if dot < level, then one or more blocks have terminated.
	if dot<level do
	.	if bDoBlock set bDoBlock=0 do WARN("SYNTAX","Code block for argumentless DO expected")
	.	new lvl
	.	for lvl=dot+1:1:level do blockEnd(lvl)
	;
	; If new level is more than one level "deeper" than previous level, it
	; is dead code
	else  if (level+bDoBlock)'=dot do WARN("SYNTAX","Incorrect line level increment")
	if bDoBlock set labels(subRou,line)=dot
	set level=dot,bDoBlock=0
	;
	for cmdNum=1:1 do cmd(rec,.ptr,.cmd) quit:ptr=0!ER
	quit
	;
	;-----------------------------------------------------------------------
main(rtn,msrc,PGM,cmperr,labels,called) ; local ; Main label for routine parsing
	;-----------------------------------------------------------------------
	; Analyze the supplied source array, and generate SYSMAP info for the
	; specified PGM (unit~type combination).
	;
	; ARGUMENTS:
	; . String rtn = name of M routine
	; . String msrc() = source array with M code		/MECH=REF:R
	; . String PGM = name of routine and type unit		/NOREC/MECH=VAL
	;	This information is passed to ^UCSYSMAP.
	;	Is should conform to the conventions that apply to the SYSMAP
	;	decomposition.
	;	If absent or empty, no SYSMAP data will be stored
	; . String cmperr() = compile errors and warnings	/NOREQ/MECH=REF:W
	;	This is an output parameter that will provide the warnings
	;	and errors of the "compilation".
	; . String labels() = subroutine labels			/NOREQ/MECH=REF:W
	;	labels(subRou) = sourceline, access, formallist, chained
	;	* sourceline = line where soubroutine occurs
	;	* access = accessability of subroutine:
	;		0 = local
	;		1 = private
	;		2 = public
	;	* formallist = list of formal parameters (without datatypes)
	;	* chained = preceeding subroutine, if not terminated explicitly
	; . Number labels(,) = dot-level			/NOREQ/MECH=REF:W
	; . String labels(,,) = type data			/NOREQ/MECH=REF:W
	;	labels(subRou,line,leftexpr) = data
	;	* subRou = subroutine where leftexpr occurs
	;	* line = source line number where block starts
	;	* leftexpr = (standardized) variable identification
	;	* data = class, scopeLine, scope, asgnLine, refLine, killLine
	;	* class = derived primitive class. Will usually be "String"
	;	* scopeLine = line where variable is scoped:
	;		if "FORMALRET", then the line where the subroutine occurs
	;		if "PUBLIC", then the line where the subroutine occurs
	;		if "NEW", then the line where the NEW command occurs
	;	* scope = scope of variable (FORMALRET, PUBLIC, NEW)
	;	* asgnLine = highest line number where value was assigned (*1)
	;	* refLine = highest line number where variable was referenced
	;		(*1)
	;	* killLine = highest line number where value was killed (*1)
	;	(*1) For unsubscripted variables, a negative value indicates that
	;		the assignment / reference / kill occurred to a
	;		subscripted node.
	; . String called(,,) = called labelrefs		/NOREQ/MECH=REF:W
	;	called("labelref(t1 p1,t2 p2)",caller,sourceline) = data
	;	* labelref = label or label^routine
	;	* tN = type of Nth parameter (likely to be String)
	;	* pN = name of Nth parameter (possibly a placeholder)
	;	* caller = calling subroutine
	;	* sourceline = line where call occurs
	;	* data = level, ifLevel, , , msrcLineNr
	;
	; OUTPUTS:
	; . This subroutine does not produce outputs, other than those passed by
	;	the procedure arguments. However, it does call ^UCSYSMAP,
	;	which will store SYSMAP info based on the structures provided by
	;	this subroutine.
	;
	; VARIABLES:
	; . ER/RM = Error indicator and error message
	; . Boolean bDoBlock = Argumentless DO indicator
	;	If true, the current line contains an argumentless DO command.
	;	The next line is expected to have a level that is one higher than
	;	the current level.
	; . Number level = DO-level of current line
	;	In order to be able to compare the level of the current line to
	;	the level of the previous line (to detect a new block, or the
	;	the termination of one or more blocks), this value must be
	;	available across calls to line().
	; . Number line = sequential line number within source code
	;	This value will start at one, and will be incremented for each
	;	line.
	; . String lptr = pointer into msrc()
	;	This value contains the subscript of the current line in msrc().
	;	$ORDER() is used to "increment" this variable.
	;	Note that if msrc() contains entries 1:1:max, then lptr = line.
	; . PSLMethod pslPrsr("pslMtd",) = method descriptors of all local and
	;	external labels. Will be filled by calls to ^PSLX.
	; . String sysmap() = SYSMAP info:
	;	sysmap("L",subroutine,0) = TAB noise TAB noise TAB formallist
	;	sysmap("T",subroutine,commandword) = count of commands
	;	sysmap("Gn",subroutine+offset,gvn,seqnr) = PUBLIC, class
	;	sysmap("Vn",subroutine+offset,lvn,seqnr) = scope, class
	;	* n = 0 if referenced, n=1 if set, n=-1 if killed
	;	* scope = "PUBLIC", "FORMALRET", or "NEW"
	;	* class = "String", "Number", or "Boolean"
	; . String subRou = name of current subroutine
	;	Contains the name of the current subroutine, or SPACE if no
	;	subroutine has been detected yet. Note that M does not require
	;	that the first line of a routine has a label.
	; . Number subLine = line number where subRou started
	;	Contains the value of 'line' where subRou was found. It is used
	;	to produce "subroutine relative" line numbers.
	; . String type(,) = data type array
	;	type(newLevel,var) =
	;		class, declLine, scope, asgnLine, refLine, killLine
	;	The order of asgnLine, refLine, and killLine is used by varExpr()
	;	when it calls typeUpd() based on the value of fset !!!!
	;
	; NOTES:
	; . This subroutine shall NEW all variables it uses.
	;
	new ER,RM
	new bDoBlock,cmmds,funcs,level,line,lptr
	new primtyp,pslPrsr,subRou,subLine,svars,sysmap,tab,type
	;
	; initialize variables required from DB
	do init(rtn)
	;
	set level=0
	set lptr="",subRou=" ",subLine=1,bDoBlock=0
	set labels(subRou)=1
	;
	if $$getLabels(.pslPrsr,"^"_rtn)
	;
	for line=1:1 set lptr=$order(msrc(lptr)) quit:lptr=""  do line(msrc(lptr))
	if subRou'="" do line(" Q")
	;
	; FSCW CR15492: storing SYSMAP info is responsibility of ^UCSYSMAP
	; Store only if requested.
	if $g(PGM)]"" do
	.	;
	.	; Save labels info for sysmap
	.	new label
	.	set label="" kill sysmap("L")
	.	for  set label=$order(labels(label)) quit:label=""  set $piece(sysmap("L",label,0),$char(9),4)=$piece(labels(label),$char(9),3)
	.	set sysmap("RTNNAME")=rtn
	.	do ^UCSYSMAP(PGM,.msrc,.sysmap,.cmperr)
	quit
	;
	;=======================================================================
	; PART 3: M Commands
	;
	;-----------------------------------------------------------------------
CLOSE	; local ; M command: CLOSE device:(par1=val1,par2)
	;-----------------------------------------------------------------------
	;
	if expr'[":" do valExpr(expr) quit
	;
	new atom,ptr
	set ptr=0,atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	do valExpr(atom) if ER quit
	if ptr do devPars($extract(expr,ptr+2,$length(expr)))
	quit
	;
	;-----------------------------------------------------------------------
DO	; local; M command: DO label^routine(act1,act2):postcond
	;-----------------------------------------------------------------------
	;
	if expr="" set bDoBlock=1 quit
	;
	if expr'[":" do actual(expr) quit
	;
	new atom,ptr
	set ptr=0,atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	do actual(atom) if ptr do condBool($extract(expr,ptr+2,$length(expr)))
	quit
	;
	;-----------------------------------------------------------------------
ELSE	; local; M command ; Process boolean else
	;-----------------------------------------------------------------------
	;
	set ifLevel=1
	quit
	;
	;-----------------------------------------------------------------------
FOR	; local ; M command; FOR lvn=range,range
	;-----------------------------------------------------------------------
	;
	if cmdDel="," do forRange(expr,0) quit
	;
	set forLevel=1
	;
	if expr="" quit			; Argumentless
	;
	new ptr,var
	;
	set ptr=0
	set var=$$ATOM^%ZS(expr,.ptr,"=",,1)
	if '$$isLvn(var) do ERROR("SCOPE","Local variable expected") quit
	if $extract(expr,ptr+1)'="=" do ERROR("SYNTAX","Equal sign expected") quit
	;
	do forRange(expr,ptr+1)
	quit
	;
	;-----------------------------------------------------------------------
GOTO	; local ; M command: GOTO label+offset^routine:postcond
	;-----------------------------------------------------------------------
	;
	if level do ERROR("SYNTAX","Invalid inside nested structures") quit
	;
	new lblref set lblref=$piece(expr,":")
	;
	if lblref["(" do ERROR("SYNTAX","GOTO does not allow an actuallist") quit
	do actual(lblref)
	if expr[":" do condBool($piece(expr,":",2))
	quit
	;
	;-----------------------------------------------------------------------
IF	; local; M command ; If
	;-----------------------------------------------------------------------
	;
	if expr'="" do condBool(expr)
	set ifLevel=1
	quit
	;
	;-----------------------------------------------------------------------
KILL	; local ; M command: KILL and KILL glvn1,glvn2,(name1,name2)
	;-----------------------------------------------------------------------
	;
	if expr="" do
	.	; set killLine in type() for all leftexprs in scope
	else  if $extract(expr)="(" do
	.	new pos,name
	.	set expr=$extract(expr,2,$length(expr)-1)
	.	for pos=1:1:$length(expr,",") do
	..		set name=$piece(expr,",",pos)
	..		if '$$isName(name) do ERROR("SYNTAX","KILL() requires unsubscripted name: "_name)
	.	; set kill at in type for all leftexprs in scope, except if name in list
	else  if $extract(expr)="@" do
	.	do valExpr($extract(expr,2,$length(expr)))
	else  do varExpr(expr,-1)
	quit
	;
	;-----------------------------------------------------------------------
MERGE	; local ; M command: MERGE glvn1=glvn2
	;-----------------------------------------------------------------------
	;
	new atom,ptr
	set ptr=0,atom=$$ATOM^%ZS(expr,.ptr,"=",,1)
	if ER do ERROR("SYNTAX",.RM) quit
	;
	if $extract(expr,ptr+1)'="=" do ERROR("SYNTAX","Equal sign expected") quit
	set expr=$extract(expr,ptr+2,$length(expr))
	;
	if '$$isGlvn(atom) do ERROR("SYNTAX","MERGE requires variables") quit
	if '$$isGlvn(expr) do ERROR("SYNTAX","MERGE requires variables") quit
	do assign(atom,expr)
	quit
	;
	;-----------------------------------------------------------------------
NEW	; local ; M command: NEW and NEW A,B,(C,D)
	;-----------------------------------------------------------------------
	;
	if $extract(expr)="(" do
	.	set expr=$$POP^%ZS(expr) do WARN("SCOPE","Exclusive NEW ("_expr_")")
	.	new atom,ptr
	.	set ptr=0
	.	for  set atom=$$ATOM^%ZS(expr,.ptr,",",,1) do  quit:ptr=0
	..		;
	..		if atom="," quit
	..		if '$$isName(atom) do ERROR("SCOPE","NEW requires variable name")
	..		if $$typeLvl(atom) ; ensure name occurs in type
	else  if $$isName(expr) do
	.	do typeIns(expr,"String",line,"NEW")
	else  if $$isKwd(.svars,.expr) do
	.	;check if NEW allowed for this svn
	.	if $piece(svars(expr),"|",3)'=2 do ERROR("SCOPE","NEW not allowed for "_expr)
	.	do typeIns(expr,$piece(svars(expr),"|",2),line,"NEW")
	else  do ERROR("SCOPE","Variable expected") quit
	quit
	;
	;-----------------------------------------------------------------------
OPEN	; local ; M command: OPEN device:(par1=val1,par2):timeout
	;-----------------------------------------------------------------------
	;
	; no parameters or timeout
	if expr'[":" do valExpr(expr) quit
	;
	new atom,ptr
	set ptr=0,atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	;
	; device
	do valExpr(atom) if ER quit
	;
	; Looking for device parameters
	set atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	if atom'=":" do ERROR("SYNTAX","colon expected") quit
	set atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	;
	; if not "::", then device paramters are present
	if atom'=":" do devPars(atom) quit:'ptr  set atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	;
	; Looking for timeout
	if atom'=":" do ERROR("SYNTAX","Open timeout expected") quit
	do valExpr($extract(expr,ptr+1,$length(expr)))
	quit
	;
	;-----------------------------------------------------------------------
QUIT	; local ; M command: QUIT or QUIT expr
	;-----------------------------------------------------------------------
	;
	if forLevel do  quit
	.	;
	.	if expr'="" do ERROR("MISMATCH","Unexpected return expression in for loop") quit
	;
	if expr'="" do valExpr(expr)
	;
	if 'ifLevel,'postCond do		; unconditional QUIT from level
	.	;
	.	do blockEnd(level)		; save type() and cleanup
	.	if level>0 set level=level-1	; decrease level
	.	else  set subRou="",ptr=0	; indicate end-of-subrou
	quit
	;
	;-----------------------------------------------------------------------
READ	; local ; M command: READ #!?intexpr,"stringlit",lvn#length:timeout,*lvn
	;-----------------------------------------------------------------------
	;
	do WARN("READ","Restricted command")
	;
	if "!#?"[$extract(expr) do writeFmt(expr) quit
	;
	new atom,newLevel,ptr,var,z
	set ptr=0
	;
	if $extract(expr,1)="*" set expr=$extract(expr,2,$length(expr))
	;
	set atom=$$ATOM^%ZS(expr,.ptr,":#",,1)
	;
	if $$isLit($$UNTOK^%ZS(atom,.mTSL)) quit
	;
	if '$$isLvn(atom) do ERROR("SYNTAX","READ requires local variable") quit
	do varExpr(atom,1)
	;
	if ptr do			; Looking for read x#length:timeout
	.	;
	.	set atom=$$ATOM^%ZS(expr,.ptr,":#",,1)
	.	if '(":#"[atom) do ERROR("SYNTAX","Read length or timeout expected") quit
	.	set atom=$$ATOM^%ZS(expr,.ptr,":#",,1)
	.	do valExpr(atom)
	if ptr do			; Looking for read x:timeout
	.	;
	.	set atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	.	if '(":"[atom) do ERROR("SYNTAX","Read timeout expected") quit
	.	set atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	.	do valExpr(atom)
	;
	quit
	;
	;-----------------------------------------------------------------------
SET	; M command ; Process the set command
	;-----------------------------------------------------------------------
	;
	new atom,ptr
	set ptr=0,atom=$$ATOM^%ZS(expr,.ptr,"=",,1)
	if ER do ERROR("SYNTAX",.RM) quit
	;
	if $extract(expr,ptr+1)'="=" do ERROR("SYNTAX","Equal sign expected") quit
	set expr=$extract(expr,ptr+2,$length(expr))
	;
	if $extract(atom)="@" set atom=$extract(atom,2,$length(atom))
	;
	if $extract(atom)="(" do			; set (v1,v2,vn)=val
	.	;
	.	if $extract(atom,$length(atom))'=")" do ERROR("SYNTAX","Parenthesis expected") quit
	.	;
	.	new atoms
	.	set atoms=$extract(atom,2,$length(atom)-1),ptr=0
	.	if atoms="" do ERROR("SYNTAX","Expression expected") quit
	.	;
	.	for  set atom=$$ATOM^%ZS(atoms,.ptr,",",,1) do  quit:ptr=0!ER
	..		if atom'="," do assign(atom,expr)
	;
	else  do assign(atom,expr)
	quit
	;
	;-----------------------------------------------------------------------
TCOMMIT ; local ; M command: TCOMMIT
TRESTART ; local ; M command: TRESTART
ZTSTART ; local ; M command: ZTSTART
	;-----------------------------------------------------------------------
	if expr'="" do ERROR("SYNTAX",cmd_" must be argumentless")
	quit
	;
	;-----------------------------------------------------------------------
USE	; local ; M command: USE device:(par1=val1,par2)
	;-----------------------------------------------------------------------
	; USE has same syntax as CLOSE
	;
	goto CLOSE
	;
	;-----------------------------------------------------------------------
VIEW	; local ; M command: VIEW expr1[:[expr2]...]
	;-----------------------------------------------------------------------
	;
	new atom,ptr
	set ptr=0
	for  do  quit:ptr=0
	.	set atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	.	if atom=":" quit
	.	do valExpr(atom)
	quit
	;-----------------------------------------------------------------------
WRITE	; local ; M command: WRITE #!!?intexpr,*intexpr,expr
	;-----------------------------------------------------------------------
	;
	if "#!?"[$extract(expr) do writeFmt(expr) quit
	if $extract(expr)="*" do valExpr($extract(expr,2,$length(expr))) quit
	do valExpr(expr)
	quit
	;
	;-----------------------------------------------------------------------
ZGOTO	; local ; M command: ZGOTO intexpr:entryref:postcond
	;-----------------------------------------------------------------------
	;
	; NOTES:
	; * The call to actual() implies that an actuallist is accepted even
	;	though GT.M does not allow that. Since this routine is an
	;	analyzing tool, and not a syntax checker, this is acceptable.
	;
	new atom,ptr
	set ptr=0,atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	;
	; level
	do valExpr(atom) if ER quit
	;
	; Looking for entryref
	if ptr do
	.	set atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	.	if atom'=":" do ERROR("SYNTAX","colon expected") quit
	.	;
	.	; obtain and handle entryref
	.	set atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	.	do actual(atom) quit:ptr=0!ER
	.	;
	.	; Looking for postcond
	.	set atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	.	if atom'=":" do ERROR("SYNTAX","colon expected") quit
	.	;
	.	; handle postcond
	.	do condBool($extract(expr,ptr+1,$length(expr))) quit:ER
	.	set postCond=1
	if 'postCond,'forLevel,'ifLevel do
	.	set expr=""
	.	for  do QUIT quit:subRou=""
	quit
	;
	;-----------------------------------------------------------------------
ZKILL	; local ; M command: ZKILL glvn1,glvn2
	;-----------------------------------------------------------------------
	;
	do varExpr(expr,-1)
	quit
	;
	;-----------------------------------------------------------------------
ZLINK	; local ; M command: ZLINK expr:expr
	;-----------------------------------------------------------------------
	;
	; no parameters
	if expr'[":" do valExpr(expr) quit
	;
	new atom,ptr
	set ptr=0,atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	;
	; routine to ZLINK
	do valExpr(atom) if ER quit
	;
	; Looking for compile parameters
	set atom=$$ATOM^%ZS(expr,.ptr,":",,1)
	if atom'=":" do ERROR("SYNTAX","colon expected") quit
	do valExpr($extract(expr,ptr+1,$length(expr)))
	quit
	;
	;-----------------------------------------------------------------------
ZSYSTEM ; local ; M command: ZSYSTEM expr
	;-----------------------------------------------------------------------
	;
	do valExpr(expr)
	quit
	;
	;-----------------------------------------------------------------------
ZWITHDRAW ; local ; M command: ZWITHDRAW glvn
	;-----------------------------------------------------------------------
	;
	do varExpr(expr,-1)
	quit
	;
	;=======================================================================
	; PART 4: supporting subroutines and functions in alphabetic order
	;
	;-----------------------------------------------------------------------
actual(expr) ; Process actual parameters
	;-----------------------------------------------------------------------
	;
	new act,atom,byRef,class,name,ptr,tag
	;
	set tag=$piece(expr,"("),expr=$extract(expr,$length(tag)+1,$length(expr))
	if tag["@" set tag=$$UNTOK^%ZS(tag,.mTSL)
	;
	if "()"[expr do called(tag_expr) quit
	if '($extract(expr)="("&($extract(expr,$length(expr))=")")) do ERROR("SYNTAX","Parenthesis expected") quit
	;
	set expr=$extract(expr,2,$length(expr)-1)
	;
	set (act,ptr)=0,tag=tag_"("
	;
	for  set atom=$$ATOM^%ZS(expr,.ptr,",",,1) do  quit:ptr=0!ER
	.	;
	.	if atom="," set tag=tag_"," quit
	.	;
	.	set act=act+1
	.	if $extract(atom)=".",$extract(atom,2)'?1N do
	..		set name=atom,atom=$extract(atom,2,$length(atom))
	..		if '$$isName(atom) do ERROR("MISMATCH","pass-by-name requires M name")
	..		if $data(byRef(atom)) do ERROR("MISMATCH","Illegal multiple reference: "_atom)
	..		set byRef(atom)=""
	..		do varExpr(atom,1,.class)
	.	else  do
	..		if $$isLvn(atom) set name=$piece(atom,"(")
	..		else  set name="val"_act
	..		do valExpr(atom,.class)
	.	;
	.	set tag=tag_class_" "_name
	;
	if ER quit
	;
	do called(tag_")")
	quit
	;
	;-----------------------------------------------------------------------
addXref(topic,ref,val) ;local void; Add to sysmap(,,)
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String topic = topic				/MECH=VAL
	;	as required by UCSYSMAP
	; . String ref = third level subscript			/MECH=VAL
	;	as required by UCSYSMAP
	; . String val = value to store in sysmap(,,)		/MECH=VAL
	;	as required by UCSYSMAP
	;
	new loc
	set loc=$piece(subRou,"(",1)_"+"_(line-subLine)
	set sysmap(topic,loc,ref)=val
	quit
	;
	;-----------------------------------------------------------------------
assign(var,expr) ; local ; handle M assignment expression
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String var = leftexpr				/MECH=VAL
	;	The target of the assignment. If it is a function, then
	;	subroutine valFunc(var,1,clsR) is called, else
	;	varExpr(var,1,clsR) is called.
	; . String expr = rightexpr				/MECH=VAL
	;	The value to be assigned. This subroutine will call
	;	valExpr(expr,0,.clsR) to decompose the rightexpr, and obtain the
	;	class of the result.
	;
	; INPUTS:
	; . String funcs() = M intrinsic function keywords
	;
	; NOTES:
	; . Assignments to M special variables are handled by varExpr()
	;
	new clsR
	;
	; handle right side first, this provides the class of the result (clsR)
	do valExpr(expr,.clsR)
	if clsR="" do ERROR("SCOPE","Expression must return a class: "_expr) quit
	;
	if $$isKwd(.funcs,$piece(var,"(")) do valFunc(var,1,clsR) quit
	do varExpr(var,1,clsR)
	quit
	;
	;-----------------------------------------------------------------------
blockEnd(level) ; local ; handle end-of-block
	;-----------------------------------------------------------------------
	; This procedure copies the information from type(level) into the
	; structure labels(subRou,line) where line is the line where the block is
	; started.
	;
	; ARGUMENTS:
	; . level = level to terminate
	;
	; INPUTS:
	; . type(level,leftexpr) = data
	; . labels(subRou,line) = level
	;
	; OUTPUTS:
	; . type(level) killed
	; . labels(subRou,line,leftexpr) = data
	;
	new ln set ln=""
	;
	; search in labels(,) for the line that started this level
	for  set ln=$order(labels(subRou,ln)) quit:ln=""  quit:labels(subRou,ln)=level
	if ln="" set ln=line,labels(subRou,ln)=level		; ???
	merge labels(subRou,ln)=type(level)
	kill type(level)
	;
	; If no new leftexprs for this block, remove its reference.
	; This will keep the structure clean.
	if $data(labels(subRou,ln))<10 kill labels(subRou,ln)
	quit
	;
	;-----------------------------------------------------------------------
called(tag) ; local; Build Call stack structure and validate call
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . tag = called tag, with label and all actual parameter signatures
	;
	; INPUTS:
	; . line = m source line number (used by SYSMAP to denote the line)
	; . subRou = calling subroutine
	; . tab = TAB character
	;
	; OUTPUTS:
	; . called(tag,subRou,line) = ""
	; . sysmap("C",subRou+offset,lbl^rtn)=params
	; . pslPrsr("pslMtd",*) for all labels in rtn will exist
	;
	new tagrtn,params
	set called(tag,subRou,line)=""
	;
	set tagrtn=$piece(tag,"(",1)
	set params=$extract(tag,$length(tagrtn)+1,32767)
	do addXref("C",tagrtn,$extract(params,2,$length(params)-1))
	;
	; Validate the call (if possible). A routine-not-found warning will have
	; been provided by $$getlabels() if applicable
	if $$getLabels(.pslPrsr,tagrtn)=2 quit
	;
	; check label
	new mtd set mtd=$piece(tagrtn,"^",2)_"."_$piece(tagrtn,"^")
	set:$extract(mtd)="." mtd=pslPrsr("moduleName")_mtd
	set:$extract(tagrtn)="^" mtd=mtd_$piece(tagrtn,"^",2)
	if '$data(pslPrsr("pslMtd",mtd)) do WARN("MISMATCH","subroutine "_tagrtn_" not found") quit
	;
	; check number of parameters (if any). Do not check an absent ap list,
	; because the tag may be from a $$lbl^rtn call without the empty list
	quit:$translate(params,"()")=""
	new apcnt,fpcnt
	set apcnt=$length(params,",")
	set fpcnt=$$getFpCount^PSLMethod(pslPrsr("pslMtd",mtd))
	if apcnt>fpcnt do WARN("MISMATCH","more actual parameters ("_apcnt_") than formal parameters ("_fpcnt_")")
	quit
	;
	;-----------------------------------------------------------------------
clsAsgn(clsL,clsR) ; local ; are classes assignment compatible
	;-----------------------------------------------------------------------
	; Check if clsR can be assigned to clsL.
	; Both clsL and clsR shall be one of the basic M types:
	; "String", "Number", or "Boolean".
	;
	; ARGUMENTS:
	; . clsL = class of leftexpr				/MECH=VAL
	; . clsR = class of rightexpr				/MECH=VAL
	;
	if clsL="String" quit 1
	if clsL="Number" quit clsR'="String"
	quit clsR="Boolean"
	;
	;-----------------------------------------------------------------------
clsBinEx(clsL,oper,clsR) ; local ; derive type of binary operation
	;-----------------------------------------------------------------------
	; This subroutine shall be called after each operand as been decomposed.
	; The first call will have 'clsL' is empty. If 'oper' is not empty in
	; that case, 'open' contains unary operators (not, plus or minus).
	; Successive calls will pass non-empty valaues for all parameters.
	; Unary operators that apply to clrR will occur at the end of 'oper'.
	;
	; ARGUMENTS:
	; . clsL = class of left side of operation		/MECH=REF:RW
	;	May be empty on entry.
	;	On exit it will contain the result type after applying oper.
	; . oper = operation					/MECH=REF:RW
	;	May be empty on entry, provided clsL is empty as well.
	;	Will be "" on exit.
	; . clsR = class of left side of operation		/MECH=REF:RW
	;	Shall be non-empty in all cases.
	;	Will be "" on exit.
	;
	new p
	;
	; First pass requires special treatment
	if clsL="" do
	.	;
	.	; handle unary operators: strip right-to-left, force type of clsR
	.	if oper'="" do
	..		for p=$length(oper):-1:1 set clsR=$select($extract(oper,p)="'":"Boolean",1:"Number")
	.	set clsL=clsR,(oper,clsR)=""
	if clsR="" quit
	;
	; second and following passes
	; Strip trailing unary oprators: they don't influence the result class
	if $length(oper)>1 do
	.	;
	.	; terminates with p>=1, so oper will be non-empty afterwards
	.	for p=$length(oper):-1:1 quit:"+-'"'[oper
	.	set oper=$extract(oper,1,p)
	if oper="_" set clsL="String"
	else  if "+-*/\#"[oper set clsL="Number"
	else  set clsL="Boolean"
	set (oper,clsR)=""
	quit
	;
	;-----------------------------------------------------------------------
clsOrd(clsL,clsR) ; local ; Return relative class order
	;-----------------------------------------------------------------------
	; Compare "order" of classes, using "Boolean" < "Number" < "String"
	;
	; ARGUMENTS:
	; . clsL = class of leftexpr				/MECH=VAL
	; . clsR = class of rightexpr				/MECH=VAL
	;
	; OUTPUTS:
	; . $$ = -1 if clsL < clsR (clsL is subtype of clsR)
	;	0 if clsL = clsR
	;	1 if clsL > clsR (clsR is supertype of clsR)
	;
	new numL,numR
	set numL=$$listPos("Boolean,Number,String",clsL)
	set numR=$$listPos("Boolean,Number,String",clsR)
	quit $select(numL<numR:-1,1:numL>numR)
	;
	;-----------------------------------------------------------------------
condBool(expr) ; local ; Evaluate boolean conditions
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String expr = expression to evaluate		/MECH=VAL
	;
	if expr="" do ERROR("SYNTAX","Expression expected") quit
	;
	new atom,del,ptr
	;
	set ptr=0
	set del="!&'"
	;
	for  set atom=$$ATOM^%ZS(expr,.ptr,del,,1) do  quit:ptr=0
	.	;
	.	if ER do ERROR("SYNTAX",.RM) quit
	.	if del[atom quit
	.	if $$POP^%ZS(atom)'=atom do condBool($$POP^%ZS(atom)) quit
	.	;
	.	do condRel(atom)
	quit
	;
	;-----------------------------------------------------------------------
condRel(expr) ; local ; Parse relational clauses
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . expr = expression to decompose			/MECH=VAL
	;
	if expr="" do ERROR("SYNTAX","Expression expected") quit
	;
	new atom,class,del,ptr
	;
	set ptr=0
	set del="[]&!<>='?"
	;
	for  set atom=$$ATOM^%ZS(expr,.ptr,del,,1) do  quit:ptr=0
	.	;
	.	if ER do ERROR("SYNTAX",.RM) quit
	.	;;if atom="?" new z set z=$$ATOM^%ZS(expr,.ptr,"&!",,1)
	.	if atom="?" new z set z=$$ATOM^%ZS(expr,.ptr,del,,1) quit
	.	if del[atom quit
	.	do valExpr(atom,.class)
	quit
	;
	;-----------------------------------------------------------------------
devPars(expr) ; local ; Parse device parameters: (par1=val1:par2)
	;-----------------------------------------------------------------------
	;
	new atom,par,ptr
	if $extract(expr)="(",$extract(expr,$length(expr))=")" set expr=$extract(expr,2,$length(expr)-1)
	;
	set ptr=0
	for  set atom=$$ATOM^%ZS(expr,.ptr,":",,1) do  quit:'ptr
	.	if atom=":" quit
	.	set par=$piece(atom,"=")
	.	if '$$isName(par) do ERROR("SYNTAX","device keyword expected: "_par)
	.	if atom["=" do valExpr($extract(atom,$find(atom,"="),$length(atom)))
	quit
	;
	;-----------------------------------------------------------------------
ERROR(grp,msg) ; local ; Report Compiler Error
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . message = error message				/MECH=VAL
	;
	; INPUTS:
	; . public Number ER = previous error
	;	If ER=2 when this procedure is called, it will quit immediately
	;	Otherwise this procedure will SET ER=2. This prevents repeated
	;	errormessages for a single line.
	;
	; OUTPUTS:
	; . public Number ER = 2
	;
	if $get(ER)=2 quit
	set ER=2
	;
	do msg(grp,msg,2)
	quit
	;
	;-----------------------------------------------------------------------
forRange(expr,ptr) ; local ; range in FOR command: init[:increment[:end]]
	;-----------------------------------------------------------------------
	;
	new atom,argNum,class
	;
	set argNum=0
	;
	for  set atom=$$ATOM^%ZS(expr,.ptr,":",,1) do  quit:ptr=0!ER
	.	;
	.	if atom=":" set argNum=argNum+1 quit
	.	if argNum=3 do ERROR("SYNTAX","Space character expected") quit
	.	do valExpr(atom,.class)
	quit
	;
	;-----------------------------------------------------------------------
getGlvnT(expr) ; local ; get M glvn type
	;-----------------------------------------------------------------------
	; Returns an indication of the kind of expr:
	; 0 = expr is not a glvn
	; 1 = expr is subscripted lvn
	; 2 = expr is an unsubscripted lvn
	; 3 = expr is a subscripted gvn
	; 4 = expr is an unsubscripted glvn
	;
	if '$$isGlvn(expr) quit 0
	new ret
	if $extract(expr)="^" set ret=3
	else  set ret=1
	if expr'["(" set ret=ret+1
	quit ret
	;
	;-----------------------------------------------------------------------
getLabels(pslPrsr,lblref) ;local Number; Add labels to lblRec()
	;-----------------------------------------------------------------------
	; Add the labels of the routine specified by lblref to pslPrsr(,) and
	; return an error indicator.
	;
	; OUTPUT:
	; . $$ = error level
	;	0 = no error, labels are present.
	;		This value will also be returned when lblref does not
	;		specify a routinename.
	;	1 = no source found
	;		This value indicates that a routine with this name was
	;		found, but that it was impossible to trace the routine
	;		back to a PSL source.
	;		pslPrsr("pslMtd") will contain the PSLMethods, but the
	;		declarations are based on the M routine.
	;	2 = no routine found
	;		This value will be returned when no M file could be
	;		found.
	;		lblRec() will not have been modified.
	;		This value will also be returned when lblref contains
	;		indirection
	;
	if lblref["@" quit 2
	if lblref'["^" quit 0
	new rtn set rtn=$piece(lblref,"^",2)
	if $data(pslPrsr("pslCls",rtn)) quit 1
	if '$$VALID^%ZRTNS(rtn) do WARN("MISMATCH","Routine "_rtn_" not found") quit 2
	new pslx
	do vcdmNew^PSLX(.pslx,"PSLX",rtn),fromTarget^PSLX(.pslx) ; !!!!
	set pslPrsr("pslCls",rtn)=pslx("pslCls",rtn)
	merge pslPrsr("pslMtd")=pslx("pslMtd")
	quit 1
	;
	;-----------------------------------------------------------------------
isExp(expr) ; local ; is expr a number in exponential notation
	;-----------------------------------------------------------------------
	; In order to qualify, the part before the "E" must be a fraction, and
	; the part after the first "E" must consist of an optional dash and 1 or
	; more digits.
	;
	quit $$isFrac($piece(expr,"E"))&($piece(expr,"E",2,999)?.1"-"1.N)
	;-----------------------------------------------------------------------
isExtr(expr) ; local ; is expr an extrinsic function
	;-----------------------------------------------------------------------
	; The validation is rather minimal. Only the part preceeding the "(" is
	; validated.
	;
	set expr=$translate($piece(expr,"("),"%@","AA")
	quit (expr?1"$$"1.AN)!(expr?1"$$".AN1"^"1.AN)
	;
	;-----------------------------------------------------------------------
isFrac(expr) ; local ; is expr a fractional number
	;-----------------------------------------------------------------------
	; helper function, called by $$isExp() and $$isNum().
	;
	quit expr?.1"-".N.1"."1.N
	;
	;-----------------------------------------------------------------------
isGlvn(expr) ; local ; is expr a valid M glvn ((un)subscripted global or local)
	;-----------------------------------------------------------------------
	; For gvn: replace "^" by "A". This translates naked references into
	; normal local references and is harmless for full gobal references
	;
	if $extract(expr)="^" quit $$isLvn("A"_$extract(expr,2,$length(expr)))
	quit $$isLvn(expr)
	;
	;-----------------------------------------------------------------------
isKwd(kws,kwd) ; local ; lookup and translate a keyword
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . $$	1 if keyword or its abbreviation occurs in kws()
	;	0 otherwise
	; . String kws() = keyword structure			/MECH=REF:R
	;	kws(keyword) = abbreviation | other | data
	;	only the first bar delimited piece is used here
	; . String kwd = keyword to look for			/MECH=REF:RW
	;	Either the complete keyword or its abbreviation
	;	If passed-by-reference, it will receive the complete
	;	keyword in uppercase.
	;
	set kwd=$$UPCASE(kwd)
	if $data(kws(kwd)) quit 1
	;
	new z set z=kwd
	for  set z=$order(kws(z)) quit:$extract(z,1,$length(kwd))'=kwd  if $piece(kws(z),"|")=kwd set kwd=z quit
	quit z=kwd
	;
	;-----------------------------------------------------------------------
isLit(expr) ; local ; is expr a stringliteral or numeric literal
	;-----------------------------------------------------------------------
	;
	quit expr?1"""".E1""""!$$isNum(expr)
	;
	;-----------------------------------------------------------------------
isLvn(expr) ; local ; is expr a valid M lvn (subscripted or unsubscripted)
	;-----------------------------------------------------------------------
	;
	if '$$isName($piece(expr,"(",1)) quit 0		; Not valid M name
	new y
	set y=$find(expr,"(") if y=0 quit 1		; unsubscripted is OK
	set y=y+1					; Reject ()
	for  set y=$find(expr,")",y)  quit:y=0!($length($extract(expr,1,y-1),"(")=$length($extract(expr,1,y-1),")"))
	quit $length(expr)+1=y
	;
	;-----------------------------------------------------------------------
isName(expr) ; local ; is expr a valid M name
	;-----------------------------------------------------------------------
	; An expr is a valid variable if it starts with an alpha or percentsign,
	; and is folllowed by zero or more alphanumerics.
	; Or if expr starts with the indirection character ("@"), and the
	; remainder is a variable.
	;
	quit expr?1A.AN!(expr?1"%".AN)!($extract(expr)="@"&$$isName($extract(expr,2,$length(expr))))
	;
	;-----------------------------------------------------------------------
isNum(expr) ; local ; is expr an M numeric value
	;-----------------------------------------------------------------------
	; true if it is a fractional number or a number in exponential notation
	;
	quit $$isFrac(expr)!$$isExp(expr)
	;
	;-----------------------------------------------------------------------
listAdd(L,V) ; local ; List.add()
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . List L = original value				/MECH=VAL
	; . String V = value to add				/MECH=VAL
	;	The value shall not contain comma's
	;
	if L="" quit V
	if V="" quit L
	if $$listCont(L,V) quit L
	quit L_","_V
	;
	;-----------------------------------------------------------------------
listCont(L,V) ; local ; List.contains()
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . List L = list (comma separated)
	; . String V = value
	;
	quit ","_L_","[(","_V_",")
	;
	;-----------------------------------------------------------------------
listPos(L,V) ; local ; List.position()
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . List L = list (comma separated)
	; . String V = value
	;
	quit $length($piece(","_L_",",","_V_","),",")
	;
	;-----------------------------------------------------------------------
msg(grp,msg,sev) ; local ; Report a message
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; .grp = group						/MACH=VAL
	;	An existing PSL WARN group
	; . msg = tokenized message				/MECH=VAL
	;	All tokens are supposed to be from the current source line, and
	;	available through mTSL
	; . sev = severity
	;	0 = informational
	;	1 = warning
	;	2 = error
	;
	; INPUTS:
	; . public Number lptr = source line subscripts
	;	This variable is optional. If absent or "", zero will be used
	; . public String msrc() = M source array
	;	Only msrc(lptr) is referenced, and the node need not exist
	; . public String mTSL = tokenized string literals
	;	Optional, passed to $$UNTOK^%ZS() to untokenize the message
	; . PGM = SYSMAP identification
	;	If present and non-empty, the warning will be listed on the
	;	principal device. If absent or empty, output is suppressed.
	;	cmperr() is filled independent of the value of PGM.
	;
	; OUTPUTS:
	; . cmperr() = message array.
	;	This procedure adds 4 nodes at the end of cmperr()
	;	* a separator line
	;	* the source line where the message applies
	;	* the message
	;	* the location (line + subroutine) where the message applies
	;
	new erline1,erline2,erline3
	;
	set erline1=$translate($get(msrc(+$get(lptr))),$char(9)," ")
	set erline2="%M-"_$extract("IWE",sev+1)_"-"_grp_": "_$$UNTOK^%ZS(msg,.mTSL)
	set erline3="At source line: "_$get(lptr)
	;
	if $get(PGM)]"" do
	.	use $principal
	.	write !,erline1,!
	.	write erline2,!
	.	write erline3,!
	;
	set cmperr($order(cmperr(""),-1)+1)="++++++++++++++++++++++"
	set cmperr($order(cmperr(""),-1)+1)=erline1
	set cmperr($order(cmperr(""),-1)+1)=erline2
	set cmperr($order(cmperr(""),-1)+1)=erline3
	quit
	;
	;-----------------------------------------------------------------------
subRou(expr,subRou,labels,type) ; local ; Set up a subroutine
	;-----------------------------------------------------------------------
	;
	; ARGUMENTS:
	; . String expr = first expression of line		/MECH=VAL
	;	(label or label + parameterlist)
	; . String subRou = current subroutine			/MECH=REF:RW
	; . String labels() = label array			/MECH=REF:RW
	; . String type() = type array				/MECH=REF:R
	;
	; INPUTS:
	; . line = source line number
	; . lptr = source line subscript
	; . level = DO-level
	;
	; OUTPUTS:
	; . labels(label)= sourceline, , formallist
	;
	new return set return=$piece(expr,"(")
	;
	if $data(labels(return)) do ERROR("MISMATCH","Label already exists: "_return) quit
	set labels(return)=line_tab_tab_$extract(expr,$length(return)+1,$length(expr))
	set subLine=line
	;
	if " "'[subRou do
	.	do WARN("SCOPE","label inside subroutine: "_subRou)
	.	set $piece(labels(return),tab,4)=subRou
	.	do called(return)	; treat as if new label called by subRou
	;
	set subRou=return,expr=$extract(expr,$length(return)+2,$length(expr)-1)
	;
	if expr="" quit
	;
	new ptr,var
	;
	; use 'return' to check for duplicate names in formallist
	set return="",ptr=0
	;
	for  set var=$$ATOM^%ZS(expr,.ptr,",") do  if ptr=0!ER quit
	.	;
	.	if var="," set return=return_var quit
	.	;
	.	if $$listCont(return,var) do ERROR("SCOPE","Parameter "_var_" is multiply defined") quit
	.	if '$$isName(var) do ERROR("SCOPE","Variable expected") quit
	.	;
	.	do typeIns(var,"String",line,"FORMALRET")
	.	set return=return_var
	quit
	;
	;-----------------------------------------------------------------------
typeAsgn(leftexpr) ; local ; register assignment to leftexpr in type()
	;-----------------------------------------------------------------------
	; This subroutine calls typeUpd(leftexpr,4)
	;
	; ARGUMENTS:
	; . leftexpr = the leftexpr (variable / property) that is the target of
	;	the assignment
	;
	do typeUpd(leftexpr,4)
	quit
	;
	;-----------------------------------------------------------------------
typeGet(leftexpr,pos) ; local ; get value from field of type()
	;-----------------------------------------------------------------------
	; This subroutine returns the value of the supplied field.
	;
	; ARGUMENTS:
	; . leftexpr = the leftexpr to retrieve			/MECH=VAL
	;	The value shall be standardized (all subscript expressions
	;	removed)
	; . pos = position of field to be modified		/MECH=VAL
	;	1 = class
	;	2 = declLine
	;	3 = scope
	;	4 = asgnLine
	;	5 = refLine
	;	6 = killLine
	; INPUTS:
	; . level = current DO-level
	; . line = current source line
	;
	; OUTPUTS:
	; . $$ = $PIECE(type(lvl,leftexpr),tab,pos)
	;	Where 'lvl' is the "deepest" level where 'leftexpr' is declared.
	; . If 'leftexpr' did not occur in type(), then it (and possibly its
	;	name) will have been inserted.
	;
	; NOTES:
	; . The call to $$typeLvl() will ensure the entry is correctly defined.
	;
	quit $piece($get(type($$typeLvl(leftexpr),leftexpr)),tab,pos)
	;
	;-----------------------------------------------------------------------
typeIns(leftexpr,class,newPtr,scope) ; local ; insert new entry in type()
	;-----------------------------------------------------------------------
	; This subroutine inserts a complete new variable in the type() array.
	; It will be inserted at the current level.
	;
	; ARGUMENTS:
	; . leftexpr = the leftexpr (variable / property) to be inserted
	; . class = the class of the leftexpr
	; . newPtr = msrc where scoped
	; . scope = scope of leftexpr
	;
	; INPUTS:
	; . level = current DO-level
	;
	set type(level,leftexpr)=class_tab_newPtr_tab_scope
	quit
	;
	;-----------------------------------------------------------------------
typeLvl(leftexpr) ; local ; return the level at which the leftexpr occurs in type
	;-----------------------------------------------------------------------
	; This function returns the highest level where the variable name of
	; leftexpr occurs. If the name does not occur at all, the name will be
	; inserted as if the variable was declared "public String" at the
	; subroutine label.
	; If the leftexpr does not occur at the level of the name, then the entry
	; is created with the same settings as the name.
	;
	new lvl,name
	set name=$piece(leftexpr,"(")
	for lvl=level:-1:0 quit:$data(type(lvl,name))
	;
	; If not found, insert at level=0
	if '$data(type(lvl,name)) new level set level=0 do typeIns(name,"String",subLine,"PUBLIC")
	;
	; If type() for subscripted leftexpr does not exist, copy it
	; from the definition of the unsubscripted name.
	if '$data(type(lvl,leftexpr)) set type(lvl,leftexpr)=type(lvl,name)
	quit lvl
	;
	;-----------------------------------------------------------------------
typeSet(leftexpr,pos,val) ; local ; register modification to leftexpr in type()
	;-----------------------------------------------------------------------
	; This subroutine stores the supplied value in the supplied field.
	;
	; ARGUMENTS:
	; . leftexpr = the leftexpr to update			/MECH=VAL
	;	The value shall be standardized (all subscript expressions
	;	removed)
	; . pos = position of field to be modified		/MECH=VAL
	;	1 = class
	;	2 = declLine
	;	3 = scope
	;	4 = asgnLine
	;	5 = refLine
	;	6 = killLine
	; . val = value to assign to specified position		/MECH=VAL
	;	Shall conform to the constraints for the field
	;
	; INPUTS:
	; . level = current DO-level
	; . line = current source line
	;
	; OUTPUTS:
	; . $PIECE(type(lvl,leftexpr),tab,pos) = val
	;	Where 'lvl' is the "deepest" level where 'leftexpr' is declared.
	; . If the name of leftexpr did not yet occur in type(), then it will
	;	have been inserted by $$typeLvl()
	;
	; NOTES:
	; . The call to $$typeLvl() will ensure the entry is correctly defined
	;
	set $piece(type($$typeLvl(leftexpr),leftexpr),tab,pos)=val
	quit
	;
	;-----------------------------------------------------------------------
typeUpd(leftexpr,pos) ; local ; register modification to leftexpr in type()
	;-----------------------------------------------------------------------
	; This subroutine stores the line where the assignment occurs.
	;
	; ARGUMENTS:
	; . leftexpr = the leftexpr to update			/MECH=VAL
	;	The value shall be standardized (all subscript expressions
	;	removed)
	; . pos = position of field to be modified		/MECH=VAL
	;	4 = assignment
	;	5 = reference
	;	6 = deletion
	;
	; INPUTS:
	; . level = current DO-level
	; . line = current source line
	;
	; OUTPUTS:
	; . $PIECE(type(lvl,leftarr),tab,pos) = line
	;	Where 'lvl' is the "deepest" level where type is declared,
	;	and 'leftarr' is the standardized array reference derived from
	;	'leftexpr' (all subscripts "removed", but parenthesis and commas
	;	included).
	;	If 'leftexpr' has not yet been declared (i.e. its name does not
	;	yet occur in type()), then a PUBLIC declaration at the current
	;	level and line will be inserted.
	; . $PIECE(type(lvl,leftname),tab,pos) = -line
	;	If the update is to a subscripted variable, and there has not
	;	yet been an explicit modification (of the same 'pos' of) the
	;	unsubscripted name, then that 'pos' field will be set to -line.
	;	This ensures that it is sufficient to look at the unsubscripted
	;	nodes to see if a variable is "used" at all.
	;
	; NOTES:
	; . The call to $$typeLvl() will ensure the entry is correctly defined
	;
	new lvl,name
	set lvl=$$typeLvl(leftexpr),name=$piece(leftexpr,"(")
	;
	set $piece(type(lvl,leftexpr),tab,pos)=line
	if leftexpr'=name,$piece(type(lvl,name),tab,pos)'>0 set $piece(type(lvl,name),tab,pos)=-line
	quit
	;-----------------------------------------------------------------------
UPCASE(string) quit $translate(string,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
	;
	;-----------------------------------------------------------------------
valArr(str,arrType) ; Process an array expression
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String str = M glvn					/MECH=VAL
	; . String arrType = array's type identification	/MECH=REF:W
	;	This variable will contain the identification of the array in
	;	the type() structure: array with all subscript expresssions
	;	removed, but parenthesis and commas in place.
	;
	new atom,ptr
	;
	set ptr=0,arrType=$piece(str,"(",1)_"("
	set str=$extract(str,$length(arrType)+1,$length(str)-1)
	;
	for  set atom=$$ATOM^%ZS(str,.ptr,",",,1) do  if ptr=0!ER quit
	.	;
	.	if atom="," set arrType=arrType_"," quit
	.	do valExpr(atom)
	;
	set arrType=arrType_")"
	quit
	;
	;-----------------------------------------------------------------------
valExpr(str,class) ; local ; Process a value expression e.g. set a= |1*3+5|
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String str = string to decompose			/MECH=VAL
	; . String class = class of result			/MECH=REF:W
	;	Will depend on last binary operator found in decomposition
	;
	; INPUTS:
	; . String cmd = current M command (used to deal with writeformats)
	;
	new atom,clsR,dels,op,ptr
	;
	set (class,clsR,op)=""
	set dels="+-*/\#_'=><[]!&?",ptr=0
	;
	for  do  quit:ptr=0!ER
	.	;
	.	set atom=$$ATOM^%ZS(str,.ptr,dels,,1) if ER quit
	.	;
	.	; incomplete Exponential notation
	.	if atom?.N.1"."1.N1"E" set ptr=ptr+1,atom=atom_$extract(str,ptr)_$$ATOM^%ZS(str,.ptr,dels,,1)
	.	;
	.	if $ascii(atom)=0 set clsR="String"
	.	else  if $ascii(atom)=1 set clsR="String"
	.	else  if $extract(atom)="(" do
	..		do valExpr($extract(atom,2,$length(atom)-1),.clsR)
	.	else  if $extract(atom)="$" do
	..		;
	..		if $$isExtr(atom) do valExtr($extract(atom,3,$length(atom)),.clsR) quit
	..		if atom["(",$$isKwd(.funcs,$piece(atom,"(")) do valFunc(atom,0,.clsR) quit
	..		if $$isKwd(.svars,.atom) set clsR=$piece(svars(atom),"|",2) quit
	..		set ER=1
	.	;
	.	else  if atom="?" set atom=$$ATOM^%ZS(str,.ptr,dels,,1),class="Boolean" quit
	.	else  if $$isNum(atom) set clsR="Number"
	.	else  if atom'="",dels[atom set op=op_atom quit	; dels no clsBinEx()
	.	else  do varExpr(atom,0,.clsR)
	.	do clsBinEx(.class,.op,.clsR)
	;
	if str=""!ER do ERROR("SYNTAX","String expression expected")
	quit
	;
	;-----------------------------------------------------------------------
valExtr(expr,class) ; local ; Process Extrinsic Function Logic
	;-----------------------------------------------------------------------
	; Decompose labelref(arg1,.arg2,...)
	;
	; ARGUMENTS:
	; . expr = labelref and actual parameter list		/MECH=VAL
	; . String class = class of reuslt (always "String")	/MECH=REF:W
	;
	do actual(expr)
	set class="String"
	;
	quit
	;
	;-----------------------------------------------------------------------
valFunc(expr,fset,class) ; local ; Process Intrinsic Function Logic
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String expr = function expression (incl "$")	/MECH=VAL
	; . String fset = assign / reference / kill indicator	/MECH=VAL
	;	Only the values 1 (assign) and 0 (reference) are allowed.
	;
	new arg,farg,fdes,fnam,ptr
	;
	set ptr=0
	set fnam=$piece(expr,"(")
	if $$isKwd(.funcs,.fnam) set fdes=funcs(fnam)
	else  set fdes="|String|" do ERROR("SYNTAX","Unknown function "_fnam)
	;
	set class=$piece(fdes,"|",2)
	set farg=$piece(expr,"(",2,999)
	set farg=$extract(farg,1,$length(farg)-1)			; Strip Parenthesis
	;
	if fset,$piece(fdes,"|",3)'=2 do ERROR("MISMATCH","Invalid assignment to function "_fnam) quit
	;
	if $extract("$SELECT",1,$length(fnam))=fnam do
	.	;
	.	new exprBool,exprVal
	.	for  set atom=$$ATOM^%ZS(farg,.ptr,",",,1) do  quit:ptr=0!ER
	..		if atom="," quit
	..		;
	..		new ptr set ptr=0
	..		set exprBool=$$ATOM^%ZS(atom,.ptr,":",,1)
	..		set exprVal=$extract(atom,ptr+2,999)
	..		if exprBool=""!(exprVal="") do ERROR("SYNTAX","Invalid $SELECT syntax") quit
	..		do condBool(exprBool)
	..		do valExpr(exprVal,.class)
	;
	else  for arg=1:1 set atom=$$ATOM^%ZS(farg,.ptr,",",,1) do  quit:ptr=0!ER
	.	;
	.	if atom="," quit
	.	;
	.	; First argument may require a glvn
	.	; This does not catch illegal constructs like: SET $piece($X,D,P)=V
	.	if arg=1,$piece(fdes,"|",3)=1!fset do varExpr(atom,fset)
	.	do valExpr(atom)
	;
	quit
	;
	;-----------------------------------------------------------------------
varExpr(atom,fset,class) ; local ; Decompose a variable expression
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . String atom = expratom to evaluate			/MECH=VAL
	;	Acceptable values for 'atom' are:
	;	- M glvn
	;	- M svn
	; . Number fset = atom shall be leftexpr?		/MECH=VAL
	;	0 = atom occurs in rightexpr
	;	1 = atom shall be leftexpr, if atom is M svn, than the svn
	;	must allow assignment.
	;	-1 = attom occurs in KILL, must be M glvn
	; . String class = class of atom			/MECH=REF:RW
	;	If fset=1, then the supplied value will be assigned to
	;	type(,atom), else it will contain the return type
	;	For M gvn: "String"
	;	For M lvn: class according to type()
	;	For M svn: class according to svars()
	;	For erroneous atom: "String"
	;
	; OUTPUTS:
	; . If M gvn, then
	;	addXref("G"_fset,gvn,"PUBLIC"_tab_class) will have been called
	; . Else
	;	addXref("V"_fset,gvn,scope_tab_class) will have been called
	;	(even if atom is invalid)
	;
	new leftexpr set leftexpr=atom
	;
	if atom="" set class="" do ERROR("SYNTAX","Variable expected "_atom) quit
	if fset=1 set class=$get(class,"String")
	;
	if $$getGlvnT(atom)#2 do valArr(atom,.leftexpr)
	;
	;;if $extract(atom)="^" do  quit			; Global variable
	;;.	set:fset'=1 class="String"		; String if referenced
	;;.	do addXref("G"_fset,$$UNTOK^%ZS(atom,mTSL),"PUBLIC"_$char(9)_class)
	;
	new svn set svn=atom
	new scope
	if $$isKwd(.svars,.svn) do
	.	set scope="PUBLIC"
	.	if fset=0 set class=$piece(svars(svn),"|",2)
	.	else  if fset<0 do ERROR("SCOPE","KILL not allowed: "_atom)
	.	else  do				; must be fset>0
	..		if $piece(svars(svn),"|",3)=0 do ERROR("SCOPE","SET not allowed: "_atom) quit
	..		new scls set scls=$piece(svars(svn),"|",2)
	..		if '$$clsAsgn(scls,class) do WARN("SCOPE","Cannot assign '"_class_"' to '"_scls_"'")
	else  if $$isGlvn(atom) do
	.	;
	.	; Update assigned at / referenced at / killed at. The call to
	.	; this subroutine will force an entry in type(), so $$getScop()
	.	; and $$getClass() will return "sensible" values.
	.	; NOTE: relies heavily on field order in type() !!!!
	.	do typeUpd(leftexpr,5-fset)
	.	set scope=$$typeGet(leftexpr,3)
	.	if fset'>0 set class=$$typeGet(leftexpr,1)
	.	else  if $$clsOrd(class,$$typeGet(leftexpr,1))>0 do typeSet(leftexpr,1,class)
	else  do
	.	set scope="PUBLIC",class="String"
	.	do ERROR("SYNTAX","Variable expected "_atom)
	;
	do addXref($select($extract(atom)="^":"G",1:"V")_fset,leftexpr,scope_$char(9)_class)
	;
	quit
	;
	;-----------------------------------------------------------------------
WARN(grp,msg) ; local ; Report a warning
	;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . grp = PSL WARN group
	;	The warning will only be reported if pslPrsr("WARN",grp) does
	;	exist
	; . msg = tokenized message				/MECH=VAL
	;	All tokens are supposed to be from the current source line, and
	;	available through mTSL
	;
	; INPUTS:
	; . subRou = current subroutine
	;	Used to suppress warnings in subroutines generated by PSL
	;
	if $extract(subRou)="v",subRou'?1"v".UN quit
	if $$getSetting^PSLCC(.pslPrsr,"WARN",grp,0) do msg(grp,msg,1)
	quit
	 	;
	;-----------------------------------------------------------------------
writeFmt(expr) ; local ; Write format: #!#!?intexpr
	;-----------------------------------------------------------------------
	;
	; Strip "#" and "!"
	new ptr
	for ptr=1:1:$length(expr)+1 quit:"#!"'[$extract(expr,ptr)
	if $extract(expr,ptr)="?" do valExpr($extract(expr,ptr+1,$length(expr)))
	quit
	;
	;#######################################################################
	; PART 5: unsorted remainders of previous version
	;
	;-----------------------------------------------------------------------
ZBREAK	;
	;-----------------------------------------------------------------------
	;
	quit
BREAK	;
HANG	;
HALT	;
JOB	;
TROLLBACK ;
XECUTE	;
ZCOMPILE ;
ZEDIT	;
ZMESSAGE ;
ZSHOW	;
ZTCOMMIT ;
ZWRITE	;
	if expr'="" do valExpr(expr)
	quit
ZPRINT	;
	if expr="" quit
	new lblref set lblref=$piece(expr,":")
	;
	if lblref["(" do ERROR("SYNTAX","ZPRINT does not allow an actuallist") quit
	do actual(lblref)
	quit:expr'[":"
	set lblref=$piece(expr,":",2)
	;
	if lblref["(" do ERROR("SYNTAX","ZPRINT does not allow an actuallist") quit
	do actual(lblref)
	quit
	;
	;-----------------------------------------------------------------------
TSTART	; M command ; Start a transaction
	;-----------------------------------------------------------------------
	;
	quit
	;
	;-----------------------------------------------------------------------
ZALLOCATE ; same syntax as LOCK
ZDEALLOCATE ; same syntax as LOCK
	;
LOCK	; M command ; Lock a reference
	;-----------------------------------------------------------------------
	;
	if expr="" quit
	;
	new ptr
	set ptr=0
	if "+-"[$extract(expr) set expr=$extract(expr,2,$length(expr))
	do varExpr($$ATOM^%ZS(expr,.ptr,":",mTSL),0)
	if ptr do valExpr($extract(expr,ptr+2,$length(expr)))
	quit
