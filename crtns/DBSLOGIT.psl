public DBSLOGIT(Record recobj, Number mode, String vx())	// Log table changes to LOG table

	/*
	Provide logging to LOG table for tables that request it based on flag
	DBTBL1.LOG.
	
	Note that the setAuditFlag(1) must be on to track entries for both
	create and update in order to log old and new values to LOG1.
	
	This procedure is the PSL version of routine ^DBSLOG.  ^DBSLOG is
	retained for backward compatibility.  PSL code, particularly the code
	generated by DBSFILB for filers and the Db.delete() method now call
	this new procedure.  Over time, all code will be converted to PSL and
	do the same, allowing ^DBSLOG to be obsoleted.
	
	ARGUMENTS:
		. recobj	Modified record object
		
		. mode		Process mode
				  0 = create
				  1 = update
				  3 = delete
				  
		. vx()		Change array, if called		/NOREQ/MECH=REFARR:R
				from filer

	---- Revision History ------------------------------------------------
	09/15/2008 - RussellDS - CR30801
		Modified to replace getSchemaTable with getPSLTable level 0
	
	10/12/06 - RussellDS - CR22719 / 20613
		   Modify to use table delimiter against vx array.
		   
		   Fixed logic structure in LOG section to avoid warnings
		   related to potentially uninstantiated object.
	
	01/18/06 - RussellDS - CR19108
		   Fix logic related to updating LOG1 when testing >255 length
		   to make sure we don't skip a column.
		   
	01/02/06 - RussellDS - CR18400
		   Modify to add optional vx() parameter if called from filers.
		   
		   Only call AUDIT^UCUTILN if no vx defined.
		   
		   Modified SEQ to ensure unique across processes.
	
	04/23/05 - RussellDS - CR15596
		   Created.
	*/
	
	type public String %LOGID
	
	type Number I
	type String delim, keys, keyvals, table
	
	if '%LOGID.exists() set %LOGID = $$LOGID^SCADRV
	
	quit:({Number}%LOGID <> 0)
	
	set table = vobj(recobj, -1).piece("Record", 2, 99)
	
	type PSLTable tblrec = PSL.getPSLTable(table, 0)
	
	set delim = tblrec.columnDelimiter.char()
	set keys = tblrec.primaryKeys
	
	set keyvals = ""
	if 'keys.isNull() for I = 1:1:keys.length(",") do {
		type String key, typ, val
		
		set key = keys.piece(",", I)
		
		type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D","%LIBS=""SYSDEV"",FID=:table,DI=:key")
		
		set typ = dbtbl1d.typ
		set val = vobj(recobj, -(I + 2))
		
		if {List}"T,U,F".contains(typ) set val = val.addQuotes()
		else  if {List}"D,C".contains(typ) set val = $$EXT^%ZM(val, typ)
		
		set keyvals = keyvals_val_","
	}
	
	set keyvals = keyvals.extract(1, keyvals.length() - 1)
	
	// Convert change info in vobj(,-100) into vx() array
	if (vx.data() = 0) do AUDIT^UCUTILN(recobj, vx(), tblrec.recordType, delim)
	
	do Runtime.start("CS")

	// If mode is delete (3) or there are no columns audited, just file LOG
	if ((mode = 3) ! 'vx.data()) do {
	
		type Number SEQ
	
		set SEQ = $$LOG(table, keys, keyvals, mode)
	}
	
	// For create mode, file values under one SEQ, in blocks
	else  if (mode = 0) do {
		
		type Number SEQ, SUBSEQ
		type String collist, column, newval, oldval, vallist
		
		// Insert into LOG table and return SEQ for LOG1
		set SEQ = $$LOG(table, keys, keyvals, mode)
		
		set SUBSEQ = 1
		set (collist, column, vallist) = ""
		for  set column = vx(column).order() do { quit:column.isNull()
		
			if 'column.isNull() do {
			
				set newval = vx(column).piece(delim, 2)
			
				if {List}"T,U,F".contains(vx(column).piece(delim, 4)) set newval = newval.addQuotes()
			}
			else  set newval = ""
				
			// If done or we get long enough, file and start again
			if (column.isNull() ! (collist.length() + column.length() > 255) ! (vallist.length() + newval.length() > 255)) do {
					
				set collist = collist.extract(1, collist.length() - 1)
				set vallist = vallist.extract(1, vallist.length() - 1)
				
				do LOG1(SEQ, SUBSEQ, collist, vallist, "")
					
				set SUBSEQ = SUBSEQ + 1
				set (collist, vallist) = ""
			}
			
			set collist = collist_column_","
			set vallist = vallist_newval_1.char()
		}
	}

	// For update mode, file each value as separate SEQ
	else  if (mode = 1)) do {
		
		type Number SEQ
		type String column, newval, oldval
		
		set column = ""
		for  set column = vx(column).order() quit:column.isNull()  do {
			
			// Insert into LOG table and return SEQ for LOG1
			set SEQ = $$LOG(table, keys, keyvals, mode)
			
			set oldval = vx(column).piece(delim, 1)
			set newval = vx(column).piece(delim, 2)
			
			if {List}"T,U,F".contains(vx(column).piece(delim, 4)) do {
				set oldval = oldval.addQuotes()
				set newval = newval.addQuotes()
			}
			
			do LOG1(SEQ, 1, column, newval, oldval)
		}
	}
	
	do Runtime.commit()
	
	quit


LOG(String table,	// Table name
    List keys,		// Access keys
    List keyvals,	// Access key values
    Number mode)	// Access mode (%O)
    
	/*
	Insert new entry into LOG table and return SEQ number
	
	RETURNS:
		. $$	SEQ key used for LOG entry
	*/
	
	type Number SEQ
	
	for  do { quit:(SEQ > 0)			// Loop on GETSEQ
		
		type Number CNT, GETSEQ
	
		// Get unique sequence number
		set GETSEQ = $$GETSEQ^SQLDD("LOG")
		set CNT = 0

		for  do { quit:(SEQ > 0)		// Loop on CNT
			
			set SEQ = (GETSEQ * 100) + CNT
		
			type RecordLOG log = Db.getRecord("LOG", "TJD=:%CurrentDate, SEQ=:SEQ", 1)
		
			/* If this entry already exists, we can file up to 100 
			   entries with this GETSEQ number.  If all used, wait and 
			   get new number
			*/
			if (log.getMode() > 0) do {
		
				set SEQ = 0
				set CNT = CNT + 1
			
				if (CNT > 99) do {
		
					hang 1
				
					set GETSEQ = $$GETSEQ^SQLDD("LOG")
					set CNT = 0
				}
			}
			// Otherwise, log it
			else  do {
			
				set log.fid = table
				set log.ackeys = keys
				set log.keyvalue = keyvals
				set log.%o = mode
				set log.uid = %UserID.get()
				set log.tlo = %UserStation.get()
				set log.libs = "SYSDEV"
				set log.time = %CurrentTime
	
				do log.save()
			}
		}
	}
	
	quit SEQ   
   
   
LOG1(Number SEQ,	// SEQ 
     Number SUBSEQ,
     String columns,	// Column name(s)
     String newvals,	// Old value(s)
     String oldvals)	// New value(s)
     
	/*
	File data to LOG and LOG1 tables
	
	Note that for insert, column values are separated by $C(1)
	*/
	
	type RecordLOG1 log1 = Class.new("RecordLOG1", "TJD=:%CurrentDate, SEQ=:SEQ, SUBSEQ=:SUBSEQ")
	set log1.dilist = columns
	set log1.dvlist = newvals
	set log1.ovlist = oldvals
	
	do log1.save()
	
	quit
 #OPTION ResultClass ON
public String vSIG()	quit "61254^68964^Dan Russell^6091"	// Signature - LTD^TIME^USER^SIZE
