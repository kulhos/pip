DBSTBLM(String TABLETYP)	// System, User, and Common Table Maintenance

	/*
	ORIG:	XUS - 03/31/94
	DESC:	System, User, and Common Table Maintenance
	 
	ARGUMENTS:
		. TABLETYP       Table type        	/NOREQ/DFT="UTBL"
	                         UTBL = User Table
	                         CTBL = Common Table
	                         STBL = System Table 	
	 
	---- Revision History -------------------------------------------------
	
	08/08/2008 - RussellDS - CR30801
		Modified LSTKEYPP to correct parameter passing error with
		change in FW v3.0
		
		Fixed PSL warnings.	
		
		Removed old revision history.
	
	*/
	
	/*
	DBSTBLM relies on calls to DBSTBLMB, which is generated by procedure
	DBSTBLMA (DBSTBLMB Builder).  DBSTBLMA builds a data access and screen
	call section for each CTBL, STBL, and UTBL table that has a data entry
	screen (DBTBL1.SCREEN) associated with it.
	   
	The following code ensures that post procedure DBSTBLMA has been compiled,
	and then calls it to build DBSTBLMB.  This code is only executed when
	DBSTBLM is compiled.
	*/
 
        // Compile procedure DBSTBLMA (DBSTBLMB Builder)
        #XECUTE do COMPILE^DBSPROC("DBSTBLMA")
 
        // Generated DBSTBLMB
        #XECUTE do ^DBSTBLMA
        
        
        // Start of main code section -----------------------------------------
	
	// I18N=QUIT
	
	type public Boolean ER
	type public String %FN, RM
	
	type String tbllist(), VFMQ
	
	if '%FN.exists() set %FN="UTBL001"
	
	if %UserClass.get().isNull() do {

		type RecordSCAU scau=Db.getRecord("SCAU", "UID=:%UserID", 1)
		
		set %UserClass = scau.%UCLS
		if %UserClass.isNull() set %UserClass = "NOCLASS"
	}
	
	if TABLETYP.get().isNull() set TABLETYP="UTBL"

	// Please Wait ...
	write $$MSG^%TRMVT($$^MSG(5624), 0, 0)
	
	// Create look-up table
	do LOOKUP(TABLETYP, tbllist())

	for  do { quit:VFMQ="Q"
		
		type Number OLNTB
		type String %NOPRMT, %READ, %TAB, fid, HDG, TABLE

		set ER = 0
		set TABLE = ""

		//  Get table name
		set HDG = "Table         File Name           Description"
		
		set %NOPRMT = "F"
		set OLNTB=30

		if TABLETYP = "UTBL" set %TAB("TABLE")=".TABLE3"
		else  if TABLETYP = "STBL" set %TAB("TABLE")=".FILENAMES"
		else  set %TAB("TABLE")=".FILENAMEC"
		
		set %TAB("TABLE") = %TAB("TABLE")_"/TYP=T/TBL=""tbllist(/RH="_HDG_"""/XPP=D TABLEVAL^DBSTBLM/REQ"
		
		set %READ="@@%FN,,TABLE,"
		do ^UTLREAD quit:VFMQ = "Q"

		set fid = tbllist(TABLE).piece("|", 2)
		
		do DBEENTRY(fid, 0)
	}

	quit
	
	
LOOKUP(String TABLETYP,		// Create look-up table
       String tbllist())
       
	/*
	ARGUMENTS:
		. TABLETYP	Table type		/REQ/MECH=VAL
		. tbllist()	Look-up table		/REQ/MECH=REFARR:W
		
	tbllist() is returned in form of:
		tbllist          = TABLETYP
		tbllist("ABC")   = "fid      desc|fid"
		tbllist("XYZ_1") = "fid      desc|fid"
		tbllist("XYZ_2") = "fid      desc|fid"
		
	where ABC or XYZ is first key to table.  If only one instance, then get
	non-numbered entry (e.g., ABC), otherwise, get numbered entries (e.g., XYZ)
	*/
	
	type Number tblcnt()

	type DbSet ds=Db.selectDbSet("DBTBL1", "%LIBS = 'SYSDEV' AND GLOBAL = :TABLETYP AND FILETYP <> 5", "ACCKEYS")

	while ds.next() do {
		
		type String desc, fid, key1
		
		type RecordDBTBL1 dbtbl1=ds.getRecord("DBTBL1")
		
		set key1 = dbtbl1.acckeys.piece(",", 1)
		
		quit:'key1.isLiteral()			// First key must be literal
		
		set key1 = key1.stripQuotes()
		
		set fid = dbtbl1.fid
		
		set desc = fid_(" ".justify(20 - fid.length()))_dbtbl1.des_"|"_fid
		
		if 'tblcnt(key1).exists() do {		// First entry
			set tbllist(key1) = desc
			set tblcnt(key1) = 0
		}
		
		else  do {

			if 'tblcnt(key1) do {		// Move first entry
				set tbllist(key1_"_1") = tbllist(key1)
				kill tbllist(key1)
				set tblcnt(key1) = 1
			}
			
			set tblcnt(key1) = tblcnt(key1) + 1
			set tbllist(key1_"_"_tblcnt(key1)) = desc
		}
	}
		
	set tbllist = TABLETYP

	quit


LOADTA(String TABLETYP)	// Load lookup info into temporary table

	/*
	ARGUMENTS:
		. TABLETYP	CTBL, STBL, or UTBL	/REQ/MECH=VAL

	Called by functions CTBL004 and UTBL004
	*/
	
	do Db.fastDelete("TLOOKUP", "PID = :%ProcessID")
	
	type DbSet ds=Db.selectDbSet("DBTBL1", "%LIBS = 'SYSDEV' AND GLOBAL = :TABLETYP AND FILETYP <> 5")

	while ds.next() do {
		
		type String key1
		
		type RecordDBTBL1 dbtbl1=ds.getRecord("DBTBL1")
		
		set key1 = dbtbl1.acckeys.piece(",", 1)
		
		quit:'key1.isLiteral()			// First key must be literal
		
		set key1 = key1.stripQuotes()
		
		if 'Db.isDefined("TLOOKUP","PID=:%ProcessID,TNAME=:key1") do {
		
			type RecordTLOOKUP tlookup = Class.new("RecordTLOOKUP","PID = :%ProcessID, TNAME = :key1")
		
			set tlookup.desc = dbtbl1.fid_(" ".justify(20 - dbtbl1.fid.length()))_dbtbl1.des
			set tlookup.file = dbtbl1.fid
			
			do tlookup.save()
		}
	}

	quit
	

DBEENTRY(String fid,			// Database Editor
	 Boolean fromFunc)

	/*
	ARGUMENTS:
		. fid		DQ table name		/REQ/MECH=VAL
		. fromFunc	Called from function?	/REQ/MECH=VAL
	*/

	type public Boolean ER = 0
	type public String RM = ""
	
	type String screen

	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:fid")
	
	if fromFunc do TABLEVER(fid) quit:ER
	
	if dbtbl1.acckeys.isNull() do { quit
		set ER = 1
		// Invalid file structure
		set RM = $$^MSG(5531)
	}
	
	set screen = dbtbl1.screen
	
	if screen = "INDEX" do { quit
		set ER = 1
		// This is an index file
		set RM = $$^MSG(3753)
	}
	
	if 'screen.isNull() for  quit:'$$SCREEN(.dbtbl1)
	else  do ^DBSEDIT("", fid)

	quit


TABLEVAL	// Table name Post-Processor

	type public Boolean ER
	type public String RM, tbllist(), X
	
	type String fid
	
	set fid = tbllist(X).get().piece("|", 2)

	do TABLEVER(fid, tbllist, X)
	
	quit
	
	
TABLEVER(String fid,		// Verify access to table
	 String TABLETYP,
	 String INPUT)
	 
	/*
	Arguments:
		. fid		DQ Table name		/REQ/MECH=VAL
		. TABLETYP	Table type		/NOREQ/MECH=VAL
				(UTBL, STBL, CTBL)
		. INPUT		Screen input		/NOREQ/MECH=VAL
	*/
	 
	type public Boolean ER
	type public String RM
	
	type String P1	

	// Invalid table name - ~p1
	if fid="" set ER = 1, RM = $$^MSG(1484, INPUT) quit
	
	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1","%LIBS=""SYSDEV"",FID=:fid")

	if 'TABLETYP.exists() set TABLETYP = dbtbl1.global
		
	// Validate file name ( user, system, common table)
	if '{List}"CTBL,STBL,UTBL".contains(TABLETYP) do { quit
		set ER = 1
		// Invalid table value ~p1
		set RM = $$^MSG(1485, fid)
	}
	
	if dbtbl1.global '= TABLETYP do { quit
		set ER=1
		// Invalid table value ~p1
		set RM=$$^MSG(1485, fid)
	}
	
	set P1 = dbtbl1.acckeys.piece(",", 1)
	
	if 'P1.isLiteral() do { quit
		set ER = 1
		// User is not allowed access to this table [not literal key]
		set RM = $$^MSG(2859)
	}
	
	do CHKACCES(TABLETYP, .dbtbl1, 0) quit:ER
	
	// If data entry pre-processor, execute it
	#ACCEPT DATE=05/27/04; PGM=Dan Russell; CR=unknown
	if 'dbtbl1.predaen.isNull() xecute dbtbl1.predaen
	
	quit


SCREEN(RecordDBTBL1 dbtbl1)	//  Call defined screen to maintain this table

	/*
	ARGUMENTS:
		. dbtbl1	DBTBL1 record		/REQ/MECH=REF:R
		
	RETURNS:
		. $$		Continue flag		/TYP=L
	*/

	type public Boolean ER = 0
	type public String RM

	type Number I, keycnt, OLNTB, vmode
	type String %NOPRMT, %READ, %TAB, acckeys, fid, KEY(), keys(), MSG, msghdr, screen, VFMQ
	
	// If screen has not been converted to PSL, won't work in non-GT.M db
	set screen = dbtbl1.screen
	
	type RecordDBTBL2 dbtbl2 = Db.getRecord("DBTBL2","LIBS=""SYSDEV"", SID = :screen")
	
	if 'dbtbl2.cscmp, $$rdb^UCDB do { quit 0
		set ER = 1
		set RM = "Screen "_screen_" must be converted to PSL to work for table maintenance"
	}
	
	set fid = dbtbl1.fid

	// File ~p1 is restricted
	if dbtbl1.rflag set ER = 1, RM = $$^MSG(5634, fid)
	
	// Get access keys
	set keys = ""
	set keycnt = $$GETKEYS(dbtbl1.acckeys,keys())

	// Build UTLREAD info - prompt for primary keys
	set msghdr = "["_fid_"] "_dbtbl1.des
	
	set %READ = "@msghdr/REV/CEN,,"
	
	for I = 1:1:keycnt do {
		
		type Number size
		type String key, lookup, X
		
		set key = keys(I)
		
		type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D","%LIBS=""SYSDEV"", FID = :fid, DI = :key")
		
		set size = dbtbl1d.siz
		if size.isNull() set size = dbtbl1d.len
		
		set X = "/DES="_dbtbl1d.des.addQuotes()_"/TYP="_dbtbl1d.typ_"/LEN="_dbtbl1d.len
		set X = X_"/SIZ="_size

		/* Last key post-processor -- add regular post-processor only if not on last key
		   For all keys other than last, assign KEYn=KEY(n) to support table lookup
		   QUERY, which doesn't allow KEY(n) references.  Set key name to value as well
		   to support other QUERIES, not built here.
		*/
		if I = keycnt set X = X_"/XPP=do LSTKEYPP^DBSTBLM("""_fid_""")"
		else  do {
			set X = X_"/XPP=set KEY"_I_"=X,"_key_"=X"
			if 'dbtbl1d.depostp.isNull() set X = X_" "_dbtbl1d.depostp
		}
		
		if 'dbtbl1d.deprep.isNull() set X = X_"/XPR="_dbtbl1d.deprep
		
		set lookup = dbtbl1d.tbl
		
		// Build lookup syntax
		if lookup.isNull() do {
			
			type Number J
			type String QRY = ":QU """
			
			set X = X_"/TBL=["_fid_"]"

			for J = 1:1:I-1 do {
				set QRY = QRY_"["_fid_"]"_keys(J)_"=<<KEY"_J_">>"
				if J '= (I - 1) set QRY = QRY_" AND "
			}
			
			set X = X_QRY_""":NOVAL"
		}
		else  do {
			set X = X_"/TBL="_lookup
			if lookup.isLike("%["_fid_"]%") set X = X_":NOVAL"
		}
		
		if 'dbtbl1d.min.isNull() set X = X_"/MIN="_dbtbl1d.min
		if 'dbtbl1d.max.isNull() set X = X_"/MAX="_dbtbl1d.max
		if 'dbtbl1d.dec.isNull() set X = X_"/DEC="_dbtbl1d.dec
		if 'dbtbl1d.ptn.isNull() set X = X_"/PAT="_dbtbl1d.ptn
		
		set X = X_"/REQ"
		
		set %TAB("KEY("_I_")") = X
		set KEY(I) = ""
		set %READ = %READ_"KEY("_I_"),"
	}
	
	// Delete prompt
	set %TAB("vmode") = ".FUN34/NOREQ/XPP=D VPOST1^DBSTBLM("""_fid_""")"
	
	set %READ=%READ_",vmode,"
	set %NOPRMT="F"
	set vmode=0
	set OLNTB = 30
	
	do ^UTLREAD quit:VFMQ="Q" 0
	
	// Set process mode
	if vmode do { quit:ER 0
		
		// Deletion is restricted
		if dbtbl1.dflag set ER = 1, RM = $$^MSG(806)
		else  set %ProcessMode = 3
	}
	else  do {
		type Number I
		type String collist, where
		
		set collist = ""
		set where = ""
		
		for I = 1:1:keycnt do {
			set collist = collist_keys(I)_","
			set where = where_keys(I)_"='"_KEY(I)_"' AND "
		}
		set collist = collist.extract(1, collist.length()-1)
		set where = where.extract(1, where.length()-5)
		
		if $$DYNSEL(collist, fid, where, .KEY()) set %ProcessMode = 1	// Modify
		else  set %ProcessMode = 0					// Create
	}

	
	// Otherwise, need to deal with old screens via fsn
	// REMOVE THIS CODE ONCE ALL *TBL SCREENS CONVERTED TO PSL
	if 'dbtbl2.cscmp do {
	
		type Number %PAGE, %PG, I
		type String fsn, PGM, SID, UX(), VFSN()
		
		set fsn = dbtbl1.fsn
		
		#ACCEPT DATE=09/21/04; PGM=Dan Russell; CR=unknown
		new @fsn
		
		// Protect key names and set values
		#ACCEPT DATE=09/21/04; PGM=Dan Russell; CR=unknown
		#BYPASS
		for I=1:1:keycnt new @keys(I) set @keys(I)=KEY(I)
		#ENDBYPASS
		
		set SID = screen		// Required by USID
		
		do ^USID
		#ACCEPT DATE=05/27/04; PGM=Dan Russell; CR=unknown
		do ^@PGM			// Screen will load data
		quit:ER ! (VFMQ = "Q")
		
		do EXT^DBSFILER(fid, %ProcessMode)	// Save data
	}
		
	// Call ^DBSTBLMB for screens converted to PSL
	else  do {
		
		set RM = $$^DBSTBLMB(%ProcessMode, .dbtbl1, .KEY())
		if 'RM.isNull() set ER = 1
	}
	
	quit:ER 0
	
	// Generate bottom of screen prompt to continue or not
	
	// Created,Modified,Displayed,Deleted,Printed
	if VFMQ '= "Q" set MSG = $$^MSG(648)
	// not Created,not Modified,not Displayed,not Deleted,not Printed
	else  set MSG = $$^MSG(8259)

	set MSG = MSG.piece(",", %ProcessMode + 1)
	// 5652 = Record ~p1.  ~p2 -- 603 = Continue?
	set MSG = $$^MSG(5652, MSG, $$^MSG(603))
	
	// Display result and prompt to continue
	quit $$YN^DBSMBAR(" ", MSG, 1)


LSTKEYPP(String fid)	// Last Key Post-Processor
	/*
	ARGUMENTS:
		. fid		DQ table name		/REQ/MECH=VAL
	*/
	
	type public Number ER
	type public String I(), KEY(), RM, X
	
	type Boolean exists
	type Number keycnt
	type String global, keys(), SAVX, select, where

	quit:X.isNull() ! (X = "?")
	
	set ER = 0
	set RM = ""
	
	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1", "%LIBS = ""SYSDEV"", FID = :fid")
	
	set global = dbtbl1.global
	
	quit:'{List}"CTBL,STBL,UTBL".contains(global)
	
	do CHKACCES(global, .dbtbl1, 0) quit:ER
	
	if global '= "STBL" do { quit:ER
	
		type String lastkey
		
		set lastkey = dbtbl1.acckeys.piece(",", dbtbl1.acckeys.length(","))
		
		type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D", "%LIBS = ""SYSDEV"", FID = :fid, DI = :lastkey")
		
		if 'dbtbl1d.depostp.isNull() do {

			// execute post-processor in data item definition
			#ACCEPT Date=09/21/04; PGM=Dan Russell; CR=unknown
			xecute dbtbl1d.depostp
		}
	}

	// Check against look-up table first
	if 'I(3).isNull(), $$VER^DBSTBL(I(3),X,"T")="" do { quit
		set ER = 1
		// Invalid table value ~p1
		set RM = $$^MSG(1485, X)
	}
	
	// Determine whether record already exists, or not
	set keycnt = $$GETKEYS(dbtbl1.acckeys, keys(), .select, .where)
	
	// Replace last key with X (input to screen)
	set where = where.replace(":KEY("_keycnt_")", ":X")
	
	#ACCEPT Date=09/21/04; PGM=Dan Russell; CR=unknown
	set exists = $$DYNSEL(select, fid, where, .KEY())
	
	set SAVX = X				// Protect X from DBSMACRO
	
	if 'exists do {				// Record does not exist
		
		type Boolean create
		
		do PROTECT^DBSMACRO("@vmode")	// Protect delete prompt
		
		// Create new record
		set create = $$YN^DBSMBAR("", $$^MSG(5518), 1)
		if 'create set ER=1
	}
	
	else  do UNPROT^DBSMACRO("@vmode")	// Unprotect delete prompt
		
	set X=SAVX
	
	quit


VPOST1(String fid)	// Post processor for operating mode
	/*
	ARGUMENTS:
		. fid		DQ table name		/REQ/MECH=VAL
	*/

	type public Boolean X
	type public Number ER
	type public String KEY(), RM
	
	quit: 'X
	
	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1", "%LIBS=""SYSDEV"", FID = :fid")
	
	if dbtbl1.dflag do { quit
		set ER = 1
		// Deletion is restricted
		set RM = $$^MSG(806)
	}
	
	do CHKACCES(dbtbl1.global, .dbtbl1, 3) quit:ER	// Check access rights for delete
	
	if $$LOWERLVL^DBSTBLMB(fid, .KEY()) do {
		set ER = 1
		// Delete Lower Level Data Entries First
		set RM=$$^MSG(8425)
	}

	quit


INTGRE	// Table Integrate Check

	// Called by function TBLINT to find C-S-UTBL tables with same global,
	// same first key, and same number of access keys
	
	type String RID, TABLETYP, TMP(,,)
	
	do Db.fastDelete("TBLINT", "PID = :%ProcessID")

	// Please Wait ...
	write $$MSG^%TRMVT($$^MSG(5624), 0, 0)
	
	// load the global to local variable
	for TABLETYP="CTBL", "STBL", "UTBL" do {
		
		type Number CNT = 0
		
		type ResultSet rs = Db.select("FID, ACCKEYS", "DBTBL1", "%LIBS='SYSDEV' AND GLOBAL = :TABLETYP", "FID")
		
		while rs.next() do {
			
			type Number keycnt
			type String fid, acckeys, key1
			
			set fid = rs.getCol("FID")
			set acckeys = rs.getCol("ACCKEYS")
			
			set key1 = acckeys.piece(",",1)
			quit:'key1.isLiteral()			// Only care about literals
			
			set key1 = TABLETYP_"_"_key1
			set fid = rs.getCol("FID")
			set acckeys = rs.getCol("ACCKEYS")
			set keycnt = acckeys.length(",")
			
			if 'TMP(key1, keycnt).data() set TMP(key1, keycnt, fid) = acckeys
			else  do {
				
				type Boolean match
				type Number I
				type String acckeys2, fid2, keyf1, keyf2
				
				set fid2 = ""
								
				for  set fid2 = TMP(key1, keycnt, fid2).order() quit:fid2.isNull()  do {
					
					set acckeys2 = TMP(key1, keycnt, fid2)
					set match = 1
					
					for I = 2:1:keycnt do { quit:'match
						set keyf1 = acckeys.piece(",", I)
						set keyf2 = acckeys2.piece(",", I)
						
						// If both literal and different, then not a match
						if keyf1.isLiteral(), keyf2.isLiteral(), keyf1 '= keyf2 set match = 0
					}
					
					if match do {
				
						set CNT = CNT + 1
						type RecordTBLINT tblint=Class.new("RecordTBLINT","PID = :%ProcessID, FILE = :CNT")
						set tblint.file1 = fid2
						set tblint.acckey1 = acckeys2
						set tblint.file2 = fid
						set tblint.acckey = acckeys
						do tblint.save()
					}
				}
			}
		}
	}
		
	set RID = "TBLINT"
	do DRV^URID				
		
	do Db.fastDelete("TBLINT", "PID = :%ProcessID")
		
	quit
	
	
FUNENTRY(String TABLE)	// Function entry point

	type public Number ER
	type public String RM
	
	type String key1

	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1", "%LIBS = ""SYSDEV"", FID = :TABLE")
	
	if '{List}"CTBL,STBL,UTBL".contains(dbtbl1.global) do {
		set ER = 1
		// Invalid table value ~p1
		set RM = $$^MSG(1485, TABLE)
	}
	
	set key1 = dbtbl1.acckeys.piece(",", 1)

	if 'key1.isLiteral() do { quit		// First key must be literal
		set ER = 1
		// Invalid table name ~p`
		set RM = $$^MSG(1484, TABLE)
	}
	
	do DBEENTRY(TABLE, 1)
	
	quit
	
	
CHKACCES(String TABLETYP,	// Check access rights
	 RecordDBTBL1 dbtbl1,
	 Number mode)
	 
	/*
	ARGUMENT:
		. TABLETYP	CTBL/STBL/UTBL		/REQ/MECH=VAL
		. dbtbl1	DBTBL1 object		/REQ/MECH=REFNAM:R
		. mode		0 = read, 3 = delete	/REQ/MECH=VAL
		
	RETURNS:
		. ER		Error flag		/TYP=N
		. RM		Error message		/TYP=T
	*/
	
	type public Number ER
	type public String RM
	
	type String ACCRGHTS, key1
			
	set key1 = dbtbl1.acckeys.piece(",", 1).stripQuotes()
	
	set ACCRGHTS = ""
	
	// Only SCA userclass can maintain STBL
	if TABLETYP = "STBL" do { quit
		
		// User does not have write access
		if %UserClass '= "SCA" set ER = 1, RM = $$^MSG(2846)
	}
	
	// Get userclass access rights
	if TABLETYP = "UTBL" do {
		
		if 'Db.isDefined("UTBLUTBL","TBL=:key1,KEY=:%UserClass") quit
		 
		type RecordUTBLUTBL utblutbl = Db.getRecord("UTBLUTBL", "TBL = :key1, KEY = :%UserClass", 1)
		
		set ACCRGHTS = utblutbl.rwd
	}
	
	else  do {				// CTBL
		
		if 'Db.isDefined("CTBLUTBLF","TBL=:key1,UCLS=:%UserClass") quit
		
		type RecordCTBLUTBLF ctblutbl = Db.getRecord("CTBLUTBLF", "TBL = :key1, UCLS = :%UserClass", 1)
		
		set ACCRGHTS = ctblutbl.desc
	}
	
	// Default access rights only if there are no entries for this table
	if ACCRGHTS.isNull() do {
		
		type Boolean ANY = 0
		
		if TABLETYP = "UTBL" do {
			
			type ResultSet rs = Db.select("KEY", "UTBLUTBL", "TBL = :key1")
			if rs.next() set ANY = 1
		}
		else  do {			// CTBL
			
			type ResultSet rs = Db.select("UCLS", "CTBLUTBLF", "TBL = :key1")
			if rs.next() set ANY = 1
		}
		
		if 'ANY do {
		
			if %UserClass = "SCA" set ACCRGHTS = "RWD"
			else  if %UserClass = "MGR" set ACCRGHTS = "RWD"
			else  set ACCRGHTS = "R"
		}
	}
	
	if mode = 0 do {
		
		if ACCRGHTS '[ "W" do {
			set ER=1
			// User does not have write access to table
			set RM = $$^MSG(2846)
		}
	
		else  if dbtbl1.rflag do {
			set ER = 1
			// This table maintenance is restricted
			set RM = $$^MSG(5638)
		}
	}
	else  do {
		
		if ACCRGHTS '[ "D" do {
			set ER = 1
			// User is not allowed to delete table entry
			set RM=$$^MSG(2860)
		}
	}
	
	quit
	
	
GETKEYS(String acckeys,		// Get access keys and build related select and where
	String keys(),
	String select,
	String where)
	
	/*
	ARGUMENTS:
		. acckeys	DBTBL1.ACCKEYS		/REQ/MECH=VAL
		. keys()	Numbered array of	/NOREQ/MECH=REF:W
				keys
		. select	Select list		/NOREQ/MECH=REF:W
		. where		Where clause		/NOREQ/MECH=REF:W
	*/
	
	type Number I, keycnt
	type String key
	
	set keycnt = 0
	set (select, where) = ""
	
	set acckeys=$$TOKEN^%ZS(acckeys)
	for I=1:1:acckeys.length(",") do {
		
		set key = acckeys.piece(",",I)
		quit:key?1.N				// Ignore numeric keys
		quit:key.extract(1)=0.char()		// Ignore literal strings
			
		set keycnt = keycnt + 1
		set keys(keycnt) = key
		
		set select = select_key_","
		set where = where _key_"= :KEY("_keycnt_") AND "
	}
	
	set select = select.extract(1, select.length()-1)
	set where = where.extract(1,where.length()-5)
				
	quit keycnt
	
	
DYNSEL(String SELECT,	// Dynamic select
       String FROM,
       String WHERE,
       String KEY())
       
	/*
	ARGUMENTS:
		. SELECT	Column list		/REQ/MECH=VAL
		. FROM		Table			/REQ/MECH=VAL
		. WHERE		Where statement		/REQ/MECH=VAL
		
	RETURNS:
		. $$		0 = empty		/TYP=L
				1 = has data
				
	Note:  Since can only have one dynamic select per routine and we
	needed two here, create just this one and they both call it.
	*/
	
	// Since SQL doesn't like host variables as array elements, substitute
	type String KEY1, KEY2, KEY3, KEY4, KEY5, KEY6, KEY7, KEY8
	
	// Set to null to avoid unreferenced variable warning
	set (KEY1, KEY2, KEY3, KEY4, KEY5, KEY6, KEY7, KEY8) = ""

	if WHERE.isLike("%KEY(%") do {
		
		type Number I
		type String X
		
		for I = 1:1:8 quit:'KEY(I).exists()  do {
			set X = "KEY"_I
			set @X = KEY(I)
			set WHERE = WHERE.replace("KEY("_I_")", "KEY"_I)
		}
	}
	
	#ACCEPT Date=09/21/04; PGM=Dan Russell; CR=unknown	
	type ResultSet rs = Db.select(SELECT, FROM, WHERE)
	
	if rs.next() quit 1
	
	quit 0


ACCESS	// Post processor for access mode
	
	type public Boolean ER
	type public String X
	
	type Number I
	type String ACC1,ACC2,TMP
	
	set ACC1=""
	set ACC2=""
	
	for I=1:1:X.length() do {  quit:ER
		set TMP=X.extract(I)
		
		// input must be ""RWD""
		if "RWD"'[TMP do Runtime.setErrMSG("DBTBL1D","5635") quit:ER
		
		// Must have read access if write access is specified
		if TMP="W" set ACC1="RW"
		
		// Must have write access if delete access is specified
		if TMP="D" set ACC2="RWD" 
		}
	
	if 'ACC1.isNull() set X=ACC1
	if 'ACC2.isNull() set X=ACC2
	
	quit
	
 #OPTION ResultClass ON
public String vSIG()	quit "61219^67049^Dan Russell^20298"	// Signature - LTD^TIME^USER^SIZE
