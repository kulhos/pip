	#PACKAGE framework
	#OPTION ResultClass ON
	/*
	Local procedure runtime driver.
	
	DBSDRV provides the ability to invoke local procedures (host-driven
	functions) and runable procedures in one of three ways:
	
	  - from the shell - see run
	  - as an MRPC to invoke a local procedure call - see rpclpc
	  - as an MRPC to invoke a runable procedure - see rpcrun
	
	Each form has different requirements in terms of registration to allow
	running.  Refer to each section for details.
	
	In all three cases, the entry point takes a command string as input.
	From the shell, the command line entered is the command string, and is
	parsed into the args() array prior to calling run.  For the MRPCs, the
	command line is one of the parameters.  See the cmdline method for
	the rules associated with the command string.
	
	A dispatch procedure, DBSDRVDSP, for both local procedure and MRPCs is
	generated by the build method, which can called as local procedure
	buildDBSDRV, without it being registered.
		    
	---- Revision History -------------------------------------------------
	2009-04-04 - RussellDS - CRs 35741/39284
		* Modified to support MRPC calls
		* Modified design of parameters to be passed
	
	2009-02-2 - RussellDS - CRs 35741/38672
		* Created.

	-----------------------------------------------------------------------
	*/

	// This entry is temporary until PSL generates the leader code
	
	// Display any error and then quit, which will exit back to shell
	catch err {
		
		type Integer retStat
		
		type String errmsg = err.type_ ", "_ err.thrownAt_ ", "_ err.description
		
		if 'err.context.isNull() set errmsg = errmsg_ err.context
		
		set retStat = $$errormsg(errmsg)
		
		#ACCEPT Date=02/22/2009; Pgm=RussellDS; CR=35741; Group=BYPASS
       		#BYPASS
	        set $ZTRAP="" ZMESSAGE 2	; Indicates uncontrolled error
        	#ENDBYPASS
	}
	
	// Need to deal with Java as well
	#IF $$isRdb^vRuntime
	#ACCEPT Date=02/22/2009; Pgm=RussellDS; CR=35741; Group=BYPASS
	#BYPASS
	NEW vStat SET vStat=$$DBCONNECTT^%DBAPI($ZTRNLNM("SCAU_DB_INI"),0)
	#ENDBYPASS
	#ENDIF
	
	// Set up select system keyword(s)
	#ACCEPT Date=02/22/2009; Pgm=RussellDS; CR=35741; Group=ACCESS
	type String %UserID = $$USERNAM^%ZFUNC	// replace with Runtime.username once available
	
	type String args()
	type Integer status
			
	#ACCEPT Date=02/22/2009; Pgm=RussellDS; CR=35741; Group=BYPASS
        #BYPASS
        ; Parse the command line
        do cmdline($ZCMDLINE,.args)
        #ENDBYPASS

        set status = $$run(args())
        
        #ACCEPT Date=02/22/2009; Pgm=RussellDS; CR=35741; Group=BYPASS
        #BYPASS
        set $ZTRAP="" ZMESSAGE status
        #ENDBYPASS
        
        quit
        	
	
public Integer run(String args())

	/*
	Local Procedure Call (host-driven function) driver
	
	For local procedures, the first argument must be the function to be
	executed, as defined in DBSFUNC.  The remaining arguments and options
	parsed from the command string, are passed in a single level array of
	strings.  The method invoked can perform the necessary casting to other
	data types.
	
	Local procedure methods must return a status string, with a null value
	indicating success and any other value a failure.  A failure string
	should indicate information about the failure.  If written as methods of
	a Class Definition Module, the method must be static.  On success the
	driver will exit with a status code of 0 to the shell.  Otherwise, it
	will exit with a status code of 1 and will write the status message to
	stderr.
	
	Local procedure methods must be coded to accept two paramters:
	
		ret Boolean isRPC	// True if call via MRPC, otherwise false
		void args(String)	// Command string input array
	
	It is the responsibility of the method to deal with this array as
	necessary, including returning an error for invalid numbers or values
	of arguments, and handling non-positional options.  The value of the
	isRPC flag can be used to direct the method to return an error if the
	method is not valid via MRPC access, to surpass console input or
	output, or for other purposes appropriate to distinguishing handling
	between shell and client/server access.
	*/

	type Integer i
	type Integer retStat = 0	// 0 = success, anything else = failure
	
	do {
		
		type String %UserClass, func
		type String errmsg = ""
	
		catch err {
		
			set errmsg = err.type_ ", "_ err.thrownAt_ ", "_ err.description
		
			if 'err.context.isNull() set errmsg = errmsg_ err.context
		
			set retStat = $$errormsg(errmsg)
		}
	
		type RecordDBSUSER dbsuser = Db.getRecord("DBSUSER", "UID=:%UserID", 1)
	
		if (dbsuser.getMode() = 0) set retStat = $$errormsg("Invalid user") quit
		if dbsuser.noaccess set retStat = $$errormsg("User not allowed access") quit
	
		set %UserClass = dbsuser.ucls
	
		if 'args(1).exists() set retStat = $$errormsg("No function input") quit
	
		set func = args(1)
		
		// Strip first positional argument (function name)
		kill args(1)
		for i = 2:1 quit:'args(i).exists()  do {
			
			set args(i - 1) = args(i)
			kill args(i)
		}
	
		// Hardcode to allow without table entry or authorization
		if (func = "buildDBSDRV") set errmsg = $$build(false, args())
		else  do {
	
			type RecordDBSFUNC dbsfunc = Db.getRecord("DBSFUNC", "FUNC=:func", 1)
	
			if (dbsfunc.getMode() = 0) set retStat = $$errormsg("Invalid function") quit
	
			type RecordDBSFUNCUCLS dbsfuncucls = Db.getRecord("DBSFUNCUCLS", "FUNC=:func,UCLS=:%UserClass", 1)
	
			if (dbsfuncucls.getMode() = 0) set retStat = $$errormsg("User not authorized for function "_ func) quit
			
			// Call dispatch
			set errmsg = $$^DBSDRVDSP(func, false, args())
		}
		
		if 'errmsg.isNull() set retStat = $$errormsg(errmsg)
	}
	
	quit retStat
	
	
public String rpclpc(ret String rpcReturn,	// Standard MRPC return data [*]
		     Number version,		// MRPC version number [*]
		     String function,		// lpc function being invoked [*]
		     String cmdStr)		// Command string [*]
		     
	/*
	RPC driver for local procedures.
	
	LPC methods, to be run as RPCs, must be registered in SCATBL5 and
	the userclass authorized in SCATBL5A.
	
	See the documentation in the run method related to local procedure
	calls.  cmdStr should contain the same arguments and options as that
	passed for the run method, with the exception that the first argument,
	the function, is passed for run, but excluded for the rpclpc call, as
	it is provided as a separate parameter (function).
	
	run methods must be coded to accept one paramter:
	
		void args(String)	// Command string input array
	
	It is the responsibility of the method to deal with this array as
	necessary, including returning an error for invalid numbers or values
	of arguments, and handling non-positional options. 
	
	Argument Notes:
		. rpcReturn	On error, null
				On success function_" complete"
				
		. version	1 is currently only allowed value
		
		. function	Valid lpc function as registered in DBSFUNC
		
		. cmdStr	Command line equivalent input string, space
				and/or tab delimited.  See cmdline method
				documentation.
				
	Returns:
		. $$		Null = no error
				Otherwise, error message
	*/
	
	type public Cache %CACHE()
	type public String %UserClass, %UserID
	
	type String args()
	type String retVal = ""
	
	if (version <> 1) quit $$ERRMSG^PBSUTL("Version number of client message is not compatible with server")
	
	if function.isNull() quit $$ERRMSG^PBSUTL("No function specified")
	
	if '%CACHE("SCATBL5").isDefined("SCATBL5","RPCID=:function") quit "Function "_ function_ " not authorized as an MRPC"
	
	type RecordSCATBL5A scatbl5a = %CACHE("SCATBL5A").getRecord("SCATBL5A", "RPCID=:function,UCLS=:%UserClass", 1)

	// Determine if authorized for this userclass
	if (scatbl5a.getMode() = 0), '%CACHE("SCATBL5A").isDefined("SCATBL5A", "RPCID=:function,UCLS='*'") quit "User is not authorized to execute function "_ function
	
	do cmdline(cmdStr.get(), args())
	
	// Call dispatch
	set rpcReturn = $$^DBSDRVDSP(function, true, args())
	
	if rpcReturn.isNull() set rpcReturn = function_ " complete"	// Success
	else  set retVal = rpcReturn					// Failure
	
	quit retVal
	
	
public String rpcrun(ret String rpcReturn,	// Standard MRPC return data [*]
		     Number version,		// MRPC version number [*]
		     String runable,		// Runable method reference
		     String cmdStr)		// Command string [*]
		     
	/*
	RPC driver for procedures with run methods.
	
	Runable procedures, to be run as RPCs, must be registered in SCATBL5 and
	the userclass authorized in SCATBL5A.
	
	The cmdStr parameter for runable procedures is parsed into the args()
	array, which is passed to the procedure's run method as it's only
	input.
	
	Argument Notes:
		. rpcReturn	On error, null
				On success "Complete"
				
		. version	1 is currently only allowed value
		
		. cmdStr	Command line equivalent input string, space
				and/or tab delimited.  See cmdline method
				documentation.
				
	Returns:
		. $$		Null = no error
				Otherwise, error message "Failure - code nnn"
				where nnn is code returned by runable call
	*/
	
	type public Cache %CACHE()
	type public String %UserClass, %UserID
	
	type String args()
	type Integer runReturn
	type String retVal = ""
	
	if (version <> 1) quit $$ERRMSG^PBSUTL("Version number of client message is not compatible with server")
	
	if runable.isNull() quit $$ERRMSG^PBSUTL("No function specified")
	
	if '%CACHE("SCATBL5").isDefined("SCATBL5","RPCID=:runable") quit "Procedure "_ runable_ " not authorized as an MRPC"
	
	type RecordSCATBL5A scatbl5a = %CACHE("SCATBL5A").getRecord("SCATBL5A", "RPCID=:runable,UCLS=:%UserClass", 1)

	// Determine if authorized for this userclass
	if (scatbl5a.getMode() = 0), '%CACHE("SCATBL5A").isDefined("SCATBL5A", "RPCID=:runable,UCLS='*'") quit "User is not authorized to execute function "_ runable
		
	do cmdline(cmdStr.get(), args())
	
	// Call dispatch
	set runReturn = $$runable^DBSDRVDSP(runable, args())
	
	if (runReturn = 0) set rpcReturn = "Complete"		// Success
	else  do {						// Failure
		
		set rpcReturn = ""
		set retVal = "Failure - code "_ runReturn
	}
	
	quit retVal
	
	
String build(Boolean isRPC,
	     String args())
	
	/*
	Build new version of DBSDRVDSP based on contents of table DBSFUNC
	*/
	
	type literal String PROCNAME = "DBSDRVDSP"
	// Replace $$TRNLNM once Host or other method is available
	#ACCEPT Date=02/22/2009; Pgm=RussellDS; CR=35741; Group=ACCESS
	type literal String TMPFILE = $$TRNLNM^%ZFUNC("SCAU$SPOOL")_ "/"_ PROCNAME_ ".tmp"
	
	type String cls, func, funcs(), funcClasses(), retVal, runables(), runClasses(), status
	
	type DbSet ds = Db.selectDbSet("DBSFUNC")
	
	if ds.isEmpty() return "Table DBSFUNC is empty"
	
	// Need to get distinct classes to include static reference
	while ds.next() do {
		
		type RecordDBSFUNC dbsfunc = ds.getRecord("DBSFUNC")
		
		set funcs(dbsfunc.func) = dbsfunc.method
		if 'dbsfunc.method.beginsWith("$$") set funcClasses(dbsfunc.method.piece(".", 1)) = ""
	}
	
	// Get runable methods
	type ResultSet rs = Db.select("RPCID", "SCATBL5", "RPCID LIKE 'run^%' OR RPCID LIKE '%.run'")
	
	while rs.next() do {
		
		type String rpcid = rs.getCol("RPCID")
		
		set runables(rpcid) = ""
		if rpcid.endsWith(".run") set runClasses(rpcid.piece(".", 1)) = ""
	}
	
	type IO iofile = Class.new("IO")	
	
	set iofile.fileName = TMPFILE
	set iofile.openParams = "NEWV"
	
	do {
		catch ioerror {
     
     			if 'iofile.device.isNull() do iofile.close()
			
			throw ioerror
		}

		do iofile.open()
		
		do iofile.write(" #PACKAGE framework")
		do iofile.write(" #OPTION ResultClass ON")
	
		do iofile.write("String "_ PROCNAME_ "(String func, Boolean isRPC, String args())")
		do iofile.write(" // Last compiled:  "_ %CurrentDate.toString()_ " "_ %CurrentTime.toString()_ " - "_ %UserName)
		do iofile.write("")
		do iofile.write(" // THIS IS A GENERATED MODULE.  Generated by build^DBSDRV.")
		do iofile.write("")
		
		set cls = ""
		for  set cls = funcClasses(cls).order() quit:cls.isNull()  do iofile.write(" type static "_ cls)
		
		do iofile.write("")
	
		set func = ""
		for  set func = funcs(func).order() quit:func.isNull()  do {
		
			type String method
			
			set method = funcs(func)
			
			do iofile.write(" if (func = "_ func.addQuotes()_ ") quit "_ method_ "(isRPC, args())")
		}
		
		do iofile.write("")
		do iofile.write(" quit ""Invalid function (""_ func_ "") - dispatcher out of date - please run buildDBSDRV""")
		
		// Runable section
		do iofile.write("Integer runable(String runable, String args())")
		do iofile.write("")
		
		set cls = ""
		for  set cls = runClasses(cls).order() quit:cls.isNull()  do iofile.write(" type static "_ cls)
		
		do iofile.write("")
	
		set func = ""
		for  set func = runables(func).order() quit:func.isNull()  do {
			
			type String call
			
			if func.beginsWith("run^") set call = "$$"_ func
			else  set call = func
		
			do iofile.write(" if (runable = "_ func.addQuotes()_ ") quit "_ call_ "(args())")
		}
		
		do iofile.write("")
		do iofile.write(" quit ""Invalid procedure (""_ runable_ "") - dispatcher out of date - please run buildDBSDRV""")
		do iofile.close()
	}
	
	// Build compiled routine
	set status = $$storePsl^PSLC(TMPFILE, PROCNAME)
	set status = $$run^PSLC(PROCNAME)
	
	if (status > 0) set retVal = "Compile error - new version of DBSDRVDSP not rebuilt"
	else  set retVal = ""
	
	#ACCEPT Date=02/22/2009; Pgm=RussellDS; CR=35741; Group=ACCESS
	set status = $$DELETE^%OSSCRPT(TMPFILE)
		
	return retVal
	
	
private Integer errormsg(String errMsg)	// Message associated with failure
		  
	/*
	Write error message to stderr and return error indicator 
	*/
	
	// Direct to stderr once we are able to     
	write errMsg, !
	
	quit 1		// Error indicator
	
        
public void cmdline(String cmdStr,	// Command string
		    String args())	// Decomposed command line arguments/options

	/* ---------------------------------------------------------------------
	Decompose a string of space and/or tab delimited command line options,
	and return in args() array.
	
	A command string may use spaces and/or tabs as delimiters between
	options and arguments.  If either spaces or tabs are part of the input,
	they must be quoted.  The quote character is the double quote (").
	Values will have one layer of quotes removed, e.g., input of ABC, 
	"ABC", or AB"C will all be treated as the string ABC.  To input a
	quoted string, it is necessary to use the standard double-quoting
	convention.  E.g., input """ABC""" to produce "ABC".
	
	The command strings supported must follow a sub-set of the Unix
	conventions:

	  - required arguments are position dependent, and are specified
	    directly, i.e., without a leading dash
	    
	  - options and optional arguments are position independent, may
	    appear before, after, or intermixed with arguments, and are
	    specified with two leading dashes.  If there is an associated
	    value, an equals sign followes the option, then the value.
	    An option or optional argument identifier cannot be a number.
	    Examples:

		--option
		--option=abc
		
	  - the single dash is not supported and entries of that form will
	    be ignored

	The parsed command string will be returned as a single level array
	of type void args(String).

	Position dependent arguments will be return with numeric subscripts, 
	starting at 1, indicating their relative position (i.e., without gaps,
	even if options or optional arguments appear between them on input).
	
	Options and option arguments will be returned in the array with the
	option identifier as the subscript and any value as the array value.

	For example, the command string shown will return the array shown:
	
		funcName file1 file2 --output --opt=A file3

		args(1)=funcName
		args(2)=file1
		args(3)=file2
		args(4)=file3
		args("opt")="A"
		args("output")=""
	
	All values are Strings.  It is up to the receiving method to cast
	them into other appropriate data types.
	
	Where input is from the shell (versus input to the RPC methods),
	consideration of the shell's pre-processing must be taken into account
	if input will include spaces, tabs, or quotes.  In those cases it may
	be necessary to use the shell's escape character.
	
	For instance, to produce the command string input shown, it may be
	necessary to enter the command line as shown:
	
	  To produce:	one "tw o"
	  Enter:	one \"tw o\"
	  As arguments: args(1) = "one"
	  		args(2) = "tw o"
	  
	  To produce:	one tw"o
	  Enter:	one two\"o
	  As arguments: args(1) = "one"
	  		args(2) = "two"	- since a layer of quotes is stripped
	  		
	  To produce argument:	tw"o
	  Enter:		two\"\"\"o
	  As arguments: 	args(1) = "tw""o"
	  
	  To produce option value:	This is "just" a test
	  Enter:			-text=\"This is \"\"\"just\"\"\" a test\"
	  As argumens:			args(1)="This is ""just"" a test"
	  
	It is recommended that input involving embedded spaces, tabs, or quotes
	be tested to ensure it is properly formed when received from the shell
	command line.
	*/
	
	type Number argCnt = 0
	type String elem, tok
	
	set cmdStr = $$TOKEN^%ZS(cmdStr, .tok)
	
	// Replace TAB by SPACE and reduce multiple space to single space
	set cmdStr = cmdStr.translate(9.char(), " ").trim().replace("  ", " ")

	while 'cmdStr.isNull() do {
	
		set elem = cmdStr.piece(" ", 1)
		set cmdStr = cmdStr.piece(" ", 2, cmdStr.length())
		
		if 'elem.beginsWith("-") do {
		
			set argCnt = argCnt + 1
			set args(argCnt) = $$UNTOK^%ZS(elem, tok).stripQuotes()
		}
		else  if elem.beginsWith("--") do {
			
			type String opt = elem.piece("=", 1)
			type String value = elem.piece("=", 2, elem.length())
			
			set args(opt.extract(3, opt.length())) = $$UNTOK^%ZS(value, tok).stripQuotes()
		}
	}

	quit
 #OPTION ResultClass ON
public String vSIG()	quit "61462^42586^Dan Russell^17121"	// Signature - LTD^TIME^USER^SIZE
