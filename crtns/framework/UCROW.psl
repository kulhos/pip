  	/*
	ORIG: FSANCHEZ - 03/24/2003  arq 51423
	DESC: PSL Row class library

	---- Comments ----------------------------------------------------------
	The Row class is a generalization of the data retuned by a ResultSet or
	a RowSet. The like a Record object, the "column" values can be addressed
	as properties (by columnname) of the object. The column names, and their
	datatypes, and the column value delimiter are defined and obtained by
	methods:
	- setDelimiter() and getDelimiter() to define and obtain the delimiter
	- setColumns() and getColumns() to define the property names and their
		datatypes.
		
	Because the class is implemented as Primitive, special code is needed to
	deal with the delimiter and the property definition.
	- For every declared Row instance the node
		struct("Row", subRou, varName, decLine) = delimiter TAB columns
	- When a compilation unit contains a Row instance declaration, then
			pp^UCROW
		will be set up as post-processor, and the main compiler
		subroutine will call this post processor before it stores the
		generated M code.
	- When a Row.property reference is detected (getCol), and the column
		definition is known to be literal, the property
		reference is translated in a
			$PIECE(vRow,delim,position)
		where position is derived directly from the literal column list,
		and delim is either the (literal) expression speficied in
		setDelimiter(), or the implied default "$C(9)".
	- When a Row.property reference is detected (getCol), and the column
		definition is not literal, the property reference is translated
		in a
			$PIECE(vRow,delim,$$vRwGC(list,property))
		and list and property are supplied at runtime.
	- When a Row.property reference is detected, and the instance has FORMAL
		scope, then
			- struct("Row", subRou, varName, decLine, codeLine) = ""
			- TAB varName . property TAB is inserted in the pass 1
				code
		This case will be handled by pp^UCROW


	---- Revision History --------------------------------------------------
	09/25/07 - Frans S.C. Witte - CR: 27800
		* Corrected call to patch() in pp for array-of-Rows
		* Replaced 'public' by 'ret' in fp declarations
		* Replaced PSLLabelRecord by PSLMethod
		* Added implementation of Row.toObject
		* All PSLBuffer.insert() calls now include a resultClass

	11/07/06 - Frans S.C. Witte - CRs: 23841 / 23842
		Added InstMode parameter in call to $$insByOvs^UCREC4OP
		
	11/03/06 - Frans S.C. Witte - CRs: 22719 / 20163
		Replaced TAB by PATCHCHAR in patched tokens

	08/22/06 - Frans S.C. Witte - CRs: 22720 / 22274
		* Warnings now use warnGroup^UCGM()
		* Modified toString to tokenize arguments passed to PSL.mExpr().


	05/10/06 - Frans S.C. Witte - CRs: 21101 / 18164
		Corrected casting in PSL code generated for Row.toString()

	03/20/06 - Frans S.C. Witte - CRs: 20280 / 18164
		Modified pp, ppsub, patch, patchCalls to use PSLLabelRecord
		when manipulating lables().
		Modified template to support specification of delimiter in
		addition to columndefinition.

	03/07/06 - Frans S.C. Witte - CRs: 19821 / 18164
		Modified Row.toRecord to call $$insByOvs^UCREC4OP instead of
		setInst^UCGM()

	11/18/05 - Frans S.C. Witte - CRs: 18163 / 18164
		Adapted Row.toRecord to always call setInst^UCGM().
		actualPar copied from UCRECORD (it is no longer used in that
		routine).
		patchCalls will supply a warning if Row actual is passed to a
		local subroutine that does not expect a Row.

	11/18/05 - Frans S.C. Witte - CRs: 18727 / 18728
		Replaced this. by PSL. and removed #XECUTE do init^UCMETHOD.
		Corrected typecasting in code generated for Row.toString().
		Enabled time format in code generated for Row.toString().
		Modified labelprefix generated for methods from "vRow" to "vRw".
		Reversed parameter order of Row.toString(,,,fmtBool,fmtTime)

	05/29/05 - Frans S.C. Witte - CRs: 15028 / 16039
		Subroutine toString: generated code now explicitly casts Row to
		String.
		Subroutine patchCalls(): minor code optimization.

	12/08/04 - Frans S.C. Witte - CRs: 13403 / 13404
		Replaced .data() with .exists().

	09/02/04 - Frans S.C. Witte - CRs: 11984 / 11987
		Modified subroutine toString (and the code that it generates):
		"Boolean isQuote" changed to "String quote" (reflected in
		OBJECTMET as well).
		Added function getDelCt() to return the compile-time value of the
		delimiter or its default. Modified all subroutines that acces the
		delimiter to call $$getDelCt().
		Removed #WARN and #OPTIMIZE (conform to environment defaults)
		Row.setDelimiter() and Row.setDelimiter("") now set delimiter to
		$CHAR(9), and runtime code uses $SELECT() to substitute $CHAR(9)
		at runtime if delimiter not literal.
		Fixed bug in code generated for toRecord(), and modified code
		to support the ability to ignore fields from the Row object.

	05/12/04 - RussellDS - CR9676
		Move Profile04 version to Profile01 to support single code
		base for PSL.

	09/28/03 - Frank Sanchez CR 6031,6032,6034  - arq 51423
	    Added toRecord and toString methods

        09/16/03 - Spier CR 6031,6032,6034  - arq 51423
             Retrofit of changes made in v7.0 up to this date into Profile01
             as well as release for v7.0

	*/
	#PACKAGE framework.psl

	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	/* ****************************************************************** */
classNew	// Class constructor for new Row object
	/* ---------------------------------------------------------------------
	INPUTS:
	. PSL.actual(1) = "Row" (classname from Class.new(,))
	. PSL.actual(2) = column list
		This is the second parameter of the Class.new(,) parameter
		It can contain the literal column list, the literal template
		specification, or a non-literal runtime value.
	. PSL.actual(3) = delimiter
		This value will not be present when the subroutine is called
		for Class.new(), but the other instantiatiators may supply this
		node to define the delimiter
	NOTES:
	. This subroutine is also called when ResultSet.getRow(), and
		RowSet.getRow() need to use an intermediate variable Row class
		instance.
		And it is unconditionally called to create the Row instance for
		String.toRow().
	*/
	type public String struct(,,,)
	type public String postProc()
	type public String tab
	type public Number ER

	type Number varPtr

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if PSL.var.exists() set varPtr = $$getNew^UCGM( PSL.var, PSL.varLevel)
	else  set varPtr = ""

	if varPtr.isNull() do PSL.error("Row object can only be asigned to properly declared variable") quit

	type String del = PSL.actual(3).get()
	type String list = $$buildList( PSL.actual(2),.del)

	if del.isNull(1) set del = $$getDelCT("")	// not filled by template

	/* FSCW CR11984: del is always initialized, list may be initialized later
	if del.isNull(1) do PSL.error("Delimiter parameter required") quit
	if list.isNull(1) do PSL.error("Attribute list parameter required") quit
	*/

	set struct("Row", PSL.subRou, PSL.var, varPtr) = del_tab_list
	set postProc("Row") = "pp^"_%RoutineName

	/* FSCW CR11984: when """""" is returned, PSL compiler optimization will
	pass """" as objectName to the method generating code. However, the
	method generating subroutines require the name of the object instance in
	the struct(,,,) array. Because "$C(-1)" has the same runtime value as
	"""""", but will not be considered a LITERAL, this ensures that objectName
	contains the instance name, in stead of its value. This problem shall be
	addressed at the PSL compiler level (UCGM).
	if PSL.method = "new" set PSL.return = """"""		// Class.new
	*/
	if PSL.method = "new" set PSL.return = "$C(-1)"	// Class.new
	quit

	// ---------------------------------------------------------------------
private actualPar( String tag, Number parNum)	// Return actual parameter value
	/* ---------------------------------------------------------------------
	ARGUMENTS:
	. String tag = complete M labelref			/MECH=VAL
		label^routine(type1 act1,type2 .act2,type3 "lit")
		The type specifications are optional.
	. parNum = parameter number				/MACH=VAL
		Shall be greater than 0 and not greater than the number of
		actual parameters in tag.
		If the value is outside this range, "" will be returned

	OUTPUTS:
	. $$ the untokenized value of the requested parameter
		($$ATOM^%ZS() untokenizes by default)
	*/
	if 'parNum quit ""

	type String return = "", tok, z
	type Number cnt,ptr

	/* get paramater list: after first "(", drop last char (= ")"),
	   and tokenize literals. */	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set z=$$TOKEN^%ZS(tag.piece("(",2).extract(1,tag.length()-1), .tok)

	set cnt=0,ptr=0

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	for  set return=$$ATOM^%ZS(z,.ptr,",",.tok) do { quit:ptr=0!(cnt=parNum)

		if return="," quit
		set cnt=cnt+1

		// found type specification, get next atom
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if z.extract(ptr+1)=" " set return=$$ATOM^%ZS(z,.ptr,",",.tok)
	}
	if ptr=0 quit ""
	quit return


	// ---------------------------------------------------------------------
buildList( String list,	// property list or template
	ret String del)	// delimiter
	/* ---------------------------------------------------------------------
	Build property list string and delimiter.

	ARGUMENTS:
	list = property list
		Either a complete comma separated list of Type space Name pairs,
		or "#" followed by a template name
	del = delimiter
		In case a template is specified, del will be assigend from the
		template definition. In all other cases, this parameter is
		ignored.
	*/

	type public Number ER

 	if list.isLiteral() do {

		set list = list.stripQuotes()

		// Template syntax begins with sentinal character #
		if list.beginsWith("#") do { if ER quit

			set list = $$template(list,.del)
			set list = list.stripQuotes()
		}

		type Number i
		if 'list.isNull() for i = 1:1:list.length(",") do {

			type String col = list.piece(",",i)
			if 'col.isNull(),col.piece(" ",2).isNull() set col = "String "_col
			set col.piece(" ",2) = col.piece(" ",2).upperCase()
			set list.piece(",",i) = col
		}

		set list = list.addQuotes()
	}

	quit list


	/* ****************************************************************** */
getCol	// Get column value
	type literal String PATCHCHAR = 6.char()

	type public String postProc()
	type public String struct(,,,,)
	type public String tab

	set postProc("Row") = "pp^"_%RoutineName

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number varPtr = $$getNew^UCGM( PSL.objectName, PSL.objectLevel)

	type String list,del

	type String z = struct("Row",PSL.subRou,PSL.objectName,varPtr).get()

	set del = $$getDelCT(z),list = z.piece(tab,2)		// FSCW CR11984

	/* Row object is passed as parameter, may be able to backpatch in PP
	   after program is parsed, for now replace reference with a token.
	   Because postProc cannot append PSL subroutines, make sure $$vRwGC()
	   is included in the source. Nonsense parameters can be passed to
	   $$getColRt() because the value returned by the function will be
	   ignored. */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if list.isNull(), $$getScope^UCGM( PSL.objectName, PSL.objectLevel) [ "FORMAL" do { quit
	
		set struct("Row",PSL.subRou,PSL.objectName,varPtr,PSL.msrc+1) = ""
		set PSL.return = $$getColRt("","","","")	// force vRwGC()
		set PSL.return = PATCHCHAR_ PSL.objectName_ "."_ PSL.ref_ PATCHCHAR
		set PSL.class = "Primitive"
	}

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if PSL.fset do setInst^UCGM(PSL.objectName,PSL.msrc,"")

	set PSL.return = $$getPos(list,PSL.objectName,PSL.ref,del,.PSL.class)

	quit


	/* ****************************************************************** */
private getPos( String list,	// property list		/REQ/MECH=VAL/NONULL
		String var,	// instance variable		/REQ/MECH=VAR/NONULL
		String col,	// column name or number	/REQ/MECH=VAL/NONULL
		String del,	// delimiter			/REQ/MECH=VAL/NONULL
		ret String cls)	// return type of column	/NOREQ/MECH=REF:W
	/* Return position expression
	*/
	set cls = "Primitive"	// default in case of indirection or runtime

	if col.beginsWith("@") quit $$getColRt(var,list,col,del) // Indirection

	set col = col.upperCase()				// Case insensitive

	if 'list.isLiteral() quit $$getColRt(var,list,col,del)	// Variable

	set list = list.stripQuotes()

	type Number y = list.find(" "_col)
	if y = 0 do PSL.error("Invalid column reference: "_col) quit """"""

	type Number pos = list.extract(1,y-col.length()).length(",")

	set cls = list.piece(",",pos).piece(" ",1)		// Class of column

	quit "$P("_var_","_del_","_pos_")"


	// ---------------------------------------------------------------------
pp	// Post processor for row class, called after program is parsed
	/* ---------------------------------------------------------------------
	If the row was instantiated with a literal column list and the
	caller(s) are identifiable and there is only one list, then replace
	the column references with literal positions at compile time.

	This function only optimizes the condition where direct calling
	ancestor(s) instantiate the Row object.  Could be further
	optimized to use data flow analysis to resolve the call tree.
	*/

	type public String struct(,,,)
	type public String calls(,,,)		// calls(subRou,dcLnr,tag)
	type public PSLParser pslPrsr

	type String cls = pslPrsr.moduleName, subRou = cls_ "."
	for  set subRou = pslPrsr.pslMtd( subRou).order() quit:subRou.piece(".")'=cls  do {
		//if subRou["^" quit		// external call, ignore

		// Skip this subroutine if there aren't Row parameters
		type PSLMethod omd = pslPrsr.pslMtd( subRou)
		if omd.formalList'[" Row " quit

		type Number newPtr = omd.codeLine
		type Boolean pubAcc = (omd.accessLevel>0)
		type String mtd = subRou.piece(".",2)

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if $$isNamePSL^UCGM( mtd) quit		// exclude PSL generated methods

		type Number i
		for i = 1:1:omd.getFpCount() do {

			if omd.getFpClass( i) '= "Row" quit

			// fp of class Row
			type String frmlPar = omd.getFpVsig( i)

			/* If subroutine is accessible to external units, don't
			   bother (specify as "unknown list"), else try to trace
			   callers. */
			if pubAcc set struct("Row", mtd, frmlPar, newPtr) = ""
			else  do ppsub( subRou, frmlPar, newPtr)

			/* In both cases, replace TAB var . property TAB as
			   appropriate. */
			do patch(mtd,frmlPar.piece("("),newPtr)
		}
	}

	/* Check all calls for Row objects, if present add list and
	   delimiter parameters if appropriate (all external calls,
	   all calls to public labels, and all 'unresolved' local calls
	*/
	set subRou = ""
	for  set subRou = calls(subRou).order() quit:subRou.isNull()  do {

		type Number callat = ""
		for  set callat = calls(subRou,callat).order() quit:callat.isNull()  do {

			type String called = ""
			for  set called = calls(subRou,callat,called).order() quit:called.isNull()  if (called["Row ") do patchCalls( subRou, callat, called)
		}
	}

	quit


	// ---------------------------------------------------------------------
private patch(	String subRou,		// subroutine
		String frmlPar,		// name of formal parameter
		Number newPtr)		// line where frmlPar is declared
	/* ---------------------------------------------------------------------
	Patch msrc row.property.
	Called by pp for every formal parameter of class Row, of all subroutines
	of this compilation unit.

	If the list is unknown (a.k.a. NULL), it will be passed into
	the function at runtime as a parameter.  This code will add
	parameters for the column list and the delimiter to the
	existing formal and actual parameters.

	NOTES:
	. Because every formal parameter name is unique per subroutine, and
		every formal parameter is declared exactly once, the newPtr
		parameter is redundant. However by providing the value, this
		subroutine does not need to reference
			public PSLLabelRecord labels()
	*/
	type literal String PATCHCHAR = 6.char()

	type Number ER = 0

	type public String msrc()
	type public String struct(,,,)

	type String z = struct("Row",subRou,frmlPar,newPtr).get()

	type String del = $$getDelCT(z)
	type String list = z.piece(9.char(),2)

	// Build code to parse list and del from Row object
	if list.isNull() do {

		// Get the formal parameters and patch

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set del = $$nxtSym^UCGM()	// Get delimiter variable

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set list = $$nxtSym^UCGM()	// get list variable

		set struct("Row",subRou,frmlPar,newPtr) = del_ 9.char()_ list

		//type Number lptr = labels(subRou).codeLine
		type String code = msrc(newPtr)

		type Number y = code.find("("_frmlPar)
		if y = 0  set y = code.find(","_frmlPar)
		if y = 0!'("),"[code.extract(y)) do PSL.error("Parameter: "_frmlPar_" expected in formal list: "_code) quit

		set code = code.extract(1,y-1)_","_del_","_list_code.extract(y,code.length())
		set msrc(newPtr) = code
	}

	/* Replace all PATCHCHAR frmlPar.property PATCHCHAR occurrences by the
	   (re)calculated value of $$getPos() */
	type String test = PATCHCHAR_ frmlPar_ "."
	type Number line = 0
	for  set line = struct("Row",subRou,frmlPar,newPtr,line).order() quit:line.isNull()  do {

		type Number y
		for  set y = msrc(line).find(test,0) quit:y = 0  do {
			type Number yz = msrc(line).find( PATCHCHAR, y)
			type String ref = msrc(line).extract(y,yz-2)
			set ref = $$getPos(list,frmlPar,ref,del)
			set msrc(line) = msrc(line).extract(1,y-test.length()-1)_ref_msrc(line).extract(yz,msrc(line).length())
		}
	}

	quit


	// ---------------------------------------------------------------------
private ppsub( String subRou
		, String frmlPar
		, Number newPtr
		)	// Replace column reference tokens
	/* ---------------------------------------------------------------------
	Called by pp for every formal parameter (frmlPar) of class Row of each
	subroutine (subRou) with local access.

	If all callers use the same Row specification, both with respect to the
	columns and with respect to the delimiter, then column positions can be
	substituted at compiletime.

	NOTES:
	. There may be multiple entries in called(called) that correspond to the
		supplied subroutine. They are likely to differ in actual
		parameter names, and may be differing in number of supplied
		parameters.
	*/
	type public PSLParser pslPrsr
	type public String called(,,)		// called(tag,subRou,dcLnr)
	type public String struct(,,,)

	type Number callat
	type String actPar,actPars,actPtr,caller,srtag,r1,r2
	type PSLMethod omd = pslPrsr.pslMtd( subRou)

	type Number parNum = omd.getFpPosition( frmlPar)

	set srtag = subRou.piece( ".", 2)_ "("
	for  set srtag = called(srtag).order() quit:'srtag.beginsWith(subRou_"(")  do {

		set actPar = $$actualPar( srtag, parNum)

		if actPar.isNull() set actPar = frmlPar	// Global scope - for now

		set caller = ""
		for  set caller = called(srtag,caller).order() quit:caller.isNull()  do {
			if caller = subRou quit

			/* Find actual par of callers */
			set callat = ""
			for  set callat = called(srtag,caller,callat).order() quit:callat.isNull()  do {

				set actPtr = struct("Row", caller, actPar, callat+1).order(-1)

				if actPtr.isNull() set r1 = ""
				else  set r1 = struct("Row",caller,actPar,actPtr).get()

				/* If column definition not literal, force
				   "different" */
				if 'r1.piece( 9.char(),2).isLiteral() set r1 = ""

				/* If no definition of the Row characteristics
				   use those f the first caller */
				if 'struct("Row",subRou,frmlPar,newPtr).exists() set struct("Row",subRou,frmlPar,newPtr) = r1 quit

				set r2 = struct("Row",subRou,frmlPar,newPtr)

				/* Both the delimiter and the column definition
				   must match. */
				// if '(r2.piece($C(9),2) = r1.piece($C(9),2)) set struct("Row",subRou,frmlPar,newPtr) = ""
				if r2 '= r1 set struct("Row",subRou,frmlPar,newPtr) = ""

			}
		}
	}

	quit


	// ---------------------------------------------------------------------
private patchCalls( String subRou,	// calling subroutine
		Number callat,		// line where call occurs
		String called)		// called tag: entryref(type1 ap1, type2 ap2)
	/* ---------------------------------------------------------------------
	Add list and delimiter parameters to call if apropriate.
	
	*/

	type public String calls(,,,)
	type public String msrc()
	type public PSLParser pslPrsr
	type public String struct(,,,,)

	type Number actPtr,newPtr,ptr = 0,parnum = 1,y
	type String actPar,actPars,atom,code,del,frmlPar,label,list,rec,tok

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set called = $$TOKEN^%ZS(called,.tok)		// Tokenize it 

	set label = called.piece("(",1)
	set actPars = called.extract(called.find("("), called.length()-1)
	
	/* For each actual parameter, check if it is of class Row. If so,
	   get the associated formal parameter, and see 
	   */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	for  set atom = $$ATOM^%ZS(actPars,.ptr,",",tok) do { if ptr = 0 quit
		if atom = "," set parnum = parnum+1 quit
		if ptr,atom = "Row" do {

			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			set actPar = $$ATOM^%ZS(actPars,.ptr,",",tok)
			set rec = ""

			if '(label["^") do {

				/* If call to label that is accesible from
				   elsewhere, the additional parameters will
				   need to be added anyway. */
				type PSLMethod omd = pslPrsr.pslMtd( pslPrsr.moduleName_ "."_ label)
				if omd.accessLevel>0 quit

				set newPtr = omd.codeLine
				//set frmlPars = labels(label).formalList

				set frmlPar = omd.getFpVsig( parnum)
				set rec = struct("Row",label,frmlPar,newPtr).get()
			}

			/* The combination of the two conditions ensures that
			   we are dealing with a local calling and called pair
			   that use the same literal parameters. This relies on
			   the fact that ppsub will have modified the structure
			   when it finds conflicting specifications. */
			if 'rec.isNull(),rec.piece(9.char(),2).isLiteral() quit

			/* Find the struct associated with the declaration of
			   the actual parameter. */
			set actPtr = struct("Row",subRou,actPar,callat+1).order(-1)
			set rec = struct("Row",subRou,actPar,actPtr).get()

			set del = $$getDelCT(rec),list = rec.piece(9.char(),2)

			set code = msrc(callat)
			set y = code.find(label_"(",0)
			if y set y = code.find(actPar,y)
			if y,'(",)"[code.extract(y)) set y = 0 
			if y,'("(,."[code.extract(y-actPar.length()-1)) set y = 0
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			if y = 0 do warnGroup^UCGM("MISMATCH","Row instance passed to subroutine that does not expect Row: "_called) quit

			/* Insert the delimiter and columndefinition for this
			   actual. */
			set code = code.extract(1,y-1)_","_del_","_list_code.extract(y,code.length())
			set msrc(callat) = code
		}
	}

  	quit


	/* ****************************************************************** */
private getColRt( String rec,	// name of Row instance
		String list,	// property list (T1 c1,T2  c2,...)
		String ref,	// property name or number
		String del)	// property delimiter
	/* Return column position at runtime
        */
	type literal String label = "vRwGC"
	
	if 'PSL.subrouExists(label) do {
 
		type PSLBuffer buf = PSL.openBuffer("(String vList,String vRef)","Dynamic column position lookup")
		do buf.add("")
		do buf.add("if vRef.isNull() quit """"")
		do buf.add("if vRef.toNumber()>0 quit vRef")
		do buf.add("")
		do buf.add("set vList = vList.upperCase(), vRef = vRef.upperCase()")
		do buf.add("type Number vP = (vList_"","").find("" ""_vRef_"","")")
		do buf.add("if vP = 0 set vP = ("",""_vList_"","").find("",""_vRef_"","") if vP = 0 quit """"")
		do buf.add("quit vList.extract( 1, vP - vRef.length()).length("","")")

		do buf.insert(label, "String")
	}

	if ref.beginsWith("@") set ref = ref.extract(2,ref.length())
	else  set ref = ref.addQuotes()

	quit "$P("_rec_","_del_",$$"_label_"("_list_","_ref_"))"


	/* ****************************************************************** */
getDel	// get the delimiter list of a Row object

	type public String struct(,,,,)
	type public String postProc()

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number newPtr = $$getNew^UCGM( PSL.objectName, PSL.objectLevel)

	type String rec = struct("Row",PSL.subRou,PSL.objectName,newPtr).get()
	
	set postProc("Row") = "pp^"_%RoutineName

	set PSL.return = $$getDelCT( rec)	// FSCW CR 11984: use $$getDelCT()
	
	quit

	/* ****************************************************************** */
private getDelCT(String rowDes)	// rowDescriptor (delim tab proplist	/REQ/NONULL
	/* Return the compile-time value of the delimiter.
	If the first piece of the descriptor is not empty, then it is returned.
	Else, "$C(9)" is returned.

	As long as PSL does not support LITERALS with MODULE SCOPE, all functions
	and subroutines shall use $$getDelCT() to obtain a consistent value for
	the delimiter.
	*/
	if 'rowDes.piece(9.char()).isNull() quit rowDes.piece(9.char())
	quit "$C(9)"


	/* ****************************************************************** */
getProp	// get the properties list of a Row object

	type public String struct(,,,,)
	type public String postProc()

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number newPtr = $$getNew^UCGM( PSL.objectName, PSL.objectLevel)

	type String rec = struct("Row",PSL.subRou,PSL.objectName,newPtr).get()
	
	set postProc("Row") = "pp^"_%RoutineName
	if 'rec.piece(9.char(),2).isNull() set PSL.return = rec.piece(9.char(),2)
	quit


	/* ****************************************************************** */
setProp	// Set the properties list of a Row object

	type public String struct(,,,,)
	type public String postProc()

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number newPtr = $$getNew^UCGM( PSL.objectName, PSL.objectLevel)

	type String rec = struct("Row", PSL.subRou, PSL.objectName, newPtr).get()

	type String del  = rec.piece(9.char())
	type String list = rec.piece(9.char(),2)
	
	// Currently disallow multiple definitions, causes conflicts in post processor
	if 'list.isNull() do PSL.error("ColumnList definition already exists: "_list) quit

	set rec.piece(9.char(),2) = $$buildList( PSL.actual(1),.del)
	set rec.piece(9.char()) = del

	set struct("Row", PSL.subRou, PSL.objectName, newPtr) = rec
	set postProc("Row") = "pp^" _ %RoutineName
	quit


	/* ****************************************************************** */
setDel	// Set the delimiter attribute of a Row object
	
	type public String struct(,,,,)
	type public String postProc()

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number newPtr = $$getNew^UCGM( PSL.objectName, PSL.objectLevel)

	type String rec = struct("Row",PSL.subRou,PSL.objectName,newPtr).get()

	/*
	type String del = rec.piece($C(9),1)

	// Currently disallow multiple definitions, causes conflicts in post processor
	if 'del.isNull() do PSL.error("Delimiter definition already exists: "_del)
	*/
	type String del = PSL.actual(1)
	if del.isNull(1) set del = $$getDelCT("")
	
	if 'del.isLiteral(),del.upperCase()'?1"$C".A1"("1.N1")" set del = "$S("_del_"]"""":"_del_",1:$C(9))"
	
	set rec.piece(9.char()) = del
	set struct("Row", PSL.subRou, PSL.objectName, newPtr) = rec
	set postProc("Row") = "pp^" _ %RoutineName

	quit


	// ---------------------------------------------------------------------
toObject	// method: Row.toClass(Object identifier,String columnMap)
	// Copy a row to a record
	type public PSLParser pslPrsr
	type public PSLTokenizer tknzr
	type public String struct(,,,,)
	type static PSLClass

	type String di,table,tok,map()
	type PSLIdentifier name = PSL.actual(1)
	type String xmap = PSL.actual(2)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number newPtr = $$getNew^UCGM( PSL.objectName, PSL.objectLevel)
	type String z = struct("Row",PSL.subRou,PSL.objectName,newPtr).get()
	type String delimit = z.piece(9.char())
	type String columns = z.piece(9.char(),2)

	if columns.isNull() do PSL.error("Columns list missing: "_ PSL.objectName) quit
	if 'columns.isLiteral() do PSL.error("Columns list must be literal: "_ PSL.objectName) quit
	if 'xmap.isLiteral() do PSL.error("ColumnMap must be literal: "_ PSL.objectName) quit

	if name.isNull() do PSL.error("Target object identifier required") quit

	type String varClass = name.class

	if varClass.isNull() do PSL.error("Target object is not in scope:"_name) quit

	/* Mark the use of this variable as an instantiation. This is similar
	   to any other subroutine call that passes an object. However, this
	   occurrence will not have been detected by the compiler automatically.
	   */
	type Number dummy
	if PSLClass.isRecord(varClass) > 0 set dummy = $$insByOvs^UCREC4OP( PSL.subRou, name, "", "U")

	// Set up one-to-one map between Row object and Record object

	type Number i

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set z = $$TOKEN^%ZS(columns.stripQuotes(),.tok)

	for i = 1:1:z.length(",") do {
		type String di = z.piece(",",i)

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set di = $$UNTOK^%ZS(di,.tok).piece(" ",2).lowerCase()
		set map(di) = di
	}

	if 'xmap.isNull(1) do {
		type String z = xmap.stripQuotes()

		for i = 1:1:z.length(",") do {
			type String ndi,x
			set x = z.piece(",",i)
			set di = x.piece("=",1).trim().lowerCase()
			set ndi = x.piece("=",2).trim()

			if di.isNull() do PSL.error("Invalid map expression: "_x) quit
			if pslPrsr.findPSLProperty( tknzr, varClass_"."_ndi, 1).isNull() do PSL.error("MISMATCH: Invalid property: "_varClass_"."_ndi) quit
		 	set map(di) = ndi
		}
 	}

	/* Make sure every occurrence ends up in its own subroutine because the
	   post-processing will not look at PSL names when patching the formal
	   and actual parameter lists */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String label = $$findSubr^UCGM("vRwTO","") 

	type String code = "(Row vRow,"_varClass_" vObj)"

	type PSLBuffer buf = PSL.openBuffer(code,"Copy Row to "_varClass)

	set z = columns

	do buf.add("do vRow.setColumns("_z_")")
	do buf.add("do vRow.setDelimiter("_delimit_")")
	set di = ""
	for  set di = map(di).order() quit:di.isNull()  do {
		if map(di).isNull() quit
		set code = "set vObj."_map(di)_" = vRow."_di
		do buf.add(code)
	}

	do buf.add("quit")
	do buf.insert(label, "void")

	set PSL.return=label_"(."_PSL.objectName_",."_name_")"

	quit

	/* ****************************************************************** */
toRecord	// method: Row.toRecord(Record identifier,String columnMap)
	// Copy a row to a record

	type public Number ER
	type public String struct(,,,,)
	type static PSLClass

	type String di,table,tok,map()

	type PSLIdentifier name = PSL.actual(1)
	type String xmap = PSL.actual(2)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number newPtr = $$getNew^UCGM( PSL.objectName, PSL.objectLevel)

	type String z = struct("Row",PSL.subRou,PSL.objectName,newPtr).get()
	type String delimit = z.piece(9.char())
	type String columns = z.piece(9.char(),2)

	if columns.isNull() do PSL.error("Columns list missing: "_ PSL.objectName) quit

	if name.isNull() do PSL.error("Record identifier required") quit

	type String varClass = name.class
	//type String instExpr = name.instExpr

	if varClass.isNull() do PSL.error("Record object is not in scope:"_name) quit
	if PSLClass.isRecord(varClass) = 0 do PSL.error("Object parameter is not a Record<Class>: "_name) quit

	/* Mark the use of this variable as an instantiation. This is similar
	   to any other subroutine call that passes an object. However, this
	   occurrence will not have been detected by the compiler automatically.
	   */
	type Number dummy = $$insByOvs^UCREC4OP( PSL.subRou, name, "", "U")

	// Set up one-to-one map between Row object and Record object

	type Number i
	if columns.isLiteral() do {

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		type String z = $$TOKEN^%ZS(columns.stripQuotes(),.tok)

		for i = 1:1:z.length(",") do {

			type String di = z.piece(",",i)

			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			set di = $$UNTOK^%ZS(di,.tok).piece(" ",2).lowerCase()
			set map(di) = di
		}
	}

	if xmap.isLiteral(),'xmap.isNull(1) do {

		type String z = xmap.stripQuotes()

		for i = 1:1:z.length(",") do { quit:ER

			type String ndi,x
			set x = z.piece(",",i)
			set di = x.piece("=",1).trim().lowerCase()
			set ndi = x.piece("=",2).trim()

			//if di.isNull()!ndi.isNull() do PSL.error("Invalid map expression: "_x) quit
			if di.isNull() do PSL.error("Invalid map expression: "_x) quit

		 	set map(di) = ndi
			//if 'ndi.isNull() kill map(ndi)
		}
 	}

	/* Make sure every occurrence ends up in its own subroutine because the
	   post-processing will not look at PSL names when patching the formal
	   ans actual parameter lists */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String label = $$findSubr^UCGM("vRwTR","") 

	type String code = "(Row row,"_varClass_" record"

	if 'columns.isLiteral() set code = code_",String columns"
	if 'xmap.isNull(1) set code = code_",String xmap"

	type PSLBuffer buf = PSL.openBuffer(code_")","Copy Row to"_varClass)

	set z = columns
	if 'z.isLiteral() set z = "columns"

	do buf.add("type public "_varClass_" record")	// declare PUBLIC to prevent vosc scope
	do buf.add("do row.setColumns("_z_")")
	do buf.add("do row.setDelimiter("_delimit_")")

	//if 'instExpr.isNull() do buf.add("#xecute do setInst^UCGM("_name.addQuotes()_",msrc,"_instExpr.addQuotes()_")")

	if 'columns.isLiteral() ! ('xmap.isLiteral() & 'xmap.isNull(1)) do {

		do buf.add("type Number i")
		do buf.add("type String di")
		if columns.isLiteral() do buf.add("type literal String columns = "_columns)

		if 'xmap.isNull(1) do {			// Add mapping logic

			do buf.add("type String map()")
			do buf.add("set di = """"")
			do buf.add("for i=1:1:xmap.length("","") set di = xmap.piece("","",i),map(di.piece(""="",1).trim()) = di.piece(""="",2).trim()")
		}

		do buf.add("for i = 1:1:columns.length("","") do {")
		do buf.add(" set di = columns.piece("","",i)")
		do buf.add(" if di["" "" set di = di.piece("" "",2)")
		if 'xmap.isNull(1) do buf.add(" if map(di).exists() set di = map(di)")
		do buf.add(" if 'di.isNull() set record.@di = {String}row.piece("_delimit_",i)")
		do buf.add("}")
	}

	else  do {

		set di = ""
		for  set di = map(di).order() quit:di.isNull()  do {

			/*
			type String code = "set record."_di_" = "
			if '("':"[map(di).extract(1)) set code = code_"row."
			set code = code_map(di)
			*/
			if map(di).isNull() quit
			type String code = "set record."_map(di)_" = row."_di
			do buf.add(code)
		}
	}

	do buf.add("quit")
	do buf.insert(label, "void")

	set PSL.return=label_"(."_PSL.objectName_",."_name

	if 'columns.isLiteral() set PSL.return = PSL.return_","_columns
	if 'xmap.isNull(1) set PSL.return = PSL.return_","_xmap
	set PSL.return = PSL.return_")"

	quit

 
	// ---------------------------------------------------------------------
private template( String expr,
		  ret String del)
	/* ---------------------------------------------------------------------
	Row list is a template (unfinished)
	*/
	type String tmplcol = ""
	type Number tmpldel
	type Row    tmplrow = Class.new( "Row", "String coldefs,Number delim")
	
	set expr = expr.extract(2,expr.length())		// Strip #

	// If an extrinsic function, execute and return string
	if expr.beginsWith("$$") do {
		catch xecEx {
			do PSL.error("Error in Row template "_expr_": "_xecEx.toString())
		}
		#ACCEPT DATE=4/22/03; PGM=Frank Sanchez; CR=Frank Sanchez;GROUP=XECUTE
		xecute "S tmplrow="_ expr
		set tmpldel = tmplrow.delim
		if 'tmpldel.isNull() set del = "$C("_ tmpldel_")"
		set tmplcol = tmplrow.coldefs.addQuotes()
	}
	else  do {
		do PSL.error("Unsupported template specification")
	}
	quit tmplcol

	// ---------------------------------------------------------------------
toString	//Method: Row.toString(colDel,quoChar,fmtDate,fmtTime,fmtBool)

	type String colDel  = PSL.actual(1)	// column separator in result
	type String quoChar = PSL.actual(2)	// add quotes to String types?
	type String fmtDate = PSL.actual(3)	// output format for Date types
	type String fmtTime = PSL.actual(4)	// output format for Time types
	type String fmtBool = PSL.actual(5)	// output format for Boolean types

	type public String struct(,,,,)
	type public String postProc()

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number newPtr = $$getNew^UCGM( PSL.objectName, PSL.objectLevel)

	type String rec = struct("Row",PSL.subRou,PSL.objectName,newPtr).get()

	type String rowDel = $$getDelCT(rec)
	type String list = rec.piece(9.char(),2)

	set PSL.return = PSL.objectName

	if colDel.isNull(1) set colDel = rowDel

	type String mask

	if list.isLiteral() do {

		set list = list.stripQuotes()

		if '(","_list[",String ")  set quoChar = ""
		if '(","_list[",Date ")    set fmtDate = ""
		if '(","_list[",Time ")    set fmtTime = ""
		if '(","_list[",Boolean ") set fmtBool = ""

		type Number i
		set mask = list.extract(1)
		for i=2:1:list.length(",") set mask = mask_list.piece(",",i).extract(1)
		set mask = mask.addQuotes()
	}

	else  set mask = list

	if quoChar.isNull(1),fmtDate.isNull(1),fmtTime.isNull(1),fmtBool.isNull(1) do { quit

		if '(colDel = rowDel) do {
			/* ---------------- begin old code ----------------
			   This code suggested that a Row can be casted to a
			   String, which is no longer true.
			set PSL.return = $$tokenPush^UCPATCH( PSL.objectName, "Row")
			set rowDel = $$tokenPush^UCPATCH( rowDel, "String")
			set colDel = $$tokenPush^UCPATCH( colDel, "String")
			set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "{String}"_ PSL.return_ ".translate("_rowDel_","_colDel_")"), 3)
			---------------- end old code ---------------- */
			set PSL.return = "$TR("_ PSL.return_ ","_rowDel_","_colDel_")"			
		}
	}

	type String label = "vRwTS"
	
	if 'PSL.subrouExists(label) do {
 
		type PSLBuffer buf = PSL.openBuffer("(String row,String rowDel,String mask,String colDel,String quote,String fDate,String fTime,String fBool)","Convert Row to formatted String")

		do buf.add("")
		do buf.add("if mask["" "" do {")
		do buf.add(" type Number i")
		do buf.add(" type String z = mask.extract(1)")
		do buf.add(" for i = 2:1:mask.length("","") set z = z_mask.piece("","",i).extract(1)")
		do buf.add(" set mask = z")
		do buf.add("}")

		do buf.add("type Number y = 0")
		do buf.add("if 'fDate.isNull() for  set y = mask.find(""D"",y) quit:y = 0  set row.piece(rowDel,y-1) = ({Date}(row.piece(rowDel,y-1))).toString(fDate)")
		do buf.add("if 'fTime.isNull() for  set y = mask.find(""T"",y) quit:y = 0  set row.piece(rowDel,y-1) = ({Time}(row.piece(rowDel,y-1))).toString(fTime)")
		;do buf.add("if 'fBool.isNull() for  set y = mask.find(""B"",y) quit:y = 0  set row.piece(rowDel,y-1) = ({Boolean}(row.piece(rowDel,y-1))).toString(fBool)")
		do buf.add("if 'quote.isNull() for  set y = mask.find(""S"",y) quit:y = 0  set row.piece(rowDel,y-1) = row.piece(rowDel,y-1).addQuotes(quote)")
		do buf.add("")
		do buf.add("if '(rowDel = colDel) set row = row.translate(rowDel,colDel)")
		do buf.add("quit row")
		do buf.insert(label, "String")
	}
	if quoChar.isNull(1) set quoChar = """"""
	if fmtDate.isNull(1) set fmtDate = """"""
	if fmtBool.isNull(1) set fmtBool = """"""
	if fmtTime.isNull(1) set fmtTime = """"""

	set PSL.return="$$"_label_"("_PSL.objectName_","_rowDel_","_mask_","_colDel_","_quoChar_","_fmtDate_","_fmtTime_","_fmtBool_")"
	quit
 #OPTION ResultClass ON
public String vSIG()	quit "61296^59347^Frans S.C. Witte^39748"	// Signature - LTD^TIME^USER^SIZE
