	/*
	ORIG: Frans S.C. Witte - 2005-03-22
	DESC: Code for methods of class Db that is called at runtime

	---- Environment Sensitive Elements ------------------------------------
	RsMsDTL
		This subroutine contains an occurrence of String.upperCase()
		that deals with potentially arbitrary SQL literals, which makes
		this unit CharacterSet dependent.

	---- Comments ----------------------------------------------------------
	To support dynamic select, the interpretation of values supplied to some
	of the methods is postponed until runtime. The functions and subroutines
	that handle this are clustered in a separate DQ procedure to enhance
	memory use at runtime.

	Naming conventions within this routine:
	. rdb*	= RDB related
	. Rs*	= ResultSet related (runtime behavior for Db.select() and
		Db.selecDbSet().
	. RsMs*	= ResultSet, Map Symbols
		Subroutines and functions that rewrite the clauses and construct
		the symbol map.

	---- Revision History --------------------------------------------------
	2009-04-22 - RussellDS - CR39733
		* Modified handling of -162 node related to blobs in rdbSaveC
		  to avoid problems in UTF environment
		* Fixed problem in rdbSave* to ignore -161 nodes that do not
		  indicate any columns modified
	
	2008-11-06, Frans S.C. Witte, CRs 35741/36525/36492
		* Corrected RsMsSel() to accept ASC and DESC as column name.

	2008-10-20, Frans S.C. Witte, CR35992
		* Added deprecation notice to description of rdb().
		* Replaced $$rtIsRdb^UCXDD() with $$isRdb^vRuntime().
		* Added code to deal with callback-computed in ORDERBY/GROUPBY
		* Added delimiter parameter to RsMsXV

	10/19/2008 - RussellDS - CR35741/35918
		Modified rdbSaveC section to clarify and correct handling of
		-152 node when it is not present, and corrected comment related
		to -152 in rdbSaveS section.
	
	08/22/2008 - RussellDS - CR30801
		Modified rdbSaveC^UCDBRT and rdbSaveS^UCDBRT to reset nodes 
		-161 and -162.
		
	2008-07-09, Frans S.C. Witte, CR34739
		Modified RsMsWtChild and RsMsWtList to fully support Db.select()
		with multiple parent/child tables.

	01/02/2008 - Frans S.C. Witte - CR30811
		Added support for parent/child tables in general (as opposed to
		for ACN/DEP/LN only).

	09/24/2007 - RussellDS - CR29295
		* Added functions rColIns and rColUpd to support RDB column
		  update/insert code which manage nodes -161 & -162 for construction
		  of update/insert data.  These functions are used when the in-line
		  code form will cause lines to be excessively long.
		  (See cdRdbAsn^UCXDD).
		* Added labels rdbSaveS and rdbSaveC to provide common code to
		  perform RDB UPDATE and INSERT based on data vobj.  With the
		  addition of nodes -161/-162, these replace the obsolete
		  VOBJ^DBSDBASE.
		* Eliminated wrapper functions for calls to %DBAPI as %DBAPI now
		  has equivalent functions that throw errors.
		* Clean up warnings due to new compiler changes.
		  
	08/29/07 - Frans S.C. Witte - CR:27800
		* Cleanup / correct use of List

	07/19/07 - Frans S.C. Witte - CR: 28353
		* Modified parameter in call to $$COLLIST^DBSDD() to include
		  Masterfields.

	03/18/07 - Frans S.C. Witte - CR: 26364
		* Added support for additional parameter to computed functions.
		* Optimized $$RsRdb() to prevent call to RsMsCls() if not RDB.

	02/12/07 - Frans S.C. Witte - CRs: 25185 / 25186 / 25187
		* Removed wrSave() because all code has been recompiled with the
		  previous version.

	08/31/06 - RussellDS, Frans S.C. Witte - CRs: 22719 / 20613
		* Modified wrSAVE call to VOBJ^DBSDBASE to match new calling
		  signature and removed calls to EXECUTE^%DBAPI().
		* Code in RsMsXV no longer adds quotes for non-numeric hostvar
		  values (requires new DB API!)
		* All %PSL-E-SQLFAIL exceptions now include the error message
		  returned by the API, with newline translated into space, and
		  comma into tilde.
		* All calls to %DBAPI now pass 0 (zero) instead of "" for vIndex

	06/30/06 - Frans S.C. Witte - CRs: 21397 / 21937
		* Added wrSAVE() as a wrapper for VOBJ^DBSDBASE().
		* Modified code generated for DQMODE join with DEP or LN.
		* Modified RsMsXV to call $$kwdRow^UCDTAUTL()

	06/14/06 - Frans S.C. Witte - CRs: 21791 / 21792
		* Added wrEXEC() as a wrapper for $$EXECUTE^%DBAPI().
		* Corrected code that added DEP.QID1 / LN.QID1 in $$RsMsWtD().

	05/10/06 - Frans S.C. Witte - CRs: 21101 / 18164
		* Code that constructs SELECT * replacement now in separate
		  function (that will also be called from UCDB).

	03/07/06 - Frans S.C. Witte - CRs: 20280 / 18164
		* Added support for SELECT *

	03/27/06 - Frans S.C. Witte - CRs: 20370 / 18164
		* RsMsWtL: the unqualified columnnames from the childtable's
		  query will now only be matched against ACN.

	03/16/06 - Frans S.C. Witte - CRs: 19170 / 18164
		* RsMsCls: null() will now also be maintained for computeds
		* RsMsXV: hostvartype "v" (unknown) now treated as "T" (was "N")

	03/06/06 - Frans S.C. Witte - CRs: 19760 / 18164
		* Added support for :%SystemKeyword as special case of hostvar.
		* Corrected Error-constructors in wrEXECSP and wrSELECT.

	02/22/06 - Frans S.C. Witte - CRs: 18981 / 18164
		* Modified RsMsDQMD to deal with (perceived) bug in Oracle.
		* Modified RsMsWtD to add CLS='L' or CLS='D' if ACN and at least
		  one other table were included. See that function for
		  explanation.

	02/02/06 - Frans S.C. Witte - CRs: 18163 / 18164
		* {PSLXyz} casts replaced by proper method calls.
		* Corrected problem with NOT in combination with less-than, etc.
		* hostvars that are inferred as "RDB numeric" will now be
		  "plussed" when passed to DB API.

	01/04/06 - Frans S.C. Witte - CRs: 19000
		* Functions $$RsMsQcn() and $$RsMsIns(): SYSDAT and "SYSDAT" are
		  now treated as different entities. SYSDAT is translated into
		  %CurrentDate and handled separately by $$RsMsVX().
		* Corrected RsMsSel to deal with literal as first expratom in
		  select primitive.

	10/10/05 - Frans S.C. Witte - CRs: 17937 / 15593
		* added $$wrEXECSP() and $$wrSELECT()
		* Modified SchemaTable by PSLTable
		* RsMsDQMD now accepts tables like CUVAR (that have no primary
		  key).
		* RsMsXV now accepts a third parameter that requests to include
		  code that converts external values to internal values.

	08/23/05 - Frans S.C. Witte - CR16965
		* Modified RsMsSel to support names of computed columns that do
		  not conform to the SQL standard definition of identifier.

	06/28/05 - Frans S.C. Witte - CR16444
		* Added support for computed column in ORDER BY: added functions
		  $$RsMsSel() and $$RsMsSelE(), modified functions $$RsMsBld()
		  and $$RsMsCls().
		* Replaced (direct) references to DBTBL1D by calls to ^UCXDD.
		* Fixed single table name replacement
		* Fixed / modified wide table SELECTs with columns from ACN only

	06/03/05 - Frans S.C. Witte - CRs: 16142 / 16143
		Removed RsMsJoin (it is no longer called)
		Added $$RsMsDQMD(), $$RsMsWtACN(), RsMsWtD(), RsMsWtL().
		Modified $$RsMsBld() and $$RsMsCls() to call these functions and
		subroutines.
		Added support for computed columns and (masterfield) SQL
		expressions to $$RsMsCls() and $$RsMsIns().
		$$RsRdb() now calls $$RsMsCls() instead of ^SQLJ.
		Added support for computed columns in ORDER BY.

	03/25/05 - Frans S.C. Witte - CRs: 14919 / 14920
		Initial version. Subroutine RselDyRT() has been	moved from UCDB.m
		into this unit, and renamed RsDyRT().
		Introduced $$RsMsBld(), $$RsMsCls(), $$RsMsDT(), RsMsEx,
		$$RsMsIns(), $$RsMsJoin(), $$RsMsQcn(), RsMsSub, $$RsMsXI(),
		$$RsMsXV(), $$RsRdb() and $$RsSelList().
	*/
	#PACKAGE framework.psl

	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.  The M routine from the     *
	// * crtns directory should be used for this purpose.                *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	// ---------------------------------------------------------------------
public rdb( String table)	// **** DEPRECATED ****
	/* ---------------------------------------------------------------------
	For $$rdb^UCDBRT(table) use rtIsRdb^UCXDD()
	For $$rdb^UCDBRT() use isRdb^vRuntime()
	*/
	if 'table.exists() quit $$isRdb^vRuntime()
        quit $$rtIsRdb^UCXDD( table)

	// ---------------------------------------------------------------------
public rdbColIns( Boolean noOverlay,	// no overlay checking
		  Record recobj,	// PSL Object
		  PSLExpression intCln,	// internal column name
		  PSLExpression nod,	// node
		  String dlmStr,	// table delimiter
		  PSLExpression value)	// value to assign to column
	/* ---------------------------------------------------------------------
	Function to manage updating nodes -161/-162 for RDB column updates
	when the equivalent in-line code will result in excessive line lengths.
	This function maintains -161/-162 for the insert form, and is coded
	to handle possible overlay situations (i.e., where a column may be set
	more than once), or not, based on noOverlay.

	ARGUMENTS:  see cdRdbAsn^UCXDD

	OUTPUTS:
	. $$ = ""	Always returns null.  Implemented as a function to
			avoid affecting $T in caller.
	*/
	type public String vobj(,,)
	
	type Number obj

	/* Remove this ACCEPT when we eventually can deal with the proper
	   passing of an object and use of the object pointer.
	   See bypassSave^DBSDYNRA
	*/
	#ACCEPT Date=09/30/2007; Pgm=RussellDS; CR=29295; Group=DEPRECATED
	set obj = recobj.getPointer()

	if 'noOverlay, (vobj(obj, -161, nod) [ (","_ intCln_ "=")) set vobj(obj, -162, nod).piece(dlmStr, vobj(obj, -161, nod).piece((","_ intCln_ "=")).length(",")+1) = value
	else  do {
		set vobj(obj, -161, nod) = vobj(obj, -161, nod)_ ","_ intCln_ "="
		set vobj(obj, -162, nod) = vobj(obj, -162, nod)_ dlmStr_ value
		set vobj(obj,-161,nod).piece(",", 1) = vobj(obj, -161, nod) + 1
	}
	quit ""


	// ---------------------------------------------------------------------
public rdbColUpd( Boolean noOverlay,	// no overlay checking
		  Record recobj,	// PSL Object
		  PSLExpression intCln,	// internal column name
		  PSLExpression nod,	// node
		  String dlmStr,	// table delimiter
		  PSLExpression value)	// value to assign to column
	/* ---------------------------------------------------------------------
	Function to manage updating nodes -161/-162 for RDB column updates
	when the equivalent in-line code will result in excessive line lengths.
	This function maintains -161/-162 for the update form, and is coded
	to handle possible overlay situations (i.e., where a column may be set
	more than once), or not, based on noOverlay.

	ARGUMENTS:  see cdRdbAsn^UCXDD

	OUTPUTS:
	. $$ = ""	Always returns null.  Implemented as a function to
			avoid affecting $T in caller.
	*/
	type public String vobj(,,)

	type Number obj

	/* Remove this ACCEPT when we eventually can deal with the proper
	   passing of an object and use of the object pointer.
	   See bypassSave^DBSDYNRA
	*/
	#ACCEPT Date=09/30/2007; Pgm=RussellDS; CR=29295; Group=DEPRECATED
	set obj = recobj.getPointer()

	if 'noOverlay, (vobj(obj, -161, nod) [ (","_ intCln_ "=")) set vobj(obj, -162, nod).piece( dlmStr, vobj(obj, -161, nod).piece( ","_ intCln_ "=:HV", 2) + 1) = value
	else  do {
		type Number vCc = +vobj(obj, -161, nod)
		
		set vobj(obj, -161, nod) = vobj(obj, -161, nod)_ ","_ intCln_ "=:HV"_ vCc
		set vobj(obj, -162, nod) = vobj(obj, -162, nod)_ dlmStr_ value
		set vobj(obj,-161,nod).piece(",", 1) = vCc + 1
	}
	quit ""

	
	// ---------------------------------------------------------------------
public rdbSaveS(Record recobj,		// PSL Object
		String dlmStr,		// table delimiter
		String where)		// WHERE clause with host variables (*3)
	/* ---------------------------------------------------------------------
	Saves (update or insert) data for an RDB table based on the column
	information in nodes -161/-162.  This code deals with "simple" tables,
	i.e., table that have a single nod value used internally in vobj, which
	excludes wide tables and table that have blobs or memos.  This nod value
	in this case is "0*".

	The related code in rdbSaveC deals with "complex" tables that may be
	represented across multiple nod values.

	See cdRdbAsn^UCXDD for documenation related to -161/-162 nodes.

	Node -152 contains the host variables values list, with a trailing
	delimiter.

	ARGUMENTS:
	(*3) where - WHERE clause, built by getWhrKey^UCXDD, using host
		variables.  Host variable numbers must be in key order
		to match the host variable value list in node -152.
	*/

	type literal Number maxLen = PSL.maxStringLength
	type literal String nod = "0*"

	type public String vobj(,,)

	type Number obj
	type String ret

	/* Remove this ACCEPT when we eventually can deal with the proper
	   passing of an object and use of the object pointer.
	   See bypassSave^DBSDYNRA
	*/
	#ACCEPT Date=09/30/2007; Pgm=RussellDS; CR=29295; Group=DEPRECATED
	set obj = recobj.getPointer()
	
	quit:(vobj(obj, -161, nod) '> 1)	// No columns modified

	// -152 will not exist if no keys, e.g., CUVAR	
	if (vobj(obj, -2) = 1) do {

		type String vlist = vobj(obj, -162, nod).piece(dlmStr, 2, maxLen)_ dlmStr_ vobj(obj, -152).get()

		set ret=$$EXECUTESQL^%DBAPI(0,"UPDATE "_ vobj(obj, -162, nod).piece(dlmStr, 1)_ " SET "_ vobj(obj, -161, nod).piece(",", 2, maxLen)_ where, dlmStr, vlist)
	}
	else  do {

		type Number i
		type String cols, HVs

		set (cols, HVs) = ""

		for i = 2:1:vobj(obj, -162, nod).length(dlmStr) set cols = cols_ ","_ vobj(obj, -161, nod).piece(",", i).piece("=", 1), HVs = HVs_ ",:HV"_ (i - 1)

		set ret = $$EXECUTESQL^%DBAPI(0, "INSERT INTO "_ vobj(obj, -162, nod).piece(dlmStr, 1)_ " ("_ cols.piece(",", 2, maxLen)_ ") VALUES ("_ HVs.piece(",", 2, maxLen)_ ")", dlmStr, vobj(obj, -162, nod).piece(dlmStr, 2, maxLen)_ dlmStr)
	}
	
	// Reset
	set vobj(obj, -161, nod) = "1", vobj(obj, -162, nod) = vobj(obj, -162, nod).piece(dlmStr)
		
	quit
	
	
	// ---------------------------------------------------------------------
public rdbSaveC(Record recobj,		// PSL Object
		String dlmStr,		// table delimiter
		String where)		// WHERE clause with host variables (*3)
	/* ---------------------------------------------------------------------
	Saves (update or insert) data for an RDB table based on the column
	information in nodes -161/-162.  This code deals with "complex" tables,
	i.e., table that may have multiple nod value used internally in vobj, which
	includes wide tables and table that have blobs or memos.

	The related code in rdbSaveS deals with "simple" tables that only have a
	single nod value.

	See cdRdbAsn^UCXDD for documenation related to -161/-162 nodes.

	Node -152 contains the host variables values list, with a trailing
	delimiter.

	ARGUMENTS:
	(*3) where - WHERE clause, built by getWhrKey^UCXDD, using host
		variables. Host	variable numbers must be in key order
		to match the host variable value list in node -152.
	*/

	type literal Number maxLen = PSL.maxStringLength

	type public String vobj(,,)

	type Number collOrder, obj
	type String nod, ret

	/* Remove this ACCEPT when we eventually can deal with the proper
	   passing of an object and use of the object pointer.
	   See bypassSave^DBSDYNRA
	*/
	#ACCEPT Date=09/30/2007; Pgm=RussellDS; CR=29295; Group=DEPRECATED
	set obj = recobj.getPointer()

	/* If insert, do main table(s) first, then blobs/memos as updates.
	   If update, do blobs/memos first, since may be key change and
	   need to make sure blob/memo is updated first.  Control with
	   collOrder (collating order).
	*/
	if (vobj(obj, -2) = 0) set collOrder = 1
	else  set collOrder = -1

	set nod = ""
	for  set nod = vobj(obj, -161, nod).order(collOrder) quit:nod.isNull()  do {
		
		quit:(vobj(obj, -161, nod) '> 1)	// No columns
	
		/* nod containing comma indicates blob/memo.  Only single blob or
		   memo per node.
		   
		   collOrder = -1 indicates update
		*/
		if nod.isLike("%,%") do {
			
			/* Since dealing with a LOB, need to treat value as a
			   byte string to avoid UTF-8 problems. */
			
			type ByteString nod162 = vobj(obj, -162, nod).toByteString()
			type String tbl = nod162.piece(dlmStr, 1)
			
			/* -152 will exist except for inserts and then is only needed
			   if doing a LOB update as part of an insert.  In that case,
			   construct it.
			*/
			if 'vobj(obj, -152).exists() do {
	
				type Number i
	
				set vobj(obj, -152) = ""
				for i = -3:-1 quit:'vobj(obj, i).exists()  set vobj(obj, -152) = vobj(obj, -152)_ vobj(obj, i)_ dlmStr
			}
			// Remove leading " WHERE" for call to LOBUPDATE
			set ret = $$LOBUPDATE^%DBAPI(0, tbl, vobj(obj, -161, nod).piece(",", 2).piece("=", 1), where.extract(7, where.length()), nod162.extract(tbl.toByteString().length() + 2, maxLen), dlmStr, vobj(obj, -152))
		}
		else  if (collOrder = -1) do {
			
			type String vlist = vobj(obj, -162, nod).piece(dlmStr, 2, maxLen)_ dlmStr_ vobj(obj, -152)
			
			set ret = $$EXECUTESQL^%DBAPI(0, "UPDATE "_ vobj(obj, -162, nod).piece(dlmStr, 1)_ " SET "_ vobj(obj, -161, nod).piece(",", 2, maxLen)_ where, dlmStr, vlist)
		}
		else  do {
	 	
			type Number i
			type String cols, HVs
	
			set (cols, HVs) = ""
		
			for i = 2:1:vobj(obj, -162, nod).length(dlmStr) set cols = cols_ ","_ vobj(obj, -161, nod).piece(",", i).piece("=", 1), HVs = HVs_ ",:HV"_ (i - 1)
	
			set ret = $$EXECUTESQL^%DBAPI(0, "INSERT INTO "_ vobj(obj, -162, nod).piece(dlmStr, 1)_ " ("_ cols.piece(",", 2, maxLen)_ ") VALUES ("_ HVs.piece(",", 2, maxLen)_ ")", dlmStr, vobj(obj, -162, nod).piece(dlmStr, 2, maxLen)_ dlmStr)
		}
		
		// Reset
		set vobj(obj, -161, nod) = "1", vobj(obj, -162, nod) = vobj(obj, -162, nod).piece(dlmStr)
	}

	quit
	

	// ---------------------------------------------------------------------
public RsDyRT( String select,		// SELECT-clause (*1)
		String from,		// FROM-clause (*1, *2)
		String where,		// WHERE-clause (*1)
		String orderby,		// ORDERBY-clause (*1)
		String groupby,		// GROUPBY-clause, HAVING-clause (*1,*3)
		String parlist,		// PSQL parameter specification (*1,*4)
		String selmap(,))	// identifier map (*5)	/MECH=REFARR:W
	/* ---------------------------------------------------------------------
	ARGUMENTS:
	(*1) literal SQL text, enclosing M quotes have been removed
	(*2) the FROM-clause cas either be a standard SQL from-clause, of a
		DQMODE from-list. The latter form will be translated into a
		standard SQL clause before it is passed to $$RsMsBld()
	(*3) by convention, the HAVING clause is appended to the GROUP BY clause
	(*4) value starts with slash
	(*5) selmap(,) = indentifier map array
		See $$RsMsBld() for a detailed description

	 OUTPUTS:
	. $$ = SQL select statement				/TYP=T
		The value will still contain place holders for each hostvar
		The mapping of placeholders to hostvars is available in selmap()
		The complete SQL statement, and vList can be constructed by:
			set vList=$$RsMsXV(.selmap,.sqlstatement)
	. selmap(,) = identifier map array			/TYP=T
		See $$RsMsIns() for a detailed description

	THROWS:
	. %PSL-E-SQLJOINFAIL
		If parlist specifies /DQMODE=1, then the list of tables will be
		transformed into a "SQL standard" joinedtable-clause. If this
		fails, an exception will be thrown.

	This code is called at runtime for RDB dynamic selects to create the
	select expression and components formatted for the RDB.
	To ensure identical behavior for runtime and compile time, it is also
	called at compile time when all parts of the statement are literal.

	The SELECT statement in its PSL form requires several transformations
	before it can be supplied to the RDB:
	* Wide table
		If a columns occur in the SELECT clause, the FROM clause must
		be modified to include the split version in which the column
		occurs. The WHERE clause must be modified to include the implicit
		join of the split tables.
	* Column name remapping
		In some cases column names in the RDB differ from the column
		name in DQ.
	* DQMODE joins
		If the parlist specifies /DQMODE=1, then Profile will transform
		the from-list into a joinedtable specification.

	To support those remappings, the clauses are decomposed and a symbol
	table of DQ identifiers (columnnames, tablenames, hostvars) is build for
	the entire query. This symbol table is stored in selmap():
	* selmap("XC",*) = columns
	* selmap("XT",*) = tables
	* selmap("XV",*) = host variables
	*/
	type String expr,fsn(),HAVING,par(),tok
	type Number ER	// exported by TOKEN^%ZS

	// Rewrite components with literals removed, and converted to uppercase
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set select  = $$TOKEN^%ZS(select,.tok,"'").upperCase()
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set from    = $$TOKEN^%ZS(from,.tok,"'").upperCase()
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set where   = $$TOKEN^%ZS(where,.tok,"'").upperCase()
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set orderby = $$TOKEN^%ZS(orderby,.tok,"'").upperCase()
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set groupby = $$TOKEN^%ZS(groupby,.tok,"'").upperCase()

	// Split GROUPBY in GROUP BY and HAVING part
	set groupby = $$TOK^SQL(groupby,"HAVING",tok)

	/* Handle DQMODE=1 if supplied. If the function cannot convert the
	   DQMODE clause into a "standard SQL" clause, then it will throw an
	   exception. This exceptino is NOT handled here, it is passed to the
	   caller, because it is unlikely that the query result is as intended.
	   */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if parlist]"" do PARSPAR^%ZS(parlist,.par)
	if par("DQMODE").get() set from = $$RsMsDQMD(from)

	// Build Symbol Map
	set expr = $$RsMsBld(selmap(,),.tok,select,from,where,orderby,groupby,HAVING.get())

	// insert columns (XC) and tables (XT)
	set expr = $$RsMsXI(selmap(,),"XC",expr)
	set expr = $$RsMsXI(selmap(,),"XT",expr)

	// return result with SQL literals back in place
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	quit $$UNTOK^%ZS(expr,tok)

	// ---------------------------------------------------------------------
public RsMsBld(	String map(,),		// map array (*1)	/MECH=REFARR:RW
		ret String sqllit,	// SQL literals (*2)	/MECH=REF:RW
		String select,		// SELECT-clause (*3)
		String from,		// FROM-clause (*3), (*4)
		String where,		// WHERE-clause (*3)
		String orderby,		// ORDER-BY-clause (*3)
		String groupby,		// GROUP-BY-clause (*3)
		String having)		// HAVING-clause (*3)
	/* ---------------------------------------------------------------------
	This function returns a modified version of the SQL SELECT statement,
	in which identifier occurrences are replaced by place holders.
	In addition it creates the symbol maps for hostvars, columns, and tables.

	ARGUMENTS:
	(*1) map(,) = map array
		The decomposition will ADD symbols to this structure.
		Place holder values of symbols that are already present will be
		used in the returned result.
	(*2) The values of SQL string literals of all clauses. It will be passed
		to called functions. It is not used within this function itself.
		Note however that the called functions may modify sqllit due to
		string literal replacement.
	(*3) All clauses shall be translated to uppercase, and all SQL string
		literals shall occur as tokens in sqllit.
	(*4) The from clause passed to this function shall be a standard SQL
		from clause. The caller is responsible to replace a DQMODE from
		list into a standard SQL from clause. According to the SQL
		standard, a from-clause consists of a list of tablereferences.
		Each tablereference can either be a tablename (possibly aliased)
		or a joinedtable, or an aliased derived table.

	OUTPUTS:
	. $$ A complete SQL SELECT statement (with ORDER BY clause appended) in
		which place holders are used to represent all identifiers.
		Place holders for SQL string literals are returned unchanged.
	. map("SELNAM") = list of names for each "column" in the SELECT-clause
		When the  "column" contains a value expression instead of a
		simple columnname, the column ordinal position will serve as the
		columnname
	. map("SELTYP") = list of Datatype / Number of decimals for each "column"
		in the SELECT-clause
	. map("XC",*) = columns, map("XT",*) = tables, map("XV",*) = hostvars
		See $$RsMsIns().

	NOTES:
	. This function does NOT do a complete syntax analysis. Decomposition
		is limited to entities that are needed to construct the symbol
		table. Subqueries are handled.
	. It has been demonstrated that the interface with Oracle does not care
		about the datatype of a hostvar, provided that its value is
		properly enclosed in SQL quotes. For this reason the code in this
		function will not try to track or guess the datatype of hostvars.
	. Recursive calls to this function (for subqueries) will result in
		multiple assignments to map("SELTYP") and map("SELECT"). Because
		the complete node is replaced just prior to returning to the
		caller, the caller will receive the result from its (sub)query.
		So the outermost call will return the result of the SELECT-clause
		of the original SQL SELECT statement.
	. The FROM-clause may contain a joined-table or aliased-table.
		When the from clause contains a joinedtable-clause that involves
		one of the wide-tables, the wide-table will need to be replaced
		by a derived table that specifies the wide tables that are needed
		to satisfy the query.
		Incorporating the effect of aliased-tables is relatively
		straightforward.
		PSQL neither supports derived-tables nor derived-column-lists.
	*/
	type literal String BAR = "|"	// standard separator

	type String expr,RsMsBld(,),tail = ""

	// Ensure we have a symbol number counter
	set map = map.get(0)

	/* Handle FROM-clause:
	- If the supplied FROM-clause specifies a joined-table, or an
	  aliased-table, then call $$RsMsCls() to handle the FROM-clause, and
	  store its return value in from. Note that $$RsMsCls() will rebuild
	  RsMsBld("FROM") to contain the list of all tables that occur in the
	  from-clause.
	- Else whitespace is removed and from and RsMsBld("FROM") will receive
	  identical values. */
	if (from.translate("()","  ")[" JOIN ")!(from[" AS ") do {
		set from = $$RsMsCls( RsMsBld(,), map(,), .sqllit, 3, from, "")
	}
	else  set (RsMsBld("FROM"), from) = from.translate(" "_ 9.char())

	/* Handle SELECT-clause:
	   Strip keyword DISTINCT or ALL, but prepend it afterwards */
	set expr = select.piece(" ")
	if (expr="DISTINCT")!(expr="ALL") set select = select.extract( expr.length()+2, select.length())
	else  set expr = ""

	/* SELECT * will be replaced by $$COLLIST^DBSDD() of the tables.
	   Use RsMsBld("FROM") as the table list, because it contains the
	   "normalized" list in case the original query contains a joined-table.
	   */
	if select = "*" set select = $$RsSelAll( RsMsBld("FROM"))

	set select = $$RsMsSel( RsMsBld(,), map(,), .sqllit, 1, select, "")
	if expr'="" set RsMsBld("SELECT") = expr_" "_select
	else  set RsMsBld("SELECT") = select

	// Handle WHERE-clause: do not yet add keyword WHERE, it may still be modified
	if where'="" set where = $$RsMsCls( RsMsBld(,), map(,), .sqllit, 2, where)

	// Handle GROUPBY-clause:
	if 'groupby.isNull() set tail = " GROUP BY "_$$RsMsSel( RsMsBld(,), map(,), .sqllit, 0, groupby, "")

	// Handle HAVING-clause:
	if 'having.isNull() set tail = tail_" HAVING "_$$RsMsCls( RsMsBld(,), map(,), .sqllit, 2, having)

	// Handle ORDERBY-clause
	if 'orderby.isNull() set tail = tail_" ORDER BY "_$$RsMsSel(RsMsBld(,), map(,), .sqllit, 0, orderby, "ASC,DESC")
	
	/* Update the FROM-clause (and the WHERE-clause) for use of wide tables
	   If from and bld("FROM") are equal, simple name substitution in
	   combination with an addition to the where-clause will do.
	   Else an aliased derivedtable clause must be created. */
	if from=RsMsBld("FROM") {	// NOTE: do{} needed: call modifies from
		do RsMsWtList(RsMsBld(,), map(,), .sqllit, .from, .where)
	}
	else  do RsMsWtJoin(RsMsBld(,),map(,))

	/* The WHERE-clause can now be prepended to tail */
	if 'where.isNull() set tail = " WHERE "_ where_ tail

	/* Export "SELNAM" and "SELTYP" from this query to map(,) */
	set map("SELNAM") = RsMsBld("SELNAM")
	set map("SELTYP") = RsMsBld("SELTYP")

	/* return values with place holders for all identifiers, use
	   RsetMsBld("SELECT") as the select clause, because it contains the
	   columns added for GROUP BY and/or ORDER BY */
	quit "SELECT "_ RsMsBld("SELECT")_ " FROM "_ from_ tail

	// ---------------------------------------------------------------------
public RsMsCls(	String bld(,),		// (*1)			/MECH=REFARR:RW
		String map(,),		// (*2)			/MECH=REFARR:RW
		ret String sqllit,	// (*3)			/MECH=REF:RW
		Number mode,		// (*4)
		String clause,		// SQL clause to be analyzed
		String kwds)		// (*6)
	/* ---------------------------------------------------------------------
	Handle a single clause. Can be called for all clauses.

	ARGUMENTS:
	(*1) bld(,) = build structure from caller	
		bld("FROM") will be modified when mode=3
		bld("FROM",*) may be modified by all clauses
		bld("CLSTYP") will be set if and only if mode=1
	(*2) map(,) = identifier map array
		Values are added to this array.
		The unsubscripted node must have been initialized.
	(*3) sqllit = SQL literal tokens
		Passed to $$TOK^SQL() when decomposing a subquery.
		Passed to $$RsMsDT() when managing the datatype of a
		value-expression. The REF:W applies when the clause contains a
		string literal that is converted to uppercase for type 'U'
		columns.
	(*4) mode = processing mode
		0 = simple column list (GROUPBY or ORDERBY)
		  - the value of kwds will be used
		  - the only valid delimiter character is ","
		  - does not append the additional TOKEN parameter for computed
		    columns that require a callback. See $$RsMsSel().
		1 = value-expression (SELECT)
		  - the value of kwds will be ignored, and replaced by
		    "NULL,COUNT,MIN,MAX,AVE,SUM,UPPER,LOWER,SUBSTR"
		  - valid delimiter characters are "*+-/|,()"
		2 = search-condition (WHERE, HAVING)
		  - the value of kwds will be ignored, and replaced by the
		    keywords for mode=1 extended with
		    ",IN,IS,OR,AND,LIKE,NOT,BETWEEN,EXISTS,ANY,ALL"
		  - valid delimiter characters are those for mode=1 plus
		    "<>="
		3 = from clause (FROM including JOIN and/or ON)
		  - the value of kwds will be ignored, and replaced by
		    "AS,JOIN,LEFT,RIGHT,KEY,CROSS,NATURAL,USING,OUTER,INNER,FULL,UNION"
		  - the only valid delimiter characters are ",()"
	(*6) kwds = comma-separated list of accepted keywords

	OUTPUTS:
	. $$ = the modified clause that has been supplied to the function
		Identifiers replaced by placeholders.
	. bld("FROM")=normalized table list
		This node is only modified when called with mode=3. This mode
		will completely rebuild the node.
	. bld("FROM",exttbl)=""
		The internal (mapped) table name of each qualified column
		reference that occurs in the clause will have been added to
		this structure. For "SELECT *", all internal table names will
		have been added. For SELECT COUNT(*), the first internal table
		name of the first conceptual table is added.
	. bld("CLSTYP") = Datatype and Number of decimals
		If and only if mode=1, this node will contain the datatype and
		number of decimals of the column or value expression.

	LOCAL STRUCTURES:
	. null() = null-predicate array
		null = count of elements currently in null()
		null(n) = n-th atom of null-predicate (1 based)
			For columns and hostvars: null(n) = the symbol map entry
			For all others: null(n) = the atom itself
		null(0) = subscript | char_pointer
			of the right most COLUMN in the array, or 0 if predicate
			does not (yet) contain a column.
		Note that every character in the delim string ends up as
		a separate element, so COL <> 10 will occupy 4 nodes.

	NOTES:
	. Because this function contains a single loop to handle all lexical
		tokens, "context information" must be passed in variables
		(between, dt, origtbl, prevatom, ptrnot).
	*/
	type literal String BAR = "|"		// standard delimiter
	type literal String TAB = 9.char()	// quote char for computeds

	type String atom		// current atom being examined
	type Boolean between = 0	// 1 indicates AND in between-predicate
	type String delim		// accepted delimiters
	type String dt = ""		// composite data type
	type Number dtmode
	type Number ER
	type String origtbl = ""	// original table name in alias
	type String null()		// individual atoms of current null-pred
	type String prevatom		// previous atom
	type Number ptr			// current position in clause
	type Number ptrnot		// position of NOT in clause
	type String seltyp = ""		// column type in SELECT

	if mode=0 set delim = ","	// and use supplied kwds
	else  {
		if mode<3 set delim = "*/+-|,()", kwds = "NULL,COUNT,MIN,MAX,AVG,SUM,UPPER,LOWER,SUBSTR"
		if mode=2 set delim = delim_"<=>", kwds = kwds_",IN,IS,OR,AND,LIKE,NOT,BETWEEN,EXISTS,ANY,ALL"
		if mode=3 set delim = ",()", kwds = "AS,JOIN,LEFT,RIGHT,KEY,CROSS,NATURAL,USING,OUTER,INNER,FULL,UNION"
	}
	if mode=3 set bld("FROM")=""

	// main decomposition loop =============================================
	set ptr = 0, atom = "", null = 0, null(0) = 0

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	for  set prevatom = atom, atom = $$ATOM^%ZS(clause,.ptr,delim,,1) do { quit:'ptr
		if ER.get() set ptr = 0 quit
		
		set null = null + 1, null(null) = atom

		/* =============================================================
		   Incomplete atom (exponential notation)
		   This is the case if the atom is a fraction followed by an
		   uppercase E. The next character shall be the "+" or "-" (not
		   checked, always syntax error if not). It is appended here, as
		   is the next atom (the exponent). */
		if atom?.N.1"."1.N1"E" do {
			set ptr = ptr+1		// advance to "+" or "-"

			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			set atom = atom_ clause.extract(ptr)_ $$ATOM^%ZS( clause, .ptr, delim, , 1)
		}

		/* =============================================================
		   handle non-standard PSQL extension:
		   keyword NOT in combination with comparison operator
		   force prevatom to contain NOT + all delimiters that
		   follow it. */
		if prevatom?1"NOT".P,delim[atom,"<=>"[atom set atom = prevatom_atom quit
		if prevatom?1"NOT".P,prevatom'="NOT" do {
			/* combination complete, replace by standard comp.op.
			   prevatom contains NOT and all delimiters following it.
			   ptrnot will contain value of ptr when NOT was found.
			   atom will contain the syntax element following the
			   entire construct */
			type String opr
			type Number pos
			if prevatom.length() > 5 quit	// incorrect anyway
			set opr = prevatom.extract(4,prevatom.length())
			if opr.length()=1 set opr = " "_opr
			set pos = " = < ><><=>=".find(opr)
			set opr = "<>>=<= = > <".extract(pos-2,pos-1)

			/* Replace (adjust ptrnot to char preceding NOT) */
			do RsMsRpl(.clause, opr_atom, ptrnot-3, .ptr)

			/* update null() to reflect the new null-pred. Note that
			   each character in opr requires its own node in the
			   null() array, and each character in the prev opr
			   occupied a separate node in that array. */
			kill null(null), null(null-1)
			set null = null - prevatom.length() + 2	// null()="NOT"
			for pos = 1:1:opr.length() set null(null) = opr.extract(pos), null = null + 1
			set null(null) = atom
		}

		// keywords that need context information ======================
		if atom="NOT" set ptrnot = ptr quit

		/* orig_tablename AS alias_tablename:
		   save orig_tablename for later use */
		if atom="AS",mode=3 set origtbl = prevatom quit

		/* OR and AND start a new predicate, except when AND occurs
		   after BETWEEN (between=1). When a new predicate starts, reset
		   dt, and save the pointer to the beginning of the predicate.
		   The between-flag can (always) be reset. */
		if (atom="OR")!(atom="AND") do { quit
			if between set between = 0 quit
			do RsMsNull( null(), sqllit, .clause, .ptr)
			set dt = ""
		}
		if atom="BETWEEN" set between = 1 quit

		/* =============================================================
		   NULL to ZERO transformation for columns that have NULLIND=1.
		   The if-statement that decides between IS NULL and IS NOT NULL
		   is lean: It will correctly replace well-formed clauses, but
		   may incorrectly modify ill-formed clauses (eg COLUMN + NULL
		   may be translated to COLUMN = 0). */
		if atom="NULL" do {  quit
			if null < 3 quit		// ro room for COLUMN IS
			type String comppred
			type Number diff
			if null(null - 2) = "IS" set comppred = " <> 0", diff = 3
			else  set comppred = " = 0", diff = 2
			if (null - diff) '= null(0).piece(BAR) quit
			type String colnull = null(null(0).piece(BAR))

			/* if colnull.NULLIND=0, then don't modify
			   null-predidcate, else replace null-predicate by
			   comparison-predicate */
			if colnull.piece(BAR,3).extract(3)=0 quit
			do RsMsRpl(.clause, 9.char()_ colnull.piece(BAR)_ 9.char()_ comppred, null(0).piece(BAR,2), .ptr)
		}

		/* =============================================================
		   FROM clause, switch between "from mode" and "where mode":
		   - keyword ON switches to "where mode"
		   - any keyword from kwds (or a comma not inside parenthesis)
		     will switch back to "from mode" */
		if atom="ON",mode=3 do {  quit			// ON in from
			/* find end of search condition */
			type Number sptr = ptr, num = 0
			type String satm
			type Boolean found = 0

			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			for  set satm=$$ATOM^%ZS(clause,.sptr,"+*-/|,()<=>",,1) do { quit:found
				if sptr=0 set found = 1 quit
				if (","_kwds_",")[(","_satm_",") set found = 1 quit
				if satm="(" set num = num + 1 quit
				if satm=")" set num = num - 1 quit
				if satm=",", num=0 set found = 1 quit
			}
			/* extract search condition, and treat as such
			   bld("FROM") will contain the correct list of tables
			   (those found so far) */
			if sptr = 0 set sptr = clause.length(), satm = ""
			type String searcond = clause.extract( ptr + 1, sptr - satm.length())
			set num = searcond.length()
			set searcond = $$RsMsCls( bld(,), map(,), .sqllit, 2, searcond, "")

			// replace original searchcond by returned and update ptr
			set clause = clause.extract( 1, ptr)_ searcond_ clause.extract( ptr+num+1, clause.length())
			set ptr = ptr + searcond.length()
		}

		// =============================================================
		if (","_kwds_",")[(","_atom_",") quit		// keyword

		// =============================================================
		if atom="(" do {				// maybe subquery
			type Number len = 0
			type String nest = clause.extract(ptr+1,clause.length())
			for  do { quit:len=0
				set len = nest.find(")",len)
				quit:len=0
				quit:nest.extract( 1, len-1).length("(") '= nest.extract( 1, len-1).length(")")
				set nest = nest.extract( 1, len-1)
				set len = 0
			}
			// save $L(nest) to update ptr, since $L(nest) may change
			set len = nest.length(), nest = nest.trim()
			if nest.extract(1,7) '= "SELECT " quit	// not subquery

			/* subquery:
			   break into components, add recursively */
			type Number ER
			type String FROM,GROUP,HAVING,RM,SELECT,subquery,WHERE

			set SELECT = $$TOK^SQL(nest.extract( 8, nest.length()), "FROM,WHERE,GROUP,HAVING", sqllit)
			if GROUP.get().extract(1,3)="BY " set GROUP = GROUP.extract( 4, GROUP.length())
			set subquery = $$RsMsBld(map(,), .sqllit, SELECT, FROM.get(), WHERE.get(), "", GROUP.get(), HAVING.get())

			// replace original subquery by returned and update ptr
			set clause = clause.extract(1, ptr)_ subquery_ clause.extract(ptr+len+1, clause.length())
			set ptr = ptr + subquery.length()
		}

		// =============================================================
		if atom = "*", prevatom="(", mode = 1 do {	// COUNT(*)
			/* Take first table from normalized list,
			   insert into map(,), then take first wide-table */
			type String tbl = bld("FROM").piece(",")
			type Number sym = $$RsMsIns( bld(,), map(,), "XT", tbl)
			set tbl = map("XT", tbl).piece(BAR,2).piece(",")
			set bld("FROM", tbl)=""
		}

		/* =============================================================
		   Translate the special Profile keyword "USERID" here, so the
		   code following it will just see an ordinary HOSTVAR.
		   The change needs to be made to the clause only because the
		   hostvar block will take care of updating null(null). */
		if atom = "USERID" do {
			do RsMsSub( ":%UID", "USERID", .clause, .ptr)
			set atom = ":%UID"
		}	

		/* =============================================================
		   Similar, but slightly different, the special Profile keyword
		   "SYSDAT" represents the equivalent of CURRENT_DATE. However,
		   DQ Dates don't map into SQL Dates, so we need to use a trick:
		   Replace by "%CurrentDate" (as if that keyword was used).
		   The other half of the trick is hard-coded into RsMsXV() where
		   "%CurrentDate" will be replaced differently for the SQL text
		   and the M code.
		   Other behavior like USERID. */
		if atom = "SYSDAT" do {
			do RsMsSub( ":%CurrentDate", "SYSDAT", .clause, .ptr)
			set atom = ":%CurrentDate"
		}	

		/* =============================================================
		   The if-else combinations below ensure that each kind of atom
		   is ready to be passed to $$RsMsDT(). The call to this function
		   is done after adding identifiers to the symbol map. This
		   ensures that column data types are available when the function
		   is called */
		if delim[atom set dtmode = 0			// all delimiters

		/* =============================================================
		   SQL accepts '+' in numeric literals, $$isNum^UCGM() does not
		   (yet) allow this. Translating the "+" into a "-" will pass a
		   value that $$isNum^UCGM() understands. */
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		else  if $$isNum^UCGM( atom.translate("+","-")) set dtmode = 1

		// =============================================================
		else  if atom.extract()=0.char() set dtmode = 2	// string literal

		// =============================================================
		else  if atom.extract()=":" do {			// hostvar
			/* replace hostvar (after ":") in clause with
			   $C(9)sym$C(9), assign its map(,) entry to null(null),
			   so it is available to $$RsMsDT(). */
			set atom = atom.extract(2, atom.length())
			type Number sym =  $$RsMsIns( bld(,), map(,), "XV", atom, dt.extract())
			do RsMsSub( TAB_ sym_ TAB, atom, .clause, .ptr)
			set null(null) = map( "XV", sym)
			set dtmode = 3
		}
		// =============================================================
		else  if mode=3 do {				// table in FROM
			/* table name in FROM-clause.
			   'origtbl' will contain the original table name if an
			   alias is used, otherwise 'origtbl' will be empty.
			   If an alias is used, then the original table has been
			   added to the list incorrectly, and must be removed.
			   In that case it will always be the last table.
			   Tables in the FROM-clause are elegible for (name)
			   substitution, so they are added to map("XT",) here,
			   and the placeholder is substituted in the clause. */
			if 'origtbl.isNull() do {
				set bld("FROM") = bld("FROM").piece(",", 1, bld("FROM").length(",")-1)
				set bld("ALIAS", atom) = origtbl
				set origtbl = ""
			}
			if 'bld("FROM").isNull() set bld("FROM") = bld("FROM")_ ","
			set bld("FROM") = bld("FROM")_ atom
			set dtmode = 5

			do RsMsSub( TAB_ $$RsMsIns( bld(,), map(,), "XT", atom)_ TAB, atom, .clause, .ptr)
		}
		// =============================================================
		else  do {					// column spec
			/* Replace columnref in clause with $C(9)sym$C(9).
			   Translate into qualified column name (qcn), and
			   insert it into the symbol table.*/
			type String qcn = $$RsMsQcn( bld(,), atom)

			/* ==================================== OTHER IDENTIFIER
			   If the qcn starts with "_.", then the name did not map
			   to a valid column name. Assume it is another kind of
			   identifier (eg a functionname), and treat it as a
			   keyword. Set dtmode=5, so $$RsMsDT() will ignore it.
			   This may bias the (final) result calculated by
			   $$RsMsDT(). */
			if qcn.extract(1,2)="_." set dtmode = 5 quit
			
			// =====================================================
			type String sym = TAB_ $$RsMsIns( bld(,), map(,), "XC", qcn)_ TAB

			/* Store the symbol map entry in null(null), so
			   it is available to $$RsMsDT().
			   The update of null(0), to reflect the subscript and
			   character position of the rightmost column, must be
			   postponed until either the columnname, or the
			   computation has been inserted.
			   Note that if the column is the last atom of
			   the clause, "position" will end up as a
			   negative value. But since RsMsNull will use it
			   only for null-predicate substitution, this is
			   ok. */
			set null(null) =  map("XC", qcn)
			set dtmode = 4

			/* ========================================= COMPUTATION
			   If the inserted entry is a computation, treat it as
			   a separate value expression. */
			type String ic = map("XC",qcn).piece(BAR,2,2,TAB)
			if ic["(" do {
				#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
				set ic = $$TOKEN^%ZS(ic.piece(TAB,2),.sqllit)
				set ic = $$RsMsCls( bld(,), map(,), .sqllit, 1, ic, "")

				/* FSCW 2007-03-16: For computeds that require
				   callback, add the additional parameter as the
				   last parameter of the function call. add the
				   parameter AFTER the translation, otherwise we
				   will have to deal with it as a special
				   hostvar when we decompose the computed.
				   The parameter is added as a special hostvar,
				   starting with "%%". $$RsMsXV will recognize
				   that, and treat it accordingly.
				   FSCW 2008-09-08: Do not add this for mode=0
				   because GROUP BY and ORDER BY will use an
				   alias instead of the computed returned by
				   this function
				   */
				if Db.isDefined( "STBLCLBKCOL", "FID=:qcn.piece(""."") AND DI=:qcn.piece(""."",2)"),mode'=0 {
				  set ic = ic.extract( 1, ic.length() - 1)
				  if 'ic.endsWith("(") set ic = ic_ ","
				  set ic = ic_ ":"_ TAB_ $$RsMsIns( bld(,), map(,), "XV", "%%$S($G(%TOKEN)'="""":0_%TOKEN,1:1_$J)","T0")_ TAB_ ")"
				}

				do RsMsSub(ic, atom, .clause, .ptr)
				set null(0) = null_ BAR_ (ptr - ic.length())
			}
			// =====================================================
			else  do {				// just a column
				do RsMsSub(sym, atom, .clause, .ptr)
				set null(0) = null_ BAR_ (ptr - sym.length())
			}

			if mode=1 do {				// SELECT clause
				/* If first column in value expression, assume it
				   will be simple, and nominate the column type,
				   else use "T0" for compound. */
				if seltyp.isNull() set seltyp = map("XC", qcn).piece(BAR, 3, 3, TAB).extract(1,2)
				else  set seltyp = "T0"
			}
			if ic'["(", qcn [ "." do {
				/* Add table name to map("XT",) and to
				   bld("FROM",), but only if the column name is
				   qualified (SYSDAT could be treated as an
				   unqualified columnname) and not computed. */
				set sym = $$RsMsIns( bld(,), map(,), "XT", qcn.piece( "."))
				// It's save to use map(,).piece() without TAB
				set bld("FROM", map("XC",qcn).piece(BAR, 2).piece(".")) = ""
			}
		} // end column specification
		set dt=$$RsMsDT(map(,), .sqllit, dtmode, dt, null(), .clause, .ptr)
	} // end main decomposition loop

	/* handle last null-pred */
	do RsMsNull( null(), sqllit, .clause, .ptr)

	/* Force datatype and decimals of SELECT-clause and pass in bld()  */
	if mode = 1 do {
		if seltyp = "" set seltyp = dt.extract()_"0" if seltyp="0" set seltyp = "T0"
		set bld("CLSTYP") = seltyp
	}

	quit clause

	// ---------------------------------------------------------------------
public RsMsDQMD( List from)		// (*1)
	/* ---------------------------------------------------------------------
	This function transforms a list of tables (for DQMODE=1) into a "standard
	SQL" from-clause:
	* If the from-clause consists of a single table, then from is returned
		unchanged.
	* If the supplied from-clause already contains one of the keywords "JOIN"
		(joinedtable) or "AS" (aliasedtable), then from is returned
		unchanged.
	* In most cases each table in the list is "LEFT OUTER JOIN"ed with the
		tables preceeding it (the keyword OUTER is redundant).
		So T1,T2,T3 becomes:
			((T1 left join T2) left join T3) 
	* If the table to be added to the join has a parent table (DEP or LN),
		then that table is "INNER JOIN"ed with the tables preceeding it.
		This is done because the implementation of JOINs in Profile/SQL
		effectively results in an INNER JOIN when DEP or LN is not the
		first table in the list.
	* The ON part is derived by comparing the key columns of the table
		being added to all columns of the tables preceeding it.
		So for T1,T2,T3, this becomes:
			( (T1 left join T2 on ( T2.keys=T1.columns) )
			  left join T3 on (T3.keys = (T1,T2).columns) ) 
	* If the primary key of a table being added does not match any column in
		the list of tables preceeding it, then a %PSL-E-SQLJOINFAIL
		exception will be thrown.

	ARGUMENTS:
	(*1) If the from-clause contains a list of tables, then it is supposed to
		be a well-formed Profile table list: only table names acceptable
		to Profile shall be included.

	OUTPUT:
	. $$ from modified according to algorithm described

	THROWS:
	. %PSL-E-SQLJOINFAIL
		If a table in the list does not share any of its keys with any
		of the columns from the tables preceeding it.

	NOTES:
	. The alogrithm used to construct the list of keys that must occur
		in the on-clause is a variation on $$NATURAL^SQLJ()
	. Even though the "Profile syntax"
			T1 left join (T2, T3) on (...)
		seems to suggest that additional tables are only joined to the
		FIRST table, reports are found that rely on joining T3 to T2.
		So the ON-clause is supposed to take all columns from all
		preceeding tables into account.
	. In certain cases Oracle is unable to deal with the construct
		( ( subquery ) alias LEFT OUTER JOIN tbl ON ( whereclause ) )
		Close reading of the SQL standard makes FSCW believe that the
		outermost pair of parenthesis can be dropped without changing
		the interpretation of the FROM clause. For this reason, the
		function has been modified, so it no longer adds parenthesis
		around joined_table.
	*/
	type Number count = from.count()
	if count=1 quit from
	if (from.toString().translate("()","  ")[" JOIN ")!(from[" AS ") quit from

	type Number elm = 2	// table name iterator for table being added
	type String key		// key column of table being added
	type String inner	// table being added
	type Number nk		// key ordinal position in table being added
	type String on		// on-clause under construction
	type String outer	// name of outer table in on construction
	type List   pk		// primary keys of table being added
	type String RsMsDQMD = from.elementAt(1)	// function return value
	type PSLTable td	// PSLTable instance for table being added

	// strip quotes from table names
	if from.toString()["""" set from = {List}(from.toString().translate(""""))

	for elm = 2:1:count do {
		/* ================
		   One line below commented out.
		   See NOTE on parenthesis.
		if elm > 2 set RsMsDQMD = "("_ RsMsDQMD_ ")"
		================ */
		set inner = from.elementAt(elm)
		set td = PSL.getPSLTable( inner, 0)

		// child-tables are INNER JOINed all others OUTER JOINed
		if td.parentTable.isNull() set RsMsDQMD = RsMsDQMD_ " LEFT JOIN "_ inner
		else  set RsMsDQMD = RsMsDQMD_ " INNER JOIN "_ inner
		set pk = td.primaryKeys

		if pk.isNull() quit		// CUVAR etc: no ON-clause
		set on = ""
		for nk = 1:1:pk.count() do {
			set key = pk.elementAt(nk)

			/* =====================================================
			   The code below tries to join the key columns of the
			   'inner' table with any column from the FIRST (left 
			   most) 'outer' table. This code has been commented out
			   when it was demonstrated that reports rely on the
			   ability to join with all preceeding tables, as
			   provided by the code block following this block.
			   =====================================================
			set outer = from.elementAt(1)
			
			if '$$isColumn^UCXDD( outer, key) quit
			//if 'Db.isDefined("DBTBL1D","%LIBS='SYSDEV',FID=:outer,DI=:key") quit
			if 'on.isNull() set on = on_ " AND "
			set on = on_ outer_ "."_ key_ "="_ inner_ "."_ key
			/* ======== end join on FIRST table only ======== */

			/* =====================================================
			   The code below presents an alternative to the code
			   above in case the 'inner' table must be joined with
			   all 'outer' tables (not just the first).
			   =====================================================
			   */
			type Number no		// iterator
			for no = 1:1:elm-1 do {
				set outer = from.elementAt(no)
				if '$$isColumn^UCXDD( outer, key) quit
				if 'on.isNull() set on = on_ " AND "
				set on = on_ outer_ "."_ key_ "="_ inner_ "."_ key
				set no = elm	// done when match found
			}
			/* ======== end join on all left tables ======== */
		}
		if on.isNull() throw Class.new( "Error", "%PSL-E-SQLJOINFAIL,,"_ RsMsDQMD)
		set RsMsDQMD = RsMsDQMD_ " ON ("_ on_ ")"
	}
	quit RsMsDQMD

	// ---------------------------------------------------------------------
private RsMsDT(	String map(,),		// map array		/MECH=REFARR:R
		ret String sqllit,		// string literals (*2)	/MECH=REF:RW
		String mode,		// dtmode (*3)
		String dt,		// current data type
		String pred(),		// predicate (*5)	/MECH=REFARR:RW
		ret String clause,	// clause (*6)		/MECH=REF:RW
		ret String ptr)		// char pointer (*7)	/MECH=REF:RW
	/* ---------------------------------------------------------------------
	This function edits the DataType string. The only purpose of this function
	is to ensure that string literals are replaced by their conceptual value
	if the DQ datatype of a column differs from the RDB datatype. This is the
	case for the DQ datatypes D, C, and L. The corresponding RDB type is
	always numeric.
	The conversion rules are simple: If a string literal occurs in the
	context of one of the types C, D, or L, then they are converted.
	In addition if the DQ datatype is U, the string literal is converted to
	uppercase.

	The returned datatype consists of at most 2 characters:
	* The first character is the datatype derived so far
	* The second character is either a binary operator (-+*|/), or the tilde
	  (~). As long as the datatype does not end in a tilde, it is under
	  construction.

	ARGUMENTS:
	(*2) sqllit will be REF:R when a SQL string literal is converted to a
		number for C, D, or L.
	     sqllit will be REF:W when a SQL string literal is converted to
		uppercase for U.
	(*3) mode describes the nature of the value passed in null(null). It can
		have any of the following values:
		0 = it is a delimiter
		1 = it is a numeric literal
		2 = it is a string literal
		3 = it is a hostvar ($C(9) sym $C(9) :HOSTVAR)
		4 = it is a qualified column name
			($C(9) sym $C(9) TABINT.COLINT $C(9) startpos)
		5 = it is a table name, or other identifier
	(*5) pred() = decomposition of current predicate
		Only pred(pred) (the current atom) will be used by this function
		pred(pred) will be REF:W when a SQL string 
	(*6) clause will be REF:W when a SQL string literal is converted to a
		number for C, D, or L. Otherwise it will be ignored.
	(*7) ptr will be REF:W if and only if clause has been modified.
	*/
	type literal String BAR = "|"
	type String dt2,dtdq		// datatype of next, datatype of first

	if mode=5 quit dt		// table, no-op

	type Number dtl = dt.length()
	type String next = pred(pred)

	if mode=0 do { quit dt
		/* Delimiter:
		   Ignore leading binops (dtl=0).
		   Never more than one (dtl=2), only binops are appended.
		   If a relop or a comma is found, this concludes the datatype
		   determination. */
		if dtl'=1 quit
		if "+*-/|"[next set dt = dt_ next quit
		if "<=>,"[next set dt = dt_ "~"
	}

	/* modes 1, 2, 3, and 4 are left */
	if mode=1 set dt2 = "N"
	else  if mode=2 set dt2 = "T"
	else  if mode=3 set dt2 = "v"
	else  set dt2 = next.piece(BAR,3).extract()

	/* check if dt ends with a delimiter (dtl=2). If not (dtl=1), this is the
	   first atom from a new valexpr, that is separated from the previous by
	   a keyword (e.g. val1 BETWEEN val2 AND val3) */
	if dtl=1 set dt = dt_ "~"

	/* If already complete, only strlit replacement may be needed */
	if dt["~" do { quit dt		// already complete
		if mode=2 do RsMsDTL( .sqllit, dt.extract(), pred, pred(), .clause, .ptr)
	}

	if dt="" quit dt2		// first datatype is always OK

	/* dt contains a datatype and a binary operator */
	set dtdq = dt.extract()
	if mode=4 do {
		/* Column:
		   Domininates the return value. Any binary operator applied to
		   two dates or times results in a number (cf DINAM^SQLC).
		   Note that HOSTVAR binop date_or_time results in date_or_time,
		   with the implied assumption that HOSTVAR is a number. */
		if dtdq="D",dt2="D" set dt="N" quit
		if dtdq="C",dt2="C" set dt="N" quit
		if dt2="N","CD"[dtdq set dt = dtdq quit	// Date op Number = Date
		set dt = dt2				// others: column type
	}
	else  if mode=3 do {
		/* Hostvar:
		   Don't modify the datatype.
		   Note that AT COMPILE TIME (only) the type() structure could
		   be used to retrieve the datatype of the hostvar */
		set dt = dtdq
	}
	else  if mode=2 do {
		/* String literal:
		   Replace by internal numeric representation if needed:
		   If dtdq in (C,D,L) then assume conversion needed. In that case
		   the resulting datatype is Number */
		do RsMsDTL( .sqllit, dtdq, pred, pred(), .clause, .ptr)
		if "CDL"'[dtdq set dt = dtdq quit	// keep previous datatype
		set dt = "N"
		}
	else  do {
		/* Numeric literal:
		   If combined with D or C result will be N, else keep previous
		   datatype. */
		if "CD"[dtdq set dt = "N" quit		// Date binop Number = Date
		set dt = dtdq
	}

	quit dt

	// ---------------------------------------------------------------------
private RsMsDTL( ret String sqllit,	// string literals (*1)	/MECH=REF:RW
		String dtdq,		// DQ data type (*2)
		Number sub,		// subcript  (*3)
		String pred(),		// (*4)			/MECH=REFARR:RW
		ret String clause,	// (*1)
		ret String ptr)		// (*1)
	/* ---------------------------------------------------------------------
	This subroutine replaces a string literal by its internal representation
	if needed.
	The conversion rules are simple:
	* An empty string is never replaced here
	* If a string literal occurs in the context of one of the types C, D, or
		L, then it is converted to a number.
	* If the DQ datatype is U, the string literal is converted to uppercase.

	ARGUMENTS:
	(*1) see $$RsMsDT()
	(*2) dtdq = target datatype (+/- first character of dt in $$RsMsDT())
	(*3) sub = subscript number of pred() to be replaced
		By passing the number to this subroutine, it can be used to
		"backpatch" literals.
	(*4) only pred(sub) is used and possibly modified

	NOTES:
	* The sqllit string contains no duplicates, so when a literal occurs more
		than once in one of the original clauses, they all map to a
		single piece in sqllit, even if one occurs in the context of a
		type 'T' column, and another occurs in the context of a type 'U'
		column. For this reason the uppercase variant is inserted into
		sqllit using TOKEN^%ZS(), and clause will be updated to refer to
		the new symbol. For 'C', 'D', and 'L', the replacement can and
		will always be made in clause.
	* The decomposition in ^SQLQ() has slightly different behavior.
	    * COLUMN = strlit will be replaced by COLUMN = numlit
		(with numlit = +strlit) when the strlit occurs in a numeric value
		expression.
	    * A strlit inside the enumeration of COLUMN IN (val1, val2, ...)
		will not be replaced at all.
	    * DATECOL = '' or TIMECOL = '' is not handled at all in ^SQLQ()
	*/
	if "CDLU"'[dtdq quit	// no conversion needed

	type String atom = pred(sub)
	type Number pos = atom.piece(0.char(),2)
	type String lit = sqllit.piece(1.char(),pos)
	type String val

	if lit = "''" quit	// don't touch empty string

	if dtdq="U",lit?.CNPU quit	// no need to convert if no lowercase

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if dtdq="U" set val = $$TOKEN^%ZS( lit.upperCase(), .sqllit, "'")

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	else  set val = $$INT^%ZM(lit.stripQuotes("'"),dtdq)

	if ptr>0 set pos = ptr
	else  set pos = clause.length()
	type Number len = atom.length()
	set clause = clause.extract(1, pos-len)_ val_ clause.extract(pos+1, clause.length())
	if ptr>0 set ptr = ptr - len + val.length()
	set pred(sub) = val
	quit

	// ---------------------------------------------------------------------
private RsMsEx( String context)	// Text for Error.context
	/* ---------------------------------------------------------------------
	Throws a PSL runtime exception

	THROWS:
	. %PSL-E-SQLFAIL - select decomposition failed
		The value of context will be assigned to Error.context (with
		comma replaced by tilde).

	NOTES:
	. No longer called. Left in case needed later.
	*/
	type Error rErr = Class.new("Error")
	set rErr.type = "%PSL-E-SQLFAIL"
	set rErr.context = context.translate( 10.char()_","," ~")
	throw rErr
	quit

	// ---------------------------------------------------------------------
public RsMsIns(	String bld(,),		// (*1)	`		/MECH=REFARR:RW
		String map(,),		// map array		/MECH=REFARR:W
		String typ,		// (*3)
		String int,		// conceptual representation of ident
		String dtd)		// (*5)			/NOREQ
	/* ---------------------------------------------------------------------
	ARGUMENTS:
	(*1) bld("ALIAS",*) = aliased names
		When the DQ name is aliased, then it occurs in this structure as
			bld("ALIAS",alias)=original
		A complicating factor exists when one of the wide-tables is
		aliased. In that case each wide-table for which columns are
		found, must be aliased as well.
	(*3) typ = identier type ("XC","XT","XV")
	(*5) dtd = datatype_decimals
		This parameter is only used when typ="XV" (hostvar). Even in that
		case the parameter may be omitted. If it is supplied, it will
		represent the datatype (and number of decimals) of the hostvar.
		This information is used by $$RsMsXV() to ensure values of String
		or unknown type are properly quoted.

	INPUTS:
	. map("MD") = mapping mode:
		0 - suppress mapping
			All internal names will be equal to the conceptual names.
		1 - RDB mapping mode
			In this mode, MAP^DBMAP is called to map table names
			and column names.
			This is the default mapping mode
	OUTPUTS:
	. $$ = symbol number for this identifier
	. map = incremented if identifier added to map(typ,*)
	. map(typ,dqname) = sym | rdbdata
		map("XC",qual_dqname) = sym | qual_rdbname | typ_dec_nullind
			for ordinary columns
		map("XC",qual_dqname) = sym | "rdb_computation" | typ_dec_null
			for computed columns and masterfields
		map("XT",DQ_name) = sym | wide_table_list
		map("XV",sym) = sym | hostvar_name | typ_dec

	NOTES:
	. If the column represents a computed field or a masterfield, then the
		second piece will be filled with the SQL expression that
		"calculates" the value. Because the SQL expression may contain
		the vertical bar (SQL concatenation operator), the expression
		will be enclosed in TAB characters.
		Code that accesses the pieces 2 or higher of map(,) and that are
		likely to access the computed instances shall supply this "quote
		character" in the 4th argument of the String.piece() method.
	. If the column represents a computed field or a masterfield, then the
		(TAB enclosed) value may contain SQL literals. It is the callers
		responsibility to "tokenize" the SQL expression.
	*/
	type public String %DB			// database environment variable

	type literal String BAR = "|"		// standard separator
	type literal String TAB = 9.char()	// quote char for computeds

	type String ext, xtr
	type Number mmd = map("MD").get(1)

	if map(typ,int).exists() quit map(typ,int).piece(BAR)	// existing ident
	set map = map+1						// new identifier

	/* hostvar:
	   Each hostvar reference needs to occur as a separate value in vList.
	   So for hostvars the symbol number is used as internal representation.
	   This will lead to incorrect behavior only if the sql code contains
	   the erroneous contruct :123 to denote a hostvar. */
	if typ="XV" set ext = int, int = map, xtr = dtd.get()

	/* table:
	   Fill ext with the value stored in DBMAP for this table (if any),
	   otherwise use int. For wide-tables ext will contain the complete
	   list of tables */
	if typ="XT" do {
		set ext = int
		if mmd=1 do MAP^DBMAP(%DB,.ext)
		set xtr = ""
	}
	/* column:
	   Treat SYSDAT as a separate (unqualified!) entity.
	   As long as SYSDAT maps into the hostvar %CurrentDate, SYSDAT will
	   never be treated as a column. However, by simply removing the
	   replacement elsewhere, we will end up here, and can use the
	   substitution without additional codein effort.

	   Remove quotes from names (not needed by MDB, will be remapped for
	   RDB). Retrieve Datatype and number of decimals from DQ DD.
	   If table is aliased, use original tablename in call to MAP^DBMAP, and
	   translate alias.
	   For computed columns or masterfields, insert the SQL expression. */
	if typ="XC" do {
		if int="SYSDAT",mmd=1 set ext = "CURRENT_DATE", xtr = "D00" quit
		if int["""" set int = int.stripQuotes()		// quoted name
		type Number ER
		type String extc,extt,intt,RM
		set intt = int.piece(".")
		set extc = int.piece(".",2)
		set extt = bld("ALIAS", intt).get(intt)

		/* Block below shall be replaced when SchemaColumn class exists.
		   positions: TYP = 9, DEC = 14, NULLIND = 31
		#ACCEPT CR=14949;PGM=FSCW;DATE=03/25/05
		type String coldef = ^DBTBL("SYSDEV", 1, extt, 9, extc).get("||||||||T")
		set xtr = coldef.piece(BAR,9)_ +(coldef.piece(BAR,14))_ +(coldef.piece(BAR,31))
		============================================================= */
		if '$$isColumn^UCXDD(extt,extc) set xtr="T00"
		else  do {
			type PSLColumn coldef = PSL.getPSLColumn( extt, extc)
			set xtr = coldef.dataType_ (+coldef.precision)_ (+coldef.isNullToZero)
		}
		if mmd=1 do MAP^DBMAP(%DB, .extt, .extc)

		/* if intt is aliased wide table,
		   add bld("ALIAS",wide_alias) = extt (tbd) */

		if extc["(" set ext = TAB_ extc_ TAB	// enclose in "quotes"
		else  set ext = extt_"."_extc
	}
	set map(typ,int) = map_ BAR_ ext_ BAR_ xtr
 	quit map

	// ---------------------------------------------------------------------
private RsMsNull( String null(),	// null-pred array (*2)		/MECH=REFARR:RW
		String sqllit,		// tokenized SQL literals
		ret String clause,	// SQL clause			/MECH=REF:RW
		ret Number ptr)		// current pointer		/MECH=REF:RW
	/* ---------------------------------------------------------------------
	Check a complete predicate for COLUMN = '' or COLUMN <> '', and replace it
	by COLUMN IS NULL or COLUMN IS NOT NULL respectively (unless the column
	has NULLIND=1, in which case '' needs to be replaced by 0).
	Note that the pred() will contain the "AND" or "OR" that terminated
	the predicate (except for the last predicate). It may also contain
	parenthesis. The trailing atoms must be appened to the replacement.
	To handle this, the following algorithm is applied:
	* +null(0) provides the subscript (pos) of the COLUMN, and serves as the
		starting subscript.
	* If pos < 1 (no COLUMN), we are done
	* If there are not at least 2 atoms following the starting point, we
		are done.
	* If the next atom is neither "=" nor "<", we are done
	* If that atom equals "<", check the next atom. If not ">" we are done
	* if the next atom is not a strlit, we are done
	* if strlit '= "''", we are done
	
	ARGUMENTS:
	(*2) null() = predicate array

	OUTPUT:
	. null is killed, and re-initialized
	. clause is updated if needed
	. ptr is updated if clause is updated (and ptr >0)
	*/
	type literal String BAR = "|"

	/* All checking and replacement occurs in a separate block, to support
	   simple QUITs from block when unable to continue. The block is followed
	   by the code that resets null(), which must always be executed */
	do {
		type Number at			// subscript of empty string
		type Number pos			// subscript of column
		type String isnull = ""

		/* find empty string, don't need to check first 2 atoms */
		set pos = null(0).piece(BAR)
		if pos < 1 quit					// no column
		if null - pos < 2 quit				// no room for = ''

		set at = pos + 1
		if null( at) = "=" set at = at + 1, isnull = " IS NULL"
		else  if null( at) = "<", null(at+1) = ">" set at = at + 2, isnull = " IS NOT NULL"

		if isnull.isNull() quit				// incorrect compop
		if null(at).extract() '= 0.char() quit		// atom not strlit
		type Number lit = null(at).piece(0.char(),2)
		if sqllit.piece(1.char(),lit) '= "''" quit	// atom not ''

		/* We have a match, a replacement will be made. Check the COLUMN's
		   NULLIND value to see if the '' needs to be translated into 0 */
		type String atom = null(pos)
		if atom.piece(BAR,3).extract(3) = 1 do {
			if isnull["NOT" set isnull = " <> 0"
			else  set isnull = " = 0"
		}

		/* Reconstruct clause by concatenating the individual atoms:
		   the column in pred(pos), followed by the constructed isnull
		   clause, followed by all atoms to the right of null(at).
		   To be save, all appended atoms will be separated from each other
		   by a space. */
		set isnull = 9.char()_ atom.piece(BAR)_ 9.char()_ isnull

		for pos = at+1:1:null set isnull = isnull_ " "_ null(pos)	
		do RsMsRpl( .clause, isnull, null(0).piece(BAR,2), .ptr)
	}
	kill null
	set null = 0, null(0) = 0
	quit

	// ---------------------------------------------------------------------
private RsMsQcn( String bld(,),		// (*1)			/MECH=REFARR:R
		String cln)		// (*2)
	/* ---------------------------------------------------------------------
	Because the SQL standard requires that column specifications uniquely
	reference a column in an underlying table, all column references will
	be translated to qualified column names. The algorithm to find the
	matching table is (supposed to be) the same as used by Profile SQL.
	The special Profile keyword "SYSDAT" is returned unchanged here, and will
	be treated separately in RsMsIns() as well.

	ARGUMENTS:
	(*1) bld("ALIAS",aliasname) = original table name
		An unqualified column name could be from an aliased table.
		Only aliased names need to be present in this array. The function
		will use the specified name if the name is not found in this
		structure.
	     bld("FROM") = list of (aliased) table names from whic cln can be
		choosen. This list shall not be empty.
	(*2) (un)qualified column name
		If the name contains quotes, they will be removed.
		Then if the name is qualified, it will be returned unchanged,
		else the leftmost table in bld("FROM") for which a row exists in
		DBTBL1D will be returned.

	OUTPUTS:
	. $$ = qualified DATA-QWIK (!) columnname
		Table name will be prepended if not yet included.
		If no match is found, "_" will be used as table name.
	*/
	if cln = "SYSDAT" quit "SYSDAT"

	if cln [ """" set cln = cln.stripQuotes()

	if cln [ "." quit cln

	type String alias, fromlist = bld("FROM"), tbl
	type Number ord

	for ord = 1:1:fromlist.length(",") do { quit:cln["."
		/*
		FROM-list contains alias names. If the name is an alias, use the
		original name for lookup in the DQ DD, else the 'alias' names the
		table itself.
		*/
		set alias = fromlist.piece(",",ord)
		set tbl = bld("ALIAS", alias).get(alias)

		if $$isColumn^UCXDD(tbl, cln) set cln = alias_"."_cln
	}
	// if no match found, insert an arbitrary "table name"
	if cln'["." set cln = "_."_cln
	quit cln


	// ---------------------------------------------------------------------
RsMsQID1( String DQtbl)		// DQ Table name
	/* ---------------------------------------------------------------------
	This helper function returns an edited form of DBTBL1.QID1:
	- M quotes will be replaced by SQL quotes
	- Parenthesis will be added if the value contains an OR clause

	OUTPUTS:
	. $$ = edited form of DBTBL1.QID1
		Note that it is the callers responsibility to ensure that the
		returned clause satisfies the additional requirements of the
		underlying RDB, such as uniqe columnname.

	NOTES:
	. The translation of M quotes to SQL quotes is a dangerous transformation
		because it will lead to incorrect results if quoted identifiers
		are used in the query. On the other hand, the feature is not used
		very frequently, and the most importanr queries (DEP and LN) do
		use M quotes instead of SQL quotes.
	*/

	/* TEMPORARY: retrieve DBTBL1D.QID1.
	   This shall be made available as a property of td !! */
	type RecordDBTBL1 rec = Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:DQtbl")
	type String clause = rec.qid1

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if clause["""" set clause = $$QSWP^%ZS(clause,"""","'")
	if clause.translate("()","  ")[" OR " set clause = "("_ clause_ ")"
	quit clause

	// ---------------------------------------------------------------------
private RsMsRpl( ret String cls,	// source and target string	/MECH=REF:RW
		String val,		// replacement value
		String old,		// old value of ptr (*3)
		ret Number cur)		// new vlaue of ptr (*4)	/MECH=REF:RW
	/* ---------------------------------------------------------------------
	ARGUMENTS:
	(*3) the value of the pointer to the atom preceding the string to be
		replaced.
	(*4) the "current" value of the pointer
		If cur=0, cls.length() will be used
	OUTPUTS:
	. cls = modified string
		The characters from cur+1 up to and including new will have been
		replaced by val.
	. cur = updated position
		If new>0, then its value will be updated to old + val.length()
	*/
	type Number pos
	if cur>0 set pos = cur
	else  set pos = cls.length()
	set cls = cls.extract( 1, old)_ val_ cls.extract( pos+1, cls.length())
	if cur>0 set cur = old + val.length()
	quit

	// ---------------------------------------------------------------------
public RsMsSel(	String bld(,),		// (*1)			/MECH=REFARR:RW
		String map(,),		// (*2)			/MECH=REFARR:RW
		ret String sqllit,	// (*3)			/MECH=REF:RW
		Number mode,		// (*4)
		String clause,		// SQL clause to be analyzed
		List kwds)		// (*6)
	/* ---------------------------------------------------------------------
	Handle a single SELECT, GROUP BY or ORDER BY clause.
	This function acts as a "wrapper" that treats its input as a list
	of value expressions (mode=1) or column names (mode=0). In either case
	$$RsMsCls() is called to decompose the single value expression.

	ARGUMENTS:
	(*1) bld(,) = build structure from caller	
		see RsMsCls for bld("FROM",*)
		bld("SELECT") may be modified when mode=0
		bld("SELECT",*) will be referenced when mode=0
		bld("SELECT",*) will be modified when mode=1
		bld("SELNAM") may be modified when mode=0, and will be modified
			when mode=1
		bld("SELTYP") may be modified when mode=0, and will be modified
			when mode=1
	(*2) map(,) = identifier map array
		Values are added to this array.
		The unsubscripted node must have been initialized.
	(*3) sqllit = SQL literal tokens
		Passed to $$TOK^SQL() when decomposing a subquery.
		Passed to $$RsMsDT() when managing the datatype of a
		value-expression. The REF:W applies when the clause contains a
		string literal that is converted to uppercase for type 'U'
		columns.
	(*4) mode = processing mode will be passed to $$RsMsCls()
		0 = simple column list (GROUPBY or ORDERBY)
		1 = value-expression list (SELECT)
	(*6) kwds = comma-separated list of accepted keywords
		if mode=0:	/REQ
		if mode=1:	/NOREQ

	OUTPUTS:
	. $$ = the modified clause that has been supplied to the function
		Identifiers replaced by placeholders.
	. bld("FROM",exttbl)=""
		See RsMsCls()
	. bld("SELECT",extqcn)=""
		The function adds each internal (mapped) qualified columnname
		to bld("SELECT",qcn). This list is used when mode=0 to be able
		to add columns to the list if needed.
		If the SELECT clause is "*", then bld("SELECT","*") will be
		defined.
	. bld("SELECT") = updated SELECT clause
		If and only if mode=0, the function checks that a referenced
		mapped column reference occurs in the SELECT-clause. If not,
		the internal qualified column reference is appended to the
		clause.
	. bld("SELNAM") = normalized SELECT column name list
		The unqualified names of columns are added to this list.
		It can be used when caller wants to select columns from the
		select-list by name instead of by ordinal position.
	. bld("SELTYP") = Datatype and Number of decimals
		For each column in the select-list, this node will contain the
		datatype and number of decimals.

	NOTES:
	. Computed columns that require a callback provide a dilemma for mode=0.
		According to the SQL standard, the ORDER BY and GROUP BY
		clause must name a column that occurs in the SELECT-clause.
		DQ / PSL relaxes the latter by adding the column to the SELECT-
		clause if it is missing.
		For computed columns, a column alias is added to the (forced)
		reference in the SELECT-clause, and the alias itself is used in
		the generated ORDER BY or GROUP BY clause. $$RsMsCls() is aware
		of this, and will NOT add the TOKEN parameter to the HOSTVAR
		list.
		If the computed column is explicitly named in the SELECT-clause,
		as required by the SQL standard, this works out as needed.
		However, if the computed column is not named in the SELCET-
		clause, it will be added here, but the TOKEN parameter will be
		missing from the call. This will not even result in a runtime
		failure (just incorrect data-item proctection behavior).
		This failure is the expected behavior, and will disappear as
		soon as the SQL statement is corrected to conform to the SQL
		Standard (by explicitly including the column in the list).
	*/
	type literal String BAR = "|"		// standard delimiter
	type literal String TAB = 9.char()	// quote char for computeds

	type String elem		// current element being examined
	type String ic			// internal column or expression
	type String qcn			// qualified column name
	type String RsMsSel = ""	// return value
	type String selalias		// SELECT column name alias (if computed)
	type String selnam = ""		// column name in SELECT
	type Number selnum		// column ordinal position in SELECT
	type String selprim		// value returned by $$RsMsCls()
	type String seltyp		// value to be appended to SELTYP

	/* Special case: SELECT *:
	   Add each table of bld("FROM") to bld("FROM",tbl).
	   If tbl is a wide-table, add each individual table from the list */
	if mode=1, clause.trim()="*" do { quit "*"
		type Number ne,ni,sym
		type String frme,tble,tbli
		for ni = 1:1:bld("FROM").length(",") do {
			set tbli = bld("FROM").piece(",", ni)
			set sym = $$RsMsIns( bld(,), map(,), "XT", tbli)
			set frme = map("XT",tbli).piece(BAR,2)
			for ne = 1:1:frme.length(",") set bld("FROM", frme.piece(",", ne)) = ""
		}
		set bld("SELECT","*")="",bld("SELNAM")="",bld("SELTYP")=""
	}

	// initializations for mode=1 (only)
	if mode = 1 set (bld("SELNAM"),bld("SELTYP")) = "", kwds = kwds.get()

	// main decomposition loop =============================================
	for selnum=1:1 set elem = $$RsMsSelE(.clause) quit:elem=""  do {

		/* assume this is a single column name, possibly followed by a
		   keyword. Prepare an alias in case of masterfield or computed.
		   Call $$RESWRD^DBMAP() to ensure that selnam (=DQ name) is
		   translated into an acceptable identifier.
		   If selnam is not a name, then this must be the start of an
		   expression, which shall only occur when mode = 1. */
		set selnam = elem.piece(" ")
		if selnam.translate("""%","AA")?1A.ANP do {
			set qcn = $$RsMsQcn( bld(,), selnam)
			//set selalias = selnam_ "_"
			//if selalias["." set selalias = selalias.piece(".", selalias.length("."))
			set selalias = $$RESWRD^DBMAP(selnam.piece(".", selnam.length(".")))_ "_"
		}
		else  do {
			set qcn = "_._"
			set selalias = ""
		}

		if mode = 0 set selprim = selnam
		else  set selprim = elem

		/* Do not pass kwds (keywords) to RsMsCls if mode=0. Because
		   selprim contains only a name in that case, it must be
		   remapped regardless of the supplied keyword list. Note that
		   RsMsCls discards the value for mode=1 anyway.
		   */
		set selprim = $$RsMsCls( bld(,), map(,), .sqllit, mode, selprim, "")

		if map("XC",qcn).exists() set ic = map("XC",qcn).piece(BAR,2,2,TAB)
		else  set ic=""

		/* If the internal column contains a parenthesis, it needs to be
		   aliased in SELECT, and referenced by its alias in ORDER BY.
		   Any alias is OK as long as it is derived from the DQ column
		   name in a consistent way, that ensures uniqueness.
		   Note that if ic contains a computed expression, it will be
		   TAB-quoted, and ic will start with a TAB.
		   Note that the else-part is technically not needed, because
		   selalias will only be referenced for computeds.
		if ic["(" set selalias = ic.piece("(").translate(TAB)_ "_"
		else  set selalias = ""
		---------------- */

		/* mode = 0 ====================================================
		   elem.piece(" ") shall be a column name. It may need to be
		   added to bld("SELECT") etc.
		   */
		if mode = 0 do {
			/* A map(,) entry must have been added. if not throw
			   exception */
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			if 'map("XC",qcn).exists() do RsMsEx(qcn_ " in ORDER BY/GROUP BY "_$$UNTOK^%ZS(elem))

			/* Check ASC / DESC keyword (if allowed). A keyword that
			   does not occur in the supplied list will trigger an
			   exception */
			type String kwd = elem.extract(selnam.length()+2,elem.length()).translate(" ")

			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			if 'kwd.isNull() set selprim = selprim_" "_kwd if 'kwds.contains(kwd) do RsMsEx(kwd_ " in ORDER BY/GROUP BY "_$$UNTOK^%ZS(elem))

			/* Check for computed column in ORDER BY: if the internal
			   column contains parenthesis, then it is a computation,
			   and it has been aliased in the select. Adding kwd is
			   harmless even if kwd="" (it results in a trailing
			   space).
			    */
			if ic["(" set selprim = selalias_ " "_ kwd quit

			if 'bld("SELECT", qcn).exists() do {
				/* column in ORDER BY or GROUP BY not in SELECT
				   the UNQUALIFIED RDB column name is added to
				   bld("SELNAM"), except if it is a call-back */
				if bld("SELECT", "*").exists() quit	// SELECT *
				
				#ACCEPT GROUP=ACCESS;CR=35741;DATE=2008-10-23;PGM=Frans S.C. Witte
				if Db.isDefined( "STBLCLBKCOL", "FID=:qcn.piece(""."") AND DI=:qcn.piece(""."",2)") do RsMsEx("invalid callback-computed "_qcn_ " in ORDER BY/GROUP BY "_$$UNTOK^%ZS(elem))
				type String sym = TAB_ map("XC", qcn).piece(BAR)_ TAB
				set bld("SELECT", qcn) = elem		// only once
				set bld("SELECT") = bld("SELECT")_ ","_ sym
				set bld("SELNAM") = bld("SELNAM")_ ","_ qcn.piece(".",2)
				set bld("SELTYP") = bld("SELTYP")_ map("XC",qcn).piece(BAR, 3, 3, TAB).extract(1,2)
			}
		}

		/* mode = 1 ====================================================
		   The value expression may be a single column or a complete
		   (computed) expression.
		   If the qcn is found in map("XC",), then the element is a single
		   column name. Use that name in SELNAM, and its type in SELTYP
		   Otherwise construct a select name for this element.
		   Replace binary operators and the opening parenthesis by an
		   underscore. Discard closing parenthesis, colon (hostvar),
		   percent (columnname), quote (columnname), space, $C(0) (literal)
		   */
		if mode = 1 do {
			if map("XC",qcn).exists() do {
				set seltyp = map("XC",qcn).piece(BAR, 3, 3, TAB).extract(1,2)
				set bld("SELECT", qcn) = elem
				if ic["(" set selprim = selprim_ " "_ selalias
			}
			else  do {
				/* Need to define a separate selname, and use the
				   seltype returned by $$RsMsCls() */
				set selnam = elem.translate("*/+-|():""% "_0.char(),"_______").upperCase()
				if selnam.isNull() set selnam = selnum_"_"
				set seltyp = bld("CLSTYP")
			}
			if selnum > 1 set bld("SELNAM") = bld("SELNAM")_ ","
			set bld("SELTYP") = bld("SELTYP")_ seltyp, bld("SELNAM") = bld("SELNAM")_ selnam
		}

		if selprim.isNull() quit

		if selnum > 1 set RsMsSel = RsMsSel_","
		set RsMsSel = RsMsSel_ selprim
		kill bld("CLSTYP")
	}

	quit RsMsSel

	// ---------------------------------------------------------------------
private RsMsSelE( ret String str)	// String to break down		/MECH=REFNAM:RW
	/* ---------------------------------------------------------------------
	Helper function that returns the next element in a SELECT, ORDER BY, or
	GROUP BY clause.

	OUTPUTS:
	. $$ = next element
		Without the terminating comma
	. str = updated input string
		The returned element and the comma will have been removed
	*/
	type Number pos = 1
	type Boolean found = 0
	type String sel
	while 'found do {
		set pos = str.find(",", pos)
		if pos=0 set pos = str.length() + 2, found = 1
		set sel = str.extract(1, pos - 2)
		if sel.length("(") = sel.length(")") set found = 1
	}
	set str = str.extract(pos, str.length())
	quit sel.trim()

	// ---------------------------------------------------------------------
private RsMsSub( String sym,	// symbol string to be used as placeholder
		String org,	// original value to be replaced
		ret String str,	// source and target string	/MECH=REF:RW
		ret Number pos)	// position of last char of org	/MECH=REF:RW
	/* ---------------------------------------------------------------------
	OUTPUTS:
	. str = modified string
		The occurrence of org at position pos will have been replaced by
		a placeholder idenfitied by sym
	. pos = updated position
		Will equal the position of the last character of the placeholder
		in str
	*/
	type Number lst
	if pos>0 set lst = pos
	else  set lst = str.length()
	set str = str.extract(1,lst-org.length())_sym_str.extract(lst+1,str.length())
	if pos>0 set pos = pos-org.length()+sym.length()
	quit

	// ---------------------------------------------------------------------
private RsMsWtChild( PSLTable child	// child table
		, String bld(,)	// tables used in from-clause
		, String map(,)	// map array
		)
	/* ---------------------------------------------------------------------
	Return "join keys" for wide table join column clause as follows:
	- If bld("FROM",parent) does not exist, then the parent table is not
		referenced in this query. The function will return "".
	- If only key columns of the parent table are referenced, then the
		parant table is not needed to satisfy the query, and every other
		wide table can be used on the left side of a key comparison.
		This is returned as "?.key1 = !.key1 AND ?.key2 - !.key2".
	- Otherwise "parent.key1 = !.key1 AND parent.key2 = !.key2" is returned.

	INPUTS:
	. bld("FROM",internalTable) contains all internal table names from which
		columns are referenced
	. map("XV",wt.kN) will be used to see if only key columns from the
		parent table are used.

	OUTPUTS:
	. $$ = join clause on primary key columns of parent table.

	NOTES:
	. If the return value only contains "!", then the parent table is used,
		and the caller will only need to replace the "!" by the
		appropriate child table.
	. If the return value contains both "|" and "?", then the parent table
		is not needed for the query, and the caller must replace "?"
		by the first child table part, and the "!" by subsequent child
		parts.
	. If the return value contains both "?" and "!", then the return value
		will start with "?"
	. This function assumes that the DQ names of the primary key columns
		are the same as the internal RDB names of the columns.
	. This function assumes that the DQ name of the parent table is the same
		as the internal RDB name of the parent table.
	*/
	type literal String BAR = "|"

	if 'bld( "FROM", child.parentTable).exists() quit ""

	/* Parent is included. However, since key columns map to the parent
	   table, it might be that only key columns of the parent are referenced
	   in the query. If that is the case, then the parent table needs not
	   be included, but any key column must be re-mapped to some other wide
	   table that is found in bld("FROM",*). If we find any column other than
	   a key column, this shall be treated as "parent table really needed".
	   */
	type String ci, cn = child.table, qcn = cn_".", tbl = child.parentTable
	type Number cnt = 0
	type List     pk = child.primaryKeys
	type Number   mx = pk.count() 

	for  set qcn=map("XC",qcn).order() quit:(cnt>mx)!(qcn.piece(".")'=cn)!qcn.isNull()  do {
		set ci = map("XC",qcn).piece(BAR,2)
		if ci.piece(".") = tbl set cnt = cnt + 1 if 'pk.contains( ci.piece(".",2)) set cnt = mx + 1
	}

	/* If cnt > mx, then a column other than a key column has been found,
	   else the query can use child table name(s) only.
	   */
	quit $$RsMsWtWhr( $SELECT( cnt>mx:tbl, 1:"?"), pk)


	// ---------------------------------------------------------------------
private RsMsWtJoin( String bld(,)	// tables used in from-clause
		, String map(,)		// map array
		)
	/* ---------------------------------------------------------------------
	Update a FROM-clause that is not a List of tablenames.

	See if there are wide tables involved. If so, replace each occurrence by
	an aliased derivedtable-clause that represents the wide tables and the
	wide table columns needed for this select-statement.
	The algorithm looks at all tables in bld("FROM") and if the table maps to
	multiple tables, it will be replaced by an aliased derivedtable-clause:

		( SELECT wt1.c11, wt1.c12, wt2.c21, wt2.c22
		  FROM wt1,wt2 WHERE wt1.k1=wt2.k1 AND wt1.k2=wt2.k2 ) dqname

	The wtN.CNM names will be the names as they occur in the internal model.
	These names will be inserted into the from-replacement WITHOUT
	placeholders. For columns in the derived table's select-list, the
	corresponding mapping in map("XC",qualDqName) will be changed to use the
	alias instead of the wide table name.

	ARGUMENTS / INPUTS / OUTPUTS:
	. bld("FROM") and bld("FROM",internalTable)
		bld("FROM") contains the List of tables that occur in the from
		clause. This will be a List of conceptual names.
	. bld("FROM",internalTable) contains all internal table names from which
		columns are referenced.
	. map("XT",conceptualTable) will be used to find the internalTable (one-
		to-one remapping) or wide tables (one-to-many mapping) that shall
		be passed to the RDB API.
		The "internalValue" field for a wide table will be replaced by
		the aliased derivedtable-clause.
	. map("XV",qualDqName) will be used and modified when a wide table in a
		joinedtable-clause is replaced by an aliased derivedtable-clause.
		In that case, the internalName will be replaced by the alias name
		(that happens to be the widetable name).

	NOTES:
	. Although this subroutine may result in a FROM-clause that differs
		significantly from the original FROM-clause, it neither reads
		nor writes the from-clause (or any of the other clauses).
		Modifications will only occur in map("XT",wideTable) and
		map("XC",wideTable.column).
	--------------------------------------------------------------------- */
	type literal String BAR     = "|"
	type literal String TAB     = 9.char()

	type String dqtbl    = ""	// from-list element (DQ table name)
	type Number elm			// from-list iterator
	type List   fromlist = {List}bld("FROM")

	for elm = 1:1:fromlist.count() do {
		set dqtbl = fromlist.elementAt(elm)
		if 'bld("FROM",dqtbl).exists() do {
			/* Tablename either
			   - not used or invalid (ignore)
			   - mapped to one or more (wide) tables (find them all).
			   */
			if 'map("XT",dqtbl).exists() quit
			type List itl = {List}(map("XT",dqtbl).piece(BAR,2))

			/* Simple (one-to-one) tablename remapping: ignore */
			if itl'["," quit

			/* wide table ======================================= */
			type String	icn = ""	// internal column name
			type String	frm = ""	// from clause
			type String	it		// internal table name
			type Number	itc		// internal table iterator
			type String	qcn		// qualified column name
			type String	sel = ""	// select clause
			type PSLTable	td = PSL.getPSLTable( dqtbl, 0)
			type List	pk = td.primaryKeys
			type String	whr = ""	// where clause
			type String	whrkey = $$RsMsWtChild( td, bld(,), map(,))

			/* for each internal table ========================== */
			for itc=1:1:itl.count() do {
				set it = itl.elementAt(itc)

				// ignore if not used
				if 'bld("FROM",it).exists() quit

				// ignore parent table if only key columns
				if it = td.parentTable, whrkey.extract() = "?" quit

				if 'frm.isNull() set frm = frm_ ","
				set frm = frm_ it

				/* if parent needed for join it occurs
				   already in whrkey */
				if it = td.parentTable quit

				// parent not included: first table sets whrkey
				if whrkey.isNull() set whrkey = $$RsMsWtWhr( it, pk) quit

				// only key columns from parent
				if whrkey.extract() = "?" do { quit
					/* remap dqtbl.keyN to wt.keyN */
					set whrkey = whrkey.replace( "?", it)
					type String cn
					type Number cc
					for cc = 1:1:pk.count() {
						set cn = pk.elementAt( cc)
						if map("XC",dqtbl_ "."_ cn).exists() set map("XC",dqtbl_ "."_ cn).piece(BAR,2) = it_ "."_ cn
					}
				}

				// subsequent wide table
				if 'whr.isNull() set whr = whr_ " AND "
				set whr = whr_ whrkey.replace( "!", it)
			} // end for all internal tables

			/* =====================================================
			   If parent is included either as the only table, or in
			   the list of tables, then add the DBTBL1.QID1 of the
			   child. Although this should only impact the final
			   result if the parent is the only table, queries have
			   been found in which Oracle invoked the computation of
			   a (say) DEP.computed() on an ACN row with
			   ACN.CLS='L'.
			   This may cause the computation to fail, and the query
			   to be aborted. Note that it is completely up to the
			   RDB implementation as to when it applies a predicate
			   to a row. By providing the RDB with the option of
			   ruling out certain rows based on QID1 before calling
			   the the computation, we hope to prevent the problem
			   ...
			   */
			if frm.contains( td.parentTable) do {
				if 'whr.isNull() set whr = whr_ " AND "
				set whr = whr_ $$RsMsQID1( dqtbl)
			}

			/* =====================================================
			   If frm contains only one table, and there is no where
			   clause (parent not needed), we are lucky.
			   Because columnreferences have not yet been remapped,
			   it is sufficient to store the name of the internal
			   table in map("XT",dqtbl). key column (re)mapping has
			   been taken care of in the construction of frm. */
			if frm'[",",whr.isNull() set map("XT",dqtbl).piece(BAR,2)=frm quit

			/* =====================================================
			   Remap column names, and construct the select list.
			   Because all columns for this wide table occur in map()
			   by their dqname, this can be done in one pass,
			   independent of the internal tables in which they occur
			   as long as key columns are mapped correctly:
			   The construction of frm caused map("XC",dqtbl.key) to
			   contain the correct qualified column reference.
			   Use this value in the select-clause before changing it
			   back to dqtbl.key. */
			set qcn = dqtbl_"."

			/* for each column used in the query ================ */
			for  set qcn = map("XC",qcn).order() quit:qcn.piece(".")'=dqtbl  do {
				set icn = map("XC",qcn).piece(BAR,2,2,TAB)

				/* Ignore computations. Their underlying columns
				   will occur separately */
				if icn[TAB quit

				/* Strip tablename from column as used in the
				   select-clause, except if dqtbl.key, and update
				   map("XC",qcn) to use the alias (= dqtbl) name.
				   */
				if 'sel.isNull() set sel = sel_ ","
				if pk.contains( qcn.piece(".",2)) set sel = sel_ icn
				else  set sel = sel_ icn.piece(".",2)
 
				set map("XC",qcn).piece(BAR,2) = dqtbl_"."_icn.piece(".",2)
			}

			/* =====================================================
			   Combine parts into the aliased derivedtable-clause,
			   and store it in map("XT",dqtbl) */
			set frm = "(SELECT "_sel_" FROM "_frm_" WHERE "_whr_")"
			set frm = frm_ " "_ dqtbl
			set map("XT",dqtbl).piece(BAR,2)=frm
		} // end if requires remap
	} // end for each table in bld("FROM")
	quit

	// ---------------------------------------------------------------------
private RsMsWtList( String bld(,),	// tables used in from-clause	/MECH=REFARR:R
		String map(,),		// map array			/MECH=REFARR:RW
		ret String sqllit,	// SQL string literals		/MECH=REF:RW
		ret String from,	// pre-processed from-clause	/MECH=REF:RW
		ret String where)	// pre-processed where-clause	/MECH=REF:RW
	/* ---------------------------------------------------------------------
	Update the FROM-clause and the WHERE-clause to reflect wide tables.
	The variables 'from' and bld("FROM") both contain the original
	from-clause, that did not contain joinedtables or aliasedtables.

	The code below examines each table t in bld("FROM"), and if that name
	does not also occur as bld("FROM,t), then it is treated as a wide table,
	and replaced by all tables that are listed in map("XT",t), and that do
	occur in bld("FROM",*).
	For each of these tables, the WHERE-clause will be extended with
	the JOIN condition (on wt.keyN).

	ARGUMENTS / INPUTS / OUTPUTS:
	. bld("FROM") and bld("FROM",internalTable)
		bld("FROM") contains the List of tables that occur in the from
		clause. This will be a List of conceptual names.
	. bld("FROM",internalTable) contains all internal table names from which
		columns are referenced
	. map("XT",conceptualTable) will be used to find the internalTable (one-
		to-one remapping) or wide tables (one-to-many mapping) that shall
		be passed to the RDB API.
	. map("XC",wt.CID) will be modified if and only if ACN.CID is the only
		column from ACN.
	. map("XC",qcn) may be extended with columnnames that occur in the
		parent/child relationship of wide tables.
	. sqllit may be extended with SQL literals that occur in the parent/child
		relationship of wide tables.
	. from contains the "original" from-clause. This value will be rewritten
		to account for wide tables (and other tablename remappings).
	. where is only modified if List of tables in the from-clause includes
		wide tables. The wide table join condition will be appended to
		the supplied clause.

	NOTES:
	. Unlike RsMsWdJoin(), this function needs to modify .from and .where
		because:
		. The from clause was not passed to $$RsMsCls() and therefor will
			not contain placeholders for the (wide) table names.
		. The join condition on the wide tables is added to the where-
			clause.
	*/
	type literal String BAR     = "|"

	type String table = ""		// from-list element
	type Number elm			// from-list iterator

	type List fromlist = {List}from
	set from = ""

	/* for each table =========================================== */
	for elm = 1:1:fromlist.count() do {
		type String joinwhr = ""	// additional where-clause
		if 'from.isNull() set from = from_ ","
		set table = fromlist.elementAt(elm)
		if 'bld("FROM",table).exists() do {
			/* Tablename either
			   * not used or invalid (ignore)
			   * mapped to one or more (wide) tables (find
			   them all). */
			if 'map("XT",table).exists() quit
			type List wtl = {List}(map("XT",table).piece(BAR,2))

			/* Simple (one-to-one) tablename remapping */
			if wtl'["," set table = wtl quit

			/* wide table =============================== */
			type String	dqt = table	// DQ table name
			type String	wt		// wide table name
			type Number	wtc		// wide table iterator
			type PSLTable	td = PSL.getPSLTable( dqt, 0)	// child table
			type List	pk = td.primaryKeys
			type String 	whrkey = $$RsMsWtChild( td, bld(,), map(,))
			set table = ""			//  list of wide tables

			/* for each wide table ====================== */
			for wtc=1:1:wtl.count() do {
				set wt = wtl.elementAt(wtc)

				// ignore if not used
				if 'bld("FROM",wt).exists() quit

				// ignore parent if only key columns
				if wt = td.parentTable, whrkey.extract() = "?" quit

				/* if parent already occurs in the from list under
				   construction, ignore it. This will be the
				   case if ACN and DEP or ACN and LN are both
				   explicitly included in the original from
				   list (strange query ...). */
				if wt = td.parentTable, (","_table_",")[(","_ td.parentTable_ ",") quit

				if 'table.isNull() set table = table_ ","
				set table = table_ wt

				/* if parent needed for join it occurs
				   already in leftkey */
				if wt = td.parentTable quit

				// parent not included at all.
				if whrkey.isNull() set whrkey = $$RsMsWtWhr( wt, pk) quit

				// Only key columns from parent
				if whrkey.extract() = "?" do { quit
					/* remap dqtbl.keyN to wt.keyN */
					set whrkey = whrkey.replace( "?", wt)
					type String cn
					type Number cc
					for cc = 1:1:pk.count() {
						set cn = pk.elementAt( cc)
						if map("XC",dqt_ "."_ cn).exists() set map("XC",dqt_ "."_ cn).piece(BAR,2) = wt_ "."_ cn
					}
				} // end if whrkey starts with '?'


				if 'joinwhr.isNull() set joinwhr = joinwhr_ " AND "
				set joinwhr = joinwhr_ whrkey.replace("!", wt)
			} // end for each wide table

			/* =====================================================
			   If joinwhr = "", only a single table is involved.
			   This may be something like:
			   	SELECT CID,BAL FROM DEP
			   Which mapped to:
			   	SELECT ACN.CID,ACN.BAL FROM ACN
			   Or the even more special case:			   
			   	SELECT CID FROM DEP
			   Which mapped to:
			   	SELECT ACN.CID FROM ACN
			   In the first case (ACN.CID is not the only column from
			   ACN), table="ACN". In the second case, table="".
			   In both cases, use DBTBL1.QID1 of the original DQ
			   table as the additional "joinclause". */
			if table.isNull() set table = td.parentTable
			if table = td.parentTable do {
				/* value returned by $$RsMsQID1() will contain
				   unqualified columnnames. Ensure that all will
				   be taken from ACN. */
				type String origFrom = bld("FROM")
				set bld("FROM") = table
				set joinwhr = $$RsMsQID1( fromlist.elementAt(elm))
				set joinwhr = $$RsMsCls( bld(,), map(,), .sqllit, 2, joinwhr, "")
				set bld("FROM") = origFrom
			}
		} // end if table not in bld("FROM",*)

		set from = from_ table
		/* =============================================================
		   append WHERE extension */
		if 'joinwhr.isNull() do {
			if where.isNull() set where = joinwhr quit
			if where.translate("()","  ")[" OR " set where = "("_ where_ ") AND "_joinwhr quit
			set where = where_ " AND "_ joinwhr
		}
	} // end for each table
	quit

	// ---------------------------------------------------------------------
private RsMsWtWhr( String left	// "table" to be used on the left side
		, List pk	// primary keys
		)
	/* ---------------------------------------------------------------------
	Return "join keys" for wide table join column clause as follows:

	OUTPUT:
	$$ = "left.key1 = !.key1 AND left.key2 = !.key2"
	*/
	type Number cnt
	type String whr = left_ "."_ pk.elementAt(1)_ " = !."_ pk.elementAt(1)
	for cnt = 2:1:pk.count() set whr = whr _" AND "_ left_ "."_ pk.elementAt( cnt)_ " = !."_ pk.elementAt( cnt)
	quit whr

	// ---------------------------------------------------------------------
public RsMsXI(	String map(,),	// identier map array		/MECH=REFARR:R
		String typ,	// identier type ("XC", or "XT")
		String str)	// source string
	/* ---------------------------------------------------------------------
	INPUTS:
	. map(typ,intrep) = sym | extrep | additional info

	OUTPUTS:
	. $$ = str with all placeholders that represent identifiers of the
		specified type replaced by there internal representation

	NOTES:
	. If extrrep contains the TAB character, it is supposed to be a computed
		column or masterfield, that has already been replaced, and does
		not occur in the supplied source string.
	. Do not call this function to replace Hostvars (typ="XV"), because that
		replacement requires additional processing
	*/
	type literal String BAR = "|"
	type literal String TAB = 9.char()

	type String extrep,intrep,sub
	type Number le,ls,pos

	set intrep = ""
	for  set intrep = map(typ, intrep).order() quit:intrep=""  do {
		set sub = TAB_ map(typ, intrep).piece(BAR)_ TAB
		set ls = sub.length()
		set extrep = map(typ, intrep).piece(BAR,2,2,TAB)
		quit:extrep[TAB
		set le = extrep.length()
		for pos = str.find(sub):0 quit:'pos  do {
			set str = str.extract(1, pos-ls-1)_ extrep_ str.extract(pos, str.length())
			set pos = str.find(sub, pos-ls+le)
		}
	}
	quit str

	// ---------------------------------------------------------------------
public RsMsXV(	String map(,),	// map array
		ret String str,	// source and target string
		Boolean bExt,	// external values? (*3)	/NOREQ
		Number dlm)	// host value delimiter (*4)	/NOREQ
	/* ---------------------------------------------------------------------
	This function can be called at runtime to construct the actual SQL
	select statement, and bind the hostvars.

	ARGUMENTS:
	(*3) bExt
		If bExt=1, then the generated value will include calls to the
		function $$INT^%ZM() for all hostvars that may require a
		transformation of an external value to an internal value.
		- For $ and N, the type and the number of decimals need to be
			passed. If the map node does not specify the number of
			decimals, this parameter will not be added (and a
			runtime default will be used).
		- For C, D, L, and U, the only the type needs to be passed
		- For B, F, M, and T no conversion is needed
		- The internal value "v" (lowercase), that denotes an "unknown"
			datatype will be treated as T (no conversion, but
			quotes added)
	(*4) dlm = host value delimiter
		For standard SELECT this will be $C(9), but since it is one of
		the paramters in the call to SELECT^%DBAPI(), we will need to
		support alternative values as well.

	INPUTS:
	. map("XV",sym) = sym | hostvar | typeinfo

	OUTPUTS:
	. $$ = leftexpr that constructs the value to be passed in vList.
		When called at compile time, this value can be inserted into the
		code as follows:
			do addline(" S vList="_$$RsMsXV(.selmap,.query)")
		When called at runtime, the value can be used with indirection
		either with a SET command, or with an XECUTE command:
			S @("vList="_$$RsMsXV(.selmap,.query))
			X "S vList="_$$RsMsXV(.selmap,.query)
		All constructs can be used unconditionally, even when the query
		does not contain hostvars.
	. str = updated to contain the hostvars instead of the placeholders
		To ensure that no Hostvar name collides with a SQL keyword, an
		underscore will have been added to all hostvar names.

	NOTES:
	. This function is similar to $$RsetMsXI(), but it uses the fact that
		each placeholder occurs exactly once.
	. Even though the structure of map("XV",) is consistent with the other
		two types, $$RsetMsXI() shall not be used to replace the values,
		because that function neither constructs the Hostvar list nor
		does it deal with special cases such as renaming hostvars.
	. Dealing with numeric HOSTVARs in the construction of vList can be done
		in either of the following ways:
		1) Do nothing.
			This will result in an "empty spot" in vList. %DBAPI
			does not handle this condition well. It will be reported
			as an "insufficient values" exception.
		2) Add quotes.
			This will result in SQL code that is acceptable to
			Oracle, but the interpretation of '' in a numeric
			context is unknown, and probably implementation
			specific.
		3) Force the numeric interpretation of the HOSTVAR value.
			This might be an acceptable way to go based on the
			following sections of the SQL II Standard:
			- 12.3, General Rules 4)
			- 12.4, Syntax Rules, 5) sub b) and sub d)
			- 19.7 embedded SQL MUMPS program
			This defines the rules for binding INTEGER, DECIMAL or
			REAL datatypes to MUMPS. The MUMPS language  will take
			the numeric (or integer) interpretation of an expression
			whenever numexpr or intexpr is implied.
		This version of UCDBRT will implement 3)
	. After a major revision of the API in the summer of 2006, quotes are
		no longer needed around host values. This function has been
		adapted to support that. 
	*/
	type literal String BAR = "|"
	type String dtd,extrep,hv,intrep,syskwd(),sub,vallist
	type Number dec

	// If no hostvars, then quit code to assign the empty string.
	if map("XV","").order() = "" quit """"""

	set (intrep,vallist) = ""
	for  set intrep = map("XV",intrep).order() quit:intrep=""  do {
		set sub = 9.char()_map("XV",intrep).piece(BAR)_9.char()
		set extrep = map("XV",intrep).piece(BAR,2)
		set dtd = map("XV",intrep).piece(BAR,3)
		set dec = dtd.extract(2)
		set dtd = dtd.extract()
		if dtd.isNull() set dtd="T"	// unknown
		if dtd="v" set dtd="T"		// another case of unknown

		/* If extrep starts with "%", it must be replaced by an
		   arbitrary placeholder that is acceptable to the API (the
		   name "V"_sym_"DBRT" is used). This replacement will always
		   occur.
		   If extrep starts with "%%", then the remainder contains the
		   expression to insert into vList.
		   Else, if the %NAME matches a STBLSYSKEYWD entry, then newrep
		   must be used instead of extrep, and the datatype is derived
		   from the first character of the Class of the keyword.
		   Note that the order of assignments matters: dtd must be
		   calculated using extrep before extrep itself is modified.
		   If extrep is an "ordinary" hostvar name, append an underscore
		   in case the programmer used a SQL keyword as hostvar name ...
		   */
		if extrep.extract() = "%" do {
			set hv = "V"_map("XV",intrep).piece( BAR)_"DBRT"
			if extrep.extract(2) = "%" set extrep = extrep.extract( 3, extrep.length()) quit
			type Row kwdRow = $$kwdRow^UCDTAUTL( extrep, syskwd()).toRow( "#$$kwdRowDef^UCDTAUTL")
			type String newrep = kwdRow.des
			if newrep.isNull() quit		// not a system keyword
			set dtd = kwdRow.class.extract().translate("BS","LT")
			set extrep = newrep
		}
		else set hv = extrep_ "_"


		/* If bExt, add code to convert external to internal */
		if bExt.get(),"$CDLNU"[dtd do {
			set extrep = "$$INT^%ZM("_ extrep_ ","""_ dtd_ """"
			if "$N"[dtd,'dec.isNull() set extrep = extrep_ ","_ dec
			set extrep=extrep_")"
		}

		/* If Numeric (C,D,L,N,$) force numeric interpretation */
		if "CDLN$"[dtd set extrep = "+"_ extrep
		/* temporarily: others add quotes */
		// else  set extrep = "$S(" _ extrep _ "'[""'"":""'""_" _ extrep _ "_""'"",1:$$QADD^%ZS(" _ extrep _ ",""'""))"
		if 'vallist.isNull() set vallist = vallist _ "_"
		set vallist = vallist_ extrep_ "_$C("_ dlm.get(9)_ ")"
		set str = str.replace(sub,hv,1)
	}
	quit vallist

	// ---------------------------------------------------------------------
public RsRdb( String from)	// FROM-clause (*1)
	/* ---------------------------------------------------------------------
	This function is a modified version of $$rdb(). This function does
	handle FROM-clauses that contain keywords (JOIN, AS).
	The FROM clause is transformed to a normalized FROM-list, that is passed
	to $$rdb().

	ARGUMENTS:
	(*1) The FROM-clause can either be supplied as a comma separated list,
		or as a clause that includes any of the keywords JOIN or AS.
	OUTPUTS:
	. $$ = 1 if the first table of the normalized list is stored in an RDB
	     = 0 if the first table of the normalized list is stored in an MDB
	*/
	if 'Runtime.isRdb quit 0

	if (from.translate("()","  ")[" JOIN ")!(from[" AS ") do {
		type Number map=0
		type String bld(,)
		type String lit

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		type String ignore = $$TOKEN^%ZS(from,.lit,"'")
		set ignore = $$RsMsCls( bld(,), map(,), .lit, 3, from, "")
		set from = bld("FROM")
	}
	else  set from = from.translate(" "_9.char())
	quit $$rtIsRdb^UCXDD(from)

	// ---------------------------------------------------------------------
public RsSelAll( List from)	// from-list (*1)
	/* ---------------------------------------------------------------------
	SELECT * will be replaced by $$COLLIST^DBSDD() of the tables.
	The parameters to the call specify that computed columns and
	masterfields will be included. However Blobs/Memos will be excluded.
	ARGUMENTS:
	(*1) fromList
		Shall be the normalized list, so no explicit JOIN or table alias
		is allowed.
	*/
	type Number n
	type String selAll = $$COLLIST^DBSDD( from.elementAt(1), 0, 1, 0)

	for n=2:1:from.count() set selAll = selAll_ ","_ $$COLLIST^DBSDD( from.elementAt( n), 0, 1, 0)
	quit selAll

	// ---------------------------------------------------------------------
public RsSelList( String select)	// SELECT-clause (*1)
	/* ---------------------------------------------------------------------
	This function returns an edited form of the specified SELECT clause in
	which insignificant whitespace has been removed, and all names have
	been translated to uppercase. The keywords ALL and DISTINCT will have
	been removed if they occur at the beginning of the SELECT clause.

	ARGUMENTS:
	. (*1) If the clause starts with an M quote, then a layer of quotes is
		removed before applying any of the other transformations.
	*/
	type String expr,tok
	if select.extract()'="""" set expr = select
	else   set expr = select.stripQuotes()

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set expr = $$SQL^%ZS(expr,.tok)
	if expr["""" set expr = expr.stripQuotes()	// Strip quotes from names

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set expr = $$UNTOK^%ZS(expr,.tok)
	if expr.extract(1,9)="DISTINCT " set expr = expr.extract(10,expr.length())
	if expr.extract(1,4)="ALL "      set expr = expr.extract( 5,expr.length())
	quit expr
 #OPTION ResultClass ON
public String vSIG()	quit "61480^60691^Dan Russell^111754"	// Signature - LTD^TIME^USER^SIZE
