	  /*
	ORIG: FSANCHEZ - 02/19/2003
	DESC: Library of PSL methods

	---------- Revision History --------------------------------------------
	2009-06-25, Frans S.C Witte, CR 41380
		* Corrected code in opti (should not call $$getExpr^UCGM())

	2009-03-30, Frans S.C Witte, CRs 35741/39032
		* Code for PSL.mExpr now also supresses MISMATCH warnings

	02/02/2009 - RussellDS - CR37982
		* Added new method, PSLTable.getChildren
	
	2008-10-15, Frans S.C. Witte, CRs 35741/?????
		Added generator for PSLTable.getExistsCode()

	03/06/2008 - RussellDS - CR30801
		* Added new method, PSLTable.getNewMethodCode
		* Added new method, PSLTable.checkAccessRights
		* Added new method, PSLTable.getLogging
	
	09/20/07 - RussellDS - CR29295
		* Added new parameter (RdbCodeForm) to getUpdateCode.
                * Added new method, PSLTable.getInitCode
		
	05/14/07 - Frans S.C. Witte - CR: 27800
		* Replaced commands(,) by PSL.xxxSetting(,)
		* Replaced $D(labels()) with $$hasSubr^UCGM(^UCGM()
		* Removed insLine (because PSL.insertLine() was removed)
		* Removed getDbLoad (because PSL.getDbload() was removed)
		* Removed cmdsRest() and cmdsSave() (no longer called)
		* Removed getLabel (PSL.getLabelRecord no longer exists)
		* All PSLBuffer.insert() calls now include a resultClass
		* Calls to ^DBARCHIVE will now only be generated conditionally
		  (Version 7, no bootrestriction, no RDB)
		* Removed isRecord (PSL.isRecord is no longer supported)

	04/05/07 - Frans S.C. Witte - CR: 26334
		Corrected fitsLinLen to add parenthesis to actual(1) if needed

	03/01/07 - RussellDS - CR26386
		* Changes to support archiving
		   - Added PSLTable.getArchive* methods.
		   - Added PSLTable.getQuery and .isParent methods.
	
	01/18/07 - Frans S.S. Witte - CRs:  25185 / 25186 / 25187
		* Subroutine INSERT: added support for ResultClass
		* Subroutune insBuf removed (method Buffer.insert now
		  implemented using insMet()
		* renamed stdMet() to statMet()

	10/17/06 - Frans S.C. Witte - CRs: 22719 / 20613
		* Added additional parameters in code generated for
		  PSLTable.getSaveCode() and PSLTable.getUpdateKey()
		* Added second parameter to all calls to $$tokenPush^UCPATCH().
		* Added $$stdCall() and stdMet

	07/11/06 - Frans S.C. Witte - CRs: 22720 / 22274
		* Added pslPrsr("Options","ResultClass") in call to
		  $$fromSubrou^UCPSLLR()
		* Added documentation to decribe use of $$tokenPush^UCPATCH()
		  and $$tokenPush^UCPATCH() with PSL.mExpr().

	06/15/06 - Frans S.C. Witte - CRs: 22060 / 22061
		* Corrected code generated for PSLSubrou.insCode() and
		  PSLSubrou.getLine, added in-line code generation for
		  PSLSubrou.addExe(), PSLSubrou.addLvn(), PSLSubrou.addTag(),
		  PSLSubrou.getLvn(), PSLSubrou.getLvnMax(), PSLSubrou.getTag(),
		  PSLSubrou.getTagMax(), PSLSubrou.getTagPrefix(),
		  PSLSubrou.setTagPrefix().
		* Added code generation for PSLExpression.fitsLineLength()
		* Modified code generated for PSLTable.getFilerLogic()

	06/14/06 - Frans S.C. Witte - CRs: 21791 / 21792
		* Added code generation for PSLTable.getFilerLogic(), and
		  PSLTable.getSaveCode().

	05/31/06 - Frans S.C. Witte - CRs: 21394 / 21395
		* Added tblHasNeg to implement PSLTbale.hasNegativeNode

	03/14/06 - Frans S.C. Witte - CRs: 20280 / 18164
		* INSERT modified the #WARN adn #OPTIMIZE settings, but did not
		  restore the previous values. This has been corrected. The
		  subroutine now uses PSLLabelRecord.
		* openBuff now stores both parameters in negative vobj() nodes.

	11/17/05 - Frans S.C. Witte - CRs: 18163/18164
		* Modified to support pslSt, and dbAcc
		* Added code generation for PSL.cachePSLColumn(),
		  PSL.cachePSLTable(), PSLColumn.getClass(),
		  PSLColumn.getPurposeNode(), and PSLTable.isOneNode().
		* Rewrote INSERT (code now added to PSL source).

	08/31/05 - Frans S.C. Witte - CRs: 15592, 17056 / 15593, 17057
		* Added subroutine getPslValue to implement properties of class
		  PSL that contain system-wide, site-dependent values.
		* Added code generation for PSLTable methods: tAssert,
		  getLodCode, getNewCode, getUpdKet, tblHasBlob, tblHasMemo,
		  tblIsRdb, tblHasMasF.
		* Use of #XECUTE init^UCMATHOD now deprecated
		* Modified code generated for getCurrentNode() and getOldNode()

	05/24/05 - Frans S.C. Witte - CRs: 15028 / 16039
		* Subroutine INSERT now also NEWs struct().
		* Added subroutines getCurExpr, getOldExpr, and getUpdCode, that
		  generate code for methods of the PSLColumn class.

	03/29/05 - Frans S.C. Witte - CRs: 14919 / 14920
		* Subroutine addSubr: Added 4th parameter to indicate call to
		  $$newLabel^UCGM() as part of generating subroutine label.
		* Added subroutine isArr (implementation of PSLExprssion.isArray)
		* Added subroutine isVar (implementation of
		  PSLExprssion.isVariable)
		* Removed code that was commented out by previous CR.
		* Grouped subroutines and functions based on class.
		* Subroutine openBuff: parenthesis to formallist will be added
		  if absent.
		* Added subroutines getCurLvn, getCurNode, getOldLvn, getOldNode,
		  and getPslCln, that generate code for methods of the PSL class
		  and the PSLColumn class. These methods will not be called until
		  CR15028 is deployed.

	11/02/04 - Frans S.C. Witte - CRs: 11445 / 11446
		Removed references / assignments to primtyp(), which is now handled
		exclusively by UCPRIM module.
		Class "Subrou" renamed to "PSLSubrou".
		Subroutine init: removed "hidden" definitions of PSLBuffer and
		PSLSubrou because these classes, and their methods are now stored
		in the OBJECT related tables.
		Added subroutine addCode to implement PSLSubrou.addCode().
		Declared PUBLIC/PRIVATE accessability of subroutines.
		Removed label newBuff (it is not used).
		#optimize and #warn follow defaults, but turn function warning on.
		replaced M intrinsic function references by method calls.
		Fixed code generated for PSLSubrou.addCode.
		Replaced .data() with .exists() and .order().
		Subroutine mExpr: removed "fif" argument from code generated for
		mExpr.
		Subroutine INSERT(): Added save/restore WARN and OPTIMIZE and
		force miminal settings for generated code.
	

        05/12/04 - RussellDS - CR9676
		Move Profile04 version to Profile01 to support single code
		base for PSL.

	09/24/03 - Frank Sanchez
		Changed PSLBUffer.insert method parameter from Literal to String

        09/16/03 - Spier CR 6031,6032,6034  - arq 51423
        	Retrofit of changes made in v7.0 up to this date into Profile01
        	as well as release for v7.0
	*/
	#PACKAGE framework.psl

	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************

	// ---------------------------------------------------------------------
INSERT( Number object,	// object id		/REQ/MECH=VAL
	String subRou,		// name of subroutine	/REQ/MECH=VAL
	String resCls)		// ResultClass (*3)
	/* ---------------------------------------------------------------------
	Runtime subroutine, called to convert PSL to M and insert buffer.

	The current version of the code just appends the PSL code to the
	existing source array. In order to prevent duplicate insertions,
	endless loops, etc. it keeps track of the subroutines that it inserted:
	- set labels(subRou) = data

	ARGUMENTS:
	(*3) resCls = ResultClass
		if absent or empty, then #OPTION ResultClass will be forced
		false. Else #OPTION ResultClass will be forced true, and the
		supplied value will be prepended.
	
	NOTES:
	. The code in subRou^UCGM, and other code that uses labels() must be
		kept in sync. However, this should be relatively simple when all
		code uses PSLLableRecord to manipulate the array.	
	. This used to be very tricky code. It simulated PART of main, including
		the calls to line(), ^UCTPACH, and dbLoad^UCRECORD(), and it
		tried to recreate a clean environment. It implied that the code
		had always to be synchronized with main^UCGM() to ensure that all
		pre-conditions for line(), UCPATCH, and dbLoad^UCRECORD were met.
		It seemed that the only reason for this behavior was the ability
		to put the compiled M code into the append(,) array, that may be
		subject to manipulation by the caller's version of UCPATCH.
	. The inserted code may contain a lot of identical #OPTION ResultClass
		settings. It is tempting to "optimize" this, and only insert a
		line if the INSERT requires a different setting. However, this
		is NOT possible, because the setting may change during the
		compilation, so there is no guarantee that the setting that was
		in effect when the code was inserted will still apply when the
		code is compiled.
	. Saving the settings of #INFO, #OPTION, #OPTIMIZE, and #WARNING, and
		restoring them after inserting the PSL source, was an overkill.
		As long as all inserted PSL code follows the original PSL code,
		it is sufficient to "force" the settings that need to be in
		effect for the inserted code. The only exception is the setting
		of #OPTIMIZE OBJECTS, but this setting is not changed here.
		So the current code does not save / restore settings.
	*/
	type public String append()	// temporary use of append()
	type public PSLParser pslPrsr	// temporary use of pslPrsr(,)

	type String  decl
	type Boolean mtdResCl = '(resCls.get().isNull())
	type PSLClass ocd = pslPrsr.getPSLClass( pslPrsr.moduleName)

	if subRou.isNull() do PSL.error("Subroutine name required") quit

	/* Setting append(subRou) will serve as an indication that a subroutine
	   with this label has been appended to the PSL source code.
	   By quiting if subRou already exists, the implementation of the method
	   will silently ignore unintended duplications.
	   (The "OLD" implementation silently rewrote each previous definition)
	   */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if $$hasSubr^UCGM(subRou) quit			// insert only once
	if mtdResCl set decl = resCls_ " "_ subRou_ vobj( object, 1)
	else  set decl = subRou_ vobj( object, 1)
	if ocd.classType>-1 set:'mtdResCl decl="String "_decl set decl = "static "_decl

	set append(subRou) = 0_ 9.char()_ vobj( object, -2)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do addM2src^UCGM( " // ----------------")
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do addM2src^UCGM(" #OPTION ResultClass "_ mtdResCl)
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do addM2src^UCGM( decl)	// Insert declaration
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do addM2src^UCGM( " //")
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do addM2src^UCGM( " #WARN "_ $$allWARN^UCGMC()_ " OFF")
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do addM2src^UCGM( " #OPTIMIZE FUNCTIONS OFF")

	type Number ln = 1
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	for  set ln = vobj(object,ln).order() quit:ln.isNull()  do addM2src^UCGM( vobj(object,ln))

	quit

	// ---------------------------------------------------------------------
insMet( String prefix, Number missing)
	/* ---------------------------------------------------------------------
	Support procedure for methods that simply translate into a call to a
	function or subroutine with objectName and all supplied actuals
	("instance" method).

	ARGUMENTS:
	. prefix = call prefix.
		Will be used as supplied, and objectName will be concatenated
		without any delimiter
	. missing = treatment of missing / empty actuals
		-1: exception when no actual supplied
		0: ignore
		1: force ""
	*/
	set PSL.return = prefix_ PSL.objectName_ ","
	type Number ap

	for ap = 1:1:PSL.actual("").order(-1) do {
		if missing = -1, PSL.actual(ap).isNull() throw class.new("Error","%PSL-E-MISSING, missing required argument (#"_ap_")")
		if missing = 1, PSL.actual(ap).isNull() set PSL.actual(ap) = """"""
		if ap>1 set PSL.return = PSL.return_ ","
		set PSL.return = PSL.return_ PSL.actual(ap)
	}
	set PSL.return =  PSL.return.trim( 1, ",")_ ")"
	quit

	// ---------------------------------------------------------------------
statMet( String prefix, Number missing)
	/* ---------------------------------------------------------------------
	Support procedure for methods that simply translate into a call to a
	function or subroutine with all supplied actuals ("static" method)

	ARGUMENTS:
	. prefix = call prefix.
		Will be used as supplied, and PSL.actual(1) will be concatenated
		without any delimiter
	. missing = treatment of missing / empty actuals
		-1: exception when no actual supplied
		0: ignore
		1: force ""
	*/
	set PSL.return = prefix
	type Number ap

	for ap = 1:1:PSL.actual("").order(-1) do {
		if missing = -1, PSL.actual(ap).isNull() throw class.new("Error","%PSL-E-MISSING, missing required argument (#"_ap_")")
		if missing = 1, PSL.actual(ap).isNull() set PSL.actual(ap) = """"""
		if ap>1 set PSL.return = PSL.return_ ","
		set PSL.return = PSL.return_ PSL.actual(ap)
	}
	set PSL.return =  PSL.return_ ")"
	quit

	// ---------------------------------------------------------------------
stdCall(String prefix, String aplist())
	/* ---------------------------------------------------------------------
	Support function that appends the supplied aplist to prefix

	ARGUMENTS:
	. prefix = call prefix.
		Will be used as supplied, and aplist(1) will be concatenated
		without any delimiter
	. aplist() = actual parameters
		the function will simply add the supplied arguments as-is,
		separated by commas.
	*/
	type String ret = prefix_ aplist(1)
	type Number ap

	for ap = 1:1:ap("").order(-1) set ret = ret_ ","_ aplist(ap)
	quit ret_")"

	/* =====================================================================
	Implementation of methods and properties of class PSL
	*/
	// ---------------------------------------------------------------------
addSubr	// Method: PSL.addSubrou - Add a subroutine

	type literal String label="vaddSubr"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(String p1,String p2,String p3,Boolean p4)","PSL.addSubrou")

		do buf.add("if p4.get() set:p1.extract()'=""v"" p1=""v""_p1 set p1=$$findSubr^UCGM(p1,"""")")
		do buf.add("else  if $$hasSubr^UCGM(p1) do PSL.error(""Subroutine exists: ""_p1) quit p1")
		do buf.add("do addSubr^UCGM(p1,p2,p3)")
		do buf.add("quit p1")

		do buf.insert(label, "PSLSubrou")
	}

	// ensure that a call with 4 parameters is generated
	if PSL.actual(2).isNull()  set PSL.actual(2) = """"""
	if PSL.actual(3).isNull()  set PSL.actual(3) = """"""
	if PSL.actual(4).isNull(1) set PSL.actual(4) = 0

	set PSL.return="$$"_label_"("_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_","_ PSL.actual(4)_")"
	quit

	// ---------------------------------------------------------------------
arrayProp	// Method PSL.actual - "array property" actual()
	/* Because PSL will interpret PSL.actual(val) as a method call, this method
	is used to transform the method call to a property reference.
	Because this subroutine uses PSL.method as the "name" value, it can be
	used as the implementing method for all array properties of the PSL class.
	*/
	set PSL.return = PSL.method _ "(" _ PSL.actual(1) _")"
	quit

	// ---------------------------------------------------------------------
caPslCln	// void
	/* ---------------------------------------------------------------------
	method PSL.cachePSLColumn(PSLColumn(),String,PSLTable())

	INPUTS:
	. PSL.actual(1) = name of PSLColumn() cache array
	. PSL.actual(2) = qualified column name (table.column, dynamic value allowed)
	. PSL.actual(3) = name of PSLTable() cache array (optional)

	OUTPUTS:
	. return = code to retrieve value at runtime ($$caPslCln^UCXDD)
	*/
	if PSL.actual(3).isNull() set PSL.return = "$$caPslCln^UCXDD("_ PSL.actual(1)_","_ PSL.actual(2)_")"
	else  set PSL.return = "$$caPslCln^UCXDD("_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_")"
	quit

	// ---------------------------------------------------------------------
caPslTbl	// void
	/* ---------------------------------------------------------------------
	method PSL.cachePSLTable(PSLTable(),String,Number)

	INPUTS:
	. PSL.actual(1) = name of PSLTable() cache array
	. PSL.actual(2) = table name (dynamic value allowed)
	. PSL.actual(3) = information level (defaults to zero)

	OUTPUTS:
	. return = code to retrieve value at runtime ($$caPslTbl^UCXDD)
	*/
	if PSL.actual(3).isNull() set PSL.actual(3) = 0
	set PSL.return = "$$caPslTbl^UCXDD("_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_")"
	quit
	
	// ---------------------------------------------------------------------
checkAccessRights	// Method: PSLTable.checkAccessRights()
	/* ---------------------------------------------------------------------
	
	INPUTS:
	. PSL.actual(1) = Boolean to force check from DBACCRTS table, versus
			  trying RecordTABLE.checkAccessRights() first
	*/

	set PSL.return = "$$checkAccessRights^UCXDD("_  PSL.objectName_ ","_ PSL.actual(1)_ ")"
	quit

	// ---------------------------------------------------------------------
error	// Method: PSL.error - Report a compile-time error

	set PSL.return = "ERROR^UCGM("_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
getPslCln	// void
	/* ---------------------------------------------------------------------
	method PSL.getPSLColumn(String,String,PSLTable())

	INPUTS:
	. PSL.actual(1) = name of table (dynamic value allowed)
	. PSL.actual(2) = name of column (dynamic value allowed)
	. PSL.actual(3) = name of PSLTable() cache array ("optional")

	OUTPUTS:
	. return = code to retrieve value at runtime (getPslCln^UCXDD)
	*/
	if PSL.actual(3).isNull() set PSL.return = "$$getPslCln^UCXDD("_ PSL.actual(1)_","_ PSL.actual(2)_")"
	else  do {
		if PSL.actual(3).extract() '= "." set PSL.actual(3) = "."_ PSL.actual(3)
		set PSL.return = "$$getPslCln^UCXDD("_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_")"
	}
	quit

	// ---------------------------------------------------------------------
getPslTbl	// void
	/* ---------------------------------------------------------------------
	method PSL.getPSLTable(String,Number)

	INPUTS:
	. PSL.actual(1) = name of table (dynamic value allowed)
	. PSL.actual(2) = information level (dynamic value allowed)
		If "absent", the maximum will be used

	OUTPUTS:
	. return = code to retrieve value at runtime (getPslTbl^UCXDD1)
	NOTES:
	. The default / maximum value for PSL.actual(2) shall be synchronized with
		tAssert^UCMETHOD and tAssert^UCXDD
	*/
	if PSL.actual(2).isNull() set PSL.actual(2) = 1
	set PSL.return = "$$getPslTbl^UCXDD("_ PSL.actual(1)_ ","_ PSL.actual(2)_ ")"
	quit

	// ---------------------------------------------------------------------
getPslValue( Primitive default)	// default value (*1)
	/* ---------------------------------------------------------------------
	This subroutine generates the code for PSL properties such as
	PSL.maxStringLength and PSL.maxLineLength.

	ARGUMENTS:
	(*1) default = default value
		The definition of OBJECTPROP.ROUTINE will include the literal
		value that shall be used as default value for the property.
		The default value will be used if:
		- code is generated in compiler completion mode
			(i.e. PSL.getSetting("boot","restrictionlevel")>1)
		- the call to $$getPslValue^UCOPTS() returns ""

	INPUTS:
	. public String ref
		The name of the property is passed to $$getPslValue^UCOPTS()

	OUTPUTS:
	. PSL.return = value of constant

	NOTES:
	. The default value of the property is coded into the value of
		OBJECTPROP.ROUTINE. For example, a default value of 450 for
		PSL.maxDataLength would be coded as:
			OBJECTPROP.ROUTINE = 'getPslValue^UCMETHOD(450)'
	*/
	type public String ref

	if PSL.getSetting("boot","restrictionlevel",0)>1 set PSL.return = default
	else  set PSL.return = $$getPslValue^UCOPTS( ref) if PSL.return.isNull() set PSL.return = default
	quit

	// ---------------------------------------------------------------------
getProp	// Property procedure of class PSL

	/* Property implementation method for properties of class PSL.
	Initially all property names will be the same as the UCGM

	actual(1-n) = Actual parameters passed
	attrib(1-2) = Attributes of parameters vptr<tab>class<tab>byref
	class       = Expect return class of this method
	cmd         = current PSL command (full word, lowercase spelling)
	fset        = Flag var within assignment scope
	level       = static DO level within subRou
	mclass      = class in which method occurs
	mcode       = Current M generated code for this line
	method      = name of current method
	msrc        = line number of current line in generated M code
	objectLevel = Stack level where identifier was scoped
	objectName  = the expression (!) that represents the object
	objectVar   = non-litralized versoin of objectName
	oLvn        = Object storage array name
	postCond    = M code of postconditional for current command
	pslSt       = do/for/if "stack" (used by UCREC4OP and UCPSLST)
	pslTmpLvn   = name of temporary variable allocated by PSL
	ref         = name of current property
	return      = genereated code for method or property
	subRou      = current subroutine
	tok         = tokenized string literals
	var         = Variable return assigned to unless void
	varLevel    = Stack level where var was scoped

	NOTES:
	. once the cleanup of the compiler has limited the use of PSL.publicVar
		to the above list, the warning shall be changed into an error.
		Use of additional public variables is no longer allowed.
		If access to additional structures is needed, they shall be
		made available as "properties" of PSLParser.
	*/
	type literal List EXPS = "actual,mcode,postCond,pslTmpLvn,return"
	type literal List NUMS = "fset,level,msrc,objectLevel,varLevel"
	type literal List SIGS = "objectName,objectVar,var"
	type literal List STRS = "cmd,attrib,class,objectScope,mclass,method,oLvn,pslSt,ref,subRou,tok"
	type literal List ALLOW = EXPS_ ","_ NUMS_ ","_ SIGS_ ","_ STRS

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if $$getNew^UCGM( PSL.ref) do PSL.error("Object scope is not visible: PSL."_ PSL.ref) quit

	/* The #ACCEPT GROUP=SCOPE is needed because List.contains uses
	   PSL.mexpr, which by the time it is evalueated will contain "ref", not
	   "PSL.ref". This will not be addressed until the parser is rewritten.
	   */
	#ACCEPT GROUP=SCOPE,ACCESS;CR=27800;DATE=2007-09-04;PGM=Frans S.C. Witte
	if 'ALLOW.contains( PSL.ref) do warnGroup^UCGM("SCOPE","non-standard PSL property PSL."_ PSL.ref)

	set PSL.return = PSL.ref

	if SIGS.contains( PSL.ref)       set PSL.class="PSLIdentifier"
	else  if EXPS.contains( PSL.ref) set PSL.class="PSLExpression"
	else  if NUMS.contains( PSL.ref) set PSL.class="Number"
	else  set PSL.class="String"

	quit

	// ---------------------------------------------------------------------
isSubr	// Method: PSL.subrExists - Return whether a subroutine exists

	set PSL.return="$$hasSubr^UCGM("_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
mExpr	// PSL.mExpr(expr)
	/* ---------------------------------------------------------------------
	Return an M expression from a PSL expression.

	This is a very powerful method that allows the compiler writer to
	express the code generated for a method as a PSL expression. Programmers
	that use this method shall be aware of the following:
	When the code generator for the method
		MyClass.myMethod(Primitive Arg1, Primitive Arg2)
	will be invoked, the Myclass instance will be available in objecName,
	and the arguments will be available in actual(1) and actual(2). Due to
	the nature of the compiler, all these entities will no longer contain
	PSL code, but will instead contain the "pass 1 code" that the compiler
	generated for each of these entities. To prevent these entities from
	being interpreted during the evaluation of the PSL expression, the
	entities that are inserted in the argument to PSL.mExpr() must be
	wrapped before they are inserted into the code. And they must be
	unwrapped from the value returned by PSL.mExpr() before being returned
	in PSL.return.

	A typical implementation of a code generator that uses PSL.mExpr will
	then read:
	myMethod // method with 2 actuals

		type String mExpr = "psl code"_  $$tokenPush^UCPATCH( PSL.objectName, "objectClass")
		set mExpr = mExpr_ "more psl code"_ $$tokenPush^UCPATCH( PSL.actual(1), "agr1Class")
		set mExpr = mExpr_ "and more psl code"_ $$tokenPush^UCPATCH( PSL.actual(2), "arg2Class")
	
		set mExpr = PSL.mExpr( mExpr )

		set PSL.return = $$tokenPop^UCPATCH( mExpr, 3)

		quit
	*/
	type literal String label="vMExpr"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(String v1)","PSL.mExpr")

		do buf.add("type String vExp,mcode,tok")	// 'tok' and 'mcode' used as public var by $$valExpr !!!!
		do buf.add("type Boolean vDep=PSL.getSetting(""WARN"",""DEPRECATED"",0)")
		do buf.add("type Boolean vMis=PSL.getSetting(""WARN"",""MISMATCH"",0)")
		do buf.add("type Boolean vFun=PSL.getSetting(""OPTIMIZE"",""FUNCTIONS"",0)")
		do buf.add("do PSL.addSetting(""WARN"",""DEPRECATED"",0)")
		do buf.add("do PSL.addSetting(""WARN"",""MISMATCH"",0)")
		do buf.add("do PSL.addSetting(""OPTIMIZE"",""FUNCTIONS"",0)")
		do buf.add("set mcode="""",v1=$$TOKEN^%ZS(v1,.tok),vExp=$$valExpr^UCGM(v1,,0)")
		do buf.add("do PSL.addSetting(""WARN"",""DEPRECATED"",vDep)")
		do buf.add("do PSL.addSetting(""WARN"",""MISMATCH"",vMis)")
		do buf.add("do PSL.addSetting(""OPTIMIZE"",""FUNCTIONS"",vFun)")
		do buf.add("quit vExp")

		do buf.insert(label, "String")
	}

	set PSL.return="$$"_label_"("_ PSL.actual(1)_")"

	quit

	// ---------------------------------------------------------------------
newVar	// PSL.newVariable

	set PSL.return = "$$nxtSym^UCGM"
	quit

	// ---------------------------------------------------------------------
patch	// PSL.patch(String expression) - Replace expression with 

	set PSL.return="$$patch^UCPATCH(subRou,objectName,objectLevel,"_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
warn	// Method PSL.warn - Report a compile-time warning

	set PSL.return="WARN^UCGM("_ PSL.actual(1)_")"
	quit


	/* =====================================================================
	Implementation of methods of class PSLBuffer

	PSLBuffer uses the following structure:
	vobj(oid,-3) = comment (cmt)
	vobj(oid,-2) = formal parameter list (fpl)
	xvobj(oid,1)  = fpl_ " // "_ cmt

	*/
	// ---------------------------------------------------------------------
openBuff	// Method: PSL.openBuffer - Open a PSL code buffer
	/* ---------------------------------------------------------------------
	NOTES:
	. This subroutine uses PSLBuffer to generate PSL code that accesses the
		vobj() array. This is wrong from a modeling perspective because
		the vobj() array is the M implementatation of PSL objects. No
		PSL code shall directly reference the variable vobj.
		This code must be rewritten to use PSLSubrou, which generates M
		code and is allowed / incurred to access vobj.
	*/
	type literal String label="vopenBuf"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(String v1,String v2)","PSL.openBuffer")

		do buf.add("type public String vobj(,)")
		do buf.add("type Number vOid")
		do buf.add($$cdNewObj^UCCLASS("vOid","""PSLBuffer"""))
		do buf.add("if v1.extract()'=""("",'v1.isNull() set v1=""(""_v1_"")""")
		do buf.add("set vobj(vOid,-2)=v1")
		do buf.add("set vobj(vOid,-3)=v2")
		do buf.add("set vobj(vOid,1)=v1_"" // ""_v2")
		do buf.add("quit vOid")

		do buf.insert(label, "PSLBuffer")
	}

	set PSL.return="$$"_label_"("_ PSL.actual(1)_","_ PSL.actual(2)_")"

	quit

	// ---------------------------------------------------------------------
addBuff	// Method: PSLBuffer.add - Add code to an existing buffer
	/* ---------------------------------------------------------------------
	NOTES:
	. This subroutine uses PSLBuffer to generate PSL code that accesses the
		vobj() array. This is wrong from a modeling perspective because
		the vobj() array is the M implementatation of PSL objects. No
		PSL code shall directly reference the variable vobj.
		This code must be rewritten to use PSLSubrou, which generates M
		code and is allowed / incurred to access vobj.
	*/
	type literal String label="vaddBuff"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(Number object,String p1)","PSLBuffer.add")

		do buf.add("type public String vobj(,)")
		do buf.add("type Number line")
		do buf.add("set line=vobj(object,"""").order(-1)+1")
		do buf.add("set vobj(object,line)="" ""_p1")
		do buf.add("quit")

		do buf.insert(label, "void")
	}

	set PSL.return=label_"(" _ PSL.objectName_","_ PSL.actual(1)_")"

	quit

	/* =====================================================================
	Implementation of methods and properties of class PSLColumn
	*/
	// ---------------------------------------------------------------------
getPcClass	// Method: PSLColumn.getClass()

	set PSL.return="$$getClass^UCXDD("_ PSL.objectName_ ")"
	quit

	// ---------------------------------------------------------------------
getCurExpr	// Method: PSLColumn.getCurrentExpr(PSLIdentifier,Boolean)

	if PSL.actual(2).isNull() set PSL.actual(2) = 0
	set PSL.return="$$getCurExpr^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
	quit

	// ---------------------------------------------------------------------
getCurLvn	// Method: PSLColumn.getCurrentLvn(PSLIdentifier)

	set PSL.return="$$getCurLvn^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
getCurNode	// Method: PSLColumn.getCurrentNode(Boolean)

	if PSL.actual(1).isNull(1) set PSL.actual(1) = 0
	set PSL.return="$$getCurNode^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
getOldExpr	// Method: PSLColumn.getOldExpr(PSLIdentifier,Boolean)

	if PSL.actual(2).isNull() set PSL.actual(2) = 0
	set PSL.return="$$getOldExpr^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
	quit

	// ---------------------------------------------------------------------
getOldLvn	// Method: PSLColumn.getOldLvn(PSLIdentifier)

	set PSL.return="$$getOldLvn^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
getOldNode	// Method: PSLColumn.getOldNode(Boolean)

	if PSL.actual(1).isNull(1) set PSL.actual(1) = 0
	set PSL.return="$$getOldNode^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
getPurNode	// Method: PSLColumn.getPurposeNode()

	set PSL.return="$$getPurNode^UCXDD("_ PSL.objectName_ ")"
	quit

	// ---------------------------------------------------------------------
getUpdCode	// Method: PSLColumn.getUpdateCode(PSLIdent,PSLExpr,Number,Number)

	if PSL.actual(3).isNull() set PSL.actual(3) = 1	// default: PSL audit
	if PSL.actual(4).isNull() set PSL.actual(4) = 0	// default: in-line update
	set PSL.return="$$getUpdCode^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_","_ PSL.actual(4)_")"
	quit

	/* =====================================================================
	Implementation of methods of class PSLExpression
	*/
	// ---------------------------------------------------------------------
fitsLinLen	// Method: PSLExpression.fitsLineLength( Number extra)
	/* ---------------------------------------------------------------------
	This method will cast the PSLExpression as a ByteString, and return 1 if
	and only if the (byte) length of the PSLExpression is not greater than
	the maximum line length minus the value of extra.

	PSLExpression.fitsLineLength( ) is equivalent to
		PSLExpression.fitsLineLength( 0)
	*/
	type PSLExpression xtr
	type Number pop = 1

	if PSL.actual(1).isNull(1) set xtr = ""
	else  if PSL.actual(1) = 0 set xtr = ""
	else  {
		set xtr = $$tokenPush^UCPATCH( PSL.actual(1), "Number"), pop = 2
		if PSL.actual(1).translate("*/\#") = PSL.actual(1) set xtr = "+"_ xtr quit
		set xtr = "+("_ xtr_ ")"
	}

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "(("_ $$tokenPush^UCPATCH( PSL.objectName, "PSLExpression")_ ").toByteString().length() "_ xtr_ "'> PSL.maxLineLength)"), pop)
	quit

	// ---------------------------------------------------------------------
isArr   // Method: PSLExpression.isArray

	set PSL.return="$$isArr^UCGM("_ PSL.objectName_")"
	quit

	// ---------------------------------------------------------------------
isLit   // Method: PSLExpression.isLiteral
	/* ---------------------------------------------------------------------
	Overrides String.isLiteral. Unlike its ancestor method, this method will
	not interpret the compiletime value.
	*/

	set PSL.return="$$isLit^UCGM("_ PSL.objectName_")"
	quit

	// ---------------------------------------------------------------------
isVar   // Method: PSLExpression.isVariable

	set PSL.return="$$isVar^UCGM("_ PSL.objectName_")"
	quit

	// ---------------------------------------------------------------------
toConsta	// Method PSLExpression.toValue

	set PSL.return="$$toLit^UCGM("_ PSL.objectName_")"
	quit


	/* =====================================================================
	Implementation of methods of class PSLIdentifier
	*/
	// ---------------------------------------------------------------------
getSym(Number pos)	// PSLIdentifier properties
	/* Return the code to retrieve one of the properties of a PSLIdentifier.
	The mapping of propertyname to position is hard-coded in the value of
	OBJECTPROP.ROUTINE for the property.
	*/
	if PSL.fset do PSL.error("Identifier table properties are read only")

	type String keys=PSL.objectName
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if keys.beginsWith("vo") set keys=$$getExpr^UCGM(keys)

	if keys="objectName" set keys="objectName,objectLevel"
	else  if keys="var" set keys="var,varLevel"
	else  set keys=keys_","

	set PSL.return="$$getAtt^UCGM("_keys_","_pos_")"

	quit

	// ---------------------------------------------------------------------
getLevel	// PSLIdentifier.scopeLevel property

	type String var=PSL.objectName
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if var.beginsWith("vo") set var=$$getExpr^UCGM(var)

	set PSL.return="$$getLevel^UCGM("_var_")"
	quit

	// ---------------------------------------------------------------------
opti	// Method: PSLIdentifier.allowOptimize - Allow backfill optimize

	type literal String label="vPSLopti"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(String var)","PSLIdentifier.optimize()")

		do buf.add("type public Integer msrc")
		do buf.add("type Integer varLevel=$$getLevel^UCGM(var)")
		do buf.add("type Integer opti=+$$getAtt^UCGM(var,varLevel,10)")
		do buf.add("if opti>msrc set opti=0 do setOpti^UCGM(var,varLevel,0)")
		do buf.add("quit opti=0")

		do buf.insert(label, "Boolean")
	}
 
 	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set PSL.return="$$"_label_"("_ PSL.objectName_ ")"
	quit


	/* =====================================================================
	Implementation of methods of class PSLSubroutine
	*/
	// ---------------------------------------------------------------------
addCode	// Method: PSLSubroutine.addCode - add a line of code
	/* INPUTS:
	. PSL.actual(1) = code to add
	
	RETURNS:
	. PSL.return = addCode^UCPSLSR( PSL.objectName, PSL.actual(1))
	*/
	set PSL.return = "addCode^UCPSLSR("_ PSL.objectName_ ","_ PSL.actual(1)_ ")"
	quit

	// ---------------------------------------------------------------------
addExe	// Method: PSLSubroutine.addExe - add a line from exe() to code
	/* INPUTS:
	. PSL.actual(1) = code to add
	
	RETURNS:
	. PSL.return = addExe^UCPSLSR( PSL.objectName, PSL.actual(1))
	*/
	set PSL.return = "addExe^UCPSLSR("_ PSL.objectName_ ","_ PSL.actual(1)_ ")"
	quit

	// ---------------------------------------------------------------------
addLvn	// Method: PSLSubroutine.addLvn - add vsql() replacement

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set PSL.mcode = $$backup^UCGM( PSL.mcode)
	set PSL.return=" S"_ PSL.postCond_" append("_ PSL.objectName_ ",-3,"_ PSL.actual(1)_ ")="_ PSL.actual(2)
	quit

	// ---------------------------------------------------------------------
addTag	// Method: PSLSubroutine.addTag - add tag to append(,-2)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set PSL.mcode = $$backup^UCGM( PSL.mcode)
	if PSL.actual(2).isNull() set PSL.actual(2) = """"""
	set PSL.return=" S"_ PSL.postCond_" append("_ PSL.objectName_ ",-2,"_ PSL.actual(1)_")="_ PSL.actual(2)
	quit

	// ---------------------------------------------------------------------
getCode	// Method: PSLSubroutine.getCode - return the code on a line

	set PSL.return="$G(append("_ PSL.objectName_","_ PSL.actual(1)_"))"
	quit

	// ---------------------------------------------------------------------
getLine	// Method: PSLSubroutine.getline - return the current line

	set PSL.return="$O(append("_ PSL.objectName_",""""),-1)"
	quit
	
	// ---------------------------------------------------------------------
getLogging	// Method: PSLTable.getLogging()
	/* ---------------------------------------------------------------------
	
	INPUTS:
	. PSL.actual(1) = Boolean to force check from DBAUDITDEF table, versus
			  trying RecordTABLE.logging() first
	*/

	set PSL.return = "$$getLogging^UCXDD("_  PSL.objectName_ ","_ PSL.actual(1)_ ")"
	quit

	// ---------------------------------------------------------------------
getLvn	// Method: PSLSubroutine.getLvn - return vsql() substitution value

	set PSL.return="$G(append("_ PSL.objectName_",-3,"_ PSL.actual(1)_ "))"
	quit

	// ---------------------------------------------------------------------
getLvnMax	// Method: PSLSubroutine.getLvnMax - highest number used

	set PSL.return="+$O(append("_ PSL.objectName_",-3,""""),-1)"
	quit

	// ---------------------------------------------------------------------
getName	// Method: PSLSubroutine.getName - name of subroutine
	/* ---------------------------------------------------------------------
	With the current implementation of PSLSubrou, the instance variable
	contains the name of the subroutine, and this name will be used as the
	first level subscript into append(,).
	This is likely to change as part of the cleanup of the PSL* classes.
	*/
	set PSL.return = PSL.objectName
	quit

	// ---------------------------------------------------------------------
getTag	// Method: PSLSubroutine.getTag - return the tag for exe(nr)
	/* ---------------------------------------------------------------------
	INPUTS:
	. PSL.actual(1) = subscript in exe()
	
	RETURNS:
	. PSL.return = getTag^UCPSLSR( PSL.objectName, PSL.actual(1))
	*/
	set PSL.return = "$$getTag^UCPSLSR("_ PSL.objectName_ ","_ PSL.actual(1)_ ")"
	quit

	// ---------------------------------------------------------------------
getTagMax	// Method: PSLSubroutine.getTagMax - highest TAG number used

	set PSL.return="+$O(append("_ PSL.objectName_",-2,""""),-1)"
	quit

	// ---------------------------------------------------------------------
getTagPrefix	// Method: PSLSubroutine.getTagPrefix - prefix used by addExe()

	set PSL.return="$G(append("_ PSL.objectName_ ",-2))"
	quit

	// ---------------------------------------------------------------------
insCode	// Method: PSLSubroutine.insCode - Insert code at line

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set PSL.mcode = $$backup^UCGM( PSL.mcode)
	set PSL.return=" S"_ PSL.postCond_" append("_ PSL.objectName_","_ PSL.actual(1)_")="_ PSL.actual(2)
	quit

	// ---------------------------------------------------------------------
setTagPrefix	// Method: PSLSubroutine.getTagPrefix - prefix used by addExe()

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set PSL.mcode = $$backup^UCGM( PSL.mcode)
	set PSL.return=" S"_ PSL.postCond_" append("_ PSL.objectName_ ",-2)="_ PSL.actual(1)
	quit

	/* =====================================================================
	Implementation of methods and properties of class PSLTable
	*/
	// ---------------------------------------------------------------------
tAssert	// Method: PSLTable.assertLevel(Number,PSLColumn())
	/* ---------------------------------------------------------------------
	method PSLtable.assertLevel(Number,PSLColumn())

	INPUTS:
	. PSL.actual(1) = information level (dynamic value allowed)
		If "absent", the maximum will be used
	. PSL.actual(2) = PSL Column cache.
		Allows to cache PSLColumn instances that are retrieved for
		information levels greater than zero.

	OUTPUTS:
	. return = code to retrieve value at runtime (tAssert^UCXDD)
	NOTES:
	. The default / maximum value for actual(1) shall be synchronized with
		getPslTbl^UCMETHOD and tAssert^UCXDD
	*/
	if PSL.actual(1).isNull() set PSL.actual(1) = 1
	if PSL.actual(2).isNull() set PSL.return = "$$tAssert^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_")"
	else  set PSL.return = "$$tAssert^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
	quit

	// ---------------------------------------------------------------------
getArchivable	//Method: PSLTable.getArchivable()

	if (PSL.getSetting("boot","restrictionlevel") = -1) ! Runtime.isRdb set PSL.return = "0" quit
	set PSL.return = "$$getArchivable^DBARCHIVE("_  PSL.objectName_")"
	quit
	
	// ---------------------------------------------------------------------
getArchiveIncluded	//Method: PSLTable.getArchiveIncluded()

	if (PSL.getSetting("boot","restrictionlevel") = -1) ! Runtime.isRdb set PSL.return = """""" quit
	set PSL.return = "$$getArchiveIncluded^DBARCHIVE("_  PSL.objectName_")"
	quit
	
	// ---------------------------------------------------------------------
getArchiveKey	//Method: PSLTable.getArchiveKey(Boolean)

	if (PSL.getSetting("boot","restrictionlevel") = -1) ! Runtime.isRdb set PSL.return = "0" quit
	if PSL.actual(1).isNull() set PSL.actual(1) = 0
	set PSL.return = "$$getArchiveKey^DBARCHIVE("_  PSL.objectName_","_ PSL.actual(1)_")"
	quit
	
	// ---------------------------------------------------------------------
getArchiveSubs	//Method: PSLTable.getArchiveSubs()

	if (PSL.getSetting("boot","restrictionlevel") = -1) ! Runtime.isRdb set PSL.return = """""" quit
	set PSL.return = "$$getArchiveSubs^DBARCHIVE("_  PSL.objectName_")"
	quit
	
	// ---------------------------------------------------------------------
getArchiveTable	//Method: PSLTable.getArchiveTable()

	if (PSL.getSetting("boot","restrictionlevel") = -1) ! Runtime.isRdb set PSL.return = """""" quit
	set PSL.return = "$$getArchiveTable^DBARCHIVE("_  PSL.objectName_")"
	quit
	
	// ---------------------------------------------------------------------
getChildren	// Method: PSLTable.getChildren()

	set PSL.return = "$$getChildren^UCXDD("_  PSL.objectName_")"
	quit

	// ---------------------------------------------------------------------
getExisCode	// Method: PSLTable.getExistsCode(PSLIdentifier,String())

	set PSL.return = "$$getExisCode^UCXDD("_  PSL.objectName_","_ PSL.actual(1)
	if 'PSL.actual(2).isNull() set PSL.return = PSL.return_","_ PSL.actual(2)
	set PSL.return = PSL.return_")"
	quit
	
	// ---------------------------------------------------------------------
getFlrLgc	// Method: PSLTable.getFilerLogic(String,Boolean())

	if PSL.actual(3).isNull() set PSL.actual(3) = 0
	set PSL.return = "$$getFlrLgc^UCXDD("_  PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_")"
	quit

	// ---------------------------------------------------------------------
getInitCode	// Method: PSLTable.getInitCode(PSLIdentifier,Boolean)

	set PSL.return = "$$getInitCode^UCXDD("_  PSL.objectName_ ","_ PSL.actual(1)_ ","_ PSL.actual(2)_ ")"
	quit

	// ---------------------------------------------------------------------
getLodCode	// Method: PSLTable.getLoadCode()
	/* ---------------------------------------------------------------------
	ACTUALS:
	. 1 PSLIdentifier recInst
	. 2 String node
	. 3 Number mode
	. 4 Boolean bExists
	. 5 PSLIdentifier lvpm()	/NOREQ
	None of the required actual() values has a default value.
	*/
	set PSL.return = "$$getLodCode^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)
	set PSL.return = PSL.return_","_ PSL.actual(3)_","_ PSL.actual(4)
	if 'PSL.actual(5).isNull() set PSL.return = PSL.return_","_ PSL.actual(5)
	set PSL.return = PSL.return_")"
	quit

	// ---------------------------------------------------------------------
getNewCode	// Method: PSLTable.getNewCode(PSLIdentifier,PSLExpression,Boolean)

	if PSL.actual(3).isNull() set PSL.actual(3) = "0"
	set PSL.return = "$$getNewCode^UCXDD("_  PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_")"
	
	quit
	
	// ---------------------------------------------------------------------
getNewMethodCode	// Method: PSLTable.getNewMethodCode(String)

	set PSL.return = "$$getNewMethodCode^UCXDD("_  PSL.objectName_","_ PSL.actual(1)_")"
	quit
	
	// ---------------------------------------------------------------------
getPrimaryKeyWhere	// Method: PSLTable.getPrimaryKeyWhere()

	set PSL.return = "$$getPrimaryKeyWhere^UCXDD("_  PSL.objectName_")"
	quit
	
	// ---------------------------------------------------------------------
getQuery	// Method: PSLTable.getQuery()

	set PSL.return = "$$getQuery^UCXDD("_  PSL.objectName_")"
	quit
	
	// ---------------------------------------------------------------------
getSavCode	// Method: PSLTable.getSaveCode()
	/* ---------------------------------------------------------------------
	ACTUALS:
	. 1 PSLIdentifier recInst
	. 2 String node
	. 3 Number mode
	. 4 PSLIdentifier lvpm()	/NOREQ
	. 5 PSLColumn rdbCol()		/NOREQ
	None of the required actual() values has a default value.
	*/
	set PSL.return = "$$getSavCode^UCXDD("_ PSL.objectName_","_ PSL.actual(1)
	set PSL.return = PSL.return_","_ PSL.actual(2)_","_ PSL.actual(3)
	if 'PSL.actual(4).isNull()!'PSL.actual(5).isNull() set PSL.return = PSL.return_","_ PSL.actual(4)
	if 'PSL.actual(5).isNull() set PSL.return = PSL.return_","_ PSL.actual(5)
	set PSL.return = PSL.return_")"
	quit

	// ---------------------------------------------------------------------
getUpdKey	// Method: PSLTable.getUpdateKey(PSLIdentifier,String())

	set PSL.return = "$$getUpdKey^UCXDD("_  PSL.objectName_","_ PSL.actual(1)
	if 'PSL.actual(2).isNull() set PSL.return = PSL.return_","_ PSL.actual(2)
	set PSL.return = PSL.return_")"
	quit
	
	// ---------------------------------------------------------------------
isParent	// Method: PSLTable.isParent()

	set PSL.return = "$$isParent^UCXDD("_  PSL.objectName_")"
	quit
	
	// ---------------------------------------------------------------------
isOneNode	//Method: PSLTable.isOneNode()

	set PSL.return = "$$isOneNode^UCXDD("_  PSL.objectName_")"
	quit

	// ---------------------------------------------------------------------
tblHasBlob	// property PSLTable.hasBlob: Return 1 if table has Blob

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "("_ $$tokenPush^UCPATCH( PSL.objectName, "PSLTable")_ ".dataTypes[""B"")"), 1)
	quit

	// ---------------------------------------------------------------------
tblHasMemo	// property PSLTable.hasMemo: Return 1 if table has Memo

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "("_ $$tokenPush^UCPATCH( PSL.objectName, "PSLTable")_ ".dataTypes[""M"")"), 1)
	quit

	// ---------------------------------------------------------------------
tblHasNeg	// property PSLTable.hasNegativeNode: Return 1 if table has node with negative subscript

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "("",""_"_ $$tokenPush^UCPATCH( PSL.objectName, "PSLTable")_ ".nodeQuotedList["",""""v"")"), 1)
	quit

	// ---------------------------------------------------------------------
tblIsRdb	// property PSLTable.isRdb: 1 if table stored in RDB
	/* ---------------------------------------------------------------------
	The generated code uses the values of the "literals" DQINT and SEP.
	As long as PSL does nopt support "global literals", the definition of
	this literal shall be coordinated with the values in UCXDD.
	*/
	type literal String SEP = "|"
	type literal String DQINT = "GTM"

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "("_ $$tokenPush^UCPATCH( PSL.objectName, "PSLTable")_ ".database'="""_DQINT_""")"), 1)
	quit

	// ---------------------------------------------------------------------
tblHasMasf	// property PSLTable.hasMasterfield: Return 1 table has Masterfields

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "'"_ $$tokenPush^UCPATCH( PSL.objectName, "PSLTable")_ ".masterfieldList.isNull()"), 1)
	quit
 #OPTION ResultClass ON
public String vSIG()	quit "61537^29763^Frans S.C. Witte^48487"	// Signature - LTD^TIME^USER^SIZE
