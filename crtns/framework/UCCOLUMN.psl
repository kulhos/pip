	/*
	DESC: Library of Column methods - DD Group
 
	KEYWORDS:     DATABASE 

	---- Comments ----------------------------------------------------------
	This unit implements the methods and properties of class Column,
	including references and assignments to Record.column.

	Subroutines generated by this unit will use the class-specific prefix
	"vCo".

	---------- Revision History --------------------------------------------
	2008-11-06, Frans S.C. Witte, CR 35741/36952
		* Removed getKey() because it is no longer called.
		* Modified colProp to support underscore in quoted column name

	08/22/2008 - RussellDS - CR30801
		Modified dynamic to use the 'external' parameter
	
	11/13/2007 - RussellDS - CR29295
		* Modified calls to method getUpdateCode to add new parameter for
		  RdbCodeForm.
		* Major changes related to column indirection code - modified to
		  always use ^DBSDYNRA, which already incorporates all the 
		  necessary get/set logic at runtime.  Modified dynamic to
		  support this, removing considerable code no longer necessary.
		  Eliminated labels dynKey, dynLd, dynLdBM, dynGet, and dynSet.
	
	10/12/07 - Frans S.C. Witte / Kevin Braun - CR: 27800
		* Added support for Column.method().
		* Replaced commands(,) references by PSL.getSetting(,,).
		* Replaced new-statement in generated PSL code with
		  type-statement.
		* Replaced 'public' by 'ret' in fp declarations.
		* Changed PSLSubrou.toString() to PSLSubrou.getName().

	10/11/07 - Frans S.C. Witte - CR 29729
		* Column assignment under postconditional now reports a compile-
		  time exception
		* When column audit is forced, needVobj is now set as well.

	05/03/07 - Frans S.C. Witte - CRs: 26334
		Curval(): lvn table is now initialized before calling $$colProp
		because the individual column properties need the table name,
		and no other code provides that.

	01/08/07 - Frans S.C. Witte - CRs: 24800 / 24803
		Method dynSet(): Corrected code that generates -150 assignment
		of key columns for vCoIndN.

	10/19/06 - Frans S.C. Witte - CRs: 23841 / 23842
		Added InstMode parameter in call to $$insByOvs^UCREC4OP

	09/15/06 - Frans S.C. Witte - CRs 22719 / 20613
		* Modified dynKey and DynSet to deal with new -150 layout
		* Modified colProp to recognize record assign mode = 1
		* All calls to %DBAPI now pass 0 (zero) instead of "" for vIndex

	07/11/06 - Frans S.C. Witte - CRs: 22720 / 22274
		* Added nCase parameter in calls to $$opGet^UCXOBJ()
		* Removed comment about use of #BYPASS in this unit. All
		  (remaining) code is now PSL.

	06/12/06 - Frans S.C. Witte - CRs: 22060 / 22061
		* Replaced $C(255) by LEFTEXMARK
		* replaced calls to $$bldgbl() by calls to $$getGbl^UCXDD() and
		  removed function $$bldgbl().
		* Replaced PSL.maxLineLength by PSLExpression.fitsLineLength()

	06/07/06 - Frans S.C. Witte - CRs: 21394 / 21395
		* dynLd: Added code to load negative nodes

	03/30/06 - Frans S.C. Witte - CRs: 20280 / 18164
		* Added $$longGet() and $$longSet() to deal with "long"
		  retrievals and assignments.
		* Modified dynamic() to consider PSLTable.indexList to force
		  bAudit
		* Modified curVal to turn optimize off for RDB and MDB because
		  -100 tree exhibits same behavior as -150 tree.

	03/07/06 - Frans S.C. Witte - CRs: 19821 / 18164
		* Dynamic column access is now noted as an instantiation by
		  parameter passing.
		* scope warning now uses SCOPE: as recognizable prefix.
		* %PSL-E-ABSTRACT changed to %PSL-E-DYNAMIC ("dynamic" record vs
		  "abstract" record).

	02/04/06 - Frans S.C. Witte - CRs: 18163 / 18164
		* Added support for dbAcc() structure
		* Added $$litVal() to deal with literal column retrievals that
		  are DBI for all tables (not just for CUVAR).
		* Subroutine colProp: removed .type() as actual parameter in
		  call to $$property^UCGM().
		* All subroutines that are no longer called have been moved to
		  ZUCDBLOAD.proc
		* Code that referenced ^OBJECT moved to UCXOBJ.

	02/03/06 - Pete Chenard - CR19388
		* Modified Dynamic section to put quotes around vOid
		  reference.

	01/20/06 - Frans S.C. Witte - CRs: 19157 / 19158
		* dynamic(): PSLTable cache entry no longer required (was not
		  available when called from overlay^UCRECORD), and added
		  support for Dynamic Record instance (through ^DBSDYNRA).
		* dynGet(): Code generated for computed column retrieval now
		  passes "vOid" to ^UCXDD (numeric value has special meaning!)

	12/23/05 - Frans S.C. Witte - CRs: 18727 / 18728
		* Column indirection now also accepts uppercase name
		* Added vobj(rec,-100,"0*")="" for recordType=11
		* All setOpti^UCGM() calls set value to -1 to prevent optimize
		  after re-instantiation

	10/07/05 - Frans S.C. Witte - CRs: 15592 / 15593
		* Corrected code used in -100 tree for keys
		* Synchronized use of PSLColumn.getOldNode() with correction in
		  UCXDD.
		* Replaced this. by PSL., and removed #XECUTE
		* Replaced pslSchCln() by pslCln(), and pslSchTbl() by pslTbl().

	06/24/05 - Frans S.C. Witte - CR16346
		* Fixed computed column retrieval in indirection for RDB. Both
		  MDB and RDB now recursively call the indirect column retrieval
		  subroutine.
		* Fixed optimize problem of MDB masterfields, and of MDB
		  subfield assignments.
		* Subroutine GETCMP "#IF"-ed out (no longer called).
		* Added $$getPslCln() to cache PSLColumn in pslSchCln()
		* Corrected error in dynLd.
		* Corrected $$bldgbl (when table has no keys)
		* Corrected dynamic to include assignment of vTyp if fset
		  (independent of bAudit)
		* modified dynLdBM/dynSet to use vobj(vOid,1,1) for type 1 table
		* modified dynSet to use new structure of -100 tree

	05/16/05 - Frans S.C. Witte - CRs: 15028 / 16039
		* Started migration to PSL. Subroutines ET, des, len, typ, req,
		  key, journal, and getKey() "converted" to PSL.
		* Code for curVal(), dbHist, dynamic(), and setProperty()
		  completely rewritten.
		* $$rdb^UCDB() changed to $$rdb^UCDBRT() (5 occurrences)
		* Changed ERROR^UCGM(.RM) to ERROR^UCGM($G(RM))
		* Removed code commented out for earlier CRs.
		* Removed append(), computed(), getBmType(), master()
		* PSLTable pslSchTbl() and PSLColumn pslSchCln() are now
		  used for table / column properties.

	03/07/05 - Pete Chenard - CR15314
		* Modified Dynamic section to only generate code for subfields
		  if on an M environment.  Because there are no subfields
		  in relational databases, this code should treat those columns
		  like normal non-subfields.

		* Also in the dynamic section, modified code to set variable 'nul'
		  to prevent undefined errors when running on relational database.

	02/10/05 - Pete Chenard - 14457
		* Modified Dynamic section to correctly set level -100
		  when on an RDB.  Prior to this change the code was setting
		  up level -100 with the name of the columns on Oracle, not
		  the DQ name.

	02/01/05 - GIRIDHARANB - CR13233
		* Modified section oldval to setup the rdb position and nod.

	01/13/05 - Pete Chenard - CR13233
		* Modified Dynamic section to always define variable typ at runtime
		  and to not New column sine it is passes in as a parameter.

	01/05/05 - Frans S.C. Witte - CRs: 13403 / 13404
		* Modified "INVALIDREF" to "%PSL-E-INVALIDREF" (2 occurrences).
		* Modified subroutines dynamic(), oldVal, readCol, and setSfd to
		  correct and standardize the handling of subfield columns.
		* Inserted QUIT before first subroutine of this routine.
		* Inserted function $$getBmType()
		* Subroutine dynamic(): renamed isTYP to bBM, and redefined its
		  use to contain the value of $$getBmType(). Eliminated variable
		  'znode'.
		* Subroutine setCol: replaced isTYP by bBM and eliminated all
		  references to 'znode' (which would be undefined at runtime).
		* Replaced append^UCCOLUMN() by append().

	11/02/04 - Frans S.C. Witte - CRs: 12994 / 12995
		Modified subroutine curVal() to add additional parameter in call
		to $$GETSUB^UCSTRING(). This is only a "partial fix". The code
		generated to handle subfields is inconsistent and limited. This
		CR ensures that "direct retrievals" (i.e. without column
		indirection) will work for all possible subfield definitions.
		The change to UCSTRING also ensures that "direct assignment" will
		generate the correct code. However, auditing changes to subfields
		(including access to subfiled.oldval) is still a problem.

	10/12/04 - GiridharanB - CR12092
		Modified section curVal to retain the rdb position for Memos and
		Blobs. Also modified section Dbhist to alter the nod value being 
		set if on a rdb.

	09/02/04 - Frans S.C. Witte - CRs: 10622 11702 11717 / 10575 11703
		Subroutine setDb(): Added formal parameter that indicates
		whether load shall occur after or before the "current line".
		Subroutine curVal(): added additional parameter to setDb() call.
		Subroutine dynamic(): turn off object optimization when column
		indirection is detected. Ensure that generated code NEWs all its
		local variables. Added code to skip loading when node has already
		been loaded. Variable 'rdb' is NEWed and initialized inside this
		subroutine because the subroutine is called by UCRECORD as well.
		Subroutine dbHist(): include generating code that sets node
		vobj(oid,-100,sub) (in addition to vobj(oid,-100,sub,colname)).

	06/04/04 - CHENARDP/GIRIDHARANB - CR9217
		     Fixed section curVal to set level -150 at the 
		     beginning of the line and section setCol to correct 
		     errors with Indirection support for rdb

	05/12/04 - RussellDS - CR9676
		     Move Profile04 version to Profile01 to support single code
		     base for PSL.

	03/29/04 - RussellDS - CR9172
		     Integrate changes as part of move of filers to PSL.

		     Added coding to support Profile01 CR1390.  This modifies
		     the dbHist section.

		     NOTE that support for CR1390 is not yet fully implemented.
		     This change just brings PSL in line across the versions.

	02/02/04 - FSANCHEZ/KELLYP - 7813
		     Fixed database loading error caused by numeric bottom key
		     and error in setDb which caused database loading code to 
		     precede object instantiation in some nested blocks.  Also 
		     changed structure of dbLoad for for Memo and Blob to better
		     comply with dataflow optimization in UCRECORD.  Also removed
		     pre-2003 history.
 
	01/14/03 - SPIER 7240
		     Fixed code review items:
			1) nul newed twice in dynamic section
			2) dynamic misspelled in previous revision notes

	12/11/03 - Spier 7240
		     Modification to dynamic and setCol section to deal with memo/blobs 
		     when a literal key is part of the key structure on rec type 11's
	
	11/03/03 - Spier 51640
		     Corrected coding related to memo and blobs for indirection
		     as well as normal sets. If the node is null, the node could
		     not be two levels deep in the db because of existing data.

	10/29/03 - GIRIDHARANB - 51637
		     Made minor fixes to correct -150 level setup for rdb .also
		     nulled the value of sfd for rdb

	09/05/03 - Spier - 6031,6032,6034 arq 51640
		     Retrofitted v7.0 version back to Profile01 one more time

	09/04/03 - Spier 51640
		     Correct auditflag check for indirection calls

	08/18/03 - Spier 51423
		     Modifications to handle sub-fields properly.

	07/30/03 - GIRIDHARANB - 45497
		     Minor fixes to pass a table parameter into the rdb check. 
		     Also modified dbHist section to set return variable with 
		     -150 level for the relational database.

	07/08/03 - SPIER - 51423
	            Change in SETDB section to correct node loading error
		     Node was being loaded prior to creation of object.

	06/06/03 - CHENARDP - 45497
		     Modified dynamic section to add support for data item
		     indirection for Oracle.

	04/29/03 - GIRIDHARANB - 45497
		     Added an additional parameter, the null indicator flag
		     at the -150 level. Fixes to also handle Memo and blob 
		     fields in the rdb

	03/20/03 - CHENARDP/GIRIDHARANB
		     Corrected the logic to build the -150 level of vobj array
		     in section fset. Also altered curVal section to correct
		     compile errors

	03/14/03 - SPIER - 51423
	            Added $G to 3/11/03 change, level of type
		     may not always be setup ( overlay method)

	03/11/03 - SPIER - 51423
	            Corrected several locations to look at the proper
		     location for the indictor that the auditflag is turned on.

	02/14/03 - SPIER - 51423
	            Bug fixes

	02/10/03 - GIRIDHARANB - 45497
		    Modified the curVal section to obtain the column positions	
		    from the DBMAP global instead of calling the RDB.
	*/
	#PACKAGE framework.psl
	#OPTION  ResultClass ON

	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	// ---------------------------------------------------------------------
String curVal( PSLIdentifier  oid,	// object variable instance
		String  tabnm,		// tablename
		String  property,	// column name
		Boolean fset,		// set (1) or get (0)
		PSLExpression objExpr,	// oid.property[.xyz] (*4)
		ret Number ptr)		// char pointer	(*5)	/MECH=REF:RW
		//Boolean nest)		// nested?		/NOREC
	/* ---------------------------------------------------------------------
	Return the leftexpr (fset=1) or rightexpr (fset=0) that represents the
	column's current value.

	ARGUMENTS:
	(*4) objExpr = object expression (oid.property[.nestedproperty])
		This is the complete expression element that may include the
		additional Property of the Column class.
	(*5) ptr = character pointer
		"points" into objExpr.
		If ptr=0, the caller expects this function to ignore objExpr.
		If ptr>0, then the caller expects this function to deal with the
		nested Column class property.
	*/
	type literal String LEFTEXMARK = 31.char()

	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	type PSLExpression return		// function return value

	/* A postconditional on column assignment is not allowed (cannot
	   generate conditional update code). */
	if 'PSL.postCond.isNull(),fset throw Class.new( "Error", "%PSL-E-SYNTAX,Postconditional not allowed for Column assignment")

	/* the Column properties need the table name too */
	//type String table = $$getReTable^UCGM( oid.class)

	if ptr quit $$colProp( oid, tabnm, property, fset, objExpr, .ptr)

	/* handle indirection before checking the table name, to allow column
	   indirection on dynamic instances */
	if property.extract()="@"  quit $$dynamic(0, oid, tabnm, property, fset)

	/* if tabnm.isNull(), then we have a reference to a Record instance */
	if tabnm.isNull() throw Class.new( "Error", "%PSL-E-DYNAMIC,Dynamic record not supported")

	/* ensure PSLTable instance for this table exists.
	   This will throw an exception when the tablename is invalid.
	   Ensure that information level is 1, to be able to use all properties.
	   Note that this must be enforced for ALL instances, not just the new
	   instances. */
	type PSLTable td = {PSLTable}$$getPslTbl( tabnm)

	set property = $$getColNm(property)
	if property.isNull() throw Class.new( "Error", "%PSL-E-REQUIRED,Missing property name")

	type String ref    = tabnm_ "."_ property

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do addXref^UCGM("P"_ fset, ref, oid)

	/* Initiate the PSLColumn instance for this column
	   The PSLColumn properties are filled with RDB values if applicable
	   */
	type PSLColumn cd = {PSLColumn}$$getPslCln(tabnm, property)
	set PSL.class = cd.getClass()

	/* If retrieving column value from literal record instance, retrieve and
	   return the value at compile time */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if $$getScope^UCGM(oid) = "LITERAL" quit $$litVal(oid, property, fset)

	/* scope is not literal, so create an access entry.
	   If this column reference does not have a root instance, report a
	   warning */
	type Boolean bHasRoot
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Boolean bAudit = ''$$getAtt^UCGM( oid, oid.scopeLevel, 12)

	/* Force bAudit for this column if the column is used in an index (and
	   not RDB, and not already part of the primary key). Also set the
	   needVobj flag for this declaration, as audit code will always use
	   vobj(). Note that this only applies when the column is assigned to
	   (fset). */
	if fset,'bAudit, pslTbl( tabnm).indexList.contains(property), 'td.isRdb, 'pslTbl( tabnm).primaryKeys.contains(property) {
		set bAudit = 1
		do setNeedVobj^UCREC4OP( PSL.subRou, oid, 1)
	}

	type Number  accPos = $$clnByOvs^UCREC4OP( PSL.subRou, oid, cd, bAudit, fset, .bHasRoot)
	if 'bHasRoot,PSL.getSetting("WARN","SCOPE",false) do PSL.warn( "SCOPE: Variable "_ oid_ " may not have been instantiated")

	/* Construct the return code based on the PSLColumn methods.
	   - For subscripted variables don't try anything fancy, just return
	     the M code
	   - For unsubscripted variables generate placeholder code
	   */
	if oid["(" do {
		if fset set return = cd.getUpdateCode(oid, LEFTEXMARK, bAudit, 0)
		else  set return = cd.getCurrentExpr(oid, 0)
	}
	else  do {
		type Number decPos = $$getDec^UCREC4OP( PSL.subRou, oid, accPos)

		#ACCEPT CR=27800; Date=2007-10-11; PGM=Frans S.C. Witte; Group=MISMATCH; passes Number as PSLIdentifier
		if 'fset set return = cd.getCurrentExpr( decPos, 0) quit
		set return = $$clnAsn1^UCREC4OP( decPos, accPos, LEFTEXMARK)

		/* Some PSL source code contains assignments to columns of a
		   locally declared record, without ever calling Record.save().
		   This will lead to code that uses voxn for nodes, but still
		   includes -161/-162 assignments. To ensure that the record is
		   marked as assigned as well, set assign as if
		   Record.bypassSave is detected (assign=1). This will allow
		   voXN use and suppress -161/-162 assignments.

		   Similar observations apply for the assignment of
		   vobj(oid,-100,nod)="" to indicate a node that changed (both
		   MDB and RDB) when recordType>1. In this case however, there
		   is no mechanism to suppress the assignment, so we will need
		   to prevent optimization all together. */
		// if td.recordType>1!td.isRdb do setAssign^UCREC4OP( PSL.subRou, oid, 2),setOpti^UCGM(oid, oid.scopeLevel, -1)
		if td.isRdb do setAssign^UCREC4OP( PSL.subRou, oid, 1)
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if td.recordType>1 do setOpti^UCGM(oid, oid.scopeLevel, -1)
	}

	/* The returned value may contain TABs when this is an RDB masterfield
	   retrieval, or a masterfield assignment (MDB/RDB). If the code does
	   not cause a linelength exception, then replace the TAB:
	   - if fset the TAB is the "line separator", and can be removed
	   - else the TAB is the "expression separator" and replace it by the
	     concatenation operator.
	  If the code does exceed the linelength, then insert as subroutine
	  calls. Note that the if-statement below assumes that there is no
	  substantial amount of additional code on the line that contains the
	  column assignment.
	   */
	if return [ 9.char() do {
		if return.fitsLineLength() set return = return.translate( 9.char(), $SELECT(fset:"",1:"_")) quit
		if fset set return=$$longSet( cd, return, bAudit) quit
		set return=$$longGet( cd, return)
	}

	quit return

	// ---------------------------------------------------------------------
private String getColNm( String cln)		// column name
	/* ---------------------------------------------------------------------
	Helper function to return the column name in all uppercase, or unquoted.
	*/
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if cln.ascii() quit $$UPCASE^UCGM( cln)
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	quit $$UNTOK^%ZS( cln, PSL.tok).stripQuotes()
	
	// ---------------------------------------------------------------------
private PSLColumn getPslCln( String tbl,		// table name
		String cln)		// column name
	/* ---------------------------------------------------------------------
	Helper function to return a PSLColumn from the pslCln() cache.
	The descriptor will be added if it does not yet occur in the cache.
	*/
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	type String ref

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if cln.ascii() set cln=$$UPCASE^UCGM( cln)
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	else  set cln=($$UNTOK^%ZS( cln, PSL.tok)).stripQuotes("""")

	set ref = tbl_ "."_ cln

	catch xcpt {
		if xcpt.type ["RECNOFL" set xcpt.type="%PSL-E-INVALIDREF",xcpt.context=ref
		throw xcpt
	}
	if 'pslCln(ref).exists() set pslCln(ref) = PSL.getPSLColumn(tbl, cln, pslTbl())
	quit pslCln(ref)

	// ---------------------------------------------------------------------
private PSLTable getPslTbl( String tbl)		// table name
	/* ---------------------------------------------------------------------
	Helper function to return a PSLTable from the pslTbl() cache.
	The descriptor will be added if it does not yet occur in the cache.
	*/
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	/* ensure PSLTable instance for this table exists.
	   This will throw an exception when the tablename is invalid.
	   Ensure that information level is 1, to be able to use all properties.
	   Note that this must be enforced for ALL instances, not just the new
	   instances. */
	catch xcpt {
		if xcpt.type ["RECNOFL" set xcpt.type="%PSL-E-INVALIDREF",xcpt.context=tbl
		throw xcpt
	}
	if 'pslTbl( tbl).exists() set pslTbl(tbl) = PSL.getPSLTable( tbl, 0)
	set pslTbl( tbl) = pslTbl(tbl).assertLevel( 1, pslCln())
	quit pslTbl(tbl)

	// ---------------------------------------------------------------------
private String longGet( PSLColumn cd,
		String expr)
	/* ---------------------------------------------------------------------
	Force subroutine for retrieval of Masterfield when the expression may
	exceed PSL.maxLineLength.

	Because the object instance may have been optimized, expr may contain
	"arbitrary" values. So use a separate subroutine for each call.

	NOTES:
	. Subroutine sharing would be possible under the following conditions:
		- the reference is known to be un-optimized
		- the reference is to the same declaration
	*/
	type String cmt = cd.table_"."_cd.column_".get()"

	type PSLSubrou sr = PSL.addSubrou( "CoGet", "()", cmt, 1)

	do sr.addCode( " N vV")

	type PSLExpression code = "S vV="_ expr.piece( 9.char())
	type String nxt
	type Number pce

	for pce=2:1:expr.length( 9.char()) do {
		set nxt = expr.piece( 9.char(), pce)
		if code.fitsLineLength( nxt.toByteString().length() + 1) set code = code_ "_"_ nxt quit
		do sr.addCode( code)
		set code = " S vV=vV_"_ nxt
	}
	do sr.addCode( code)
	do sr.addCode(" Q")
		
	quit "$$"_ sr.getName()_ "()"

	// ---------------------------------------------------------------------
String longSet( PSLColumn cd,
		String leftexp,		// instance var or declaration position
		String rightexp,
		Number mode)
	/* ---------------------------------------------------------------------
	Return complete M statement to assign (masterfield) column, which may
	be longer than PSL.maxLineLength.

	Because leftepxr may be an assignment to an optimized instance (unlikely
	but possible), each call will create a separate subroutine.
	*/
	type String cmt = cd.table_"."_cd.column_".set("_ leftexp_ ","_ mode_ ")"

	type Number pce
	type PSLSubrou sr = PSL.addSubrou( "CoSet", "(vV)", cmt, 1)
	type String expr = cd.getUpdateCode( leftexp, "vV", mode, 0)

	for pce=1:1:expr.length( 9.char()) do sr.addCode( " "_ expr.piece( 9.char(), pce))
	do sr.addCode(" Q")

	quit " D "_ sr.getName()_ "("_ rightexp_ ")"

	// ---------------------------------------------------------------------
private String litVal( PSLIdentifier  oid,	// object variable instance
		String  property,	// column name
		Boolean fset)		// set (1) or get (0)
	/* ---------------------------------------------------------------------
	Return the column value of a literal Record instance.
	This function uses $$propGet^DBSDYNRA()
	*/
	if fset do PSL.error( "Db class is read-Only under LITERAL scope") quit ""

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String vOid = $$getExpr^UCGM( oid)
	if vOid="" do PSL.error( "LITERAL scope "_ oid_ " was not instantiated") quit ""

	type String val = $$propGet^DBSDYNRA(vOid, property)
	if val.isNumber() quit val
	quit val.addQuotes()

	// ---------------------------------------------------------------------
private String colProp( PSLIdentifier recVar,	// record instance variable
		String tabnm,		// tablename
		String  colnm,		// column name
		Boolean fset,		// assignment flag
		PSLExpression propExpr,	// object expression (*4)
		ret Number ptr)		// character pointer (*5)	/MECH=REFNAM:RW
	/* ---------------------------------------------------------------------
	Process column methods and properties
	If the method or property exists in the Column class, return its value.
	Otherwise return the current column value and class and process this
	mnethod or property on that class.

	The formal parameters are the same as the (corresponding) formal
	parameters in $$curVal()

	Column methods: setNull()
	Column properties: curval, des, journal, key, len, oldval, typ

	ARGUMENTS:
	(*4) propExpr = object expression
		Passed to and by $$curVal(). Used here to obtain the name of the
		property (or method)
	(*5) ptr - character pointer
		Although the use as formal parameter suggests "local scope",
		this is not the case. Because this function may call
		$$property^UCGM(), the name 'ptr' is essential, because it is
		the public variable that is expected by $$property^UCGM().
	*/
	type public String class
	type public String setVar
	type public PSLParser pslPrsr
	type public PSLTokenizer tknzr

	type Number optr = ptr		// old value of ptr
	type String ref			// Column property or method
	type String name		// the name
	type String params		// the parenthesis, and parameters

	set ptr  = ptr + 1		// skip "."
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set ref = $$ATOM^%ZS( propExpr, .ptr, ".", , 1)
	set name = ref.piece("(")

	if ref.upperCase() = "CURVAL" quit $$curVal( recVar, tabnm, colnm, fset, propExpr, .ptr)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do initClass^UCGM("Column")
	
	type String prpid = pslPrsr.findPSLProperty( tknzr, "Column."_ name, 1)
	type String mtdid = pslPrsr.findPSLMethod( tknzr, "Column."_ name, 1)

	/* Not found at all. Must be property (or method) of Primitive
	   descendant, that is applied to recVar.colnm
	   Reset ptr to its original value (for the caller of $$curVal()), and
	   return just $$curVal(). */
	if prpid.isNull(),mtdid.isNull() set ptr=optr quit $$curVal( recVar, tabnm, colnm, fset, "", 0)

	/* Create a dummy entry in type(,) to represent the Column instance.
	   FSCW CR35741: For column properties the temp lvn is not used, as all
	   property code (labels journal, key, len, req, and typ) use the
	   "public" vars initiated here. The column methods (isNull() and
	   isNotNull() do use it to obtain the column reference to which the
	   method is applied (see UCPRIM).
	   */
	set class="Column"
	type PSLIdentifier colId
	type Number i
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	for i=1:1 set colId = "vol"_i  quit:$$getNew^UCGM(colId)=""
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do typeDec^UCGM( colId, class, "PUBLIC")

	// Assert: we have either a property or a method
	type String return
	if 'prpid.isNull() {
		// not supported: property on dynamic columns
		if colnm.extract()="@" throw Class.new("Error", "%PSL-E-DYNAMIC,Properties and methods not supported on dynamic columns")
		if ptr>0,fset throw Class.new("Error", "%PSL-E-ACCESS,Column class property is readOnly")
		set colnm = $$getColNm(colnm)	// standardize name
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set return = $$property^UCGM( colId, PSL.level, ref, fset, .class, .setVar)
	}
	else  {
		/* When the method generating method gets invoked, we need to
		   know what record and column it is being invoked on.  Calling
		   setInst^UCGM() lets this be provided in PSL.objectName.expr.
		   It expects an untokenized expression; recVar is already
		   untokenized but colnm is not, so untokenize colnm.
		*/
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		do setInst^UCGM( colId, "", recVar_"."_$$UNTOK^%ZS(colnm, PSL.tok), PSL.level)	
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set return = $$method^UCGM( colId, PSL.level, ref, fset, .class, .setVar)
	}
	quit return

	// ---------------------------------------------------------------------
private void des	// Property table.column.des ; Return Schema Description
	/* ----------------------------------------------------------------------
	*/
	type public String property,return,tabnm
	set return=($$DES^SQLDD(tabnm_ "."_ property)).addQuotes()
	quit

	// ---------------------------------------------------------------------
private void len	// Property table.column.len ; Return Schema Length
	/* ---------------------------------------------------------------------
	*/
	type public String property,tabnm
	type PSLColumn cd = {PSLColumn}$$getPslCln(tabnm,property)

	set PSL.return = cd.length
	if PSL.return.isNull() set PSL.return = PSL.return.addQuotes()
	quit

	// ---------------------------------------------------------------------
private void typ	// Property table.column.typ ; Return Schema type
	/* ---------------------------------------------------------------------
	*/
	type public String property,tabnm
	type PSLColumn cd = {PSLColumn}$$getPslCln(tabnm,property)

	set PSL.return = cd.dataType.addQuotes()
	quit

	// ---------------------------------------------------------------------
private void req	// Property table.column.req ; Return Schema is required
	/* ---------------------------------------------------------------------
	*/
	type public String property,return,tabnm
	set return=$$REQ^SQLDD(tabnm_"."_property).addQuotes()
	quit

	// ---------------------------------------------------------------------
private void key	// Property table.column.key ; Return Schema key level (Null if not key)
	/* ---------------------------------------------------------------------
	*/
	type public String property,tabnm
	
	type PSLColumn cd = {PSLColumn}$$getPslCln( tabnm, property)
	if cd.node["*" set PSL.return = cd.position
	else  set PSL.return = """"""

	quit

	// ---------------------------------------------------------------------
private void oldVal	// Property table.column.oldVal
	/* ---------------------------------------------------------------------
	This subroutine is called because it is listed in OBJECTPROP.ROUTINE for
	the combination ('Column', 'oldVal'). The call stack will be as follows:
	- property^UCGM calls curVal^UCCOLUMN for Record.column.colProp
		objExpr and ptr will be supplied
	- curVal^UCCOLUMN calls colProp^UCCOLUMN
		this subroutine uses:
		- recVar to name the Record instance variable
		- colnm to name the column
		- propExpr for the object expression that includes the .oldVal
		- ptr for the character pointer into propExpr
	- colProp^UCCOLUMN calls property^UCGM
		this subroutine has objectName, objectLevel, ref, class, and
		setVar as formal parameters, so the values are overwritten by
		whatever colProp supplied
	- property^UCGM calls oldVal^UCCOLUMN
	
	This subroutine needs access to the following entities:
	- the Record instance variable
	- the name of the column
	Both are accessed using the (formal parameter) name from colProp.

	NOTES:
	. This subroutine assumes that property^UCGM will take care of the fact
		that oldVal is a "read-only property".
	*/
	type public String        tabnm		// tablename as used by colProp
	type public String	  colnm		// columnname as used by colProp
	type public PSLColumn     pslCln()	// column descriptor cache
	type public PSLTable      pslTbl()	// column descriptor cache
	type public PSLIdentifier recVar	// recordvar as used by colProp

	type String    ref   = tabnm_ "."_ colnm
	type PSLColumn cd    = PSL.cachePSLColumn( pslCln(), ref, pslTbl())
	type Boolean   bHasRoot
	type Number    accPos = $$clnByOvs^UCREC4OP( PSL.subRou, recVar, cd, 0, 0, .bHasRoot)
	
	/* If this column reference does not have a root instance, report a
	   warning */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if 'bHasRoot,$$getScope^UCGM(recVar)'="LITERAL",PSL.getSetting("WARN","SCOPE",false) do PSL.warn("SCOPE: Variable "_ recVar_ " may not have been instantiated")

	/* Turn off optimization for recVar, because .oldVal requires vobj() by
	   definition. */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do setOpti^UCGM( recVar, recVar.scopeLevel, -1)

	/* Construct the return code based on the PSLColumn methods.
	   Do not generate placeholder code, because .oldvar assumes needVobj.
	   Replace TAB by underscore for masterfield.oldval (see curVal).
	   */
	set PSL.class = cd.getClass()
	set PSL.return = cd.getOldExpr( recVar, 0)
	if PSL.return [ 9.char() set PSL.return = PSL.return.translate( 9.char(), "_")
	quit

	// ---------------------------------------------------------------------
private void journal	// Property table.column.journal
	/* ---------------------------------------------------------------------
	*/
	type public Boolean       fset
	type public String	  colnm		// columnname as used by colProp
	type public PSLIdentifier recVar	// recordvar as used by colProp
	
	/* ================ start v6.3 change
	if '$G(type(level,var,5)) Q		; check audit flag
	=============== end v6.3 change */
	set fset=0
	set PSL.return = PSL.oLvn_ "("_ recVar_ ",-400,"""_ colnm_ """)"
	do setOpti^UCGM( recVar, recVar.scopeLevel, -1)
	quit

	// ---------------------------------------------------------------------
private String dynamic( Boolean external,	// are values in external representation?
		PSLIdentifier var,	// object variable instance
		String  table,		// table name (*3)
		String  property,	// column expression (*4)
		Boolean fset)		// set (1) or get (0)
	/* ---------------------------------------------------------------------
	Property passed through indirection.
	This subroutine is also called by overlay^UCRECORD.
	
	ARGUMENTS:
	(*3) table name
		If an empty table name is supplied, then the intention is to
		generate assignment to or retrieval from an arbitrary Record
		descendent at runtime. That code will be added later.
	(*4) property
		The value will be supplied as detected by the caller, i.e.
		including the initial "@", that will be stripped unconditionally.
		The remaining leftexpr will be used in as the actual parameter
		to represent the column name at runtime.
	(*6) leftexpr
		This parameter is ignored when fset=0, and it is required when
		fset=1. In that case it represents the value to be assigned to
		the column.

	INPUTS:
	. String append(,)
		Subroutines and functions to be appended to the generated code
	. SchemaColumn pslCln(table.property)
		Shall have been initiated by the caller

	OUTPUTS:
	. $$  if fset=0: call to $$propGet^DBSDYNRA()
	      if fset=1: complete code for DO propSet^DBSDYNRA() with LEFTEXMARK
	*/
	type literal String LEFTEXMARK = 31.char()

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number varLvl = $$getLevel^UCGM( var)	// type level of var
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Boolean bAudit = ''$$getAtt^UCGM( var, varLvl, 12)

	/* First things to do:
	   - turn off optimization of the object instance
	   - mark as subroutine call that passes object
	   	Because this subroutine is called for Record.overlay(), the
	   	supplied var may be dummy. So ignore the declaration not found
	   	exception.
	   */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do setOpti^UCGM( var, varLvl, -1)
	do {
		catch errRec {
			// ignore insert error
		}
		type Number dummy = $$insByOvs^UCREC4OP( PSL.subRou, var, "", "U")
	}
	set property = property.extract(2, property.length())

	// For now, resolve at runtime
	set PSL.class = "String"
	
	// Track indirection use if we know the table
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if 'table.isNull() do addXref^UCGM("I"_fset, table, var)

	/* Dynamic Record instances generate calls to propXyz^DBSDYNRA()
	   */
	if fset quit " D propSet^DBSDYNRA("_ var_ ","_ property_ ","_ LEFTEXMARK_ ","_ bAudit_ ","_ external_ ")"
	quit "$$propGet^DBSDYNRA("_ var_ ","_ property_ ")"
 #OPTION ResultClass ON
public String vSIG()	quit "61348^60532^Frans S.C. Witte^36690"	// Signature - LTD^TIME^USER^SIZE
