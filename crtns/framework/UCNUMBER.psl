	/*
	ORIG: FSANCHEZ - 03/17/2003
	DESC: PSL Number Class Method Library

	*************************************************************************
	* IMPORTANT NOTE:							*
	*	Although this DQ procedure is considered a member of the	*
	*	Insensitive group, it does contain code that may fail during	*
	*	bootstraps. See rndCRCD for details.				*
	*************************************************************************

	---- Environment Sensitive Elements ------------------------------------
	%CRCD
		Used to generate code for Number.roundCur()
	$$curdec^CRCDUTL()
		This function will be called when a Number.roundCur() method has
		an explicit or implicit constant currency value, and the routine
		does already exist.

	---- Methods implemented in other units --------------------------------
	Number.byte()
		This method is implemented in UCBYTSTR, because the code
		generated for this method  must obey the same rules as class
		ByteStream.
	Number.char()
		This method is implemented through psl2m^UCPRIM()
	Number.fnumber( local String format,local Number decimals)
		This method is implemented through psl2m^UCPRIM()
	Number.random()
		This method is implemented through psl2m^UCPRIM()

	---- Revision History --------------------------------------------------
	2009-06-25, Frans S.C. Witte, CR 41380
		* Added support for Number.round()

	2008-12-18, Frans S.C. Witte, CR 35741/36952
		* Number.roundDec() and Number.roundCur() now generate code that
		  calls roundDec^vNumber()

	08/22/07 - Frans S.C. Witte - CR 27800
		* Local variables used in PSL-generated code now use v* names.
		* Corrected implementation of Number.toString()

	09/20/06 - Frans S.C. Witte - CRs: 22720 / 22274
		Replaced public String x by PSL.x equivalents

	11/01/05 - Frans S.C. Witte - CRs: 15592 / 15593
		Removed subroutines that were commented out by previous CRs.
		Eliminated reference to CUVAR.CO in rndCRCD.
		Removed #IF CUVAR.%CRCD, so genereated code will always check
		CUVAR.%CRCD at compile time, independent of the state of
		CUVAR.%CRCD when UCNUMBER itself was compiled.
		Replaced this. by PSL., and removed #XECUTE do init^UCMETHOD.

	12/21/04 - Frans S.C. Witte - CRs: 13403 / 13404
		Inserted QUIT before rndDec to prevent depecation warning.
		Commented out subroutines unpack and unpack2.

	10/25/04 - Frans S.C. Witte - CRs: 11445 / 11446
		Moved subroutines unpack and unpack2 to UCSTRING, because they
		implement methods of class String.
		Added accessibility of subsroutines.
		Fixed code generated by subroutine roundSub() (second param is
		String roundoption, third param is decimals).

        05/20/04 - RussellDS - CR9676
		Move Profile04 version to Profile01 to support single code
		base for PSL.		   

	05/20/04 - RussellDS - CR9172
		   Fix scope errors in section zero.

 	12/08/03 - spier 7403
 		psl compiler warning message clean up.
 		
        09/16/03 - Spier CR 6031,6032,6034  - arq 51423
             Retrofit of changes made in v7.0 up to this date into Profile01
             as well as release for v7.0


	 03/26/03 - Spier cr 3104
		     Retrofited to Profile01
	*/
	#PACKAGE framework.psl

	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************

	// ---------------------------------------------------------------------
rnd()	// Number.round(Number decimal,String opt)
	// Returns rounded Numeric value

	if PSL.actual(1).isNull() set PSL.actual(1) = 2
	if PSL.actual(2).isNull(1) set PSL.return = "+$J("_ PSL.objectName_ ",0,"_ PSL.actual(1)_ ")"
	else  set PSL.return = "$$round^vNumber("_ PSL.objectName_ ","_ PSL.actual(1)_ ","_ PSL.actual(2)_ ")"
	quit

	// ---------------------------------------------------------------------
rndDec   // Number.roundDec(Number decimal,String opt,Number just)
	// Returns rounded value as a String (may include leading spaces)

	if PSL.actual(1).isNull() set PSL.actual(1) = 2
	if PSL.actual(3).isNull() set PSL.actual(3) = 0

	if PSL.actual(2).isNull(1) set PSL.return = "$J("_ PSL.objectName_ ","_ PSL.actual(3)_ ","_ PSL.actual(1)_ ")"
	else  do roundSub( PSL.actual(1), PSL.actual(2), PSL.actual(3))

	quit

	// ---------------------------------------------------------------------
rndCRCD	// Number.roundCRCD(String CRCD,String opt,Number just)
	/* ---------------------------------------------------------------------
	Generate code for rounded currency value

	INPUTS:
	. PSL.actual(1) = currency code
		If absent or "", the system currency (CUVAR.%CRCD) will be used.
		If the value is literal, and the routine CRCDUTL does exist,
		a compiletime call to $$curdec^CRCDUTL() is made to obtain the
		number of decimals at compile time.
		If the routine does not yet exist, the call to
		$$curdec^CRCDUTL() will be deferred to runtime. Note that this
		will only occur during initial environment creation.
	. PSL.actual(2)
		rounding option.
	. PSL.actual(3)
		character length of result.

	NOTES:
	. The version of UCNUMBER that is called during phase 1 and phase 2 of
		an upgrade will use the number of decimals of the system
		currency at the ORIGINATING site in case of an absent or empty
		currency argument.
	*/
	type Number dec

	if PSL.actual(1).isNull(1) do {
		set PSL.actual(1) = CUVAR.%CRCD.addQuotes()
		if PSL.actual(1).isNull(1) set dec = 2
	}

	if 'PSL.actual(1).isNull(1) do {
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if PSL.actual(1).isLiteral(),$$VALID^%ZRTNS("CRCDUTL") set dec = +$$curdec^CRCDUTL( PSL.actual(1).stripQuotes())
		else  set dec = "+$$curdec^CRCDUTL("_ PSL.actual(1)_ ")"
	}

	if PSL.actual(3).isNull() set PSL.actual(3) = 0
	if PSL.actual(2).isNull(1) set PSL.return = "$J("_ PSL.objectName_ ","_ PSL.actual(3)_ ","_ dec_ ")"
	else  do roundSub( dec, PSL.actual(2), PSL.actual(3))

	quit

	// ---------------------------------------------------------------------
toString	// Method: Number.toString(Number decimal,String mask)

	/* Convert a number into a formatted string

	Uses mask syntax from $$NUM^%ZM as 2nd parameter
			Byte#1 = Decimal character
			Byte#2 = Thousand separator character
			Byte#3 = Negative value format (Supported by $FN)
			Byte#4 = Prefix character
	*/

	if PSL.objectName.isNull(1) set PSL.return = """""" quit

	if PSL.actual(2).isNull(1)!(PSL.actual(2)=""".""") do { quit
		if PSL.actual(1).isNull() set PSL.return = PSL.objectName quit
		set PSL.return = "$J("_ PSL.objectName_ ",0,"_ PSL.actual(1)_ ")"
	}

	if PSL.actual(2).isNull() set PSL.actual(2) = PSL.actual(2).addQuotes()

	if PSL.actual(2).isLiteral() do { quit

		type String msk = PSL.actual(2).stripQuotes()
 		type String vm = msk.extract(1)					//	Replace Decimal
		type String vf = msk.extract(3)			 		//	Negative Number
		if 9'[msk.extract(2) set vf = vf_",", vm = vm_msk.extract(2) 	//	Replace thousand sep

		if 'vf.isNull() do {
			set PSL.return = "$FN("_ PSL.objectName_ ","""_ vf_ ""","_ PSL.actual(1)_ ")"
			if vm.extract(1,2)'=".," set PSL.return = "$TR("_ PSL.return_ ","".,"","""_ vm_ """)"
		}

		else  do {
			set PSL.return = "$J("_ PSL.objectName_ ",0,+"_ PSL.actual(1)_ ")"
			if vm'="." set PSL.return = "$TR("_ PSL.return_ ",""."","""_ vm_ """)"
		}

		if msk.length()=4 set PSL.return = """"_ msk.extract(4)_ """_"_ PSL.return

	}

	set PSL.return = "$$NUM^%ZM("_ PSL.objectName_ ","_ PSL.actual(1)_ ","_ PSL.actual(2)_ ")"

	quit

	// ---------------------------------------------------------------------
roundSub(Number dec,String option, Number jus)	//  Round a number up/down to decimal precision
	/* This is a local subroutine.

	================ old code ================
	type String label = "vNumRnd"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(Number v1,String v2,Number v3)","Number.round")
	
		do buf.add("type Number y=v1.find(""."")+v3-1")
		do buf.add("if y<v3!(y=v1.length()) quit v1.justify(v3)")
		do buf.add("if v1.extract(y+1)=0 quit v1.extract(1,y).justify(v3)")
		do buf.add("if v2=""+"" set v1=v1+("".0000000000000"".extract(1,v3)_1)")
		do buf.add("quit v1.extract(1,y).justify(v3)")

		do buf.insert(label, "String")
	}
	
	set PSL.return="$$"_label_"("_PSL.objectName_","_dec_","_option_")"
	*/
	#ACCEPT GROUP=ACCESS;CR=35741;DATE=2008-12-18;PGM=Frans S.C. Witte
	if {List}"Number,Integer".contains($$getClass^UCGM( PSL.objectName)) set PSL.return = PSL.objectName
	else set PSL.return = "+"_ PSL.objectName

	set PSL.return="$$roundDec^vNumber("_ PSL.return_ ","_ dec_","_ option_ ","_ jus_ ")"
	quit

	// ---------------------------------------------------------------------
zero	// Method Number.zero - returns zero fill
	
	if PSL.actual(1).isNull(1) do PSL.error("Length required")
	if PSL.actual(2).isNull(1) set PSL.actual(2)=0
	if PSL.actual(3)>1!(PSL.actual(3)<0) do PSL.error($$^MSG(7609))
	if PSL.actual(3).isNull(1) set PSL.actual(3)=0
	if PSL.actual(4)>2!(PSL.actual(4)<0) do PSL.error($$^MSG(7609))
	if PSL.actual(4).isNull(1) set PSL.actual(4)=0

	type String label = "vNumZero"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(Number vo,Number v1,Number v2,Number v3,Number v4)","String.zero")

		do buf.add("type String vSign,vX")
		do buf.add("set vX=""""")
		do buf.add("set vo=vo.roundDec(v2)")
		do buf.add("if v3=1,v2'=0 S vo=vo*(10**v2)")
		do buf.add("if v4'=0 do {")
		do buf.add(" set v1=v1-1")
		do buf.add(" if vo<0 set vo=vo*-1,vSign=""-""")
		do buf.add(" else  set vSign=""+""")
		do buf.add(" }")
	//	do buf.add("I vo.length()>v1 throw Class.new(""Error"","%PSL-E-MISMATCH,"_$$^MSG(3037,vo,v1))")
		do buf.add("set vX.piece(0,v1-vo.length())=0 set vo=vX_vo")
		do buf.add("if v4=0 quit vo")
		do buf.add("if v4=1 quit vSign_vo")
		do buf.add("quit vo_vSign")

		do buf.insert(label, "String")
	}

	set PSL.return="$$"_label_"("_ PSL.objectName_","_PSL.actual(1)_","_PSL.actual(2)_","_PSL.actual(3)_","_PSL.actual(4)_")"

	quit
	
 #OPTION ResultClass ON
public String vSIG()	quit "61537^60709^Frans S.C. Witte^10577"	// Signature - LTD^TIME^USER^SIZE
