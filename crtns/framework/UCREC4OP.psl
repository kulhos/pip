	/*
	DESC:	Library of Record methods - Insensitive Group
		Incremental loading, Record optimization

	KEYWORDS:     DATABASE 

	I18N=QUIT

	---- Comments ----------------------------------------------------------
	This unit contains functions and subroutines to support the  incremental
	loading of Record nodes and the optimization of Record variable access.
	There are three groups of code:
	1) Code that builds dbAcc(,,)
		This code is primarily called during pass 1 of the compilation,
		and includes functions such as $$decByOvs(), $$insByOvs(), and
		$$accByOvs().
	2) Code that deals with incremental node loading.
		This unit supports two ways of loading records:
		- immediately after instantiation (default for MDB)
		- immediately prior to first access (default for RDB)
	3) Code that deals with Record variable access optimization.
		This unit supports two techniques of optimization
		- calculate "complex computeds" at most once
		- vobj() to voXN mapping.
		This code is called during pass2. See subroutine optNload() for
		details.

	Even though incremental load code and optimization code operate on the
	same Record declarations, they are to a large extend independent of each
	other.

	Subroutines generated by this unit will replicate the class-specific
	prefix of the pass 1 labels they replace:
	- "vCa"		Cache.getRecord
	- "vReCp"	Record.copy()
	- "vReSav"	Record.save()

	This unit deals with class Record and its descendants. It should be
	noted however, that the code that builds dbAcc(,,), and the vobj-to-voxn
	substitution could be applied to any Reference descendant (that uses
	vobj). In order to use this unit for that purpose, all Record-specific
	code must be isolated.

	Structure of dbAcc(subroutine,objectvariablesignature,position)
	===============================================================
	This part of dbAcc(,,) contains all the declarations, instantiations,
	and accesses on a per subroutine and variable basis. It has the
	following structure:
	dbAcc(subRou,ovs,position)=
		01	class
		02	decPos (position of declaration)
		03	scope (New,Formal,Public,Pointer)
		04	insList (positions of instantiations)
		05	Occcurence expression
		06	DO level at occurrence
		07	DO stack at occurrence
		08	IF stack at occurrence
		09	FOR stack at occurrence
		10	Need vobj Switch (0 = can optimize, 1 = need vobj(,))
		11	Assignment Switch
			for acc: 0=reference, 1=assignment
			for dec: 0=instantiated
				 1=Record.bypassSave(), and no index columns
				 2=Record.save() (needs vobj())
				""=referenced only (implied local)
		12	Audit Switch (0=Off, 1=On)
		13	Instantiation Mode indicator (1, 0, -1, -2, "I", "U")
		14	source code line number at occurrence
		15	Occurrence call: $$label(ap1,ap2,ap3) or purpose lvns
		16	Occurrence subscripts

	Not all fields of a dbAcc() entry will be filled in all cases. The
	matrix below describes whether an entry will be filled (+) or empty (-):

	dbAcc() fill matrix
	field		dec	ins	acc	pur	sav
	class		*1	*1	*1	*1	*1
	decPos		-	+	+	+	+
	scope		+	+	-	-	-
	insList		-	-	+	+	+
	occExpr		-	*2	*2	*2	*2
	doLevel		+	+	+	+	+
	doStack		+	+	+	+	+
	ifStack		+	+	+	+	+
	forStack	+	+	+	+	+
	needVobj	+	-	-	-	-
	assign		+	-	+	-	-
	audit		-	-	+	-	-
	instMode	*3	*3	-	-	-
	scLnr		+	+	+	+	+
	occCall		*4	*4	-	-	*4
	occSubs		+	+	+	+	+

	(*1) For instantiations, the class field will contain the name of the
	instantiating class. For Class.new() and Db.getRecord() this is encoded
	in the instantiation expression itself. However for Cache.getRecord(),
	and DbSet.getRecord() the type() descriptor of the instantiator must be
	examined.
	For all other occurrences, the class field will contain the record class
	name.

	(*2) For instantiations this field contains the PSL source expression
	that caused the instantiation.
	For column access ocurrences this field contains the table.column
	reference.
	For save occurrences this value will be empty.

	(*3) For declarations this contains:
		0 if Record.setCreateOnly() has been found for this declaration
		1 if Record.setUpdateOnly() has been found for this declaration
	For instantitations this contains the instMode value as described for
	ins2me(). The value "I" corresponds to inherited, and the value "U" to
	unchanged. A value of "U" must always be assigned explicitly by the
	caller of $$InsByXxx(). The other values can be passed explicitly, but
	will be calculated by $$InsByDec() if "" is supplied. Ins2me() uses
	the values to calculate the combined value for an incremental load
	position.

	(*4) For declarations that use the voxn model, this piece contains the
	list of variables allocated for incemental load, and special purposes.
	The KILL vobj(+$GET(recInst)) for vobj() code shall be replaced by
	KILL nodeList in the voxn model. See decOpt for the purpose lvns that
	need to occur in the list.
	For assignment instantiations (i.e. where the record instance variable
	occurs on the left side) this contains the instantiator expression.
	For save occurrences this call will contain the vReSav() call as it
	would occur in the unoptimized pass 1 code.

	A combined declaration / instantiation will be an instantiation with
	decPos=position

	Several "index" type of structures are available in dbAcc(,,) as well:
	. dbAcc( "*", "<", purPos ) = decPos TAB purpose
		Every purpose node (whether ordinary or special) receives a
		unique "position" as well. This position will be substituted in
		the code generated for pass one, and will be replaced by the
		actual purpose variable (vobj(oid,pur) or voXN) in pass two.
	. dbAcc( "*", "*", decPos ) = subroutine TAB ovs
		Since every entry in dbAcc(,,) receives a unique "position",
		this index provides a unique reference to the declaration
		descriptor.
	. dbAcc( "*", "=", insPos ) = subroutine TAB ovs
		Since every entry in dbAcc(,,) receives a unique "position",
		this index provides a unique reference to the instantiation
		descriptor.
	. dbAcc( "*", "@", accPos ) = subroutine TAB ovs
		Since every entry in dbAcc(,,) receives a unique "position",
		this index provides a unique reference to the access
		descriptor.
	. dbAcc( "*", "$$", accPos ) = function call for computation
		This index will contain all columns that require a function call
		inside the calculation of a computed column.  The value contains
		the function call and arguments as specified in the computation
		property of the column descriptor.
	. dbAcc( "*", "<$$", purPos ) = function call for computation
		Like dbAcc( "*", "$$", accPos), but this leave contains the
		pass 1 code, with colum ocurrence position placeholders.
	. dbAcc( "*", decPos, purpose) = purPos
		This index quickly shows which purpose nodes are accessed during
		the entire liftime of the declaration. If vobj(,) to voXN
		replacement will be applied, each of these occurrences will use
		a separate variable.
	. dbAcc( "=", decPos, insPos) = ""
		Shortcut index to find all instantiation occurrences of a
		declaration.
	. dbAcc( "+", decPos, accPos ) = ""
		This index will contain all columns accessed as leftexpr (i.e
		columns that occur in an assignment).
	. dbAcc( "^", decPos, savPos ) = subroutine TAB ovs
		This index will contain all occurrences or Record.save() or
		Record.bypassSave() for RDB tables that can bypass the filer.
	. dbAcc( "@", insPos, accPos) = decPos
		Shortcut index to find all accesses that may refer to a given
		instantiation.
	. dbAcc( "*sr*", "*", PSLSubrou) = ""
		If the specified PSLSubrou contains wrapped column / record
		references. The occurrences are likely to be in the range of the
		line that contains the method who's implementation ends up in
		the subroutine. So the integer part of the occurrence number
		will not be related to any subscript of mp1() or append(sr,).

	Record class instantiation occurrences
	======================================
	There are different ways to either instantiate a Record class object, or
	substantially modify its contents. The following general patterns are
	distinguished:
	- set rec = Cache.getRecord("RecordTABLE","accesskey")
		Retrieves initial and incremental nodes through the class Cache
		object to which the method is applied.
		Note that incremental loading for this type of instantiation can
		never be combined with incremental loading of any of the others.
		Record class declarations that have this kind of instantiations
		are subject to vobj-by-voxn substitution.
	- set rec = Class.new("RecordTABLE", "accesskey')
		Creates a brand new instance. Only the top/exist node, and the
		special nodes -1, and -2 will always be there. Nodes for key
		columns will exist, but may contain empty strings.
		The -150 tree will exist for all key columns (even when the key
		value is NULL).
		Record class decarations that have this kind of instantiations
		are subject to vobj-by-voxn substitution.
	- set rec = Db.getRecord("RecordTABLE, "accesskey", autoCreate)
		Retrieves an instance from the database. The top/exist node,
		and the special nodes -1 and -2 will exist, as will the nodes
		for key columns. Key column nodes will be non-empty.
		The special node -152 will exist if an existing row was
		selected from an RDB table.
		Record class decarations that have this kind of instantiations
		are subject to vobj-by-voxn substitution.
	- set rec = DbSet.getRecord("TABLE")
		Retrieves an instance from the database, like Db.getRecord().
		However, only existing nodes will result from this call.
		Record class decarations that have this kind of instantiations
		are subject to vobj-by-voxn substitution.
	- set rec = Record.copy() (same class)
		When both instances are of the same class, the instance on the
		right-hand side is "completed" (by incremental loading of the
		missing nodes), before the Object.copy() method is invoked.
		In theory, all access to both the lefthand side object and the
		right-hand side object does not require any incremental load
		code.
		Record class declarations that have this kind of instantiations
		will not be optimized (even though they could be).
	- set rec = Record.copy() (different class)
		This is only supported for tables with recordType=1, and does
		not involve incremental loading.
		Record class decarations that have this kind of instantiations
		are subject to vobj-by-voxn substitution.
	- do Row.toRecord( rec, "columnmap")
		This method acts as a normal subroutine call that passes a
		record class object.
		Record class decarations that have this kind of instantiations
		could be optimized if the columnmap is literal. However, this is
		not yet implemented
	- do label^routine( rec)
		Passing a record class object to a subroutine will be treated
		as an instantiation with unknown characteristics.
		Record class declarations that have this kind of instantiations
		cannot be optimized.
		With respect to incremental loading, one could differentiate
		between record instance passed-by-value and passed-by-name.
		In the latter case, the called subroutine can re-instantiate the
		object, and no assumptions can be made with respect to the nodes
		that are present after the call.
		If the instance is passed by value, one can assume that the
		object is not re-instantiated inside the subroutine. If it is,
		most likely a new object ID will be used, and that value cannot
		be passed back to the caller.
		Note that at this time there is no syntax to distinguish between
		pass-by-value and pass-by-name at the declaration level. 
	- label( RecordTABLE rec)
		Declaring a formal record class parameter will be treated as an
		initial instantiation with unknown characteristics.
		Record class decarations that have this kind of instantiations
		cannot be optimized.
	- type public RecordTABLE rec
		Declaring a public record class variable will be treated as an
		initial instantiation with unknown characteristics.
		Record class decarations that have this kind of instantiations
		cannot be optimized.
	- set rec.@column = value
		The generated subroutine may incrementally load nodes.
		All incremental load code following this "instantiation" shall
		use $D(vobj(vOid,vNod)) to see if the node hasn't already been
		loaded.
		Note that both column assignment and column reference exhibit
		this behavior.
	- do rec.overlay( array)
		The generated subroutine uses column indirection, so may have
		loaded nodes incrementally.
	- do rec.method() or set val = rec.method()
		Methods implemented for Record descendants (such as RecordCIF)
		will not re-instantiate the instance, but may incrementally load
		nodes. It will be treated as passing the instance "by value" to
		a subroutine or function.

	In addition, a PSL class method can return a specific record class
	instance. There is currently only one case:
	- type RecordTTX rec = TransSet.getTran( number)

	Implementation notes
	====================
	* PSL still supports the Schema.createTable() and Schema.deleteTable()
		methods. Due to the way this is currently implemented, the
		associated table- and column- definitions will only be available
		after the compiler handled the .createTable(), up to the line
		that contains the .deleteTable(). So all functions and
		procedures that deal with "pass 2" code generation must use the
		cached PSLTable and PSLColumn entries. The "pass 1" code shall
		make sure that the entries are loaded into the cache.
	* Support for Cache.getRecord(,,classNew) is still incomplete.
		For example, a Cache.getRecord(,,) occurrence is still treated
		as "record mode known to be 1". This will not impact incremental
		load code, because the (MDB) retrieval uses $G() to access the
		DB. But it may lead to incorrect code if a Record.save() for the
		instance variable is present as well.

		
	---------- Revision History --------------------------------------------
	2009-02-11, Frans S.C. Witte, CRs 35741/38252/38491
		* Corrected ldMap1Acc() to use strict increasing accPos order.

	2009-02-05, Frans S.C. Witte, CRs 35741/37665
		* replaced wrap^UCREC4OP() by wrap()

	02/02/2009 - RussellDS - CRs 35741/37982
		* Modified decSav to include check if RDB table is parent to
		  determine if rdbSaveC or rdbSaveS is appropriate call.
	
	2008-12-05, Frans S.C. Witte, CR35741/37067
		Corrected code that generates incremental load for RDB INSERT of
		child table (already initialized by Class.new()!)

	10/27/2008 - RussellDS - CRs 35741/35918
		Corrected syntax error in insOptDb related to access rights
		check.
	
	03/08/2008 - RussellDS - CR30801
		* Modified insOptCA, insOptCL, insOptDb, insOptDs for change to
		  getRecord code which are now methods in RecordTABLE code
		* Modified dbAccSet and decOpt to include code to allow the
		  optimizer to provide special handling the access rights
		  on tables with SELECT with restrict qualifiers.
		* Modified decByOvs to always use vobj for child tables
	
	09/27/2007 - RussellDS - CR29295
		* Modified loadAcc and loadIns to set up lvpm for new -161/-162
		  nodes for use by getLodCode^UCXDD for RDB update data as
		  replacement for use of -150 node.
		* Modified pur2M to test for unwrapped code line too long,
		  in which case it will retry using RDB code form for
		  function call versus in-line code to manage -161/-162.
		* Modified clnAsn2 to accept RdbCodeForm parameter from call by
		  pur2M and to pass it in call to method getUpdateCode.
		* Modified decSav to replace use of VOBJ^DBSDBASE with
		  rdbSave*^UCDBRT.
		* Modified decSavCode to pass object name reference versus dec
		  to getSavCode^UCXDD.
		* Modified loadCode to pass object name reference versus dec
		  to getLoadCode() method.
		* Modified decOpt, decSav, insOptDb, loadLvpm to add handling
		  of new node -152 (WHERE clause host variable value list, with
		  leading delimiter). Eliminated use of -151, which used to
		  contain the WHERE clause, as that is now pre-built with host
		  variables and -152 used for the host variable values.  Modified
		  comments throughout that reference -151 to replace with -152.
		  
	05/30/07 - Frans S.C. Witte - CR: 27800
		* Changed keyword 'public' to 'ret' in fp declaration.
		* Changed PSLubrou.toString() to PSLSubrou.getName()

	05/16/07 - Frans S.C. Witte - CR: 27486
		* Added preliminary (!) support for Cache.getRecord(,,classNew)
		* Added support for PSLParser.getSetting("DEBUG","DBIOCOUNT")
		* Modified ldMapMode to prevent incorrect incremetnatl load code
		  insertion after conditional instantiation

	04/05/07 - Frans S.C. Witte - CR: 26334
		Added $$wrapFits(), and modified decSav() to call it.

	03/23/07 - RussellDS - CR26386
		* Added support for new purpose node -99 for archive directory.
	
	03/02/07 - Frans S.C. Witte - CRs: 25185 / 25186 / 25187
		* Added support for / use of occMark()

	01/23/07 - Frans S.C. Witte - CRs: 24902 / 24903 / 24974
		* Corrected treatment of "I" in findInst() to prevent "object
		  may not have been instantiated" warning after Record.copy().
		* Corrected code generated for RecordSame.copy() when optimized
		  target accessed blob or memo column.

	10/19/06 - Frans S.C. Witte - CRs: 23841 / 23842
		Added use of InstMode field for all instantiations

	09/15/06 - Frans S.C. Witte - CRs: 22719 / 20613
		* Added support for record assign mode = 1 ("fast save", no -150
		  tree).
		* Corrected loadCode to bypass Cache for incremental loads of
		  blob. memo, negative nodes, and RDB (wide) tables.

	06/12/06 - Frans S.C. Witte - CRs: 22060 / 22061
		Replaced PSL.maxLineLength by PSLExpression.fitsLineLength()
		Added subroutine srAdd()

	05/31/06 - Frans S.C. Witte - CRs: 21394 / 21395
		Corrected code generated for optimized Record.copy()

	05/18/06 - Frans S.C. Witte - CRs: 21101 / 18164
		Corrected incremental load code for RDB blob/memo (needs -151)

	05/08/06 - Frans S.C. Witte - CRs: 21158 / 18164
		Corrected code generated for optimized Record.copy()
		Corrected mode value returned for DbSet.getRecord instantiation
		Corrected code generated for incremental load of complex
		computeds.

	03/22/06 - Frans S.C. Witte - CRs: 20280 / 18164
		Replaced Boolean bAtIns by Number ldMode.
		Corrected several subroutines to deal with subscripted instances.
		Modified clsAsn2 to deal with "long" masterfield assignments.
		Re-organized code, and implemented more selective use of -2 node
		on MDB.
		Function $$loadCode(): corrected code generated for incremental
		load through Cache.

	02/24/06 - Frans S.C. Witte - CRs: 19772 / 18164
		Fixed issue with incremental load from Cache.

	11/01/05 - Frans S.C. Witte - CRs: 18163 / 18164
		Initial program.
	*/
	#PACKAGE framework.psl

	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	// ---------------------------------------------------------------------
accByDec( Number decPos,	// position of declaration
		String   subscr,	// subscripts
		PSLExpression expr,	// access expression
		Boolean bAudit,		// audit flag at access
		Number  nAssign,	// assignment (1,2) or retrieval (0)
		ret Boolean bHasRoot)	// root INS?	/NOREQ/MECH=REFNAM:W
	/* ---------------------------------------------------------------------
	Insert ACCESS in dbAcc() by passing the declaration position of the
	ACCESS.

	ARGUMENTS:
	(*1) decPos = declaration position
		Shall be an existing declaration
	(*2) subscr = subscripts at access occurrence
		Needed to build the incremental load code for the access
	(*3) expr = the access expression
	(*6) bHasRoot = does this ACC have a root INS?
		This is an output parameter that specifies if this access can be
		related to a root instance. If not, there is a possible runtime
		UNDEFINED exception. The caller can report this.

	OUTPUTS:
	. $$ = the position used to denote this occurence
	. dbAcc( sr, nam, accPos) = data with:
		- sr and nam derived from decPos
		- class = ovs.class
		- decPos, audit, assign as supplied
		- insExpr = expr
		- insList derived from dbAcc( sr, ovs, *)
		- doLevel, doStack, ifStack, forStack from current pslSt values
		- occSubs = subscr
	- dbAcc( "*", "@", accPos) = sr _ SEP _ ovs
	- dbAcc( "+", decPos, accPos ) = ""
		if and only if nAssign>0
	- dbAcc( "@", insPos, accPos ) = decPos
		For all insPos values in instList
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String decOvs = dbAcc( "*", "*", decPos)
	type String sr = decOvs.piece( SEP)
	type PSLIdentifier nam = decOvs.piece( SEP, 2)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String ins = $$getClass^UCGM( nam_$$leftSig^UCGM( subscr))
	set ins.piece( SEP,  2) = decPos
	set ins.piece( SEP,  5) = expr
	set ins.piece( SEP, 11) = nAssign
	set ins.piece( SEP, 12) = bAudit

	type Number pos = $$dbAccSet( sr, nam_subscr, ins, 0)
	set dbAcc( "*", "@", pos) = sr _ SEP _ nam

	if nAssign>0 set dbAcc( "+", decPos, pos) = ""

	/* calculate the (initial) instList */
	type List insLst = $$findIns( sr, nam, pos, .bHasRoot)
	if insLst.isNull() set insLst = ","
	set dbAcc( sr, nam, pos).piece( SEP, 4) = insLst

	quit pos

	// ---------------------------------------------------------------------
accByOvs( String sr,
		PSLIdentifier ovs,
		PSLExpression expr,
		Boolean bAudit,		// audit flag at access
		Number  nAssign,	// assignment (1,2) or retrieval (0)
		ret Boolean bHasRoot)	// root INS?	/NOREQ/MECH=REFNAM:W
	/* ---------------------------------------------------------------------
	Insert ACCESS in dbAcc() by (sr, ovs).
	Helper function for accByDec( $$findDec( sr, ovs), ...).

	ARGUMENTS:
	(*1) sr = subroutine
		The subroutine in which the ACCESS occurs
	(*2) ovs = object variable signature
		The instance variable as it occurs in the code, including
		subscripts. Stringliterals in subscripts shall be untokenized.

	OUTPUTS:
	. $$ = $$accByDec( $$findDec( sr, nam), subs, expr, bAudit, bAssign, .bHasRoot)
	*/
	type String nam =ovs.piece( "(")
	
	quit $$accByDec( $$findDec( sr, nam), ovs.extract( nam.length()+1, ovs.length()), expr, bAudit, nAssign, .bHasRoot)

	// ---------------------------------------------------------------------
clnAsn1( Number dec,
	Number acc,
	String value)
	/* ---------------------------------------------------------------------
	Return the code to indicate an assignment to a column in pass 1.

	For MDB tables, one could easily return $$getUpdCode^UCXDD(), because
	the code to be inserted is completely defined by the data avaialable in
	dbAcc(sr,ovs,acc). However for RDB tables, the final code depends on the
	actaul save method: if bypassSave() can bypass the filer, then there is
	no need to include code that maintains the -150 tree. Since this is not
	know until the end of pass one, a separate placeholder must be inserted
	here, that will be substituted later (using the appropriate update code)

	OUTPUTS:
	. $$ = code to insert for pass 1
	. dbAcc("+",dec,acc) = ""
	*/
	type public String dbAcc(,,)

	if dec>0 set dbAcc( "+", dec, acc) = ""

	quit $$wrap( acc_ "="_ value)

	// ---------------------------------------------------------------------
clnByCln( Number dec,		// declaration position (*1)
		PSLColumn cdouter,	// outer column descriptor (*2)
		PSLColumn cdinner)	// inner column descriptor (*3)
	/* ---------------------------------------------------------------------
	Notification of a nested column reference.

	ARGUMENTS:
	(*1) dec = declaration position
		Note that this will only provide the variable name, not the
		possible subscript at this access.
	(*2) cdouter = outer column descriptor
		The column descriptor of the immediately enclosing column (the
		computed column). It will be used to find the subscripts that
		need to be appended for this access.
	(*3) cdinner = inner column descriptor
		The column descriptor of the the column that is used in the
		computation. A column access occurrence for this column must be
		created here.

	OUTPUTS:
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type Number        acc = ""
	type String        des = dbAcc( "*", "*", dec)
	type String        srn = des.piece( SEP, 1)
	type PSLIdentifier nam = des.piece( SEP, 2)
	type String        qcn = cdouter.table_ "."_ cdouter.column

	/* Find the access to the computed column itself, and report an error
	   if not found */
	for  set acc = dbAcc( srn, nam, acc).order(-1) quit: acc=""  quit:dbAcc( srn, nam, acc).piece( SEP, 5) = qcn
	if acc = "" do PSL.error( "INTERNAL: column access for "_ qcn_ " not found") quit

	/* If this is the first call to calculate this computed column, there
	   will not yet be an acc entry for the inner column. However, if the
	   computed column is "recalculated" e.g. optimization purposes, then:
	   1) There will already by an acc occurrence for the columns
	   2) The recalculated value shall be identical to the original
	   3) If the recalculation occurs when the declaration is no longer
		current (e.g. during pass 2), $$findDec() will report an
		exception.
	   For the (re)calculation, look for an acc occurrence greater than the
	   acc occurrence of the outer column. If not found, this is probably
	   the first pass, and it is needed to generate the access occcurence
	   of the inner column. Else we are done. */
	type Number accInner = acc
	set qcn = cdinner.table_ "."_ cdinner.column
	for  set accInner = dbAcc(srn, nam, accInner).order() quit:accInner=""  quit:dbAcc( srn, nam, accInner).piece( SEP, 5) = qcn
	if 'accInner.isNull() quit

	/* Append the subscripts of the computed column to the access occurrence
	   of the component */
	set nam = nam_ dbAcc( srn, nam, acc).piece( SEP, 16)
	set acc = $$clnByOvs( srn, nam, cdinner, 0, 0)

	if cdinner.computation.extract(1,2) = "$$" set dbAcc( "*", "$$", acc) = cdinner.computation

	quit

	// ---------------------------------------------------------------------
clnByOvs( String sr,
		PSLIdentifier ovs,
		PSLColumn cd,		// column descriptor
		Boolean bAudit,		// audit flag at access
		Boolean bAssign,	// assignment (1) or retrieval (0)
		ret Boolean bHasRoot)	// root INS?	/NOREQ/MECH=REFNAM:W
	/* ---------------------------------------------------------------------
	Insert column ACCESS in dbAcc() by (sr, ovs).
	Helper function for accByDec( $$findDec( sr, ovs), ...).
	This function ensures that the purpose node for the column exists.

	ARGUMENTS:
	(*1) sr = subroutine
		The subroutine in which the ACCESS occurs
	(*2) ovs = object variable signature
		The instance variable as it occurs in the code, including
		subscripts. Stringliterals in subscripts shall be untokenized.

	OUTPUTS:
	. $$ = $$accByDec( $$findDec( sr, nam), subs, expr, bAudit, bAssign, .bHasRoot)
	*/
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	type String nam =ovs.piece( "(")
	type Number dec = $$findDec( sr, nam)
	type String dummy = $$lvpm( dec, cd.getPurposeNode(), 1)

	quit $$accByDec( dec, ovs.extract( nam.length()+1, ovs.length()), cd.table_ "."_ cd.column , bAudit, bAssign, .bHasRoot)

	// ---------------------------------------------------------------------
dec2ovs( Number decPos)	// declaration position
	/* ---------------------------------------------------------------------
	Return the objectvariable signature for the supplied declaration.

	OUTPUTS:
	. $$ = object variable signature
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String nam = dbAcc( "*", "*", decPos).piece(SEP, 2)

	quit nam_dbAcc( dbAcc( "*", "*", decPos).piece(SEP), nam, decPos).piece( SEP, 16)

	// ---------------------------------------------------------------------
decByOvs( String sr,
		PSLIdentifier ovs)
	/* ---------------------------------------------------------------------
	Insert DECLARATION in dbAcc().

	ARGUMENTS:
	(*1) sr = subroutine
		The subroutine in which the DECLARATION occurs
	(*2) ovs = object variable signature
		If it deals with an unsubscripted variable, then the name of the
		variable, else the subscripted reference wih all subscrcipt
		expressions removed.

	OUTPUTS:
	. $$ = the position used to denote this occurrence
	. dbAcc( sr, ovs, decPos) = descriptor with:
		class = ovs.class
		decPos IS NULL
		scope = ovs.scope
		doLevel, doStack, ifStack, forStack from current pslSt
		needVobj = ovs.noPatch, but will be forced 1 for FORMAL,
			FORMALRET, LITERAL, and PUBLIC.
		occSubs = subscripts from ovs
	. dbAcc( "*","*", decPos) = sr TAB nam
	*/
	type literal String SEP = 9.char()

	type public PSLTable  pslTbl()
	type public String    dbAcc(,,)
	
	type Boolean isChild = false

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String ins = $$getClass^UCGM( ovs)
	
	type String tblName = ins.extract( 7, PSL.maxStringLength)
	
	/* May be null, e.g., if adding dummy Reference descendant actual parameter. */
	if 'tblName.isNull() do {
	
		type PSLTable td = PSL.cachePSLTable( pslTbl(), tblName, 0)
		
		set isChild = 'td.parentTable.isNull()
	}

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String scope =  $$getScope^UCGM( ovs)
	set ins.piece( SEP,  3) = scope
	
	/* The decision to require vobj() for child tables is not ideal, but
	   is based on existing application code that is using dep and ln as
	   public Record instances.  That code expects them to be vobj()
	   based.  Problems are created in these situations if their initial
	   instantiation has been optimized since this is not known by the
	   eventual, public, user.  Once we get to V4.0, that application
	   code must be cleaned up and this can be eliminated. */
	
	set ins.piece( SEP, 10) = ''ovs.noPatch or isChild

	/* FORMAL*, LITERAL, and PUBLIC variables need vobj(,) */
	if ({List}"FORMAL,FORMALRET,LITERAL,PUBLIC").contains( scope) set ins.piece( SEP, 10) = 1 

	type Number pos = $$dbAccSet( sr, ovs, ins, scope="PUBLIC")
	set dbAcc( "*", "*", pos) = sr_ SEP_ ovs.piece( "(")
	quit pos

	// ---------------------------------------------------------------------
findDec( String sr,	// subroutine
	PSLIdentifier ovs)	// object variable signature (*2)
	/* ---------------------------------------------------------------------
	Helper function that returns the declaration position of the supplied
	(sr,ovs) combination.
	The supplied combination shall be the "active combination", because the
	starting position of the search will be derived from ovs.scopeLine.

	ARGUMENTS:
	(*2) ovs = object variable signature
		In general, the callers will supply a complete lvn.
		Because the declaration will be stored by name (without the
		subscripts), this subroutine accepts both and will remove the
		subscripts before starting the search.

	NOTES:
	. Translating an subscripted lvn to an unsubscripted name assumes that
		the array is homogeneous.
	. Starting with the active position has the advantage that it reduces
		the number of entries that are searched: the search starts
		"close to" the declaration. There are however cases where this
		will not work:
		- source level literals like CUVAR
		- objects instantiated inside a PSLBuffer
		For these cases, if the first search does not find the
		declaration, a second seach starts at the current "position".
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number dp = $$getNew^UCGM( ovs) + 1

	/* check if name-to-array translation is needed */
	set ovs = ovs.piece( "(")

	if dbAcc( sr, ovs, "").order() = "" throw Class.new("Error","%PSL-E-INTERNAL no declaration found for "_ovs_" in "_sr)

	type Boolean found = 0
	while found'!dp.isNull() do {
		set dp = dbAcc( sr, ovs, dp).order( -1) quit:dp.isNull()
		type String data = dbAcc( sr, ovs, dp)

		/* If this declaration is not in scope, ignore it (ovs declared
		   more than once, UGH!!) */
		if '$$isDoScope( data.piece( SEP, 7), $$getDo^UCPSLST( PSL.pslSt)) quit

		set found = $$isDec( data, dp)
	}
	/* found it the fast way */
	if found quit dp

	/* search entire subroutine structure */
	set dp = dbAcc.get() + 1
	while found'!dp.isNull() do {
		set dp = dbAcc( sr, ovs, dp).order( -1)
		if dp.isNull() throw Class.new("Error","%PSL-INTERNAL no declaration found for "_ovs_" in "_sr)

		type String data = dbAcc( sr, ovs, dp)

		/* If this declaration is not in scope, ignore it (ovs declared
		   more than once, UGH!!) */
		if '$$isDoScope( data.piece( SEP, 7), $$getDo^UCPSLST( PSL.pslSt)) quit

		set found = $$isDec( data, dp)
	}

	quit dp

	// ---------------------------------------------------------------------
forceMode( String sr,		// subroutine
		PSLIdentifier ovs,	// record instance variable
		Number mode)		// insert or update mode
	/* ---------------------------------------------------------------------
	Force the record mode to be CREATEONLY (0) or UPDATEONLY (1).
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if $$getScope^UCGM( ovs) = "NEW" do PSL.error( "Method can not be applied to local scope object: "_ovs) quit

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if $$getScope^UCGM( ovs) = "LITERAL" do PSL.error( "Method can not be applied to literal scope object: "_ovs) quit

	type Boolean dummy = ovs.optimize()	// side effect: set optimize
	type String  expr  = $SELECT(mode=0:"Class.new()",1:".getRecord(,,0)")
	type Number  dec   = $$findDec(sr, ovs)

	/* Allow only once */
	set ovs = ovs.piece( "(")
	if 'dbAcc( sr,ovs, dec).piece( SEP, 13).isNull() do PSL.error("RecordMode already "_ "CREATE;UPDATE".piece(";",mode + 1)_ "ONLY") quit

	/* Update instExpr and forceMode type(,), and forceMode of dbAcc(,,) */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do typeFldSet^UCGM( ovs,  5, expr)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do typeFldSet^UCGM( ovs, 13, mode)

	set dbAcc( sr, ovs, dec).piece( SEP, 13) = mode

	quit

	// ---------------------------------------------------------------------
getDec( String sr,		// subroutine
		PSLIdentifier ovs,	// object variable signature
		Number pos)		// position
	/* ---------------------------------------------------------------------
	Helper function that returns the declaration position of the supplied
	position combination.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	quit dbAcc( sr, ovs.piece( "("), pos).piece( SEP, 2)
	
	
	// ---------------------------------------------------------------------
getOptApl(  PSLTable td,		// table descriptor
		String decPos)		
	/* ---------------------------------------------------------------------
	Helper function that returns the actual parameters for the special
	purpose nodes (-2, -99, -152) for calls to vRCgetRecord*Opt() methods.
	
	All possible special purpose nodes must be provided as actual parameters since
	they are expected as formal parameters.  If one does not apply, use null.
	*/
	
	type public String dbAcc(,,)
	
	type String xnods = ""
		
	if dbAcc("*", decPos, -2).exists() set xnods = xnods_"."_ dbAcc("*", decPos, -2)
	else  set xnods = xnods_ """"""
		
	if 'td.getArchiveTable().isNull() do {
		
		if dbAcc("*", decPos, -99).exists() set xnods = xnods_",."_ dbAcc("*", decPos, -99)
		else  set xnods = xnods_ ","""""
	}
		
	if td.isRdb do {
			
		if dbAcc("*", decPos, -152).exists() set xnods = xnods_",."_ dbAcc("*", decPos, -152)_",1"
		else  set xnods = xnods_ ","""",0"
	}
		
	//if td.primaryKeys.isNull() set xnods = xnods.extract( 2, xnods.length())
	
	quit xnods
	

	// ---------------------------------------------------------------------
hasWrap( String data)	// arbitrary data
	/* ---------------------------------------------------------------------
	Helper function that returns 1 if data contains code that resulted from
	calls to $$wrap(), and returns 0 otherwise.
	It is considered to contain code created by $$wrap() if it contains at
	least one wrap-begin-character, AND the number of wrap-begin-characters
	is the same as the number of wrap-end-characters.
	*/
	type literal String BGN = 7.char()
	type literal String END = 8.char()

	if data '[ BGN quit 0
	quit data.length( BGN) = data.length( END)

	// ---------------------------------------------------------------------
insByDec( Number decPos,
		String subscr,
		PSLExpression expr,
		String imd)
	/* ---------------------------------------------------------------------
	Insert INSTANTIATION in dbAcc()

	ARGUMENTS:
	(*1) decPos = position of declaration
	(*2) subscr = subsrcipts at instantiation
		see accByDec.
	(*3) expr = the instantiation expression
	(*4) imd = explicit instantiation mode or "" if to be derived

	OUTPUTS:
	. $$ = the position used to denote this occurence
	. dbAcc( sr, nam, insPos) = descriptor with:
		class = ovs.class
		decPos as supplied
		scope = ovs.scope
		insPos IS NULL
		insExpr = expr
		doLevel, doStack, ifStack, and forStack from current pslSt
		instMode = imd (if not null) or derived (by $$getInstMode)
		occSubs = subscr
	. dbAcc( "*","=", insPos) = sr SEP nam
	. dbAcc( "=", decPos, insPos) = ""
	. dbAcc( "@", insPos, accPos) = decPos
		For all access occurrences that are in the same FOR block as the
		instantiation occurrence being created.
		The insList of the associated dbAcc( sr, ovs, accPos) entry will
		be updated as well.

	NOTES:
	. Instantiations cannot use override value 1, because the instantiation
		will usually represent an assignement, or other cause of change
		to the Record object. The only exception to this rule is the
		implied instantiation that results from a PUBLIC declaration.
		This needs attention, because the PUBLIC declaration does not
		result in a code line in the destination. So access occurrences
		that follow the declaration may end up with the same "current
		line number" as the PUBLIC declaration.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String decOvs = dbAcc( "*", "*", decPos)
	type String sr = decOvs.piece(SEP)
	type PSLIdentifier nam = decOvs.piece(SEP, 2)
	type String dec = dbAcc( sr, nam, decPos)
	type String cls

	/* setInst^UCGM() will be called with the variable signature of the
	   array, when an assignment to an array node is detected. Such an
	   "instantiation" is of no use for dbAcc().
	   The only signature instantiation that is of interest for dbAcc() is
	   that of a FORMAL parameter, as part of the parameter declaration
	   */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if subscr?1"(".","1")" quit:dec.piece( SEP, 3)'["FORMAL" "" quit:(decPos\1)'=$$getDcLnr^UCGM() ""

	/* Derive the class of the instantiator */
	if expr.isNull() set cls = ""
	else  if expr.beginsWith( "Class.") set cls = "Class"
	else  if expr.beginsWith( "Db.") set cls = "Db"
	else  do {
		type String tl

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		type String exp = $$TOKEN^%ZS( expr, .tl)

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		type PSLIdentifier lvn = $$UNTOK^%ZS( exp.piece("."), .tl)
		set cls = lvn.class
	}

	type String ins = cls

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String scope = $$getScope^UCGM( nam)
	set ins.piece( SEP, 2) = decPos
	set ins.piece( SEP, 3) = scope
	set ins.piece( SEP, 5) = expr

	type Number insPos=$$dbAccSet( sr, nam_subscr, ins, 0)
	set dbAcc( "*", "=", insPos) = sr _ SEP _ nam
	set dbAcc( "=", decPos, insPos) = ""

	/* If this instantiation has a non-empty class-field, throw an exception
	   if the scope is FORMAL (ie. FORMALRET is OK), else set the assignmode
	   of the declaration to 0 (zero). */
	if 'cls.isNull() {
		if ins.piece( SEP, 3) = "FORMAL" throw Class.new("Error","%PSL-E-READONLY, Formal parameter '"_nam_ "' cannot be instantiated")
		do setAssign( sr, nam, 0)
	}

	/* If this instantiation is in iterative code, add it to the instList
	   of all accesses that are also in that iterative code */
	type String forBlock = $$getForBlock^UCPSLST( PSL.pslSt, dec.piece( SEP, 7))
	if 'forBlock.isNull() do {
		type Number ap = insPos
		for  set ap = dbAcc(sr, nam, ap).order(-1) quit:ap=""  quit:ap'>decPos  do {
			type String opt = dbAcc(sr, nam, ap)
			if $$isIns( opt) quit			// skip INS
			if $$isDec( opt, ap) quit		// skip DEC
			if opt.piece( SEP, 2)'=decPos quit	// different DEC
			if '$$isDoScope( forBlock, opt.piece(SEP, 7)) quit

			// this ACC is in the same FOR block as INS
			type String insLst = opt.piece(SEP, 4)
			set dbAcc( "@", insPos, ap) = decPos
			set dbAcc( sr, nam, ap).piece(SEP, 4) = $SELECT(insLst.isNull():insPos, 1:insPos_","_insLst)
		}
	}

	/* Store the instantiation mode:
	   - the explicit value if specifed
	   - the derived value calculated by $$getInstMode()
	   */
	set dbAcc( sr, nam, insPos).piece( SEP, 13) = $select('imd.isNull():imd,1:$$getInstMode(dbAcc( sr, nam, insPos)))
	quit insPos

	// ---------------------------------------------------------------------
insByOvs( String sr,
		PSLIdentifier ovs,
		PSLExpression expr,
		String imd)
	/* ---------------------------------------------------------------------
	Insert INSTANTIATION in dbAcc()

	ARGUMENTS:
	(*1) sr = subroutine
		The subroutine in which the INSTANTIATION occurs
	(*2) ovs = object variable signature
		The instance variable as it occurs in the code, including
		subscripts. Stringliterals in subscripts shall be untokenized.
	(*3) expr = the instantiation expression
	(*4) imd = explicit instantiation mode or "" if to be derived

	OUTPUTS:
	. $$ = the position used to denote this occurence
	*/
	type String nam = ovs.piece( "(")
	quit $$insByDec( $$findDec( sr, nam), ovs.extract( nam.length()+1, ovs.length()), expr, imd)

	// ---------------------------------------------------------------------
occMark()
	/* ---------------------------------------------------------------------
	Call to indiciate that the current occurrence position shall be treated
	as the reference point for all new occurrences.

	A language construct, such as a method call may contain multiple record-
	and column-occurrences. For example the constrcut
		do label( .rec, rec.col)
	contains an instantiation occurrence (.rec), and an access occurrence
	(rec.col). All these ocurrences shall relate to the same state. In
	particular, the rec.col occurrence references the rec instance BEFORE
	the call, not the reference that may be modified by the call.
	Relevant places in the compiler can call this subroutine to "mark" the
	current position as the reference position for new occurrences. A sloppy
	compiler could call this subroutine for each line (which will exclude
	instantiation and access on the same line). A more reasonable place
	seems to be at the beginning of a statement.

	NOTES:
	. The current solution may not be the brightest solution, because it
		requires that other parts of the compiler are aware of this
		bahavior/limitation of occurrences, but it does provide a
		working mechanism.
	*/
	type public String dbAcc(,,)
	set dbAcc( "*","<=","=") = dbAcc.get(0)	// save current position
	quit

	// ---------------------------------------------------------------------
isWrap(	String data)	// arbitrary data
	/* ---------------------------------------------------------------------
	Helper function that returns 1 if the data is the result of a call to
	$$wrap(), and returns 0 otherwise.
	*/
	type literal String BGN = 7.char()
	type literal String END = 8.char()

	if data.extract() = BGN, data.extract(data.length()) = END quit 1
	quit 0

	// ---------------------------------------------------------------------
lvpm(	Number decPos,	// declaration occurence position (*1)
		String pur,	// purpose (*2)
		Boolean bIns)	// insert new value (*3)
	/* ---------------------------------------------------------------------
	This function implements $$lvpm^UCXDD() for numeric recInst values.
	It uses dbAcc("*",recInst,pur) to return the token to represent the
	purpose variable.
	
	ARGUMENTS:
	(*1) decPos = record declaration position identifier
		This value will be used unconditionally to find the purpose
		token. If the purpose token is not found at the position,
		a new token willl be generated.
	(*2) pur = "purpose" of variable
		See $$lvpm^UCXDD(). In addition the following "purpose" values
		are recognized:
	(*3) bIns = insert new value
		If bIns=1, then a new value will be inserted when no purpose
		entry is found.
		If bIns=0, then "" will be returned if the entry does exist

	OUTPUTS:
	. $$ = token to substitute in the code
	. dbAcc( "*", decPos, pur) = purPos (provided bIns'=0)
	. dbAcc( "*", "<", purPos) = decPos TAB pur (provided bIns'=0)

	NOTES:
	. This function does not provide an "index" on token values that have
		been returned. So the compiler will need to go over all code
		generated in pass one, and replace tokens by actual variables.
	. The behavior of pur.isNull() and of key_*" nodes shall be kept in sync
		with the corresponding behavior in $$lvpm^UCXDD().
	. Unlike $$lvpm^UCXDD() this function accepts additional special purpose
		nodes, such as "*"_COLNAME for blob/memo
	. Unlike $$lvpm^UCXDD() there is no default when bIns=0, and there is no
		mapping for the purpose node.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	if pur.isNull() set pur = "0*"		// sync with UCXDD !!!!

	if dbAcc( "*", decPos, pur).exists() quit dbAcc( "*", decPos, pur)

	if pur?1.N1"*",pur'="0*" quit $$lvpm( decPos, -2 - pur.toNumber(), bIns)

	if 'bIns quit ""

	/* ================
	   Alternative: return standard vobj(recInst,node) value (will not work
	   for subscripted access).

	if 'bIns quit $$lvpm^UCGM( dbAcc("*", "*", decPos).piece( SEP, 2), pur)
	================ */

	type Number pos = $$createPos()
	set dbAcc( "*", decPos, pur) = $$wrap( pos)
	set dbAcc( "*","<",pos) = decPos _ SEP_ pur
	quit dbAcc( "*", decPos, pur)

	// ---------------------------------------------------------------------
optNload( String mp1(),	// M code from pass 1 (*1)
		Boolean bOpti,	// allow optimize (*2)
		Number ldMode)	// incremental load mode (*3)
	/* ---------------------------------------------------------------------
	Optimize Record access if possible and allowed.
	Include incremental node loading code and replace placeholders by the
	correct M code.

	When this subroutine is called, dbAcc(srn,nam,*) contains all
	declarations, instantiations, and access occurrences that occur in the
	unit. Furthermore, dbAcc("*",decPos,purNode) will contain a "purpose
	wrap" for each purpose node that is explicitly accessed in the code.
	The only purpose nodes that may need to be added are:
	- the -152 node if incremental loading of an RDB table is to be
		generated
	- the -2 node if instantiations with unknown record mode occur in the
		code.

	Because ldMap(), that calculates the incremental load positions, is
	called before decOpt(), that optimizes a declaration, special purpose
	nodes added by ldMap(), or any subroutines or functions called by it,
	will automatically be taken into account during optimization.
	This is a two-way implication: Any node that does not occur in dbAcc()
	when decOpt is called, is not used explicitly in the code. This is
	particularly important for key purpose nodes and the special purpose
	nodes -2 and -152.

	ARGUMENTS:
	(*1) mp1() = pass 1 destination code
		Like its predecessor, this subroutine still assumes that the
		code is predominantly M (with placeholders for access
		occurrences)
	(*2) bOpti = allow optimize
		A value of 0 indicates that object optimization has been turned
		off for this source unit.
		A value of 1 indicates that object optimization is allowed, and
		shall be investigated on a per-declaration basis.
	(*3) ldMode = incremental load mode
		A value of 0, indicates to use the default for the environment
		A value of 1 indicates that incremental load code will be
		inserted immediately after the instantiation occurrence.
		This is the default for MDB environments
		A value of 2 indicates that incremental load code will be
		inserted just prior to the first access of the node.
		This is the default for RDB environments

	INPUTS:
	. dbAcc(,,) = the database access structure
		As produced by the other functions and subroutines in this unit
	. dbAcc( "*", "@", accPos ) = subroutine TAB ovs

	NOTES:
	. The vobj-to-voxn remapping that is used as optimization technique for
		record access only involves using local variables instead of the
		vobj() array. This does in no way impact the positions where
		nodes shall be loaded incrementally (it only impacts which lvns
		are used in the load code).
	. The following subroutines and functions can add purpose nodes to
		dbAcc() that will be considered in vobj-to-voxn remapping:
		- ldMap(), ldMap1Acc(), ldMap1Ins(), ldMap4Acc(), ldMap4Ins()
	*/
	type public String dbAcc(,,)

	type String ldMap(,,,)	// load map
	type String ldMap2()	// load map, version 2
	type String lvMap()	// purPos-to-lvn map

	// Step 1: Build code to calculate values of complex computeds only once
	// This code impacts incremental loading
	type Number acc = 0
	for  set acc = dbAcc("*", "$$", acc).order() quit:acc=""  do cmp2pur( acc, mp1())

	// Step 2: Build the incremental load map (insensitive to optimize)
	if ldMode = 0 set ldMode=$select(Runtime.isRdb:2,1:1)
	do ldMap( ldMode, ldMap2())

	// Step 3: try to optimize access to records
	type Number dec = 0
	while 'dec.isNull() do {
		set dec = dbAcc( "*", "*", dec).order()
		if dec.isNull() quit

		/* If dec.assign=1 try to create direct SQL.
		   This shall be done independent of bOpti, and before calling
		   decOpt(,), because dec.assign may be upgraded to 2.
		   decSav(,) will add the SAVE wrap replacements to lvmap().
		   */
		do decSav(dec, lvMap())
		if bOpti do decOpt( dec, mp1())
	}

	// Step 4: add purPos-to-lvn map for all nodes
	do lvMap( lvMap())

	// Step 5: insert incremental load code and convert for pass 2
	do load( mp1(), ldMap2(), lvMap())

	// Step 6: replace placeholders by real M code
	type Number dln = 0
	set acc = 0

	/*
	while 'acc.isNull() do {
		set acc = dbAcc( "*", "@", acc).order()
		if acc.isNull() quit	// done
		if acc\1 '> dln quit	// same line
		set dln = acc\1
		set mp1( dln) = $$pur2M( mp1(dln), lvMap())
	}
	*/
	for  set dln = mp1( dln).order() quit:dln.isNull()  set mp1( dln) = $$pur2M( mp1(dln), lvMap())

	// Step 7: replace placeholders in append(,)
	type public String append(,)
	type String sr = ""
	for  set sr = dbAcc("*sr*", "*", sr).order() quit:sr.isNull()  do {
		set dln = 0
		for  set dln=append( sr, dln).order() quit:dln.isNull()  set append( sr, dln) = $$pur2M( append(sr, dln), lvMap())
	}

	quit

	// ---------------------------------------------------------------------
paNeedVobj( String srn,		// subroutine
		String nam,		// subscripts
		Number decLine)		// declaration line
	/* ---------------------------------------------------------------------
	Support function for procPtr^UCPATCH() to determine if the declaration
	it has in patch(0,srn,nam,decLine) needs vobj, and thus requires vobj()
	memory management.

	This function will only be called for variables with NEW scope that are
	still optimizable according to UCPATCH (i.e. for which the optimization
	has not been turned off explicitly).

	RETURNS:
	* $$ = 0 if and only if the declaration's needVobj = 0
		If the declaration is not found, a 1 will be returned

	NOTES:
	. At some point these two mechanisms shall be merged.
	. Based on the algorithmes used, decLine = decPos \ 1
	. This function cannot call $$findDec() because that function assumes
		the "active" instance (e.g. to compare DO-scopes)
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type Number  dp = decLine + 1
	type Boolean found = 0
	while dp>decLine&'found {
		set dp = dbAcc( srn, nam, dp).order( -1) quit:dp.isNull()
		type String data = dbAcc( srn, nam, dp)
		set found = $$isDec( dbAcc( srn, nam, dp), dp)
	}
		
	if found quit dbAcc( srn, nam, dp).piece( SEP, 10)
	quit 1				// not found assumes need vobj()

	// ---------------------------------------------------------------------
purByDec( Number decPos,	// position of declaration
		String subscr,		// subscripts
		String pur,		// purpose value
		ret Boolean bHasRoot)	// root INS?	/NOREQ/MECH=REFNAM:W
	/* ---------------------------------------------------------------------
	Insert ACCESS to purpose node in dbAcc() by passing the declaration
	position of the ACCESS. This function is similar to $$accByDec().
	The function is likely to be called only for special purpose nodes,
	because access to columns will use $$accByDec().

	The behavior of special purpose node access is similar to ordinary
	access, especially with respect to tying them to instantiations.

	This function returns the position of the purpose identifier, not the
	position of the access occurrence. It does however create an access
	descriptor in the dbAcc(,,) array.
	returns
	ARGUMENTS:
	(*1) decPos = declaration position
		Shall be an existing declaration
	(*2) expr = the access expression
	(*3) bHasRoot = does this ACC have a root INS?
		See $$accByDec. This applies here just as to ordinary ACCESS

	OUTPUTS:
	. $$ = the "wrapped" position of the purpose identifier (!)
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String decOvs = dbAcc( "*", "*", decPos)
	type String sr = decOvs.piece(SEP)
	type PSLIdentifier nam = decOvs.piece(SEP, 2)

	type String ins = nam.class
	set ins.piece( SEP,  2) = decPos
	set ins.piece( SEP,  5) = $$lvpm( decPos, pur, 1)

	type Number pos = $$dbAccSet( sr, nam_subscr, ins, 0)

	/* calculate the (initial) instList */
	type List insLst = $$findIns( sr, nam, pos, .bHasRoot)
	if insLst.isNull() set insLst = ","
	set dbAcc( sr, nam, pos).piece( SEP, 4) = insLst
	set dbAcc( "*", "@", pos) = sr _ SEP _ nam

	quit ins.piece( SEP, 5)

	// ---------------------------------------------------------------------
purByOvs( String sr,
		PSLIdentifier ovs,
		String pur,
		ret Boolean bHasRoot)	// root INS?	/NOREQ/MECH=REFNAM:W
	/* ---------------------------------------------------------------------
	Insert special purpose node ACCESS in dbAcc() by (sr, ovs).
	Helper function for $$purByDec( $$findDec( sr, ovs), ...).

	ARGUMENTS:
	(*1) sr = subroutine
		The subroutine in which the ACCESS occurs
	(*2) ovs = object variable signature
		The instance variable as it occurs in the code, including
		subscripts. Stringliterals in subscripts shall be untokenized.

	OUTPUTS:
	. $$ = $$purByDec( $$findDec( sr, ovs), subs, pur, .bHasRoot)
	*/
	type String nam = ovs.piece( "(")

	quit $$purByDec( $$findDec( sr, nam), ovs.extract( nam.length()+1, ovs.length()), pur, .bHasRoot)

	// ---------------------------------------------------------------------
savByDec( Number decPos,	// position of declaration
		String subscr,		// subscripts
		String expr)		// Record.save() subroutine call
	/* ---------------------------------------------------------------------
	Insert SAVE occurrence in dbAcc() by passing the declaration
	position of the Record.save().

	ARGUMENTS:
	(*1) decPos = declaration position
		Shall be an existing declaration
	(*3) expr = the access expression

	OUTPUTS:
	. $$ = the wrapped position assigned to this occurrence
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String decOvs = dbAcc( "*", "*", decPos)
	type String sr = decOvs.piece(SEP)
	type PSLIdentifier nam = decOvs.piece(SEP, 2)

	type String ins = nam.class
	set ins.piece( SEP,  2) = decPos
	set ins.piece( SEP,  4) = "^"		// $$isIns() assumes ""==> ins
	set ins.piece( SEP, 15) = expr

	type Number pos = $$dbAccSet( sr, nam_subscr, ins, 0)
	set dbAcc( "^", decPos, pos) = sr _ SEP _ nam

	quit $$wrap(pos)

	// ---------------------------------------------------------------------
savByOvs( String sr,
		PSLIdentifier ovs,
		PSLExpression expr)
	/* ---------------------------------------------------------------------
	Insert Reocrd.save occurrence in dbAcc() by (sr, ovs).
	Helper function for savByDec( $$findDec( sr, ovs), ...).

	ARGUMENTS:
	(*1) sr = subroutine
		The subroutine in which the ACCESS occurs
	(*2) ovs = object variable signature
		The instance variable as it occurs in the code, including
		subscripts. Stringliterals in subscripts shall be untokenized.

	OUTPUTS:
	. $$ = $$savByDec( $$findDec( sr, nam), subs, expr)
	*/
	type String nam =ovs.piece( "(")
	
	quit $$savByDec( $$findDec( sr, nam), ovs.extract( nam.length()+1, ovs.length()), expr)

	// ---------------------------------------------------------------------
setAssign( String sr,		// subroutine
		PSLIdentifier ovs,	// object variable signature
		Number assign)		// assignment (0, 1, 2)
	/* ---------------------------------------------------------------------
	Set the assignment value of the declaration.
	If the new value is greater than the current value or the current value
	"", then it will be stored (value can only be upgraded, not downgraded).

	If the value is greater than 1, needVobj will be set as well.

	NOTES:
	. The algorithm implies that a negative value can only be assigned if
		the current value is "".
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String nam = ovs.piece( "(")
	type Number dec = $$findDec( sr, nam)

	type String des = dbAcc( sr, nam, dec)
	type Number cur = des.piece( SEP, 11)

	if assign>cur!cur.isNull() {
		set dbAcc( sr, nam, dec).piece( SEP, 11) = assign
		if assign>1 set dbAcc( sr, nam, dec).piece( SEP, 10) = 1
	}
	quit

	// ---------------------------------------------------------------------
setInsCall( String sr,		// subroutine
		PSLIdentifier ovs,	// object variable signature
		Number ins,		// instantiation position
		String call)		// occurrence call
	/* ---------------------------------------------------------------------
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	set dbAcc( sr, ovs.piece( "("), ins).piece(SEP, 15) = call.translate( SEP, 10.char())
	quit

	// ---------------------------------------------------------------------
setScope( String sr,		// subroutine
		PSLIdentifier ovs,	// object variable signature
		String scope)		// scope
	/* ---------------------------------------------------------------------
	NOTES:
	. This suroutine shall be used with care! Changing the scope may impact
		the positions where nodes are incrementally loaded.
	*/
	do setDecVal( sr, ovs, 3, scope)
	quit

	// ---------------------------------------------------------------------
setNeedVobj( String sr,		// subroutine
		PSLIdentifier ovs,	// object variable signature
		Boolean need)		// need vobj?
	/* ---------------------------------------------------------------------
	*/
	do setDecVal( sr, ovs, 10, need)
	quit

	// ---------------------------------------------------------------------
srAdd( PSLSubrou sr)	// PSLSubrou instance with wrap
	/* ---------------------------------------------------------------------
	Remember that PSLSubrou instance has wrap and needs to be processed by
	optNload().

	OUTPUTS:
	. dbAcc("*sr*,"*",sr) = ""
	*/
	type public String dbAcc(,,)

	set dbAcc("*sr*", "*", sr) = ""

	quit

	// ---------------------------------------------------------------------
stripWrap( String wrap)	// data for which isWrap returned true
	/* ---------------------------------------------------------------------
	Helper function that removes fist and last character

	ARGUMENTS:
	(*1) wrap = wrapped string
		Because this function unconditionally removes the first and the
		last character of the supplied value, it is the callers
		responsibility to supply a "real" wrap.
	*/
	quit wrap.extract(2, wrap.length() - 1)

	// ---------------------------------------------------------------------
wrap( String value)	// position
	/* ---------------------------------------------------------------------
	Wrap value by prepending and appending a unique character.

	ARGUMENTS:
	(*1) value = String to be wrapped
		The value is wrapped, regardless of its value. So calling the
		funtion multiple times will "wrap" it multiple times
	OUTPUTS:
	. $$ = 7.char() _ value _ 8.char()
	*/
	type literal String BGN = 7.char()
	type literal String END = 8.char()

	quit BGN _ value _ END

	// ---------------------------------------------------------------------
wrapFits( String code,	// code that contains wrap
		Number reserve)	// additional charactes
	/* ---------------------------------------------------------------------
	Support function that calculates if the supplied code fits on a line,
	given that that the code contains purpose wraps.

	The determination whether line-length will be exceeded will require the
	use of estimates if code contains purpose wraps instead of runtime
	variables. The length of the wrap equals purpos.length()+2 (with purpos
	the position occurrence as line.nnnnn) whereas a vobj() reference will
	equal node.length()+6+recInst.length(). In particular when recInst is an
	array reference, the length of recInst will be considerable.
	Based on the above the following estimate will be used:
	- the number of characters in a wrap is between 9 (wrap in lines 1-9)
		and 12 (wrap in line 9999)
	- the length of a node is 1 or 2 for wide tables
	- the length of recInst for a subscripted variable is estimated as 12
	- this leads to an actual node reference length of 2+6+12=20
	- the code will have to add 10 characters per wrap occurrence.

	ARGUMENTS:
	(*1) value = String to be wrapped
		The value is wrapped, regardless of its value. So calling the
		funtion multiple times will "wrap" it multiple times
	OUTPUTS:
	. true if code (probably) fits on line, false if not

	NOTES:
	. A more accuarate calculation would be possible if the declaration
		position would be supplied as well. In that case the actual
		length of the name of the varaible could be used.
	*/
	type literal String BGN = 7.char()

	quit ({PSLExpression}(code)).fitsLineLength(code.length(BGN) * 10 + reserve)

	/* ================================================================== */
	/* LOCAL FUNCTIONS AND SUBROUTINES				      */
	/* ------------------------------------------------------------------ */

	// ---------------------------------------------------------------------
private clnAsn2( String mp1,		// pass 1 code (*1)
	 Number RdbCodeForm)	// form of code for RDB (*2)
	/* ---------------------------------------------------------------------
	Return the (final) code for assignment to a column in pass 2.

	ARGUMENTS:
	(*1) mp1 = pass 1 code
		Code as returned by $$clnAsn1()
		
	(*2) RdbCodeForm = form of code to return for RDB
		If table is RDB table, code can be returned for	either update
		or insert and in either in-line or function form.  (Parameter
		is ignored for MDB.] See cdRdbAsn^UCXDD for details.

	OUTPUTS:
	. $$ = code to insert for pass 2
	*/
	type literal String SEP = 9.char()
	type literal Number RDBSUPPRESS = 3

	type public String dbAcc(,,)
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	type Number eq = mp1.find("=")
	type Number acc = mp1.extract(1, eq - 2)

	type String des = dbAcc( "*", "@", acc)
	type String srn = des.piece( SEP)
	type String nam = des.piece( SEP, 2)

	set des = dbAcc( srn, nam, acc)
	type Number dec  = des.piece( SEP,  2)	// declaration position
	type String prop = des.piece( SEP,  5)	// table.column
	type Number mode = des.piece( SEP, 12)	// audit mode
	type String subs = des.piece( SEP, 16)	// subscripts at access

	/* If subscripted, then use the actual subscripted reference as found in
	   the source code. This will bypass all purpose variable mapping, which
	   is OK for subscripted variables. For unsubscripted variables, purpose
	   node remapping is essential, and decPos needs to be passed. */
	type String ovs = $SELECT(subs.isNull():dec,1:nam_subs)

	type PSLColumn cd = PSL.cachePSLColumn( pslCln(), prop, pslTbl())

	/* If assignment switch for declaration = 1, then there is no need to
	   include -150 code. Indicate that by adding RDBSUPPRESS to mode */
	if dbAcc( srn, nam, dec).piece( SEP, 11) = 1 set mode = mode + RDBSUPPRESS

	type PSLExpression code = cd.getUpdateCode( ovs, mp1.extract( eq, mp1.length()), mode, RdbCodeForm)

	/* Handle the special cases:
	   - masterfield assignments may (MDB) or will (RDB) contain TABs.
	     Like the code in UCCLOUMN, this code assumes that there is no
	     significant amount of addtional code on the line that contains the
	     assignment.
	   */
	if code [ 9.char() do {
		if ({PSLExpression}code).fitsLineLength() set code = code.replace( 9.char()) quit
		set code = $$longSet^UCCOLUMN( cd, ovs, mp1.extract( eq, mp1.length()), mode)
	}
	quit code

	// ---------------------------------------------------------------------
private cmp2pur( Number acc,		// access occurrence (*1)
		String mp1())		// pass 1 code (*2)		/MECH=REFARR:RW
	/* ---------------------------------------------------------------------
	Create special purpose node for (complex) computed column

	ARGUMENTS:
	(*1) acc = access occurrence of complex computed
		This value shall occur in dbAcc("*","$$",)
	(*2) mp1() = pass 1 code
		mp1(acc\1) contains the pass 1 code that includes the complex
		computed

	INPUTS:
	. dbAcc("*","$$",acc) = computation

	OUTPUTS:
	. dbAcc("*", "<$$",acc) = computation with placeholders
	. abAcc("*", "<", purpos) and dbAcc("<",decPos,purPos)
		will have been created for the special purpose node "~"_colname

	NOTES:
	. The use of "~" in the first position of the pupose node identification
		ensures that this type of purpose nodes sort "at the end", after
		all other purpose nodes. This in turn ensures that other columns
		referenced as part of the complex computed are available.
	. The above may not be true for complex computeds that are needed to
		compute complex computeds, because the "load order" is
		determined by the alphabetic order of the column names. The code
		here simply assumes that this will never occur.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)
	type public PSLColumn pslCln()
	type public PSLTable pslTbl()

	type String des = dbAcc( "*", "@", acc)
	type String srn = des.piece( SEP)
	type String nam = des.piece( SEP, 2)

	set des = dbAcc( srn, nam, acc)
	type String    qcn = des.piece( SEP, 5)
	type PSLColumn cd  = PSL.cachePSLColumn( pslCln(), qcn, pslTbl())
	type Number    dec = des.piece(SEP, 2)
	#ACCEPT CR=27800; Date=2007-10-11; PGM=Frans S.C. Witte; Group=MISMATCH; passes Number as PSLIdentifier
	type String    cmp = cd.getCurrentExpr( dec, 0)

	/* Now cmp contains the computation as it shall occur in mp1(acc\1).
	   Generate a purpose entry for this computed column */
	type Number pur = $$purByAcc( acc, "~"_ qcn.piece( ".", 2))

	/* replace cmp by pur */
	type String code = mp1(acc\1)
	type Number at   = code.find( cmp)
	type Number sub  = cmp.length() + 1

	while at>0 set code = code.extract( 1, at-sub)_ pur_ code.extract( at, code.length()), at=code.find( cmp, at)
	set mp1(acc\1) = code
	set dbAcc( "*", "<$$", $$stripWrap(pur)) = cmp
	quit

	// ---------------------------------------------------------------------
private createPos( Number line)	// Target pass 1 line			/NOREQ
	/* ---------------------------------------------------------------------
	Helper function that returns a new "position" value.
	The value will be derived from $$getDcLnr^UCGM() and the highest number
	in use for this line. Each call to $$createPos() will return a different
	value. The integer part will correspond to the destination line number
	of the occurrence, provided that the number of calls is less than 1E5
	per line.

	OUTPUTS:
	. $$ = generated position
		will be the first non-integer value greater than "the current
		destination code linenumber" that does not yet exist anywhere in
		dbAcc(,,)

	NOTES:
	. This mechanism combines the "linenumber" oriented approach as used in
		type(,) with a token number approach that guarantees that every
		occurrence in dbAcc() can in fact be uniquely identified by the
		return value of this function.
	. This function also handles the case where $$getDcLnr()+1<dbAcc
		This occurs when the compiler goes back to an "old" line e.g.
		to deal with the construct
			do { if ER quit
		In this case, dbAcc is not incremented, but 
	. It is the caller's responsibility to ensure that the return value is
		used consistently (e.g. a single call per occurrence).
	*/
	type public String dbAcc(,,)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number val = $SELECT(line.exists():line,1:$$getDcLnr^UCGM())

	/* If not yet defined, the not-greater-than ensures that dbAcc is
	   initiated even if val=0 */
	if dbAcc.get() '> val set dbAcc = val

	set val = val + 1
	if dbAcc < val set dbAcc = dbAcc + 1E-5 quit dbAcc

	/* current linenumber less than current position.
	   Find the highest occurrence position used for this line.
	   Look for max( accPos, decPos, insPos, purPos)
	   */
	type Number max = dbAcc( "*", "@", val).order(-1)
	type Number pos
	type String typ

	for typ = "=", "*", "<" set pos = dbAcc( "*", typ, val).order(-1) if pos > max set max = pos

	/* If no occurrences on this line, the difference between val and max
	   will be greater than one. */
	if val - max > 1 quit val - 1 + 1E-5
	quit max + 1E-5

	// ---------------------------------------------------------------------
private dbAccSet( String sr,		// subroutine (*1)
		PSLIdentifier ovs,	// object variable signature (*2)
		String data,		// data to insert (*3)
		Number ovrMd)		// override mode (*4)
	/* ---------------------------------------------------------------------
	Insert entry in dbAcc()

	ARGUMENTS:
	(*1) sr = subroutine
		The subroutine in which the INSTANTIATION occurs
	(*2) ovs = object variable signature
		Both subscripted and unsubscripted values are allowed.
		The subscript part will be stored in piece 16.
	(*3) data = data to insert
		this subroutine will insert doState, ifState, and ForState,
		sourceLineNumber, and the subscript part of ovs
	(*4) ovrMd = override mode, one of:
		0 = no override.
			In this mode, doState, ifState, and ForState will be
			taken from PSL.pslSt, and level will be taken from
			PSL.level
		1 = PUBLIC declare override
			In this mode a PUBLIC declaration is supplied. The
			following values will be used
			- level = 0
			- doState = bottom value of PSL.pslSt
			- ifState = 0
			- forState = 0
			- $$createPos( doState)

	INPUTS:
	. PSL.level = doLevel
	. PSL.pslSt = PSLstate stack

	OUTPUTS:
	. $$ = the position used to denote this occurence
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String nam = ovs.piece( "(")
	type Number pos

	if ovrMd = 0 do {
		set data.piece( SEP,  6) = PSL.level
		set data.piece( SEP,  7) = $$getDo^UCPSLST( PSL.pslSt)
		set data.piece( SEP,  8) = $$getIf^UCPSLST( PSL.pslSt)
		set data.piece( SEP,  9) = $$getFor^UCPSLST( PSL.pslSt)

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set data.piece( SEP, 14) = $$getScLnr^UCGM()

		set pos = $$createPos()
	}
	else  do {
		set pos = $$botDo^UCPSLST( PSL.pslSt)
		set data.piece( SEP,  6) = 0
		set data.piece( SEP,  7) = pos
		set data.piece( SEP,  8) = 0
		set data.piece( SEP,  9) = 0

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set data.piece( SEP, 14) = $$getScLnr^UCGM()

		set pos = $$createPos( pos)
	}
	
	/* Special optimization handling is necessary for tables with access
	   rights on SELECT with restrict clauses.  See comments in decOpt
	   and coordinate any changes here with those.
	   Because the record declaration is a formal parameter, this code
	   will trick the optimizer into treating it as a normal, within
	   label new declaration.  */
	if (sr ? 1"selectOptmOK"1.N) do {
		
		if (data.piece( SEP, 1)  = ("Record"_ ovs.upperCase())), (data.piece( SEP, 3).isLike("FORMAL%")) do {
		
			set data.piece( SEP, 10) = 0
			set data.piece( SEP, 3) = "NEW"
		}
		
		else  if data.piece( SEP, 1).isNull(), (data.piece( SEP, 3).isLike("FORMAL%")) do {
			
			set data.piece( SEP, 1) = "Db"
			set data.piece( SEP, 3) = "NEW"
		}
	}
	
	set data.piece( SEP, 16) = ovs.extract( nam.length()+1, ovs.length())
	set dbAcc( sr, nam, pos) = data
	quit pos

	// ---------------------------------------------------------------------
private decNew( String var,		// variable of declaration
		String code,		// pass 1 code line
		String lvnList)		// local variables to be NEWed (*3)
	/* ---------------------------------------------------------------------
	Add the supplied lvnList to the NEW statement of the declaration

	ARGUMENTS:
	(*3) lvnList = list of lvns
		The list shall start with a comma (and contain at least one lvn)
	NOTES:
	. derived from patchNew^UCPATCH()
	*/
	type String txt = "N "_var	// text to find (var as first in NEW)

	/* code line does not contain "NEW var". The var could be
	   somewhere in a list of NEWed vars:
		NEW v1,var
		NEW v1,var,v2
	   */
	if code'[txt set txt = ","_var
	
	/* If neither found, report an error */
	if code'[txt do PSL.error( "INTERNAL: cannot find declaration for "_var)

	quit code.piece( txt)_ txt_ lvnList_ code.piece( txt, 2, 999)

	// ---------------------------------------------------------------------
private decOpt( Number dec,		// declaration position
		String mp1())		// pass 1 code
	/* ---------------------------------------------------------------------
	Try to optimize access to this declaration.
	If needVobj is set, or if the declaration is for the abstract class
	Record, or for an array, don't optimize.
	Otherwise:
	- allocate local variables for all purpose nodes accessed for this dec
	- optimize the instantiation calls (and the called subroutines).

	If lvns are allocated, they will be NEWed in the statement generated for
	the declaration. In addition, some of these lvns need to be KILLed when
	the object is re-instantitated. This list will be stored in piece 15 of
	the declaration description. The following observations determine the
	rules for inclusion of the purpose node in this list:
	- key purpose variables will always be assigned explicitly, and the $D()
		value of the lvn is never used. This implies that they don't
		need to be killed.
	- If the -2 purpose node is used for the declaration, then it will
		always be assigned by code generated for the instantiations.
		This implies that it doesn't need to be killed.
	- If the -152 purpose node is used for the optimimized declaration,
		and the instance is used read-only, then this is due to a an
		incremental load of a Blob or Memo column. As long as the value
		of the lvn is in sync with the keys and the -2 node, there is no
		need to kill it, provided all decisions (in generated code) are
		made based on the -2 lvn
	- If the -152 purpose node is used in a read-write situation, then
		this deals with a table that has no filer. In this case, the DB API
		routines may use the presence or absence of -152 to
		discriminate between INSERT and UPDATE. So in this case the -152
		lvn needs to be killed to reflect the correct record status.
	- lvns for data nodes must always be killed because the generated code
		may use the $D() to decide if loading is needed (or in case of
		save without filer: decide if save is needed).

	NOTES:
	. If the PSL source code explicitly accessed a key column, then a
		purpose position will already have been allocated. Because the
		PSLColumn.getCurrentExpr() uses PSLColumn.getPurposeNode(), the
		entry will occur in dbAcc( "*", decPos, -keynum - 2).
	*/
	type literal String SEP = 9.char()

	type public String   dbAcc(,,)
	type public PSLTable pslTbl()
	type static PSLClass

	type String        decDes = dbAcc( "*", "*", dec)	// descriptor
	type PSLIdentifier ovs    = decDes.piece( SEP, 2)	// object var
	type String        srn    = decDes.piece( SEP)		// subroutine

	set decDes = dbAcc( srn, ovs, dec)
	
	/* Table access rights that make use of SELECT with a restrict clause
	   require special optimization handling to force optimization of the
	   selectOptmOKn method code.  These methods are called by bypass code
	   and are designed to be called with an optimized loaded record as
	   a parameter and then do any incremental loading in an optimized
	   manner.  This requires special handling here and in dcAccSet.  These
	   sections must be coordinated with the addRightsOK method code in
	   PSLRecordBuilder in the event of method name changes or key variable
	   name changes. */
	type Boolean optOvr = false
	if (srn ? 1"selectOptmOK"1.N), (decDes.piece( SEP, 1)  = ("Record"_ ovs.upperCase())) set optOvr = true

	if decDes.piece( SEP, 10).toNumber() '= 0 quit		// need vobj()
	if decDes.piece( SEP, 3) '= "NEW" do paSetVobj( srn, ovs, dec, 0) quit		// NEW scope only
	if decDes.piece( SEP, 1)  = "Record" do paSetVobj( srn, ovs, dec, 1) quit	// abstract
	if 'decDes.piece( SEP, 16).isNull() do paSetVobj( srn, ovs, dec, 0) quit	// array
	if dbAcc( "=", dec, "").order().isNull() do paSetVobj( srn, ovs, dec, 0) quit	// no instantiations

	/* If dbAcc(,,).assign>0, Record.save() has been invoked:
	   assign = 2 indicates Record.save(), that needs vobj()
	   assign = 1 indicates Record.bypassSave(), and no index columns, that
	   indicates that the filer can be bypassed. In this case vobj-to-voxn
	   optimization is possible (in theory even for type 10/11 tables),
	   except if PSLTable.isAutoLog, because ^DBSLOGIT() expects vobj().
	   Note that the latter case results in RDB vobj() code without -150
	   assignments.
	   */
	if decDes.piece( SEP, 11) = 2 do paSetVobj( srn, ovs, dec, 1) quit		// .save() needs vobj()

	type PSLTable td = PSL.cachePSLTable( pslTbl(), PSLClass.tableNameOf(decDes.piece( SEP)))

	/* ================
	   Code below is no longer needed: saveNoFl^UCRECORD will set neeVobj
	   when /LOG is detected. So Assign=1 without needVobj for isAutoLog
	   indicates that a column value was assigned, but either no .save() was
	   found, or a .save("/NOLOG") was found.
	if decDes.piece( SEP, 11) = 1, td.isAutoLog do paSetVobj( srn, ovs, dec, 1) quit  // .save() calls ^DBSLOGIT()
	================ */

	/* ================
	   Code below will deal exclusively with Record declarations that will
	   indeed be optimized.

	   Allocate lvn's for each purpose node needed for this declaration.
	   Also use a standard (instantiation independent) algorithm to
	   determine which node to assign to the object variable. */
	type String   i			// iterator
	type List     kilLst = ""	// purpose lvns that need to be killed
	type String   lvn		// single lvn
	type List     lvnLst = ""	// all lvns
	type String   nod		// node iterator
	type String   nodInc		// incremental load node

	set td = td.assertLevel(1)	// need hasBlob / hasMemo

	/* Determine which purpose node will end up in the object variable */
	set nod = $$getRecPur^UCXDD( td)
	
	/* Check if incremental load code is required:
	   Look for the first non-negative purpose node (since the compiler
	   controls the negative nodes, the use of -1 is safe).
	   If that happens to be the getRecord node, try the next one
	   */
	set nodInc = dbAcc( "*", dec, -1).order()
	if nodInc = nod set nodInc = dbAcc( "*", dec, nodInc).order()
	
	/* Forced optimization for vselectOptmOKn sections - these sections
	   may load data from related tables and reference keys.  Force
	   use of the key names used. */
	if optOvr do {
		type List pk = td.primaryKeys

		for i = 1:1:pk.count() set dbAcc( "*", dec, -2 - i) = "vkey"_ i
	}
	
	/* If nodInc IS NOT NULL, then there is the need for incremental loads.
	   In that case, if the table is an RDB table with blob/memo, allocate
	   an lvn for -152.
	   For MDB and RDB tables, allocate lvns for all primary key variables.
	   Do not yet allocate the lvn for the record mode purpose node, because
	   that lvn will only be needed in case the incremental load code deals
	   with "undetermined" instantiations.
	   */
	if 'nodInc.isNull() do {
		type Number dummy
		if td.isRdb, td.hasBlob ! td.hasMemo do decOptLv( dec, -152, srn, .lvnLst)

		type List pk = td.primaryKeys

		/* For each key column, force an entry in
		   dbAcc("*",dec,purpose) for -2-i, (for assign-to-key
		   in vDbN).
		   DO not generate key_"*" for incremental load, because
		   the actual lvns used there may be different (depending on
		   the load context).
		   */
		for i = 1:1:pk.count() do {
			/* First version: allocate lvn unconditionally.
			   Later versions may try to use the value of the
			   expression used in the access keys (if possible). 
			   If overriding optimzation, use fixed key names
			   corresponding to vselectOptmOKn. */
			if 'optOvr do decOptLv( dec, -2-i, srn, .lvnLst)
		}  /* end - for each key */
	}  /* end if incremental load */

	// If table is archived, allocate lvn for -99.
	if 'td.getArchiveTable().isNull() do decOptLv( dec, -99, srn, .lvnLst)

	/* if no standard node for ovs, use first data node (that will still
	   be loaded incrementally !!) */
	if nod.isNull() set nod = dbAcc( "*", dec, -1).order()

	if 'nod.isNull() set dbAcc( "*", dec, nod) = ovs, nod = ""

	for  set nod = dbAcc( "*", dec, nod).order() quit:nod.isNull()  do {
		/* special purpose nodes, keys, and the default are already
		   mapped. These lvns don't need to be killed either */
		if '$$isWrap(dbAcc("*", dec, nod)) quit
		do decOptLv( dec, nod, srn, .lvnLst)
		set kilLst = kilLst.add( dbAcc("*", dec, nod))
	}

	/* If this is an RDB record assign declaration, then add -151 variable
	   to KILL list. Store the list in decDes */
	if td.isRdb, decDes.piece( SEP, 11) > 0 do {
		if 'dbAcc("*", dec, -152).exists() do decOptLv( dec, -152, srn, .lvnLst)
		set kilLst = kilLst.add( dbAcc("*", dec, -152))
	}
	set decDes.piece( SEP, 15) = kilLst, dbAcc( srn, ovs, dec) = decDes

	/* Add all allocated lvns to the NEW command of the declaration.
	   If optimization override, need to add new line and simply
	   NEW lvnLst since dec line is vselectOptmOKn label. */
	if 'lvnLst.isNull() do {
	
		if 'optOvr set mp1(dec\1) =  $$decNew( ovs, mp1(dec\1), lvnLst)
		else do {
			
			type Number lnr  = mp1( (dec\1) + 1).order(-1) + 1E-3
			
			set mp1(lnr) = " N "_ lvnLst.extract(2, PSL.maxStringLength)
		}
	}

	/* Modify the instantiation expressions for all instantiations */
	type String apl()	// actual parameter list
	type String head	// code preceding $$lbl(apl)
	type Number ins = 0	// instantiation iterator
	type String insCls	// instantiator class
	type Number insCnt	// instantiation count for current line
	type String insCod	// code line of instantiation
	type String insDes	// instantiation descriptor
	type Number insPrv = ins - 1 // previous instantiation
	type String lbl		// label
	type String tail	// code following $$lbl(apl)
	type String tsl		// tokenized string literals

	while 'ins.isNull() do {
		set ins = dbAcc( "=", dec, ins).order()
		if ins.isNull() quit

		if (ins\1) > (insPrv\1) set insCnt = 0	// on different line
		set insCnt = insCnt + 1
		set insPrv = ins

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set insCod = $$TOKEN^%ZS( mp1( ins\1), .tsl)
		do insCode( insCod, ovs, insCnt, .lbl, apl(), .head, .tail)

		set insDes = dbAcc( srn, ovs, ins)
		set insCls = insDes.piece( SEP)

		if insCls.isNull() do pass2Err( dec, "INTERNAL: unexpected optimize for "_ovs) quit
		if optOvr				// Already dealt with optimization override
		else  if PSLClass.isRecord( insCls) > 0 set insCod = $$insOptCp( td, srn, ovs, ins, insDes, lbl, apl(), head, tail)
		else  if insCls = "Cache"   set insCod = $$insOptCa( td, srn, ovs, ins, insDes, lbl, apl(), head, tail)
		else  if insCls = "Class"   set insCod = $$insOptCl( td, srn, ovs, ins, insDes, lbl, apl(), head, tail)
		else  if insCls = "Db"      set insCod = $$insOptDb( td, srn, ovs, ins, insDes, lbl, apl(), head, tail)
		else  if insCls = "DbSet"   set insCod = $$insOptDs( td, srn, ovs, ins, insDes, lbl, apl(), head, tail)
		else  do pass2Err( ins, "INTERNAL: unexpected intantiator class '"_ insCls_ "' for "_ovs_ "="_ insDes.piece( SEP, 5))

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set mp1( ins\1) = $$UNTOK^%ZS( insCod, .tsl)
	}
	quit

	// ---------------------------------------------------------------------
private decOptLv( Number dec,		// declaration position
		String nod,		// purpose node
		String srn,		// subroutine
		ret String lvnLst)		// list of lvns			/MECH=REFNAM:RW
	/* ---------------------------------------------------------------------
	Generate lvn for purpose node, and store (insert or update!) this value
	in dbAcc( "*", dec, nod).
	*/
	type public String dbAcc(,,)

	type String lvn = $$getSym^UCPATCH( srn, "vop")
	set lvnLst = lvnLst_ ","_ lvn
	set dbAcc( "*", dec, nod) = lvn
	quit

	// ---------------------------------------------------------------------
private decSav( Number dec,		// declaration position
	        String lvmap())		// local variable map
	/* ---------------------------------------------------------------------
	Try to generate Record.save() code that contains direct SQL statements.

	NOTES:
	. This subroutine shall not modify dbAcc(,,) settings of MDB tables.
		For MDB save, save^UCRECORD will not insert a wrap, and will
		have addressed the optimizability directly through setOpti^UCGM.
		In particular changing decPos.assign from 1 to 2 would prevent
		optizations that are possible for MDB tables.
	*/
	type literal String SEP = 9.char()

	type public String    dbAcc(,,)
	type public PSLTable  pslTbl()
	type static PSLClass

	type String        decDes = dbAcc( "*", "*", dec)	// descriptor
	type PSLIdentifier ovn    = decDes.piece( SEP, 2)	// object var
	type String        srn    = decDes.piece( SEP)		// subroutine

	set decDes = dbAcc( srn, ovn, dec)

	if decDes.piece( SEP, 11) < 1 quit		// not an assignment

	/* Iterate over all instantiations.
	   See if the save occurrences can use direct SQL, and compute rmd and
	   exs as part of the iteration.
	   The descision is conservative: only instantiations that are known to
	   be OK will keep bDirect=1. These are:
	   - Cache.getRecord()
	   - Class.new()
	   - Db.getRecord()
	   - DbSet.getRecord()
	   */
	type PSLTable td = PSL.cachePSLTable( pslTbl(), PSLClass.tableNameOf( decDes.piece( SEP)))

	if 'td.isRdb quit				// Applies to RDB only

	type Boolean  bDirect = td.isOneNode() & (decDes.piece( SEP, 11) = 1)
	type Number   ins = 0, rmd = "", exs = ""

	while 'ins.isNull()&bDirect do {
		set ins = dbAcc( "=", dec, ins).order()
		if ins.isNull() quit

		do ins2me( ins, .rmd, .exs)	// update rmd and exs

		/* Instantiating class known to be OK: */
		if ({List}"Cache,Class,Db,DbSet").contains( dbAcc( srn, ovn, ins).piece( SEP)) quit

		/* All others: */
		set bDirect = 0
	}

	/* For each SAVE occurrence of this declaration replace the wrap either
	   by the direct SQL call(s) or by the call to rdbSave*^UCDBRT.
	   Note that the save code is the same for all occurrences that are tied
	   to this declaration.
	   Note that the code also relies on the fact the variable name from the
	   declaration can be inserted into the code.
	   */
	type String code
	type Number sav = ""		// save iterator

	if 'bDirect do {
		type String saveLabel, where
		
		if td.isOneNode(), 'td.isParent() set saveLabel = "rdbSaveS"
		else  set saveLabel = "rdbSaveC"
		
		set where = td.getPrimaryKeyWhere()
		
		set code = decDes.piece( SEP, 16)
		if 'code.isNull() set code = SEP
		set code = " D "_ saveLabel_ "^UCDBRT("_ ovn_ code_ ",$C("_ td.columnDelimiter _"),"_ where.addQuotes()_ ")"
		set dbAcc( srn, ovn, dec).piece( SEP, 11) = 2	// set assignMode
		set dbAcc( srn, ovn, dec).piece( SEP, 10) = 1	// set needVobj
	}
	else  do {
		set code = $$decSavCode( td, dec, rmd)

		/* If code contains TAB character(s) or if the bytelength of
		   code plus the bytelength to the -2/-152 assignments is likely
		   to exceed the maximum line length, then move code to a
		   separate new subroutine.
		   In addition to the need to call $$wrapFits() to deal with
		   purpose wraps, it also needs to compensate for -152
		   assignments, where the length of the code depends on the
		   number of primary keys. */
		type Number reserve = 200
		set:dbAcc( "*", dec, -152).exists() reserve = td.primaryKeys.count() * 66 + reserve
		if code '[ 9.char(), $$wrapFits( code, reserve) quit

		type PSLSubrou sr = PSL.addSubrou( "ReSv", "()", "SQL for "_ovn_".save()", 1)
		type Number ln
		for ln = 1:1:code.length( 9.char()) do sr.addCode( code.piece( 9.char(), ln))
		do sr.addCode( " Q")
		do srAdd( sr)
		set code = " D "_ sr.getName()_"()"
	}

	for  set sav = dbAcc( "^", dec, sav).order() quit:sav.isNull()  do {
		/* If unsubscripted just use code, else replace SEP by the
		   actual subscripts at sav */
		if code'[ SEP set lvmap(sav) = code quit
		set lvmap(sav) = code.piece( SEP)_ dbAcc( srn, ovn, sav).piece( SEP, 16)_ code.piece( SEP, 2)
	}

	quit

	// ---------------------------------------------------------------------
private decSavCode( PSLTable td,		// table descriptor
		Number dec,		// declaration position
		Number rmd)		// record mode, passed to $$getSavCode
	/* ---------------------------------------------------------------------
	Return the direct SQL statement(s) for this SAVE occur.
	*/
	type literal String SEP = 9.char()

	type public String    dbAcc(,,)
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	type Number    acc			// access iterator
	type String    accDes			// access descriptor
	type PSLColumn clnByPos()		// column descriptor by position
	type String    code			// direct SQL code
	type String    expr			// occurrence expression
	type Number    pos			// position

	set acc = 0
	while 'acc.isNull() do {
		set acc = dbAcc( "+", dec, acc).order() quit:acc.isNull()
		set accDes = $$getByPos( "@", acc)
		set expr = accDes.piece( SEP, 5)
		quit:'$$expIsCln( expr)				// not a column
		quit:accDes.piece( SEP, 11).toNumber() = 0	// not assigned

		do addRdbPos^UCXDD( clnByPos(), PSL.cachePSLColumn( pslCln(), expr, pslTbl()))
	}

	/* Current version of $$getSavCode requires at least one column
	   If no explicit column assignments, insert the first key column as if
	   it was modified explicitly. Even though in reality this will only
	   result in an INSERT, do not force rmd, because rmd=-1 will generate
	   conditional code depending on the record mode.
	   */
	if clnByPos("").order().isNull() do {
		/*
		type String decDes = dbAcc( "*", "*", dec)
		type String srn = decDes.piece( SEP)
		type String ovn = decDes.piece( SEP, 2)
		set decDes = dbAcc( srn, ovn, dec)
		set code = " D VOBJ^DBSDBASE("_ ovn_ decDes.piece( SEP, 16)_ ",$C("_ td.columnDelimiter _"))"
		set dbAcc( srn, ovn, dec).piece( SEP, 11) = 2
		*/
		if td.primaryKeys.isNull() do pass2Err( dec, "RDBSAVEFAIL: No columns to INSERT or UPDATE ") quit
		do addRdbPos^UCXDD( clnByPos(), PSL.cachePSLColumn( pslCln(), td.table_ "."_ td.primaryKeys.elementAt(1), pslTbl()))
	}
	set code = $$getSavCode^UCXDD( td, dec, "", rmd, , clnByPos())

	quit code

	// ---------------------------------------------------------------------
private expIsCln( String expr)	// expression
	/* ---------------------------------------------------------------------
	Helper function that returns if the expression specified by the
	parameter is a column reference
	*/
	if expr.endsWith("()") quit 0
	if $$isWrap(expr) quit 0
	quit 1

	// ---------------------------------------------------------------------
private findIns( String sr,		// subroutine
		PSLIdentifier nam,	// instance variable name
		Number pos,		// position value
		ret Boolean hasRoot)	// root instance found?	/MECH=REFNAM:W
	/* ---------------------------------------------------------------------
	Helper function that returns the List of positions of all instantiations
	that may provide the data for the supplied (sr,ovs,pos) access
	combination.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String acc = dbAcc( sr, nam, pos)
	type Number accDec = acc.piece( SEP, 2)
	type String accDo  = acc.piece( SEP, 7)
	type Number dp = dbAcc( "*", "<=","=") + 1E-5
	type List insLst = ""
	set hasRoot=0

	while 'dp.isNull() do {
		set dp = dbAcc( sr, nam, dp).order( -1)
		quit:dp.isNull()

		type String data = dbAcc( sr, nam, dp)

		quit:data.piece( SEP,2) '= accDec		// different dec
		quit:'dbAcc( "=", data.piece( SEP, 2), dp).exists()

		set dbAcc( "@", dp, pos) = accDec
		set insLst = insLst.add( dp)

		/* check if root instance. Currently, instMode "U" can never be
		   a root instance */
		if data.piece( SEP, 13) = "U" quit
		if $$isDoScope( data.piece( SEP, 7), accDo) set hasRoot=1, dp="" quit
	}
	quit insLst

	// ---------------------------------------------------------------------
private findXDes( Number pos)		// position value
	/* ---------------------------------------------------------------------
	Helper function that returns an extended descriptor that describes the
	the occurrence at the specified position. This function will check the
	access, instantiation, and declaration index to see if the specified
	position exists. If one is found, then the extended information is
	constructed and returned, otherwise "" is returned.

	This is not a very efficient function. If the type of position is known,
	it is much faster to access the appropriate index directly. The function
	shall only be called by subroutines and functions that do know a
	position, but don't know what kind of position is supplied (e.g. in code
	that deals with errors).

	OUTPUTS:
	$$ = typ TAB srn TAB ovs TAB dbAcc( srn, ovs, pos)
		with typ = "*" for a declaration, "=" for an instantiation, and
		"@" for an access.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String xdes = ""
	type String typ

	for typ = "@", "=", "*" if dbAcc( "*", typ, pos).exists() do { quit
		set xdes = dbAcc( "*", typ, pos)
		type String srn = xdes.piece( SEP)
		type PSLIdentifier nam = xdes.piece( SEP, 2)
		set xdes = typ_ SEP_ xdes_ SEP_ dbAcc( srn, nam, pos)
	}

	quit xdes
	
	// ---------------------------------------------------------------------
private getByPos( String typ,		// type (*1)
		Number pos)		// position value
	/* ---------------------------------------------------------------------
	Helper function that returns the dbAcc( srn, nam, pos) description for
	the supplied position and the supplied type.
	
	ARGUMENTS:
	(*1) typ = occurrence typ with
		"*" for a declaration,
		"=" for an instantiation,
		"@" for an access.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String des = dbAcc( "*", typ, pos)
	type String srn = des.piece( SEP)
	type PSLIdentifier nam = des.piece( SEP, 2)

	quit dbAcc( srn, nam, pos)

	// ---------------------------------------------------------------------
private getInstMode( String des)	// Instantiation descriptor
	/* ---------------------------------------------------------------------
	Support function that returns the stored or derived InstMode value
	(piece 13). If a value is already stored, it is returned, else it is
	derived as specified below.
	. instMode = 1
		If the instance is known to contain an existing Record.
		This is the case for the following instantiation expressions:
		- ri = Cache.getRecord()
		- ri = Db.getRecord(tbl,acckey), ri = Db.getRecord(tbl,acckey,0)
		- ri = DbSet.getRecord()
	. instMode = 0
		If the instance is known to contain a new Record, but it is
		unknown whether all primary key columns are assigned.
		This is the case for the following instantiation expressions:
		- ri = Class.New()
		- ri = Record.copy( differentRecordClass)
	. instMode = -1
		It is unknown if the instance contains a new or an existing
		Record, but all primary key columns are assigned
		This is the case for the following instantiation expressions:
		- Db.getRecord(tbl,accKey,1)
	. instMode = -2	
		It is unknown if the instance contains a new or an existing
		Record, and it is unknown whether all primary key columns are
		assigned.
		This is the case for the following instantiation expressions:
		- do label^routine( .ri)
		- label( Record ri)
		- type public Record ri
	. instMode = "I" (inherited)
		The instance inherits the instMode e.g from the instantiator.
		This is the case for the following instantiation expressions:
		- ri = Record.copy( sameRecordClass)
	. instMode = "U" (unchanged)
		Currently a number of PSL constructs are flagged as
		instantiation to indicate that the existance of nodes can no
		longer be predicted, but these constructs do not really create a
		new instance.
		This is the case for the following instantiation expressions:
		- set ri.@column = value
		- do Row.toRecord( ri, "colmap")
		- do label^routine( ri)
		- do ri.overlay( array)
		- do ri.method()

	NOTES:
	. instMode = "U" will never be derived. This is not a problem, because
		in all cases the instantiation occurrence is created explicitly
		by a caller that "knows" that it creates an instantiation with
		InstMode="U".
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)
	type static PSLClass

	type String imd = des.piece( SEP, 13)

	/* If already stored, return stored value
	   */
	if 'imd.isNull() quit imd

	type String exp = des.piece( SEP, 5)
	type String cls = des.piece( SEP)

	// Cache.getRecord() and DbSet.getRecord() ==> 1
	if ({List}"Cache,DbSet").contains( cls) quit 1

	// Class.new() ==> 0
	if cls = "Class" quit 0

	// Db.getRecord() ==> either -1 or 1
	if cls = "Db" quit $select($$getPar^UCPATCH(exp,3).toNumber()=1:-1,1:1)

	// Record.copy(), same class ==> -2, different class ==> 0
	if PSLClass.isRecord( cls) > 0 { quit imd
		type String dec = $$getByPos( "*", des.piece( SEP, 2))
		set imd = $select(dec.piece( SEP) = cls:"I",1:0)
	}
	quit -2

	// ---------------------------------------------------------------------
private ins2me( Number ins,		// instantiation position
		ret Number rmd,		// record mode of previous call
		ret Boolean exs,	// exists flag of previous call
		ret String call)	// cache.getRecord call
	/* ---------------------------------------------------------------------
	Support subroutine that sets rmd and exs based on the supplied values,
	and the instantiation mode of ins.

	The new value of rmd is derived according to transition table below.
	Note that the transitions are commutative, so only one "half" of the
	matrix will be provided. Furthermore the valid values of rmd ("", 1, 0,
	-1, -2) are a subset of the ins.InstMode values (with the exception of
	the initial "").

	The first vesion of the algorithm does not transform "I" into its
	inherited value, but simply treats it as -2 (completely unknown) 

	This leads to the following table:
	rmd and ins	result	comment
	any	"U"	any	"U" does not change the supplied value
				There is a small, theoretical chance that the
				first instantiation is "U". Even in that case it
				is save to return rmd unchanged.
	any	"I"	-2	to be done (need to prevent endless loops)
	any	-2	-2	Once there is a completely unknown, it will
				never get better
	1	1	1
	0	0	0
	-1	-1	-1
	1,-1	0	-2	Combinations with 0 result in -2, because it is
				unknown whether the key columns are non-empty
	1	-1	-1

	A result value of -2 or "U" forces exs = 1

	NOTE:
	. Because this routine is supposed to be called multiple times to
		calculate rmd and exs for all instantiations that need to be
		considered at the position in question, it does NOT look at
		decPos.forceMode.
		It is the caller's responsibility to take this value into
		account (e.g. before calling ins2me).
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	if rmd = -2 quit		// Sorry, it won't get better

	/* First instantiation flips exs from "" to 0
	   Second and following force it to 1 */
	if exs.isNull() set exs = 0
	else  set exs = 1

	type String insDes = $$getByPos( "=", ins)
	type String imd = insDes.piece( SEP, 13)

	if imd = "I" set imd = -2	// do not yet chase inheritance tree

	/* Fill Cache.getRecord call if applicable
	   */
	if insDes.piece(SEP) = "Cache" set call = insDes.piece( SEP, 15)

	/* If same, or imd = "U" there is no change (but "U" forces exs=1)
	   If imd = -2, the result will be -2
	   If this is the first assignment, make it now (but AFTER "U", and
	   after imd = -2 because of the side effect to exs)
	   */
	if rmd = imd quit
	if imd = "U" set exs = 1 quit
	if imd = -2  set rmd = -2, exs = 1 quit
	if rmd.isNull() set rmd = imd quit

	/* At this point the values are different, and in the set (-1, 0, 1)
	   The presence of a zero results in -2 (unknown key).
	   The remaining combination must be (-1,1) and results in -1.
	   */
	if rmd = 0 ! (imd = 0) set rmd = -2, exs = 1 quit
	set rmd=-1
	quit

	// ---------------------------------------------------------------------
private insApa2Apl( String apa())	// actual parameter array
	/* ---------------------------------------------------------------------
	Helper function that transforms apa(n) to apa1,apa2,...
	*/
	type String apl = ""
	type Number i
	for i=1:1:apa("").order(-1) set apl = apl_ ","_ apa(i)
	quit apl.extract( 2, apl.length())

	// ---------------------------------------------------------------------
private insCode( String mp1,		// pass 1 code line, tokenized
		PSLIdentifier ovs, 	// object variable
		Number occ,		// occurrence number
		ret String lbl,		// label of asisgnment function
		String apl(),		// actual parameter list
		ret String head,	// code preceding $$lbl(apl)
		ret String tail)	// code following $$lbl(apl)
	/* ---------------------------------------------------------------------
	Helper subroutine that decomposes the line that contains an instantiation
	into several parts that can be used by insOptXx.
	This code looks for the occ-th assignment to ovs in mp1.

	NOTES:
	. The code in this subroutine highly depends on the M code that is
		generated for pass 1. In particular this code assumes that every
		(optimizable) instantiation consists of a an assignment of the
		form
			S ovs=$$someFun(ap1,ap2,ap3)
	. If a subscripted form of ovs is passed into the subroutine, the caller
		is responsible to supply the exact spelling of the occurrence
		in mp1.
	. The following code reconstructs the original code line assuming that
		head_"S "_ovs_"=$$"_lbl_"("_apl_")"_tail
	*/

	/* The code block below:
	   - sets 'head' to the code preceeding the "S ovs="
	   - sets 'apl'  to $$someFun(K1,K2,K3)
	   - sets 'tail' to the code following the ")"
	   */
	type String del  = "S "_ovs_"="
	type String exp
	type Number apn,ptr
	type Number ER=0	// required by nextExpr^UCGM()

	set head = mp1.piece( del, 1, occ)
	set tail = mp1.extract( head.length() + del.length() + 1, mp1.length())

	for ptr=1:1:tail.length(")") set exp =tail.piece(")",1,ptr)_")" quit:exp.length("(")=exp.length(")")
	set tail=tail.extract(exp.length() + 1, tail.length())

	/* The code below
	   - sets label to someFun
	   - sets exp   to K1,K2,K3
	   */
	set lbl = exp.piece( "(").extract( 3, exp.length())
	set exp = exp.extract( lbl.length() + 4, exp.length() - 1)

	kill apl		// in case caller provided a "used" array
	if exp.isNull() quit

	set apn = 0, ptr = 0

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	for  set del = $$nextExpr^UCGM( exp, .ptr, "", 1, 0) do { quit:'ptr
		if del="," quit
		set apn = apn + 1, apl( apn) = del
	}
	quit

	// ---------------------------------------------------------------------
private insOptAA( Number decPos,	// declaration position
		String apl())		// actual parameter list
	/* ---------------------------------------------------------------------
	Support function that creates a list of assignments that includes all
	key purpose variables that are used to be APPENDED to instantiation
	assignement. The value of the n-th actual parameter is assigned to the
	n-th key purpose variable.

	OUTPUT:
	. $$ = assignment list, starting with a comma, or "" if no assignments
		need to be made (no keys used)

	NOTES:
	. the return value can unconditionally be appended to a previous
		assignment (e.g. to the Record instance variable).
	*/
	type public String dbAcc(,,)

	type String asn = ""
	type Number key
	type Number nod

	for key=1:1:apl("").order(-1) do {
		set nod = -key-2
		if 'dbAcc( "*", decPos, nod).exists() quit
		if 'apl(key).exists() quit		// absent optional key
		set asn = asn_ ","_ dbAcc( "*", decPos, nod)_ "="_ apl( key)
	}
	quit asn

	// ---------------------------------------------------------------------
private insOptAP( Number decPos,	// declaration position
		String apl())		// actual parameter list	/MECH=REFARR:RW
	/* ---------------------------------------------------------------------
	Support function that creates a list of assignments that includes all
	key purpose variables that are used to be PREPENDED to instantiation
	assignement. The value of the n-th actual parameter is assigned to the
	n-th key purpose variable, and the n-th actual parameter is replaced by
	the n-th key purpose variable, unless the actual parameter is on of
	(variable, literal, M svn).

	OUTPUT:
	. $$ = assignment list, ending with a comma, or "" if no assignments
		need to be made (no keys used)
	. apl(n) = vopKn

	NOTES:
	. the return value can unconditionally be prepended to an exisiting
		assignment (e.g. to the Record instance variable).
	*/
	type public String dbAcc(,,)

	type String asn = ""
	type Number key
	type Number nod
	type PSLExpression val

	for key=1:1:apl("").order(-1) do {
		set nod = -key-2
		if 'dbAcc( "*", decPos, nod).exists() quit
		if 'apl(key).exists() quit		// absent optional key
		set val = apl( key)
		set asn = asn_ dbAcc( "*", decPos, nod)_ "="_ val_ ","
		if val.isVariable() quit		// don't replace VAR
		if val.isLiteral() quit			// don't replace literal
		if val.extract()=0.char(),val.extract( val.length())=0.char(),val.extract(2,val.length()-1)?1.N quit  // tokenized literal

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if $$isSys^UCGM( val) quit		// don't replace M svn
		set apl( key) = dbAcc( "*", decPos, nod)
	}
	quit asn

	// ---------------------------------------------------------------------
private insOptCa( PSLTable td,		// table descriptor
		String srn,		// subroutine
		PSLIdentifier ovs,	// object variable
		Number ins,		// instantiation position
		String insDes,		// instantiation descriptor
		String lbl,		// pass 1 label
		String apl(),		// pass 1 actual parameter list
		String head,		// code preceding S ovs=$$lbl(apl)
		String tail)		// code following S ovs=$$lbl(apl)
	/* ---------------------------------------------------------------------
	Optimize Cache.getRecord()
	INPUTS:
	. append(lbl)
		This code is accessed directly to find the call to $$vRCgetRecord()
		and replace it by its no-object counterpart.
	NOTES:
	. This code has been derived from Cache^UCPATCH.
	*/
	type literal String SEP = 9.char()
	type literal String PREFIX = "vRCgetRecord"

	type public String append(,)
	type public String dbAcc(,,)

	type Number lnr = ""	// line number iterator in append(,)
	type String vdbCod	// line in append(,)
	type String vdbApl()	// actual list of $$vDbN() in append(,)
	type String vdbDes	// "instantiation" descriptor for vDb in append
	type String vdbLbl	// label of $$vRCgetRecord() in append(,)

	for  set lnr = append( lbl, lnr).order() quit:lnr=""  do {
		if append( lbl,lnr) '[ PREFIX quit
		/* get label and actual parameter list for call to insOptDb()
		   force syntax that is expected by insCod (in particular
		   " S "_ovs)
		   */
		do insCode( " S vOid=$$"_ PREFIX_ append( lbl, lnr).piece(PREFIX, 2), "vOid", 1, .vdbLbl, vdbApl())

		set vdbDes = insDes
		set vdbDes.piece( SEP, 5) = "Db.getRecord("""_ td.table_""","""",1)"

		/* FSCW CR20280: Code below may not work if -152 node is needed
		   */
		set vdbCod = $$insOptDb( td, lbl, "vOid", ins, vdbDes, vdbLbl, vdbApl(), "", "")

		/* Extract the call from the generated code. Note that insCode()
		   cannot be called, because the code retruned by $$insOptDb()
		   may not contain the expected pattern (..." S "_ovr_"="...)
		   */
		set vdbLbl = vdbCod.piece( "vOid=",2).piece( "(")
		set lnr=999
	}

	/* Extract the instantiator variable from the instantiation expression.
	   Because this can be a subscripted var with literals use TOKEN/UNTOK
	   to find the correct separator.
	   Also extract the classNew parameter, because it must be passed to
	   CachSr^UCDB, and added to the subroutine comment.
	   */
	type String expr = insDes.piece( SEP, 5)
	type String tsl
	type Number dflt = $$getRecCN^UCDB( $$getPar^UCPATCH( expr, 3))
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set expr = $$TOKEN^%ZS( expr, .tsl).piece(".getRecord(")

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set expr = $$UNTOK^%ZS( expr, .tsl)

	type String cmt   = "voXN = ({Cache}"_ expr_ ".getRecord("_ td.table_ ","_ dflt_ ")"

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String p2lbl = $$findSubr^UCGM( "vCa", cmt)
	
	if 'PSL.subrouExists( p2lbl) do CacheSr^UCDB( td, 0, p2lbl, cmt, expr, dflt, vdbLbl)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do decrLabel^UCGM( lbl)		// decrement reference count old label

	/* Update the apl() array by calling $$insOptAP() and append this part
	   to head. */
	type Number dec = insDes.piece( SEP, 2)

	set head = head_ "S "_ $$insOptAP( dec, apl())
	set p2lbl = "$$"_ p2lbl_ "("_ $$insApa2Apl(apl())
	
	/* Add special purpose node actual parameters */
	//set p2lbl = p2lbl_ $$getOptApl(td, dec)
	/* Add code that sets -2 lvn as part of call if it is used */
	if dflt=1 set:'p2lbl.endsWith("(") p2lbl = p2lbl_ "," set p2lbl = p2lbl_ "."_ dbAcc("*", dec, -2)
	
	set p2lbl = p2lbl_ ")"

	do setInsCall( srn, ovs, ins, p2lbl)

	/* If -2 lvn not part of the call (dflt=0), but used, add code that
	   sets it to 1 */
	type String xnods = ""
	if dflt = 0, dbAcc("*", dec, -2).exists() set xnods = ","_ dbAcc("*", dec, -2)_ "=1"

	quit head_ ovs_  "="_ p2lbl_ xnods_ tail

	// ---------------------------------------------------------------------
private insOptCl( PSLTable td,		// table descriptor
		String srn,		// subroutine
		PSLIdentifier ovs,	// object variable
		Number ins,		// instantiation position
		String insDes,		// instantiation descriptor
		String lbl,		// pass 1 label
		String apl(),		// pass 1 actual parameter list
		String head,		// code preceding S ovs=$$lbl(apl)
		String tail)		// code following S ovs=$$lbl(apl)
	/* ---------------------------------------------------------------------
	Optimize Class.new()

	Replace the assignment to the Record record instance variable through
	the call to $$vRCnew^RecordTABLE() by a direct assignment of "", and
	append the assignment(s) to key purpose variables if they occur.

	Note that this optimization can only be applied to RDB tables, if the
	filer can be bypassed on save, and if it can be applied, it can use the
	same code as for an MDB table.

	NOTES:
	. This subroutine is derived from getRecNew^UCPATCH(). For MDB tables,
		the code generated here is identical to the code generated by
		getRecNew^UCPATCH.
	. This subroutine could be modified to discard assignments of "" to key
		purpose noded.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	/* Add code that sets -2 lvn (to 1) if it is used) */
	type Number dec   = insDes.piece( SEP, 2)
	type String xnods = ""
	if dbAcc("*", dec, -2).exists() set xnods = ","_ dbAcc("*", dec, -2)_ "=0"

	quit head_ "S "_ ovs_ "="""""_ $$insOptAA( dec, apl())_ xnods_ tail

	// ---------------------------------------------------------------------
private insOptCp( PSLTable td,		// table descriptor
		String srn,		// subroutine
		PSLIdentifier ovs,	// object variable
		Number ins,		// instantiation position
		String insDes,		// instantiation descriptor
		String lbl,		// pass 1 label
		String apl(),		// pass 1 actual parameter list
		String head,		// code preceding S ovs=$$lbl(apl)
		String tail)		// code following S ovs=$$lbl(apl)
	/* ---------------------------------------------------------------------
	Optimize Record.copy()
	
	This optimization needs to distinguish 2 cases
	- Copy the same record type when the target is optimized, and the source
		is not
	- Copy different record types when the target is optimized, and the
		source is not

	NOTES:
	. The code in this subroutine is derived from Copy^UCPATCH,
		CopyDiff^UCPATCH, and CopySame^UCPATCH.
	. This subroutine directly modifies the code in the append(,) array.
		It relies on the fact that each Record.copy() occurrence ends
		up in a separate subroutine, and a well-defined distinction in
		the text of the comment to differentiate between copy-to-same
		and copy-to-different
	. Because all optimizations are "target driven", there is a fundamental
		problem when the source of a copy is optimized and the target is
		not. The optimization loop will skip that target because it is
		not optimized. However, the generated code will call a function
		that expects an object ID as parameter, not the object's data
		value.
		The only way to prevent this, is to disable optimization of the
		source of the copy. The side effect of doing that is that a
		construct like
			set savObj = origObj.copy()
			(... code ...)
			set origObj = savObj.copy()
		will effectively turn off optimization of both instances
	*/
	type literal String SEP = 9.char()

	type public String append(,)
	type public String dbAcc(,,)
	type public PSLColumn pslCln()

	type String cod		// code line being modified
	type Number decPos = insDes.piece( SEP, 2)
	type Number ln		// line iterator

	/* Find the line that has the label (does not start with SPACE */
	for ln=1:1 quit:append(lbl,ln).translate(9.char()," ").extract()'=" "

	set cod = append(lbl,ln)
	if cod.piece(";",2) [ " to: " do {
		/* copy-to-different
		   - assumes that the target object reference will be vobj(vOid)
		   - assumes that the temporary local variable will be vRec, and
			that this local variable will be used for the
			construction of the target object
		   - assumes that the subroutine has a single exit: Q vOid
		   */
		type String fnd = PSL.oLvn_ "(vOid"

		for  set ln=append(lbl,ln).order() quit:ln=""  do { set append(lbl,ln)=cod

			set cod = append(lbl,ln)

			/* replace quit vOid by quit vRec */
			if cod [ "Q vOid" set cod = " Q vRec" quit

			if cod '[ fnd quit

			/* comment out the line that generates the new object
			   ID and the line that assigned vRec to vobj(vOid) */
			if cod [ "S vOid=" set cod = " ;"_ cod quit
			if cod [ ("S "_fnd_")=") set cod = " ;"_ cod quit

			/* comment out the assignments to special purpose nodes
			   that are not used, otherwise replace with assignment
			   to purpose lvn. */
			if cod [ (fnd_ ",-") do {

				type String nod = cod.piece( fnd_ ",", 2).piece(")")

				/* For now:
				   Assignments to -150 tree are not replaced.
				   For later:
				   Because the target is optimized, it is either
				   not saved, or its save bypasses the filer. In
				   both cases, the assignments to the -150 tree
				   can be removed. However, this is not simply a
				   matter of commenting the line out because the
				   line may also contain a column assignment.
				   */
				if nod [ "-150" quit

				type String lvn = $$lvpm( decPos, nod, 0)

				/* if not used, comment out */
				if lvn = "" set cod = " ;"_ cod quit

				/* The line with the assignment to a KEY purpose
				   node may also contain a -150 assignment.
				   For now: ignore. For later: remove */
				set cod = " S "_ lvn_ "="_ cod.piece("=",2,99)
			}  /* end if special purpose node */
		}  /* end for each line */
	}  /* end if copy-to-different */
	else  do {
		/* copy-to-same
		   - Assumes that original code uses vobj(v1) to reference the
			source object
		   Because the target is optimizable, its scope must be NEW, and
		   all purpose nodes of the target that are accessed are known.
		   So there is no need to incrementally load ALL missing source
		   nodes. It is sufficient to incrementally load the missing
		   source nodes that are accessed for the target.
		   This part completely rewrites the subroutine body
		   */
		set ln=ln+1,append( lbl, ln) = " ;"

		/* Iterate over all purpose nodes in dbAcc("*", decPos, purpose)
		   and look at the lvn used for that purpose. If that lvn equals
		   the name of the target variable, then the associated source
		   node shall be specified as the function return value.
		   Otherwise, generate an assignment to that variable. */
		type String nod = ""		// purpose node iterator
		type String expr		// vobj(v1,nod) (= source)
		type String lvn			// target lvn
		type String quitNod = ""	// node for function return

		for  set nod = dbAcc( "*", decPos, nod).order() quit:nod=""  do {
			set lvn = dbAcc( "*", decPos, nod)
			if lvn = ovs set quitNod = nod quit
			if nod?1.N1"*" quit	// key-as-parameter mapping

			set cod = " S "_lvn_ "="
			set expr = PSL.oLvn_ "(v1,"_ nod_ ")"
			if nod<0 set cod = cod_ PSL.oLvn_ "(v1,"_ nod_ ")"
			else  if nod.extract() = "~"  set cod = cod_ PSL.oLvn_ "(v1,-300,"_ nod.extract( 2, nod.length()).addQuotes()_ ")"
			else  if nod.extract() = "*" { // blob or memo
				/* Use 2 lines: First line ensures that node is
				   loaded. Second line can then use unconditional
				   assignment. */
				set ln = ln + 1, append( lbl, ln) = td.getLoadCode( "v1", nod, -1, 1)
				type PSLColumn cd = PSL.cachePSLColumn( pslCln(), td.table_ "."_ nod.extract( 2, nod.length()))
				set cod = cod_ cd.getCurrentLvn( "v1")
			}
			else  set cod = cod_ "$S($D("_ expr_ "):"_ expr_ ",1:"_ $$getDataNode^UCXDD( td, "v1", nod, 0)_ ")"

			set ln = ln + 1, append( lbl, ln) = cod
		}

		/* Add code to return the function value.
		   If quitNod.isNull(), not a single node in the copied object
		   is referenced. Even though this is a weird case, the compiler
		   needs to return a value, so:
		   - use the same node that Db.getRecord() will use
		   - if there is no such node just return "". */
		if quitNod.isNull() set quitNod = $$getRecPur^UCXDD( td)
		if quitNod.isNull() set cod = " Q """""
		else  if quitNod = "0*" set cod = " Q "_ PSL.oLvn_ "(v1)"
		else  set expr = PSL.oLvn_ "(v1,"_ quitNod_ ")", cod = " Q $S($D("_ expr_ "):"_ expr_ ",1:"_ $$getDataNode^UCXDD( td, "v1", quitNod, 0)_ ")"

		set ln = ln + 1, append( lbl, ln) = cod

		/* remove remaining pass 1 code */
		for ln=ln+1:1 quit:'append(lbl,ln).exists()  kill append(lbl,ln)
	}  /* end else copy-to-same */

	quit head_ "S "_ovs_ "=$$"_ lbl_ "("_ apl(1)_ ")"_ tail

	// ---------------------------------------------------------------------
private insOptDb( PSLTable td,		// table descriptor
		String srn,		// subroutine
		PSLIdentifier ovs,	// object variable
		Number ins,		// instantiation position
		String insDes,		// instantiation descriptor
		String lbl,		// pass 1 label
		String apl(),		// pass 1 actual parameter list
		String head,		// code preceding S ovs=$$lbl(apl)
		String tail)		// code following S ovs=$$lbl(apl)
	/* ---------------------------------------------------------------------
	Optimize Db.getRecord()

	The following cases are distinguished:
	- If no special nodes are accessed, and a ClassNew value
		of 1 is specified, then the function call can be replaced by
		the $GET(gvn) (for MDB) or $$wrXXXX^UCDBRT() (for RDB). This is
		achieved by calling $$getDataCode^UCXDD(,,,0,) using the actual
		parameters as "key variables".
	- In all other cases replace the call to the appropriate vRCgetRecord*()
		method in the RecordTABLE class.

	NOTES:
	. There are some differences between the code generated before CR18163,
		and the code introduced by that CR. Most differences are due to
		the extension of the vobj-to-voxn optimization to RDB tables.
		The following differences are noted:
		- Before CR18163 assignments to the -2 special purpose variable
			were either ignored, or implemented inside vDbN(). Both
			treatments were incorrect (because vDbN() can be called
			from different places, using different -2 lvns). As of
			CR18163, values of the -2 (and the -151) purpose nodes
			are passed through additional (output) parameters on the
			vDbB() call, but only if they are needed for the
			declaration being optimized. This results in 4 different
			versions of optimized vDbN() calls.  As of CR29295, purpose
			node -152 is included and -151 removed, since the WHERE
			clause is now pre-built using host variables and -152
			used to track the host variable value list for the WHERE
			clause.
		- Before CR18163 if a recordType 10 table with existsNode IS NULL
			was accessed, loading the first data node into the record
			variable would occur as the return value from the call
			to $$vDbN(). As of CR18163 the return value from the call
			will be "" in that case, and the data node needs to be
			loaded incrementally as per vobj() use. The "cost" of
			this change is one extra assignment (of "") to the record
			variable.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)
	
	if 'lbl.beginsWith("vRCgetRecord") do pass2Err(ins, "Unexpected label '"_lbl_"' for Db.getRecord()") quit ""

	type String expr = insDes.piece( SEP, 5)
	type Boolean dflt = $$getRecCN^UCDB( $$getPar^UCPATCH( expr, 3))
	type Number i
	type String mcode = head

	set mcode = mcode_ "S "

	type String decPos = insDes.piece( SEP, 2)
	type String nod    = dbAcc( "*", decPos, "").order()

	/* If Db.getRecord(,,1), no access rights, and no special purpose nodes
	   (nod'<0), then replace by direct retrieval. This covers keys and RDB
	   special cases as well. */
	if dflt = 1, nod '< 0, td.checkAccessRights(false)'["select", 'PSL.hasSetting("DEBUG","DBIOCOUNT") set mcode = mcode_ ovs_ "="_ $$insOptNoVDB( td, decPos, apl())
	else  do {
		
		/* Get actual parameters for special purpose nodes.
		   Note that the order of setting optparams and aparams
		   is important, since insOptAP may modify apl() */
		type String xnods = $$getOptApl(td, decPos)
		type String optparams = $$insOptAP( decPos, apl())
		type String aparams = $$insApa2Apl(apl())
		
		if aparams.isNull() set aparams = xnods
		else  set aparams = aparams_ ","_ xnods
		
		set mcode = mcode_ optparams_ ovs_ "=$$"_ lbl.piece("^", 1)_ "Opt^"_ lbl.piece("^", 2)_ "("_ aparams_ ")"
	}

	quit mcode_ tail

	// ---------------------------------------------------------------------
private insOptDs( PSLTable td,		// table descriptor
		String srn,		// subroutine
		PSLIdentifier ovs,	// object variable
		Number ins,		// instantiation position
		String insDes,		// instantiation descriptor
		String lbl,		// pass 1 label
		String apl(),		// pass 1 actual parameter list
		String head,		// code preceding S ovs=$$lbl(apl)
		String tail)		// code following S ovs=$$lbl(apl)
	/* ---------------------------------------------------------------------
	Optimize DbSet.getRecord()

	Before CR18163 the call to $$vDbN() for a DbSet.getRecord() was
	completely replaced by inline code, based on the following observations:
	-  can elimate view query and defined test because keys come directly
	   from the result table (that satisfy the view query).

	As of CR18163 a similar approach is taken:
	- If an assignment to -152 is needed, treat as Db.getRecord()
	- Else, if an (unlikely) assignment to -2 is needed, add code that sets
		that lvn to 1 (existing record)
	- Replace call to $$vDb() by call that retrieves initial node, and
		 move assignments to keys into inline code.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String decPos = insDes.piece( SEP, 2)
	type String mcode, mid

	if dbAcc( "*", decPos, -152).exists() ! PSL.hasSetting("DEBUG","DBIOCOUNT") quit $$insOptDb( td, srn, ovs, ins, insDes, lbl, apl(), head, tail)
	if dbAcc( "*", decPos,   -2).exists() set tail = ","_ dbAcc("*", decPos, -2)_ "=1"_tail

	if 'lbl.beginsWith("vRCgetRecord") do pass2Err(ins, "Unexpected label '"_lbl_"' for DbSet.getRecord()") quit ""
	
	// Transform before build aparams
	set mid = $$insOptAP( decPos, apl())
	
	/* Get actual parameters for special purpose nodes.
	   Note that the order of setting optparams and aparams
	   is important, since insOptAP may modify apl() */
	type String xnods = $$getOptApl(td, decPos)
	type String optparams = $$insOptAP( decPos, apl())
	type String aparams = $$insApa2Apl(apl())
		
	if aparams.isNull() set aparams = xnods
	else  set aparams = aparams_ ","_ xnods
	
	quit head_ "S "_ mid_ ovs_ "=$$"_ lbl.piece("^", 1)_ "Opt^"_ lbl.piece("^", 2)_ "("_ aparams_ ")"_ tail

	
	// ---------------------------------------------------------------------
private insOptNoVDB( PSLTable td,	// table descriptor
		Number decPos,		// declaration position
		String apl())		// pass 1 actual parameter list
	/* ---------------------------------------------------------------------
	Support function that returns the inline code to retrieve the initial
	node without a call to $$vRCgetRecord().

	NOTES:
	. This function is the DBI equivalent of $$diref^UCPATCH() before CR18163
	*/
	type Number i
	type String lvpm()
	type String nod = $$getRecPur^UCXDD( td)

	// No initial load: assign empty string
	if nod.isNull() quit """"""

	// build key purpose nodes that use actual parameters
	for i = 1:1:apl("").order(-1) set lvpm( i_"*") = apl(i)
	
	quit $$getDataNode^UCXDD( td, decPos, nod, 0, lvpm())

	// ---------------------------------------------------------------------
private isAutoLoad( Number purPos)	// Purpose identifier
	/* ---------------------------------------------------------------------
	Helper function that returns 1 if the purpose identifier represents a
	node that is automatically loaded, and returns 0 otherwise.

	The following nodes are considered AutoLoad:
	- 0* (top node)
	- 1*, etc. (explicit key overrides!)
	- negative nodes
	- PSLTable.existsNode, provided PSLTable.recordType = 10

	NOTES:
	. Key column purpose nodes, generated for column access in PSL source
		code will have called 
			$$lvpm(decPos, PSLColumn.getCurrentNode(),1)
		This will create purpose nodes using the (negative) subscript of
		the node in vobj(,).
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)
	type public PSLTable pslTbl()
	type static PSLClass

	type String data = dbAcc( "*", "<", purPos)
	type String pur = data.piece( SEP, 2)

	if data.piece(SEP, 2)?1.N1"*"	quit 1	// top node and keys AutoLoad
	if pur.toNumber() < 0		quit 1	// other neg nodes are AutoLoad
	if pur?.E1","1.N		quit 0	// blob/memo never AutoLoad

	/* Need to get table descriptor (using declaration) */
	type Number decPos = data.piece( SEP)
	set data = dbAcc( "*", "*", decPos)

	type String sr = data.piece( SEP)
	type PSLIdentifier nam = data.piece( SEP, 2)

	set data = dbAcc( sr, nam, decPos)

	type String tbl = PSLClass.tableNameOf( data.piece( SEP))

	
	type PSLTable td = PSL.cachePSLTable( pslTbl(), tbl, 0)

	if td.recordType'=10 quit 0

	quit pur=td.existsNode

	// ---------------------------------------------------------------------
private isDec( String data,	// dbAcc(,,) data string
		Number pos)	// the position value
	/* ---------------------------------------------------------------------
	Helper function that returns 1 if the data at the specified position
	represents a declaration, and returns 0 otherwise.
	*/
	type literal String SEP = 9.char()

	type Number dpd = data.piece( SEP, 2)

	if dpd.isNull() quit 1		// standard dec
	if dpd = pos quit 1		// combined dec/ins
	quit 0

	// ---------------------------------------------------------------------
private isDoScope( String outer,	// outer scope doState
		String inner)		// inner scope odState
	/* ---------------------------------------------------------------------
	Helper function that returns 1 if either
	- outer = inner
	- inner.endsWith(outer) and the overlap is at a true block boundary
	*/
	if inner = outer quit 1

	type Number diff = inner.length() - outer.length()
	if inner.extract( diff) = "," quit inner.endsWith( outer)
	quit 0

	// ---------------------------------------------------------------------
private isIns(	String data)	// dbAcc(,,) data string
	/* ---------------------------------------------------------------------
	Helper function that returns 1 if the data at the specified position
	represents an instantiation, and returns 0 otherwise.
	*/
	type literal String SEP = 9.char()

	if data.piece( SEP, 2).isNull() quit 0	// standard dec
	quit data.piece( SEP, 4).isNull()	// standard ins

	// ---------------------------------------------------------------------
private ldMap( Number ldMode,		// load mode (1 or 2)
		String ldMap())		// incremental load mapping (*2)
	/* ---------------------------------------------------------------------
	Derive the incremental load mapping from the access index.

	ARGUMENTS:
	. ldMap() = output array
		ldMap( loadPos) = rmd, exs, cache, purList with:
		- loadPos = load position, which is either and access position
			or an instantiation position
		- rmd = record mode to be passed to PSLTable.getLoadCode()
		- exs = exists flag to be passed to PSLTable.getLoadCode()
		- cache = insPos of Cache.getRecord() that can be used for this
			incremental load.
		- purList = List of purpose positions that need to be loaded at
			this position.

	INPUTS:
	. dbAcc("*","@", accPos)
		This part of the dbAcc(,,) array contains all access occurrences

	NOTES:
	. The access occurrence index is the index with the finest granularity.
		It can be used for both load modes.
	. The section in this subroutine that reduces load4(,,,) to ldMap() uses
		the following knowledge about the code that will be returned by
		PSLTable.getLoadCode():
		- MDB and RDB incremental load code use the -2 purpose node if
			the record mode is unknown at compile time (to prevent
			unnecessary DB API calls and to prevent NULL SUBSCRIPT
			exceptions at runtime (new object, with missing keys)).
		- RDB incremental load code for blob/memo requires the -152
			purpose node, whereas incremental load code for wide
			tables behaves like MDB incremental load code, that uses
			the key purpose lvns (voXN) or "current keys" (vobj).
	*/
	type literal String SEP = 9.char()

	type public String    dbAcc(,,)
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()
	type static PSLClass

	type Number acc,accMin,elm,pur
	type String accDes,accState,data,expr,nod,ovs,sr
	type String load4(,,,,)		// first round, four level map

	/* Build the array with load positions per do-block. Only one load
	   position per instantiation per do block is needed, determined by the
	   lowest access position found for that triple. */
	set acc = ""
	for  set acc = dbAcc( "*", "@", acc).order() quit:acc=""  do {
		set data = dbAcc( "*", "@", acc)
		set sr = data.piece( SEP), ovs = data.piece( SEP, 2)
		set expr  = dbAcc( sr, ovs, acc).piece( SEP, 5)
		if '$$isWrap( expr) do {	// not yet wrapped
			/* could be method invocation "access" */
			if '$$expIsCln(expr) quit

			/* Must be column, get its purPos (except if computed)
			   */
			type PSLColumn cd = PSL.cachePSLColumn( pslCln(), expr, pslTbl())

			if 'cd.computation.isNull() quit

			/* If RDB Master, then we need to replace the descriptor
			   by a descriptor of one of the subfields, because the
			   RDB Masterfield does not specify a node.
			   Note that this assume that:
			   - all subfields reside on the same node
			   - the table is not a temporary table (because its
				definition will no longer exist, and
				PSL.getPSLColumn() will fail)
			   */
			if cd.masterfieldType = 2 do {
				type String sfd()
				type String dummy = $$getSfd^UCXDD( cd.table, cd.column, sfd()))
				type Row sf = sfd(1).toRow( "#$$getSfdRT^UCXDD()")
				set cd = PSL.getPSLColumn( cd.table, sf.di)
			}

			// tbd: if keycolumn AND assignment AND MDB table
			// AND possibly existing node, force load positions for
			// all data purpose nodes if existing node.

			set nod = cd.getCurrentNode(1)
			if nod?.E1","1.N set nod = "*"_ cd.column
			set expr = $$lvpm( dbAcc( sr, ovs, acc).piece( SEP, 2), nod, 1)
		}

		if '$$isWrap(expr) quit		// not a purPos (eg computed)
		set pur = expr.extract(2, expr.length() - 1)

		if $$isAutoLoad( pur) quit	// discard if AutoLoad node

		/* Because the load code will preceed the access, the load code
		   for an access in conditional code will effectively load in
		   the DO-block of the line in which the access occurs, and thus
		   serve as a load point for other access occurrences in that
		   DO-block as well. To take advantage of this:
		   a) pop one stack level if in iterative code
		   b) pop one stack level if in conditional code
		   c) use that DO-stack value in the call to ldMap4Acc()
		   tbd: may not work if instance var is subscripted (subscript
		   may be used as iterator ) !!!!
		   */
		set accDes = dbAcc( sr, ovs, acc)
		set accState = $$new^UCPSLST( accDes.piece( SEP, 7), accDes.piece( SEP,8), accDes.piece( SEP, 9))
		if $$topFor^UCPSLST( accState) do pop^UCPSLST( .accState)
		if $$topIf^UCPSLST( accState)  do pop^UCPSLST( .accState)

		/* Add purpose node of this access either to the instantiation
		   or to the access. Use $$ldMapMode() to calculate the
		   appropriate value. */
		if $$ldMapMode(ldMode, sr, ovs, accDes)=1 do ldMap4Ins( load4(,,,), pur, acc, $$getDo^UCPSLST(accState), accDes.piece( SEP, 4)) quit
		do ldMap4Acc( load4(,,,), pur, acc, $$getDo^UCPSLST(accState), accDes.piece( SEP, 4))
	}

	/* At this point load4(,,,) contains the results of calling ldMap4Acc()
	   and/or ldMap4Ins(). This 4 level structure can be reduced to a 1
	   level structure ldMap(pos), with 'pos' either an insPos or an accPos.
	   The applicable values of RecordMode and ExistsCheck can and will be
	   derived here as well. Furthermore, the resulting structure will also
	   contain an indicator that Cache.getRecord() can be used. */
	type Number pos, s1=""

	for  set s1 = load4(s1).order() quit:s1.isNull()  do {
		if dbAcc( "*", "=", s1).exists() set pos = $$ldMap1Ins( ldMap(), load4(,,,), s1)
		else  set pos = $$ldMap1Acc( ldMap(), load4(,,,), s1)

		/* Allocate lvns for special purpose nodes that are effectively
		   used for incremental loading (-2, -99 and -152). Do not allocate
		   lvns for purpose nodes that are not used, because lvns
		   allocated here will impact the code generated for voXN
		   optimization.
		   See NOTES in subroutine header for considerations.

		   For all tables with unknown mode (rmd=-2) the -2 node will be
		   used.
		   Use the first purpose position get to the declaration, to get
		   the table, to get the PSLTable descriptor (...).
		   */
		set pur = ldMap( pos).piece( SEP, 4).piece(",")
		type Number dec = dbAcc( "*", "<", pur).piece( SEP)
		if ldMap( pos).piece( SEP) = -2 set expr = $$lvpm( dec, -2, 1)
		
		type String des = $$getByPos( "*", dec)
		type PSLTable td = PSL.cachePSLTable( pslTbl(), PSLClass.tableNameOf( des.piece( SEP)), 1)
		
		if 'td.getArchiveTable().isNull() set expr = $$lvpm( dec, -99, 1)

		if 'Runtime.isRdb quit	// no extras for MDB inc load

		/* For RDB tables with blob or memo, both -152 and -2 are used.
		   For RDB wide tables with known mode, no special purpose nodes
		   need to be allocated. However for RDB tables with rmd=-1
		   the -2 node will be used to prevent calls to the API.
		   */

		if 'td.isRdb quit		// MDB table in RDB environment

		if ldMap( pos).piece( SEP) = -1 set expr = $$lvpm( dec, -2, 1)
		if td.hasBlob!td.hasMemo set expr = $$lvpm( dec, -2, 1), expr = $$lvpm( dec, -152, 1) quit
	}

	quit

	// ---------------------------------------------------------------------
private ldMap1Acc( String ldMap(),	// ouput load map (1 level)	/MECH=REFARR:RW
		String load4(,,,), 	// input load map (4 levels)	/MECH=REFARR:R
		Number pur)		// purpose position
	/* ---------------------------------------------------------------------
	Because load4(,,,) is organized by (pur,stk,acc), and ldMap() will be
	organized by acc only, successive calls for different purpose node
	entries can be collapsed into a single access position when they share
	the same "line" (acc\1).
	However, a single line could be the load point of several different
	declarations. The different declarations will be coded in the load4()
	"automatically" because they have different purpose nodes. So when the
	purpose node no longer appears in the subscript, the code in this
	subroutine will need to ensure that it only collapses access positions
	that share the same declaration.
	The 'stk' subscript in the array was useful to calculate the load
	positions, but the repeated calls to ins2me() require strict increasing
	values of accPos. So load4(pur,stk,acc,ins) is re-organized into
	load2(acc,ins), which does not loose information as the 'stk' value
	is completely dependent on accPos, and 'pur' is constant for this call.

	If there are multiple load points for the same purpose node, then this
	means that the node is accessed in multiple do-blocks. Once we get into
	this subroutine, these do-blocks are either disjunct, or the node is
	used in a conditional-block and after that block.
	Example of disjunct blocks:
		if cond {
			node needed here
		}
		esle {
			node needed here
		}
	Example of conditional blocks:
		if cond {
			node needed here
		}
		node needed here too

	Furthermore a line could serve as the load point for an instantiation
	and for an access. So ldMap(acc\1:acc+1\1) may contain instantiation
	positions and access positions.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type Number acc,accLine,cc,cci,des,des2,exs,ins,pos,rmd,srn
	type String stk, load2(,)

	set (acc,stk,ins) = ""
	for  set stk = load4(pur, stk).order() quit:stk=""  {
		for  set acc = load4(pur, stk, acc).order() quit:acc=""  {
			for  set ins = load4(pur, stk, acc, ins).order() quit:ins=""  set load2( acc, ins) = ""
		}
	}

	/* Iterate over load2().
	   To be on the save side, exs and rmd are initialized here.
	   This basically implies that the incremental load code in the second
	   disjunct do-block is less optimial (it may have exs=true when it
	   could have exs=false). But it ensures that in all other cases the
	   effect of potentially having loaded the node will be fully considered
	   in the "later" loads.
	   */
	set (acc,exs,rmd) = ""
	set pos = dbAcc( "*", "<", pur).piece( SEP)
	set des = dbAcc( "*", "*", pos).piece( SEP)	// subroutine and var

	for  set acc = load2( acc).order() quit:acc=""  do {
		/* Find the access position to use in ldMap().
		   Compare the subroutine / ovs at pos with the one of
		   the declaration associated with the purpose position.
		   Use .get() to deal with case that pos is an insPos.
		   */
		set (pos,accLine) = acc\1
		for  set pos = ldMap( pos).order() quit:(pos\1)'=accLine  quit:dbAcc( "*", "@", pos).get()=des

		if (pos\1) '= accLine set pos = acc

		/* If existing position, it is sufficient to add the
		   purpose position (the other values must be identical)
		   */
		if ldMap(pos).exists() set ldMap( pos) = ldMap( pos)_ ","_ pur quit

		/* New access position, calculate record mode, exists
		   flag, and cacheCall.
		   The current version of ins2me returns the Name of the
		   cacheCall. However, because ldMap1Acc() will be
		   called before optimization is applied, the Name could
		   change, and it must be translated to an insPos.
		   See above about not initializing rmd and exs.
		   */
		//set (rmd,exs,cc,cci,ins)=""
		set (cc,cci,ins)=""
		while (rmd'=-2) set ins = load2( acc, ins).order() quit:ins=""  do ins2me( ins, .rmd, .exs, .cc) if cci.isNull(),'cc.isNull() set cci=ins

		set ldMap( pos) = rmd_ SEP_ exs_ SEP_ cci_ SEP_ pur
	}
	quit pos

	// ---------------------------------------------------------------------
private ldMap1Ins( String ldMap(),	// ouput map (1 level)		/MECH=REFARR:RW
		String load4(,,,), 	// input load map (4 levels)	/MECH=REFARR:R
		Number ins)		// instatiation position
	/* ---------------------------------------------------------------------
	Because load4() for instantitations is organized by (ins,pur), and
	ldMap() will be	organized by ins only, this subroutine just needs to
	iterate over the pur level to construct the purList.
	The values for rmd, exs and cacheIns are taken directly from this ins.

	Again: A line could serve as the load point for an instantiation
	and for an access. So ldMap(ins\1:ins+1\1) may contain instantiation
	positions and access positions
	*/
	type literal String SEP = 9.char()

	type Number cci, exs="", rmd="", pur=""
	type String cc="", purList=""
	/* Create ldMap( ins) = rmd, exs, cache, purList
	   All purpose nodes share the same value of rmd and exs
	   */
	do ins2me( ins, .rmd, .exs, .cc)

	for  set pur = load4( ins, pur).order() quit:pur.isNull()  set purList = purList_","_pur

	if 'cc.isNull() set cc = ins
	set ldMap( ins) = rmd_ SEP_ exs_ SEP_ cc_ SEP_ purList.extract(2, purList.length())

	quit ins

	// ---------------------------------------------------------------------
private ldMap4Acc( String purByDo(,,,), 	// load map array	/MECH=REFARR:RW
		Number pur,			// purpose identifier
		Number acc,			// access position
		String accDo,			// DO stack at access position
		List insList)			// applicable instantiations
	/* ---------------------------------------------------------------------
	Add load map entries for specified combination.

	For each instantiation ins in insList
	- If ins < accMin, then the instantiation is already covered
		by the load at accMin, so assume it will be stored there
	- Else assume it will be loaded at accPos.
	- In addition, check if there is already a load point in an
		outer block. If so, and that load point follows the
		instantiation, store it there.
	- Furthermore, collapse all access positions on the same line
		(i.e. if purByDo(pur,stk,acc1)) exists with acc1\1 = acc\1,
		then use the aleady existing one).
	
	INPUTS:
	. purByDo(,,,) = entries that are already defined

	OUTPUTS:
	. purByAcc(,,,ins) = ""
		Inserted for the applicable tiple (pur, loadDo, loadPos) for
		each ins in insList.

	NOTES:
	. When the instantiation comes from a Record.copy(), then all nodes
		that are accessed will be loaded by the $$vReCpN() function
		See also insOptCp() and copy^UCRECORD.
	. When ldMode=2, the loadDo and loadPos subscripts of purByDo()
		are irrelevant, because the load code will be completely tied
		to the instantiation.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)
	type static PSLClass

	type Number accMin = purByDo( pur, accDo, acc).order(-1)

	if accMin.isNull() set accMin = acc

	type Number elm
	for elm = 1:1:insList.count() do {
		type Number ins = insList.elementAt( elm)
		type String cls = $$getByPos( "=", ins).piece( SEP)

		/* If the instantiator class is RecordXYZ, then this must be
		   a Record.copy() instantiation */
		if PSLClass.isRecord( cls) > 0 quit

		type String outer   = 0		// start with non-NULL value !!
		type String loadDo  = accDo	// assume in supplied block
		type Number loadPos = $SELECT(ins<accMin:accMin, 1:acc)
		while 'outer.isNull() do {
			set outer = purByDo(pur, outer).order()
			/* Condition below will also take care of outer.isNull()
			   */
			if '$$isDoScope(outer,accDo) quit
			type Number outerMin = purByDo( pur, outer, acc).order(-1)
			if outerMin > ins set loadDo = outer, loadPos = outerMin, outer = ""
		}

		/* Instantiation and access on same line is not (yet) supported
		   for incremental loading.
		   However ignore if ins.insExpr.isNull(), because this is most
		   likely a case of parameter passing.
		   Note that each parameter receives a separate position. So it
		   will be hard to tell if an access following the instantiation
		   is just the next actual parameter or a reference after the
		   call. */
		if (loadPos\1) = (ins\1), loadPos > ins do {
			type String insDes = $$getByPos( "=", ins)
			if insDes.piece( SEP,5).isNull() quit
			do pass2Warn( ins, "DATABASE", "Instantiation and access on same line may cause unexpected results for "_dbAcc("*","=",ins).piece(SEP,2))
		}

		/* The line where the incremental load needs to be inserted is
		   equal to acc\1. If there is already a purByDo() entry for
		   that line, it will be used. */
		set accMin = purByDo( pur, loadDo, loadPos\1).order()
		if (loadPos\1) = (accMin\1), loadPos '= accMin set loadPos = accMin

		set purByDo( pur, loadDo, loadPos, ins) = ""
	}
	quit

	// ---------------------------------------------------------------------
private ldMap4Ins( String insByPur(,,,), 	// load map array	/MECH=REFARR:RW
		Number pur,			// purpose identifier
		Number acc,			// access position
		String accDo,			// DO stack at access position
		List insList)			// applicable instantiations
	/* ---------------------------------------------------------------------
	Add load map entries for specified combination.

	For each instantiation ins in insList
	- set insByPur( ins, pur, acc, accDo) = ""
	
	INPUTS:
	. insByPur(,,,) = entries that are already defined

	OUTPUTS:
	. insByPur(ins, pur, acc, accDo) = ""

	NOTES:
	. The insByPur(,,,) array does have 4 levels, like the purByDo(,,,)
		array, but only the ins and pur subscripts are relevant, because
		the load code will be completely tied to the instantiation.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)
	type static PSLClass

	type Number elm
	for elm = 1:1:insList.count() do {
		type Number ins = insList.elementAt( elm)
		type String cls = $$getByPos( "=", ins).piece( SEP)

		/* If the instantiator class is RecordXYZ, then this must be
		   a Record.copy() instantiation */
		if PSLClass.isRecord( cls) > 0 quit

		set insByPur( ins, pur, acc, accDo) = ""
	}
	quit

	// ---------------------------------------------------------------------
private ldMapMode( Number ldMode
		, String srn
		, String nam
		, String accDes
		)
	/* ---------------------------------------------------------------------
	Support function that returns the load mode that applies to this access.
	This is primarily determined by the supplied load mode.
	However, incremental loading of nodes of Records with FORMAL* scope can
	only occur at the instantiation that is associated with the declaration if
	- the declaration is unsubscripted
	- all access to the declaration is LOCAL (i.e not PASSED).
	The algorithm is as follows:
	- if the load mode is "at access", we are done (quit "at access")
	- else, if scope is PUBLIC return "at access"
	- else, if any of its instantiations occurs in conditional code return
		"at access"
	- else, if scope not FORMAL* return "at instantiation"
	- else, if subscripted return "at access"
	- else, if local access, return "at instantiation"
	- else, if no explicit instantiations, return "at instantiation"
	- else return "at access"

	NOTES:
	. Returning "at instantiation" for FORMAL* scope declarations without
		explicit instantiations is correct if and only if UCGM ensures
		that every occurrence of the variable as pass-by-return actual
		will be flagged as instantiation with assignmode=0.
	. In theory, if the access is tied to an instantiation other than the
		instantiation implied by the formal parameter declaration, then
		the purpose node could be loaded at that instantiation. However,
		because an access may be tied to multiple instantiations, some
		purpose nodes may occur as tied to both an instantiation and an
		access, which will make the generated code hard to understand.
		So the current algorithm forces a single load mode for all
		access tied to the declaration.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	if ldMode = 2 quit 2

	// supplied ldMode = 1 for all code below
	type String decDes = dbAcc( srn, nam, accDes.piece( SEP, 2))

	if decDes.piece( SEP, 3) = "PUBLIC" quit 2	// PUBLIC = at acc

	// check for conditional instantiations
	type List insList = accDes.piece( SEP, 4)
	type Number elm, ins
	type String insDes
	for elm=1:1:insList.count() set ins = insList.elementAt( elm), insDes = dbAcc( srn, nam, ins) if insDes.piece(SEP, 8).extract() set ldMode = 2 quit
	if ldMode = 2 quit 2				// conditional ins.

	if decDes.piece( SEP, 3) '[ "FORMAL" quit 1	// not FORMAL

	// scope = FORMAL for all code below
	if 'decDes.piece( SEP,16).isNull() quit 2	// subscripted = at acc
	if decDes.piece( SEP, 11)<0 quit 1		// local = at ins
	if decDes.piece( SEP, 11).isNull() quit 1	// no ins, implied local

	quit 2						// don't take the risc

	// ---------------------------------------------------------------------
private load( String mp1(),			// M code from pass 1 (*1)
		String load(),		// load position map (*2)
		PSLIdentifier pp2lv())	// purPos-to-localVar map (*3)
	/* ---------------------------------------------------------------------
	Add load code to mp1() array.

	ARGUMENTS:
	(*1) mp1() = M code from pass 1
		The code is supposed to be M code, with the line levels as
		indicated in dbAcc()
	(*2) load() = load position map
		The array as produced by ldMap().
		The single subscript level may contain instantiation positions
		and access positions.
	(*3) pp2lv() = purPos to local variable mapping
		The load code for an individual occurrence will create its own
		lvpm() array for access keys and other elements that are used to
		construct the load code. However, that code may itself contain
		wrapped purpose positions, that need to be translated to exprs
		that are valid at the particular load point. pp2lv() will be
		used for that purpose, and is passed to $$pur2M.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type Number occ = ""		// occurrence position iterator

	/* For each load position, in the returned array, calculate what kind
	   of load code is needed and insert it either immediately before the
	   access or immediately after the instantiation. */
	for  set occ = load( occ).order() quit:occ=""  do {
		if dbAcc( "*", "=", occ).exists() do loadIns( mp1(), occ, load(occ), pp2lv()) quit
		do loadAcc( mp1(), occ, load(occ), pp2lv())
	}
	quit

	// ---------------------------------------------------------------------
private loadAcc( String mp1(),		// pass 1 code		/MECH=REFARR:RW
		Number acc,		// access occurence
		String occDes,		// descriptor (rmd, exs, cache, purList)
		PSLIdentifier pp2lv())	// purpose-to-lvn map
	/* ---------------------------------------------------------------------
	Insert the load code for this access occurrence.

	This subroutine calculates the lvpm() overrides to pass to $$loadCode(),
	and calls that function for each purpose position in purList.
	When the occurrence is subscripted ALL purpose nodes will occur in the
	lvpm() override array. Else only the applicable key / mode variables
	will be added.

	NOTES:
	. All purpose positions can use the same lvpm() array, even if the
		access may need to load nodes from different instantiations.
		However, if different instantiations do apply, the actual
		parameters supplied to the instantiation subroutine function
		cannot be used.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)
	type public PSLTable pslTbl()
	type static PSLClass

	// decompose occDes
	type Number  rmd    = occDes.piece( SEP, 1)
	type Boolean exs    = occDes.piece( SEP, 2)
	type Number  caIns  = occDes.piece( SEP, 3)	// ins of Cache.getRec
	type List    purLst = {List}(occDes.piece( SEP, 4))

	type String  accDes = dbAcc( "*", "@", acc)	// access index
	type String        srt = accDes.piece( SEP)	// subroutine
	type PSLIdentifier nam = accDes.piece( SEP, 2)	// object variable

	set accDes = dbAcc( srt, nam, acc)		// access descriptor
	type Number dec  = accDes.piece( SEP, 2)	// declaration position

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String dots = $$initLine^UCGM( accDes.piece( SEP, 6))
	
	type String tbl  = PSLClass.tableNameOf( accDes.piece( SEP))

	if 'pslTbl(tbl).exists() set pslTbl(tbl) = PSL.getPSLTable( tbl, 0)

	// create lvpm() based on this access position and purpose list
	// tbd
	type PSLExpression lvpm()

	/* If the occurrence is a subscripted variable, then the lvMap() entries
	   for this declaration need to be modified to include the subscripts.
	   */
	type String subs = accDes.piece( SEP, 16)
	if 'subs.isNull() do loadLvpm( lvpm(), dec, subs)

	/* Add the lvpm() entries that are independent of the purpose nodes
	   */
	do loadXnodes( srt, nam, dec, subs, pslTbl( tbl).isRdb, pp2lv(), lvpm())

	/* for each purpose node in the list, get the load code, and insert
	   it before the access */
	type String cod
	type Number elm
	type Number lnr  = mp1( acc\1).order(-1)

	for elm = 1:1:purLst.count() do {	
		set cod = $$loadCode( dec, purLst.elementAt( elm), rmd, exs, caIns, lvpm())
		set lnr = lnr  + 1E-3
		set mp1(lnr) = dots_ $$pur2M( cod, pp2lv(), lvpm())
	}

	quit

	// ---------------------------------------------------------------------
private loadCmp(Number dec,		// declaration postion
		Number pur,		// purpose position (*1)
		Number rmd,		// record mode (0, 1, -1, -2) (*2)
		Boolean exs,		// exists indicatoe (*2)
		PSLIdentifier lvpm())	// dbAcc(,,) override values (*3)
	/* ---------------------------------------------------------------------
	Return the code to "load" the value of a complex computed column into
	a variable.

	ARGUMENTS:
	(*1) pur = purpose position
		This position shall occur in dbAcc("*","<")
		The computation shall occur in dbAcc("*","<$$",pur)
	(*2) rmd, exs
		As in getLodCode^UCXDD.
		rmd<0 will be ignored (as was the case prior to CR18163)
	(*3) lvpm() = local variable purpose mapping
		This array will be used to obtain the value of the leftexpr, and
		it is passed to $$pass2lvpm() to obtain the -2 purpose lvn if
		rmd<0

	INPUTS:
	. dbAcc( "*", "<", pur) = dec SEP node
	. dbAcc( "*", dec, node) = lvn to receive value of complex computed
		If this entry still contains a purpose position, then that
		purpose position will show up in the return value, and the
		caller will have to translate it into a real variable.
	. dbAcc( "*", "<$$", pur) = complex computed expression
		This entry will almost certainly contain purpose positions.

	NOTES:
	. Replacement of the purpose positions in the returned value is the
		responsibility of the caller. The caller shall expect purpose
		positions that correspond to nodes that would usually occur in
		the lvpm() array.
	. The need to supply the lvpm() entry for the node corresponding to pur
		(i.e. the complex computed target) stems from the fact that the
		declaration may be subscripted. So even though the node will
		occur in dbAcc( "*", dec,), it may need a local override for
		this load point.
	. The load code for vobj(,-300,) and and its optimized equivalent in
		PSL prior to CR18163 did not check the recordMode when "loading"
		the node. This is implemented here as well.
		If rmd<0 is to be taken into account, then additional changes
		are needed, because no -2 purpose node will have been allocated
		for voXN incremental loading. This could be achieved by
		"forcing" a -2 purpose node in cmp2pur().
	*/
	type literal String SEP = 9.char()
	type public String dbAcc(,,)

	type String node = dbAcc( "*", "<", pur).piece(SEP, 2)
	type String left = $$pass2lvpm( dec, node, lvpm())

	type String code = " S"
	if exs set code = code_ ":'$D("_left_")#2"
	set code = code_ " "_left_ "="

	if rmd = 0 quit code_ """"""

	/* ======== code commented out
	   ("old" -300 loading did not look at RecordMode either).
	   See NOTES before enabling these lines again.

	else  if rmd = 1 quit code_ dbAcc( "*" , "<$$", pur)
	quit code_ "$S("_ $$pass2lvpm(dec, -2, lvpm())_ ":"_ dbAcc( "*" , "<$$", pur)_ ",1:"""")"
	======== */

	quit code_ dbAcc( "*" , "<$$", pur)

	// ---------------------------------------------------------------------
private loadCode( Number dec,		// declaration position
		Number   pur,		// purpose position
		Number   rmd,		// record mode indicator
		Boolean  exs,		// bExists indicator
		Number   cacheIns,	// original call for cache.getRecord()
		PSLIdentifier lvpm())	// purpose-to-lvn map
	/* ---------------------------------------------------------------------
	Return the incremental load code for the supplied parameters.

	OUTPUTS:
	. $$ = incremental load code.
		The code may have been constructed with $$lvpm(), in which case
		it will contain wrapped purpose occurrences. It is the caller's
		responsibility to replace these occurrences by M code.

	NOTES:
	. When the access that causes the load is subscripted, the lvMap()
		entries must reflect the subscript value at the access. This
		requires rebuild of lvMap() for this declaration on each access,
		because each access may use a different subscript expression.
		This also assumes that subscripted objects will not be optimized
		(because all lvMap() entries are replaced).
		Because the load code occurs on the line preceeding the access,
		another assumption is that the subscript expressions are not
		modified on the line in which the access occurs. For example
		the following is likely to fail:
			SET sub=sub+1,var=recArray(sub).someColumn
	. Note that similar problems exist for the load-at-instantiation code,
		when the subscript value is modified after the instantiation on
		the same line:
			SET recArray(sub)=Db.getRecord("TBL","AKEY"),sub=sub+1
	*/
	type literal String SEP = 9.char()

	type public String   dbAcc(,,)
	type public PSLTable pslTbl()
	type static PSLClass

	type String decIdx = dbAcc( "*", "*", dec)
	type String code
	type String node   = dbAcc( "*", "<", pur).piece( SEP, 2)
	type String ovs    = decIdx.piece( SEP, 2)
	type String srn    = decIdx.piece( SEP)
	type String tbl    = PSLClass.tableNameOf( dbAcc( srn, ovs, dec).piece( SEP))

	if 'pslTbl(tbl).exists() set pslTbl(tbl) = PSL.getPSLTable( tbl, 0)

	/* If blob, memo, negative node, or RDB suppress Cache retrieval (see
	   CacheSr^UCDB).
	   If the request is for a new (rmd=0) RDB child node (recordType=11)
	   no code is needed, because Class.new() will create all nodes.
	   Else if complex computed, call local translator.
	   Else if no Cache.getRecord() is detected, return standard load code.
	   Else generate code that follows same pattern (using exs and rmd),
	   but that calls the incremental load function assoiciated with the
	   cacheCall. */
	type PSLTable td = pslTbl(tbl)
	if $$nodIsBM^UCXDD( node) ! $$nodIsNeg^UCXDD( node) ! td.isRdb set cacheIns = ""
	if rmd=0,td.isRdb,td.recordType=11 set code=" ; node "_node_" already created by Cleass.new()"
	else  if node.extract() = "~" set code = $$loadCmp( dec, pur, rmd, exs, lvpm())
	#ACCEPT CR=27800;Date=2007-10-11;PGM=Frans S.C. Witte;Group=MISMATCH; passes Number as PLSIdentifier
	else  if cacheIns.isNull() set code = td.getLoadCode( dec, node, rmd, exs, lvpm())
	else  do {
		/* Incremental load for Cache.geRecord(): generate an assignment
		   to the node using $$vCaNL(). The code below is largely copied
		   from $$getLodCode^UCXDD(), taking the following into account:
		   - the value of rmd will be either 1 or -1 (Cache.getRecord
			excludes 0)
		   - keys will be taken from k_"*" (which has -k-2 as fall back)
		   */
		type String left = $$pass2lvpm( dec, node, lvpm())	// target lvn
		type String expr = dbAcc( srn, ovs, cacheIns).piece( SEP, 15)
		if expr.extract()'="$" set expr = "$$"_expr

		if expr?1"$$vCa"1.N1"()" set expr = expr.piece( "(")_ "L("_ node_ ")"
		else  do {
			type List keys = td.primaryKeys
			type Number k
			set expr = expr.piece("(")_ "L("
			for k=1:1:keys.count() set expr = expr_ $$pass2lvpm( dec, k_"*", lvpm())_ ","
			set expr = expr_ node_ ")"
		}

		set code = " S"
		if exs set code = code_ ":'$D("_ left_ ")"
		set code = code_" "_left_ "="
	
		if rmd<0 set code = code_"$S("_ $$pass2lvpm( dec, -2, lvpm())_ ":"_ expr_ ",1:"""")"
		else  set code = code_ expr
	}
	quit code

	// ---------------------------------------------------------------------
private loadIns( String mp1(),		// pass 1 code		/MECH=REFARR:RW
		Number ins,		// instantiation position
		String occDes,		// descriptor (rmd, exs, cache, purList)
		PSLIdentifier pp2lv())	// purpose-to-lvn map
	/* ---------------------------------------------------------------------
	Insert the load code for this instantiation occurrence.

	If the incremental load code can be inserted "in line", this will be
	done. This is checked as follows:
	- if the line following the instantiation line (at mp1(ins\1).order())
		has the same DO-level, or a lower DO-level, then the code can be
		inserted inline.
	For FORMAL* and PUBLIC scope instantiations, the code will be inserted
	directly after the subroutine declaration line, and can always be
	inserted inline.

	Otherwise, this subroutine will have to create a vDbL() subroutine that
	contains the incremental load code for all nodes accessed in the scope
	of this instantiation.
	The line that constains the instantiation shall be modified to contain
	the DO vDbL() after the instantiation code.
	Until such code is implemented, a warning will be generated

	This subroutine calculates the lvpm() overrides to pass to $$loadCode(),
	and calls that function for each purpose position in purList.
	When the occurrence is subscripted ALL purpose nodes will occur in the
	lvpm() override array. Else only the applicable key / mode variables
	will be added.

	NOTES:
	. This subroutine already uses dbAcc( "<", ins, -key-2) if it exists.
		This implies that these entries will be used as soon as there is
		code that generates them.
	. Because this function uses dbAcc( "<", ins, -key-2) unconditionally,
		the code that constructs this data needs to contain the
		"intelligence" to decide which cases make sense.
	. Further optimizations are possible by allocating temporary variables
		for keys and mode if the number of purpose positions justifies
		the additional assignments. The rules for this justification are
		rather loose.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)
	type public PSLTable pslTbl()
	type static PSLClass

	// decompose occDes
	type Number  rmd    = occDes.piece( SEP, 1)
	type Boolean exs    = occDes.piece( SEP, 2)
	type Number  caIns  = occDes.piece( SEP, 3)	// ins of Cache.getRec
	type List    purLst = {List}(occDes.piece( SEP, 4))

	type String  insDes = dbAcc( "*", "=", ins)	// instance index
	type String        srt = insDes.piece( SEP)	// subroutine
	type PSLIdentifier nam = insDes.piece( SEP, 2)	// object variable

	set insDes = dbAcc( srt, nam, ins)		// instance descriptor
	type Number dec  = insDes.piece( SEP, 2)	// declaration position
	type Number lvl  = insDes.piece( SEP, 6)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String dots = $$initLine^UCGM( lvl)
	
	type String tbl = insDes.piece( SEP)
	if PSLClass.isRecord( tbl) {	// table can be derived from insDes
		set tbl  = PSLClass.tableNameOf( tbl)
	}
	else  {		// need to look at declaration
		set tbl = PSLClass.tableNameOf( dbAcc( srt, nam, dec).piece( SEP))
	}

	if 'pslTbl(tbl).exists() set pslTbl(tbl) = PSL.getPSLTable( tbl, 0)

	// create lvpm() based on this access position and purpose list
	// tbd
	type PSLExpression lvpm()

	/* If the occurrence is a subscripted variable, then the lvpm() entries
	   for this load point need to be modified to include the subscripts.
	   */
	type String subs = insDes.piece( SEP, 16)
	if 'subs.isNull() do loadLvpm( lvpm(), dec, subs)

	type Number lnr = (ins\1) + 1

	type Number ln1 = mp1(ins\1).order()
	type Boolean needSrn = mp1(ln1).translate(9.char()_" ").extract(1, lvl+1)?."."

	/* If a subroutine is needed, this may be due to the instantiation
	   associated with a PUBLIC declaration. In that case, the code can be
	   inserted BEFORE ins.
	   The specific case is detected as follows:
	   - an instantantiation of a PUBLIC declaration
	   - the value of ins is immediately preceeded by decPos in dbAcc(srn,ovs)
	   Because every PUBLIC declaration will be followed immediately by an
	   instantiation, the combination of these two conditions is a correct
	   determination of the particular instantiation.
	   */
	if needSrn do {
		if insDes.piece( SEP, 3) '= "PUBLIC" quit	// not PUBLIC
		type Number occ = dbAcc( srt, nam, ins).order(-1)
		if occ'= insDes.piece( SEP, 2) quit		// not the decl.

		// can insert code before instantiation
		set lnr = lnr - 1, needSrn=0
	}

	if needSrn do pass2Warn( ins, "DATABASE", "Cannot insert incremental load code after instantiation")

	/* Add the lvpm() entries that are independent of the purpose nodes
	   */
	do loadXnodes( srt, nam, dec, subs, pslTbl( tbl).isRdb, pp2lv(), lvpm())


	/* for each purpose node in the list, get the load code, and insert
	   it after the instantiation */
	type String cod
	type Number elm

	set lnr = mp1(lnr).order(-1)	// last line after ins\1
	for elm = 1:1:purLst.count() do {
		
		set cod = $$loadCode( dec, purLst.elementAt( elm), rmd, exs, caIns, lvpm())
		set lnr = lnr  + 1E-3
		set mp1(lnr) = dots_ $$pur2M( cod, pp2lv(), lvpm())
	}

	quit

	// ---------------------------------------------------------------------
private loadLvpm( PSLExpression lvpm(),		// purPos to lvn map		/MECH=REFARR:RW
		Number dec,		// declaration instance
		String subs)		// subscript expression to append
	/* ---------------------------------------------------------------------
	This subroutine will go through dbAcc("*",dec,node), and create a
	matching entry in lvpm().

	Furthermore, it will fill in the remaining key entries lvpm( key_"*")
	and the recordMode purpose node for reference in incremental load code.

	If 'subs.isNull(), then lvpm() will be killed before entries are added
	This subroutine will create special purpose node entries and key entries
	for all keys if subscripted access.

	ARGUMENTS:
	(*1) lvpm() = map array
		map(node) = "vobj(ovs,nod)"
		purPos may include ~colname for complex computeds

	INPUTS:
	. dbAcc( "*", dec, purpose) = purPos
	. dbAcc( "*", "*", dec ) = subroutine TAB ovs

	OUTPUTS:
	. lvpm( node) = either the lvn stored in dbAcc( "*", dec, node) or
		"vobj(nam,node)"
		With
		- nam = variable name with supplied subscriptlist appended
		- node = node derived from purpose (may have required
			transformation e.g. for Blob/Memo)
	*/
	type literal String SEP = 9.char()

	type public String    dbAcc(,,,)
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()
	type static PSLClass

	type String des		// scratch data
	type PSLExpression left	// leftexpr to use
	type Number n		// key ordinal iterator
	type PSLIdentifier nam	// subscripted object var
	type String nod	= ""	// purpose node iterator
	type String nodLvpm	// node in lvpm()
	type PSLIdentifier ovs	// object variable
	type String srn		// subroutine
	type String tbl		// table name
	type PSLTable td	// table descriptor (from cache)

	set des = dbAcc( "*", "*", dec)
	set srn = des.piece( SEP)
	set ovs = des.piece( SEP, 2)
	set nam = ovs_ subs
	set des = dbAcc( srn, ovs, dec)
	set tbl = PSLClass.tableNameOf( des.piece( SEP))
	set td = PSL.cachePSLTable( pslTbl(), tbl)

	/* iterarate over all purpose positions */
	for  set nod = dbAcc( "*", dec, nod).order() quit:nod=""  do {
		set left = dbAcc( "*", dec, nod)

		// complex computeds don't go through $$lvpm^UCXDD()
		if nod.extract() = "~" set lvpm(nod) = PSL.oLvn_ "("_ nam_ ",-300,"_ nod.extract( 2, nod.length()).addQuotes()_ ")" quit

		// if not wrapped, and not subscripted, use as defined
		if '$$isWrap( left), subs.isNull() set lvpm(nod) = left quit

		/* Use nodLvpm to denote the node in lvpm(). Do not modify
		   nod, because it is used as iterator */
		if nod.extract() = "*" do {
			type PSLColumn cd = PSL.cachePSLColumn( pslCln(), tbl_nod.translate("*","."), pslTbl())
			set nodLvpm = cd.getCurrentNode(0)
		}
		else  set nodLvpm = nod

		set lvpm(nodLvpm) = $$lvpm^UCXDD( nam, nodLvpm)
	}

	/* Add lvpm( key_"*") for key columns to be used for key column
	   references in SELECT or in the globalref and the negative purpose
	   nodes -2 and -152.
	   Add only if not yet defined.
	   */
	for n=-2,-152 if 'lvpm( n).exists() set lvpm( n) = $$lvpm^UCXDD( nam, n)
	if 'td.getArchiveTable().isNull() set lvpm( -99) = $$lvpm^UCXDD( nam, -99)
	for n=1:1:td.primaryKeys.count() if lvpm( n_"*").exists() set lvpm( n_"*") = $$lvpm^UCXDD( nam, n_"*")
	
	quit

	// ---------------------------------------------------------------------
private loadXnodes( String srt		// subroutine
		, String nam		// 
		, Number dec		// declaration instance
		, String subs		// subscripts at access/instantiation
		, Boolean isRdb		// load for RDB?
		, String pp2lv()	// purpose to lvn mapping
		, PSLExpression lvpm()	// purpose mapping
		)	// create the extra nodes (-99, -161, and -162)
	/* ---------------------------------------------------------------------
	This subroutine creates the nodes in lvpm() that are common to both
	loadAcc() and loadIns():
	- lvpm(-99) for access to archived date
	- lvpm(-161) and lvpm(-162) for database modify code on RDB.
		Note that these nodes actually reference the top of a (sub)tree
		so the values created for them end with a comma, not with the
		closing parenthesis.

	NOTES:
	. If we ever decide to map -161/-162 to voXN variables, then the code
		can easily be modified to end with the opening parenthesis.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String cod

	// If archived (purpose node -99), set lvpm to ensure extended reference
	if dbAcc( "*", dec, -99).exists() set cod = dbAcc( "*", dec, -99), lvpm(-99) = $SELECT($$isWrap(cod):pp2lv($$stripWrap(cod)),1:cod)	
		
	// If using vobj and is RDB, set up map for -161/-162 as signal to
	// getLodCode^UCXDD to create those nodes
	quit:'dbAcc( srt, nam, dec).piece( SEP, 10)
	quit:'isRdb

	set lvpm(-161) = PSL.oLvn_"("_ nam_ subs_ ",-161,"
	set lvpm(-162) = PSL.oLvn_"("_ nam_ subs_ ",-162,"

	quit

	// ---------------------------------------------------------------------
private lvMap(String map())	// purPos to lvn map			/MECH=REFARR:W
	/* ---------------------------------------------------------------------
	This subroutine will go through dbAcc("*",dec,node), and when the
	entry contains a wrapped purpose position, it will add it to the map()
	using the vobj(recInst,node) substitution, except if already defined.

	Furthermore, for each decPos, it will fill in the remaining key entries
	(i.e. dbAcc("*",decPos,N*)), and the recordMode purpose node for
	reference in incremental load code.

	This subroutine will (shall) NOT modify dbAcc("*",decPos,node), because
	other subroutines expect a wrapped purpose entry for all nodes that still
	need to be loaded.

	This subroutine will (shall) NOT modify exisiting entries, that may have
	been filled with voXN variables for optimized access, but it will
	overwrite existing entries if 'subs.isNull() (i.e subscripted access).

	ARGUMENTS:
	(*1) map() = map array
		map(purPos) = "vobj(ovs,nod)"
		purPos may include ~colname for complex computeds

	INPUTS:
	. dbAcc( "*", decPos, purpose) = purPos
	. dbAcc( "*", "*", decPos ) = subroutine TAB ovs

	OUTPUTS:
	. map( purPos) = "vobj(nam,node)"
		With
		- nam = variable name
		- node = node derived from purpose (may have required
			transformation e.g. for Blob/Memo)
	*/
	type literal String SEP = 9.char()

	type public String    dbAcc(,,,)
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()
	type static PSLClass

	type String dec = ""	// declaration position
	type String des		// scratch data
	type Number n		// key ordinal iterator
	type PSLIdentifier nam	// object variable
	type String nod	= ""	// purpose node iterator
	type String nodLvpm	// purpose node for $$lvpm^UCXDD()
	type Number pur		// purpose position
	type String srn		// subroutine
	type String tbl		// table name
	type PSLTable td	// table descriptor (from cache)

	/* iterarate over all declarations, and generate standard unsubscripted
	   access. */
	for  set dec = dbAcc( "*", dec).order() quit:'dec.isNumber()  do {

		/* iterarate over all purpose positions */
		set des = dbAcc( "*", "*", dec)
		set srn = des.piece( SEP)
		set nam = des.piece( SEP, 2)
		set des = dbAcc( srn, nam, dec)
		set tbl = PSLClass.tableNameOf( des.piece( SEP))

		if 'tbl.isNull() set td = PSL.cachePSLTable( pslTbl(), tbl)

		for  set nod = dbAcc( "*", dec, nod).order() quit:nod=""  do {
			set pur = dbAcc( "*", dec, nod)

			// if not wrapped, skip
			if '$$isWrap( pur) quit

			set pur = $$stripWrap( pur)

			// if already defined, don't overwrite
			if map(pur).exists() quit

			// complex computeds don't go through $$lvpm^UCXDD()
			if nod.extract() = "~" set map(pur) = PSL.oLvn_ "("_ nam_ ",-300,"_ nod.extract( 2, nod.length()).addQuotes()_ ")" quit

			if nod.extract() = "*" do {	// Translate *BM to "real" node
				type PSLColumn cd = PSL.cachePSLColumn( pslCln(), tbl_nod.translate("*","."), pslTbl())
				set nodLvpm = cd.getCurrentNode(0)
				// may need to ensure that -152 node is defined ???
			}
			else  set nodLvpm = nod

			set map(pur) = $$lvpm^UCXDD( nam, nodLvpm)
		}

		/* Add dbAcc("*",decPos,n*) for key columns to be used for key
		   column references in SELECT or in the globalref.
		   This code can be removed once loadAcc and loadIns create
		   lvpm() entries for all "implied keys" and all implied purpose
		   nodes (-152).
		   Don't do this for dynamic tables
		   */
		if 'tbl.isNull() for n=1:1:td.primaryKeys.count() if 'dbAcc( "*", dec, n_"*").exists(),'dbAcc( "*", dec, -n-2).exists() set dbAcc( "*", dec, n_"*") = $$lvpm^UCXDD( nam, n_"*")
	}
	quit

	// ---------------------------------------------------------------------
private paSetVobj( String srn,		// subroutine
		String ovs,		// object variable signature
		Number dec,		// declaration position
		Boolean bWarn) 	// warning needed?
	/* ---------------------------------------------------------------------
	Helper subroutine that sets needVobj to ensure that a subsequent call to
	$$paNeedVobj() will return 1 (true).
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String decDes = dbAcc( srn, ovs, dec)
	quit:decDes.piece( SEP, 10)

	set dbAcc( srn, ovs, dec).piece( SEP, 10) = 1
	if bWarn do pass2Warn( dec, "INTERNAL", "possible vobj() memory leak for "_ ovs_ " in "_ srn)

	quit

	// ---------------------------------------------------------------------
private pass2Err( Number pos,	// position for which to report the error (*1)
		String msg)	// PSL error message
	/* ---------------------------------------------------------------------
	Helper function that extracts information from 'pos' to simulate an
	error at the associated source line.

	When an error is detected in the second pass, the "source line pointer"
	is at the end of the sourde. This function initiates the relevant lvns
	to allow PSL.errror() to report the error as if it occurred in pass 1.

	ARGUMENTS:
	(*1) pos = any valid argument for $$findXDes()
		The call to $$findXDes() is used to obtain all available data.
		Only the subroutine, and the source line number are used.

	NOTES:
	. All names of variables shall be synchronized with ERROR^UCGM
	. Apart from the lvns (re)declared here, the subroutine relies on the
		presence of:
		- m2src() = source code array
		- cmperr() = error report array
	*/
	type literal String SEP = 9.char()

	type String xdes = $$findXDes( pos)

	type String ER = ""	// set by PSL.error()
	type Number lptr	// source line poiter expected by WARN^UCGM()
	type String subRou	// name of subroutine expected by WARN^UCGM()
	type String tok	= ""	// referenced in WARN^UCGM() if msg[$C(0)

	if xdes.isNull() set subRou = " ", lptr = 0
	else  do {
		type String desX = xdes.piece( SEP, 2, 3)
		type String desD = xdes.piece( SEP, 4, xdes.length( SEP))
		set subRou = desX.piece( SEP)
		set lptr   = desD.piece( SEP, 14)
	}
	do PSL.error( msg)
	quit

	// ---------------------------------------------------------------------
private pass2lvpm( Number decPos,		// declaration position (*1)
		String node,		// purpose node (*2)
		PSLIdentifier lvpm())	// overrides (*3)
	/* ---------------------------------------------------------------------
	This function is the pass2 equivalent of $$lvpm() and $$lvpm^UCXDD().
	It acts much like $$lvpm^UCXDD() in that overrides passed in lvpm()
	take precedence over standard values in dbAcc( "*", decPos, node).
	
	ARGUMENTS:
	(*1) decPos = record declaration position identifier
		This value will be ignored if a lvpm(node).exists().
	(*2) node = "purpose" node of variable
		See $$lvpm^UCXDD(). In addition the following "purpose" values
		are recognized:
	(*3) lvpm() = override values
		If lvpm(node).exists(), then that value will be returned.

	OUTPUTS:
	. $$ = code to use, which will be (in the order specified):
		- lvpm(node) if it exists
		- dbAcc( "*", decPos, node) if it exists
		- vobj( decOvs, node)

	NOTES:
	. The behavior of pur.isNull() and of key_*" nodes shall be kept in sync
		with the corresponding behavior in $$lvpm^UCXDD().
	. Unlike $$lvpm^UCXDD() this function accepts additional special purpose
		nodes, such as "*"_COLNAME for blob/memo, provided that mappings
		for these nodes exist in either lvpm() or in dbAcc( "*", decPos)
	. Like $$lvpm^UCXDD() there is a fall-back mechanism for key_"*" nodes
		to -key-2 nodes. To ensure that lvpm() always prevails, the code
		will check lvpm( -key-2) before dbAcc( "*", decPos, key_"*").
		Because key purpose nodes key_"*" will never occur in dbAcc(,,),
		the additional round of fall-back processing is needed as
		fall-back for key_"*" to dbAcc( "*", decPos, -key-2). This leads
		to the following precedence order for a key_"*" node:
		1) lvpm( key_"*")
		2) lvpm( -key-2)
		3) dbAcc( "*", decPos, key_"*") [ UNLIKELY TO EXIST !!! ]
		4) dbAcc( "*", decPos, -key-2)
		5) "vobj("_decOvs_","_(-key-2)_")"
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	if node.isNull() set node = "0*"		// sync with UCXDD !!!!

	if lvpm( node).exists() quit lvpm( node)

	// key purpose node fall-back has higher precedence than dbAcc(,,key_"*)
	if node?1.N1"*", node'="0*", lvpm( -2 - node.toNumber()).exists() quit lvpm( -2 - node.toNumber())

	if dbAcc( "*", decPos, node).exists() quit dbAcc( "*", decPos, node)

	// needed as fall-back for a non-existant dbAcc( "*", decPos, key_"*")
	if node?1.N1"*",node'="0*" quit $$pass2lvpm( decPos, -2 - node.toNumber(), lvpm())

	/* Return standard vobj(recInst,node) value (will not work
	   for subscripted access !!). 
	   Note that there is no need to pass lvpm() because it does not contain
	   a match for node once we get here. */
	quit $$lvpm^UCXDD( dbAcc("*", "*", decPos).piece( SEP, 2), node)

	// ---------------------------------------------------------------------
private pass2Warn( Number pos,	// position for which to report the warning (*1)
		String grp,	// warning group
		String msg)	// PSL warning message
	/* ---------------------------------------------------------------------
	Helper function that extracts information from 'pos' to simulate a
	warning at the associated source line.

	NOTES:
	. See pass2Err for ARGUMENTS and NOTES.
	*/
	type literal String SEP = 9.char()

	type String xdes = $$findXDes( pos)

	type String ER = ""	// set by PSL.error()
	type Number lptr	// source line poiter expected by WARN^UCGM()
	type String subRou	// name of subroutine expected by WARN^UCGM()
	type String tok	= ""	// referenced in WARN^UCGM() if msg[$C(0)

	if xdes.isNull() set subRou = " ", lptr = 0
	else  do {
		type String desX = xdes.piece( SEP, 2, 3)
		type String desD = xdes.piece( SEP, 4, xdes.length( SEP))
		set subRou = desX.piece( SEP)
		set lptr   = desD.piece( SEP, 14)
	}
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do warnGroup^UCGM( grp, msg)
	quit
	
	// ---------------------------------------------------------------------
private pur2M( String code,		// pass 1 code line
		String map(),		// purPos-to-lvn map
		String override())	// override the map() entries
	/* ---------------------------------------------------------------------
	This function will replace all wrapped purPos references by their
	associated lvn.
	If a purPos reference is found that is not mapped, the function will
	return "".

	ARGUMENTS:
	(*1) cod = pass 1 code line
		arbitrary line that contains zero or more wrapped purPos
		references
	(*2) map() = map array
		map(pos) = code
		- If pos is a purpose position, then the actual code that gets
			inserted may be overwritten by override(node)
		- Else map(pos) shall contain the code

	OUTPUTS:
	. $$ = code in which all "wraps" are replaced.
		If a purPos is not mapped, "" will be returned

	NOTES:
	. The empty return value for un-mapped purPos values is used for the
		recordMode variable. Subroutine save^UCRECORD inserts a wrap for
		the assignment to the purpose variable. If optimization detects
		that this purpose node is never explicitly accessed, it can
		remove the map entry, which will result in removing the
		assignment from the code generated for Reocrd.save.
	. The condition wrap.extract()=BGN prevents certain cases of recursive
		"wraps".
	*/
	type literal String BGN = 7.char()
	type literal String END = 8.char()
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type Number acc,b,e,q
	type Number RdbCodeForm = 0
	type String node,wrap
	type String origcode
	
	/* If code, as unwrapped, exceeds maximum line length, do it again
	   using RdbCodeForm for function call (1), not in-line (0).  See
	   cdRbdAsn^UCXDD for details.
	*/
	set origcode = code

	for b=code.find(BGN):0 quit:b=0  do {
		set e=b
		for  set e = code.find(END,e) quit:code.extract(1,e-1).length(BGN)=code.extract(1,e-1).length(END)

		set wrap = code.extract( b, e - 2)
		if wrap.isNumber() do {
			if 'dbAcc( "*", "<", wrap).exists() set wrap = map( wrap) quit
			set node = dbAcc( "*", "<", wrap).piece( SEP, 2)
			if 'map(wrap).exists() do {
				/* Try to copy from dbAcc(,,)
				   */
				type Number dec = dbAcc( "*", "<", wrap).piece( SEP)
				if '$$isWrap(dbAcc( "*", dec, node)) set map( wrap) = dbAcc( "*", dec, node)
			}
			if map(wrap).exists()'!override(node).exists() set (code,wrap) ="" quit
			set wrap = override( node).get( map( wrap))
		}
		else  do {
			/* placeholder for assignment (inserted by $$clnAsn()),
			   or for other code that varies based on context.
			   Call pur2M recursively, and if the result is of the
			   form number=text, then it is a column assignment.
			   Call clnAsn2() to generate the approriate update
			   code.
			   */
			set wrap = $$pur2M( wrap, map(), override())
			if wrap.piece("=").isNumber() set wrap = $$clnAsn2( wrap, RdbCodeForm)
		}

		set code = code.extract( 1, b - 2)_ wrap_ code.extract( e, code.length())
		set b=code.find(BGN)
		
		// Try again
		if (RdbCodeForm = 0), '({PSLExpression}code).fitsLineLength() do {
			
			set code = origcode
			set b = code.find(BGN)
			set RdbCodeForm = 1
		}
	}
	quit code

	// ---------------------------------------------------------------------
private purByAcc( Number accPos,	// position of access
		String pur)		// purpose value
	/* ---------------------------------------------------------------------
	Insert ACCESS to purpose node in dbAcc() by passing an access occurrence
	and a purpose node. This is a support function for pass 2.

	One problem with pass 2 insertions is that the "pass 1 context" such as
	subroutine, and destination line number are no longer available. This
	function creates a position on the same line as the access, and copies
	almosts all dbAcc() fields from this access.

	This function returns the position of the purpose identifier, not the
	position of the access occurrence.

	ARGUMENTS:
	(*1) accPos = access position
		Shall be an existing access

	OUTPUTS:
	. $$ = the "wrapped" position of the purpose identifier (!)
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String decOvs = dbAcc( "*", "@", accPos)
	type String sr = decOvs.piece(SEP)
	type PSLIdentifier nam = decOvs.piece(SEP, 2)

	/* Take the access occurrence as source */
	type String des = dbAcc( sr, nam, accPos)

	type Number decPos = des.piece( SEP, 2)
	set des.piece( SEP,  5) = $$lvpm( decPos, pur, 1)

	type Number pos = $$createPos( accPos\1)

	/* Store the description and its index */
	set dbAcc( sr, nam, pos) = des
	set dbAcc( "*", "@", pos) = sr _ SEP _ nam

	quit des.piece( SEP, 5)

	// ---------------------------------------------------------------------
private setDecVal( String sr,		// subroutine
		PSLIdentifier ovs,	// object variable signature
		Number field,		// field to modify
		Primitive val)		// value to assign
	/* ---------------------------------------------------------------------
	Helper subroutine that locates the declaration of (sr,ovs), and assigns
	the specified value to the specified field.
	*/
	type literal String SEP = 9.char()

	type public String dbAcc(,,)

	type String nam = ovs.piece( "(")
	type Number dec = $$findDec( sr, nam)
	set dbAcc( sr, nam, dec).piece( SEP, field) = ({String}val).translate( SEP, 10.char())

	quit
 #OPTION ResultClass ON
public String vSIG()	quit "61473^50064^Frans S.C. Witte^181216"	// Signature - LTD^TIME^USER^SIZE
