	/*
	ORIG: Frans S.C. Witte - 03/22/05
	DESC: Generating code for methods of class Db in case of RDB

	---- Comments ----------------------------------------------------------
	Not all code for RDB occurs in this unit.

	---- Revision History --------------------------------------------------
	2008-10-16, Frans S.C. Witte, CR 35741/35918/35922
		Modified code generated for select to use vResultSet when
		appropriate, and to set vobjCurs() to track open cursors.

	2008-07-22 - RussellDS - CR30801
		* Modified selBoot to avoid calls to SQLQ if where clause is null.
	
	2008-04-04, Frans S.C. Witte, CR: 33569
		* Corrected code genertated for vFetch to ensure an "all-empty"
		  resultset-row.

	09/03/07 - Frans S.C. Witte - CR: 27800
		* Changed keyword 'public' to 'ret' in fp declaration.
		* Replaced commands(,) by pslPrsr(,)
		* Modified selSrOpen en selSrFetch to request and cache multiple
		  rows from the API.
		* Changed PSLubrou.toString() to PSLSubrou.getName()
		* Removed lbl* parameters from selBootReplace, because the code
		  may execute at a do-level that does not accept GOTO.

	08/20/07 - KWANL / Frans S.C. Witte - CR 28995
		* Removed conditional #IF 0 code, and subroutines only called
		  by that conditional code.
		* Adapted to new CATCH/THROW mechanism

	09/04/06 - Frans S.C. Witte - CRs: 22719 / 20613
		* All %PSL-E-SQLFAIL exceptions now include the error message
		  returned by the API, with newline translated into space, and
		  comma into tilde.
		* Modified code generated for vOpen() and vFetch() to use the
		  new DB API signatures and to support dataitem protection.
		* All calls to %DBAPI now pass 0 (zero) instead of "" for vIndex

	06/12/06 - Frans S.C. Witte - CRs: 22060 / 22061
		* Replaced PSL.maxLineLength() by PSLExpression.fitsLineLength()

	05/11/06 - Frans S.C. Witte - CRs: 21101 / 18164
		* Subroutine selBoot: warnings now use gorup "PSLBOOT"
		* Code generated for vOpen/vFetch now uses "vOid" instead of
		  "object"

	03/06/06 - Frans S.C. Witte - CRs: 20280 / 18164
		* Added warning for /PSLBOOT
		* Corrected ACCEPTS to use semi-colon, all required fields, and
		  the GROUP tag.

	02/02/06 - Frans S.C. Witte - CRs: 18163 / 18164
		* {PSLXyz} casts replaced by proper method calls.

	11/15/05 - Frans S.C. Witte - CRs: 18727 / 18728
		* Adapted selBoot to support dynamic selectclause
		* Corrected where to deal with boundary conditions
		  (qid1 is null, where is null).
		* Added isDefined()

	09/25/05 - Frans S.C. Witte - CRs: 15592 / 15593
		* Added subroutines selBoot and selBootReplace
		* Added functions $$colSub() and $$selBootReplace() and
		  subroutines qrySub(), and selBoot().
		* Replaced this.var by PSL.var and removed #XECUTE

	08/31/05 - Frans S.C. Witte - CRs: 17056 / 17057
		* replaced literal String MAXLENGTH by PSL.maxLineLength

	06/27/05 - Frans S.C. Witte - CR16346
		* Added functions $$where() and $$getKey().
		* Renamed SelOpen to SelSrOpen, SelFetch to SelSrFetch. Added
		  SelCdFetch()
		* Modified SelSr* to call SelCdFethc for common code.
		* Modified all references to vEr to treat <0, 100, >=0 as
		  separate cases.

	03/25/05 - Frans S.C. Witte - CRs: 14919 / 14920
		Initial version. Subroutine Rselect() has been moved from UCDB.m
		into this unit as select(). Subroutine OPENLAB moved from UCDB.m
		into this unit as selOpen. Subroutine FETCHLAB moved from UCDB.m
		into this unit as selFetch.
		Subroutines XvClose() and XvCloseC() are introduced.
	*/
	#PACKAGE framework.psl

	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	// ---------------------------------------------------------------------
public colSub(	String context(),	// context data (*1)
		String table,		// name of table (*2)
		String column)		// name of column (*3)
	/* ---------------------------------------------------------------------
	This function is the column substitution handler for RDB getRecord
	instances. Its signature conforms to the signature expected by
	qrySub^UCDBR

	ARGUMENTS:
	. context()
		This function expects that context("Inst") contains the name of
		the Record instance variable.
		...
	. table
		The name of the table is completely ignored. It is the callers
		responsibility to ensure that the tablename is 'correct'.
	. column
		The name of the column. This value is unconditionally translated
		to lowercase, and appended as the Row property.

	OUTPUTS:
	. $$ = PSLColumn.getCurrentExpr(context("Inst"),0)
		Note that this assumes that the context will always be retrieval
	. context("NODE",table,node) = PSLColumn.getCurrentLvn(context("Inst"))
		This node will only be created if
			'PSLColumn.getCurrentNode().isNull()

	NOTES:
	. Although neither the tablename nor the columnname are validated, the
		call itself is harmless. A compiletime (or runtime) exception
		may occur if the caller tries to use the returned value in a PSL
		source line.
	*/
	type PSLColumn cd = PSL.getPSLColumn( table, column)
	type String recInst = context("Inst")
	type String nod = cd.getCurrentNode()
	if 'nod.isNull() set context("NODE",table,nod) = cd.getCurrentLvn(recInst)

	quit cd.getCurrentExpr(recInst,0)

	// ---------------------------------------------------------------------
getKey( ret String table		// conceptual table name (*1)
		, List primkey		// list of primary key columns (*2)
		, String keyvals	// list of key value expressions (*3)
		, Number md		// hostval mode (*4)
		, String hostval	// host value expression (*5)
		, PSLColumn coldes()	// Column descriptions of keys (*6)
		)	// Build primary key WHERE-clause and hostvar list
	/* ---------------------------------------------------------------------
	Build the WHERE clause on the primary key, and the code string to pass
	the values of the host variables
	
	ARGUMENTS:
	(*1) table = conceptual table name
		When passed by reference, it will contain the internal tablename
		on output
	(*2) primkey = list of primary key columns
		Only the primary key columns shall be supplied. Literal keys as
		used for MDB shall be removed by the caller
	(*3) keyvals = list of values to be passed as host values
		The caller is responsible to tokenize literals
		$$ATOM^%ZS(keyvals,,",",,1) will be used to match a primkey with
		a keyval
	(*4) md = hostval mode
		- 1 = For call to $$EXECSP^%DBAPI()
			In this case, the generated code uses $C(1) as separator
			and no quote-processing will be added
			The "hostvars" in the where-clause will not be prepended
			with a colon
		- 2 = For call to $$SELECT^%DBAPI()
			In this case the generated code will use $C(9), and SQL
			quote enclosure will be included in the generated code
			The "hostvars" in the where-clause will be prepended with
			a colon
	(*5) hostval = host value expression
		M code to construct the parameter that passes the host values.
		The input value is unconditionally reset.
	(*6) coldes = columndescriptior array
		coldes(ordpos)= PSLColumn of key column
	
	QUTPUT:
	. $$ = where-clause (key1=:V1 AND key2=:V2)
		The clause will not contain the keyword "WHERE"
	. table = internal table name
		Provided the caller passes this argument by reference
	. hostval = host value expression
		If keyvals="", then hostval=""
	. coldes = PSLColumn descriptions of keycolumns
		The array is indexed by key ordinal position
	*/
	type public String %DB

	type String col			// individual (key)column name
	type String extt = table	// external table name
	type Number k			// interator
	type Number ptr = 0		// pointer in calls to $$ATOM^%ZS()
	type String val			// individual key value expr
	type String where = ""		// where clause

	// variables used to differentiate code depending on md
	type String colon,qtpre,qtpost,sep

	set hostval = ""

	// If no keyvalues supplied translate tablename and quit ""
	if keyvals = "" do MAP^DBMAP( %DB, .table) quit ""

	// Set colon, qtpre, qtpost, and sep based on md
	if md=1 set sep = "_$C(1)_", (colon,qtpre,qtpost) = ""
	else  set sep = "_$C(9)_", colon = ":", qtpre = "$$QADD^%ZS(", qtpost = ",""'"")"

	/* Construct where and hostval in single loop
	   Note that table will have the "correct" internal tablename, provided
	   that all keys map to the same table. */
	for k=1:1:primkey.count() do {
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set val = $$ATOM^%ZS(keyvals,.ptr,",",,1) if ptr set ptr=ptr+1
		set col = primkey.elementAt( k), table = extt
		set coldes(k) = PSL.getPSLColumn( extt, col)
		do MAP^DBMAP( %DB, .table, .col)
		if k>1 set where = where_ " AND ", hostval = hostval_ sep
		set where = where_ col_ "="_ colon_ "V"_ k
		set hostval = hostval_ qtpre_ val_ qtpost
	}
	quit where

	// ---------------------------------------------------------------------
isDefined( PSLTable td		// table descriptor
		, String where		// where clause (*2)
		, Number matchCnt	// match count
		)	// Generate code for vDbEx() of RDB Db.isDefined()
	/* ---------------------------------------------------------------------
	Generate code for vDbEx()

	ARGUMENTS:
	(*2) where = where clause
		Althouh the value is required, it may be empty. This will be the
		case for tables that do not have a primary key (CUVAR), or if a
		matchCount is specified.

	OUTPUTS:
	. $$ = subscript in append() where vOpenN() code starts
	. append() has been extended with vOpenN() code
	*/
	type literal String oLvn = "vobj"

	type String map(,)
	type PSLSubrou sr = PSL.addSubrou("DbEx", "()", "EXISTS "_td.table_" WHERE "_where, 1)

	do sr.addCode(" N vCurID,vData,vEr,vList,vRm")

	/* Convert whereclause for RDB. Let $$where() translate the external
	   name to the correct internal name in this context (even for wide
	   tables only a single name is relevant). */
	type String intTbl = td.table
	if 'where.isNull() set where = $$where( .intTbl, where, map(,))

	/* Add code that assigns vList, and transform sql to its string
	   representation. */	
	do sr.addCode(" S vList="_ $$RsMsXV^UCDBRT( map(,), .where))

	/* The length of the SQL statement (in sql) may exceed the maximum line
	   length supported for a GT.M routine. If that is the case, split the
	   line. */
	type PSLExpression sql = "SELECT COUNT(*) FROM "_ intTbl
	if 'where.isNull() set sql = sql_ " WHERE "_ where
	if 'sql.fitsLineLength() do {
		do sr.addCode(" N vSql")
		do setLong(sr, "vSql", sql)
		do sr.addCode(" S vEr=$$SELECT^%DBAPI(0,vSql,$C(9),vList,.vData,.vRm)")
	}
	else  do sr.addCode(" S vEr=$$SELECT^%DBAPI(0,"_ sql.addQuotes()_ ",$C(9),vList,.vData,.vRm)")

	do sr.addCode(" I vEr<0 S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)),$EC="",U1001,""")

	do sr.addCode(" Q vData'<"_matchCnt)

	quit "$$"_ sr.getName()_ "()"

	// ---------------------------------------------------------------------
select( String select			// SELECT-clause
		, String from		// FROM-clause
		, String where		// WHERE-clause
		, String orderby	// ORDERBY-clause
		, String groupby	// GROUPBY-clause and HAVING-clause
		, String parlist	// PSQL parameter specification
		)	// RDB SELECT when all componetns are known at compile-time
	/* ---------------------------------------------------------------------
	This subroutine handles the SELECT statement when all components are
	known at compile time (literals). It calls RsDyRT^UCDBRT() to transform
	the statement into its RDB equivalent.

	ARGUMENTS:
	. all parameters shall match the equivalent parameters of RsDyRT^UCDBRT
		See RsDyRT^UCDBRT for details.

	INPUTS:
	. msrc = line number of last line added to M code
	. struct("s",*)
	. subRou = current PSL subroutine
	. tab = TAB character ($CHAR(9))
	. var = assignment target
	. varPtr = line in M code where ResultSet (DbSet) is NEWed

	OUTPUTS:
	. struct("s",subRou,varPtr,var) = ResultSet description (see UCDB for
		details). This subroutine does not set piece 3, but it does
		set piece 8 to indicate select against RDB table(s).
	*/
	type public Number msrc
	type public String struct(,,,)
	type public String subRou
	type public String tab
	type public PSLIdentifier var
	type public Number varPtr

	/* Deal with dataitem protection, but only if requested (qualifiers
	   contain /PROT). getExe^SQLPROT may modify the select list, so call it
	   before calling $$RsDyRT^UCDBRT().
	   Note that regardless of the PSL coding rules regarding /PROTECTION,
	   this subroutine deals with an all-litral Db.select.  */
	type String aqual()			// qualifiers for SQLPROT
	type String dip()			// data item protection

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if ("/"_parlist)["/PROT" do PARSPAR^%ZS(parlist,.aqual()),getExe^SQLPROT( from, .select, .dip(), aqual())

	/* call same function as used at runtime */
	type String selmap(,)
	type String expr = $$RsDyRT^UCDBRT(select, from, where, orderby, groupby, parlist, selmap(,))

	type PSLSubrou sr = PSL.addSubrou("Open", "(vOff)", "New RDB result set", 1)
	type String openLab = sr.getName()

	type Number seq = openLab.extract(6, openLab.length())
	type String fetchLab = "vFetch"_seq

	#ACCEPT GROUP=ACCESS;CR=35741;DATE=2008-10-23;PGM=Frans S.C. Witte
	set PSL.return = "$$"_openLab_"("_ ($$getLevel^UCGM(var) - PSL.level + 1)_ ")"

	do selSrOpen( sr, fetchLab, expr, dip(), selmap(,))
	do selSrFetch(sr, fetchLab, 0, dip())
	do XvClose()

	/* Save info for fetch optimization and column name support
	   If this identifier is already instantiated, check the statement
	   and null out if they are different
	*/	
	type String z = (msrc+1)_tab_seq

	// Store Columnnames and Datatypes for Row class
	// 02/09/04 - Piece #7 added to fix fetch label problem

	set z.piece(tab,4) = selmap("SELNAM")
        set z.piece(tab,6) = selmap("SELTYP")

        #ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set z.piece(tab,7) = $$getScope^UCGM(var)
	set z.piece(tab,8) = 1

	if struct("s",subRou,varPtr,var).exists() do {
		set z.piece(tab,2) = ""
		set z.piece(tab,5) = seq
		if struct("s",subRou,varPtr,var).piece(tab,4)'= selmap("SELNAM") set z.piece(tab,4) = ""
	}
	set struct("s",subRou,varPtr,var) = z
	quit

	// ---------------------------------------------------------------------
public qrySub(	String context()	// context data (*1)
		, String routine	// context handler routine (*2)
		, String query()	// decomposed query (*3)
		, String qrySub()	// column substitutions (*4)
		)	// utility subroutine for the column substitution array of SQL*
	/* ---------------------------------------------------------------------
	This is a general utility subroutine that can be used to generate the
	column substitution array that is used by SQL* modules when translating
	column references into M code.
	The handler will be called only if qrySub(table.column) does not yet
	exist. So it will be called at most once for each column reference in
	query().

	ARGUMENTS:
	. context()
		The context array will be passed to the handler without any
		processing. It provides a general way to pass information
		between the caller and the handler.
	. routine
		The name of the routine that contains the context handler.
		The routine shall contain the follwoing function:
			public String colSub(	String context(),
						String table,
						String column)
		The function return value will be assigned to
		qrySub(table.column)
	. query()
		The decomposition of the query, as produced by ^SQLQ()
	. qrySub()
		The query substitution array to which the entries must be added

	OUTPUTS:
	. qrySub(table.column) will exist for each column referenced in query()
		Note that if the combination already existed when the subroutine
		was called, it will not be modified.
	. context()
		The handler free to modify the data in context(). In fact proper
		OO interface handling require that all side effects are through
		the context array (or through objects who's instances are passed
		through the this array).

	*/
	type Number e,j		// scratch loop vars
	type Number n = ""	// loop var for query()
	type String expr	// query expression
	type String term	// query term
	type String colref	// column reference in term
	for  set n = query(n).order() quit:n.isNull()  do {
		set term = query(n)
		for e=1,2 do {
			set expr = term.piece(9.char(), e)
			for j=2:2:expr.length(1.char()) do {
				set colref = expr.piece(1.char(), j)
				quit:qrySub(colref).exists()

				/* PSL does not (yet) accept routine name
				   indirection */
				#ACCEPT CR=15592;PGM=Frans S.C. Witte;DATE=2005-09-06;GROUP=BYPASS
				#BYPASS
				set qrySub(colref)=$$colSub^@(routine)(.context,$P(colref,"."),$P(colref,".",2))
				#ENDBYPASS
			}
		}
	}

	quit

	// ---------------------------------------------------------------------
selBoot( String select			// SELECT-clause
		, String from		// FROM-clause
		, String where		// WHERE-clause
		, String orderby	// ORDERBY-clause
		, String groupby	// GROUPBY-clause and HAVING-clause
		, String parlist	// PSQL parameter specification
		)	//  Db.select(,,,,,"/PSLBOOT")
	/* ---------------------------------------------------------------------
	This subroutine handles the SELECT statement when parlist contains the
	/PSLBOOT qualifier.
	This subroutine calls select^UCDB again, with /PSLBOOT removed. That
	call will generate the "normal" vOpenN and vFetchN. The sequence number
	of those calls will be found in struct(). The code generated by this
	subroutine will call these labels when not in boot-mode.

	ARGUMENTS:
	. all parameters shall match the equivalent parameters of RsDyRT^UCDBRT
		See RsDyRT^UCDBRT for details.

	INPUTS:
	. msrc = line number of last line added to M code
	. struct("s",*)
	. subRou = current PSL subroutine
	. tab = TAB character ($CHAR(9))
	. var = assignment target
	. varPtr = line in M code where ResultSet (DbSet) is NEWed

	OUTPUTS:
	. struct("s",subRou,varPtr,var) = ResultSet description (see UCDB for
		details). This subroutine does not set piece 3, but it does
		set piece 8 to indicate select against RDB table(s).
	. type(objectLevel,objectName)
		Object optimization for this instance will be turned off 

	NOTES:
	. The generated code for vOpen() looks to see if pslPrsr("boot",table)
		already contains an Object reference to the RowSet. If not, it
		will load the data into a "public" instance in pslPrsr(,).
		The resulting code ensures a load-once behavior. It has the
		advantage that the caller does not need to worry about
		instantiating the RowSets that may be used somewhere down the
		line. The disadvantage of this approach is that the RowSet
		instances are not disposed of automatically. In fact there are
		no proper ways to dispose of the objects, unless the outer
		most caller explicitly KILLs all command("boot",*) entries,
		using proper typecasting.
		The alternative would be that the Open code always instantiates
		the RowSet, and that code will be included to dispose of the
		RowSet when the ResultSet goes out of scope (like vClose() for
		RDB ResultSets. This is non trivial either (unless
		pslPrsr("boot",table) will be used in that case as well, but it
		adds additional runtime code that checks $DATA(pslPrsr("boot"))
		prior to every QUIT from a subroutine.
		that contains such a Db.select()
	*/
	type public Number msrc
	type public String struct(,,,)
	type public String subRou
	type public String tab
	type public PSLIdentifier var
	type public Number        varLevel

	/* Issue a warning (no warnopt, cannot be suppressed) */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do warnGroup^UCGM( "PSLBOOT","qualifier - please validate against Framework Upgrade Rules")

	/* remove "/PSLBOOT/" from parlist, and call select^UCDB to return the
	   code for a "normal" select */
	type String actual()
	set actual(1) = select
	set actual(2) = from
	set actual(3) = where
	set actual(4) = orderby
	set actual(5) = groupby
	set actual(6) = parlist.stripQuotes().replace("/PSLBOOT","").addQuotes()
	do select^UCDB

	/* If there are violations of the /PSLBOOT restrictions give a warning
	   and quit. This effectively ignores the /PSLBOOT qualifier */
	type literal String prefix="invalid /PSLBOOT ignored: "

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if 'from.isLiteral() do warnGroup^UCGM( "PSLBOOT", prefix_"FROM must be literal") quit
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if from["," do warnGroup^UCGM( "PSLBOOT", prefix_"Only single table allowed") quit
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if from.translate(tab_"(","  ")[" " do warnGroup^UCGM( "PSLBOOT", prefix_"Only single table allowed") quit
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if 'where.isNull(1),'where.isLiteral() do warnGroup^UCGM( "PSLBOOT", prefix_"WHERE must be literal") quit
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if 'orderby.isNull(1) do warnGroup^UCGM( "PSLBOOT", prefix_"ORDER BY not allowed") quit
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if 'groupby.isNull(1) do warnGroup^UCGM( "PSLBOOT", prefix_"GROUP BY not allowed") quit

	type Boolean bDyn = 'select.isLiteral()
	set from  = from.stripQuotes()
	set where = where.stripQuotes()

	/* now struct() can be used to obtain the sequence number of vOpenN and
	   vFetch when in normal mode. 'return' could be used as well to obtain
	   the vOpen call. Both struct() and return must be updated. */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number varNew = $$getNew^UCGM( var, varLevel)
	type String rsdes = struct("s",subRou,varNew,var)
	type String sellist = rsdes.piece(tab,4)
	type Number seqpiece = 2
	type Number seqnorm = rsdes.piece(tab, 2)
	if seqnorm.isNull() set seqpiece = 5, seqnorm = rsdes.piece(tab, 5)

	type String openLab = "vOpen"_(seqnorm+1)
	type Number seq = openLab.extract(6, openLab.length())
	type String fetchLab = "vFetch"_seq

	/* Use ^SQLQ() and QUERY^SQLA() to decompose the WHERE-clause, and
	   obtain the M code that must be inserted into the program. The
	   following variables are used specifically for this purpose:
	*/
	type String C2R()	// column to Row mapping, passed to QUERY^SQLA()
	type String OUT()	// not used, passed to ^SQLQ()
	type String RNG()	// not used (passed to ^SQLQ())
	type String VDD()	// not used, passed to ^SQLQ()
	type String WHD()	// where-clause decomposition
	type String WHM()	// where-clause M code, passed from QUERY^SQLA()

	type String exe()	// public output from ^SQLQ()
	type String vsql()	// public output from ^SQLQ() and  QUERY^SQLA()
	type String vsub()	// public output from ^SQLQ()
	type String vxp = -1	// public input for QUERY^SQLA()
	type String frm = from	// public input for QUERY^SQLA()

	// decompose where-clause and construct M code
	if 'where.isNull() do ^SQLQ( where, from, .WHD(), .RNG(), , , , .VDD(), .OUT())

	/* The first argument to QUERY^SQLA() is a mask that contains a 1 at
	   all positions p for which WHD(p) must be included in WHM(). Because
	   all positions are needed here, create a mask of ones for as many
	   elements as are present in WHD() */
	type String msk = ""
	set msk.piece(1, WHD("").order(-1)+1) = ""

	/* The fourth argument to QUERY^SQLA() is an array of table.property
	   occurences with their representation in the generated code
	   (cf VIEW^UCDB()). In this case we want each column to be translated
	   to vR.columnname. Use qrySub() to find all columns in WHD(),
	   and tell it to call $$colSub^UCROWSET() to obtain the substitution
	   value. */
	type String ctx()
	set ctx("Inst") = "vR"
	do qrySub( ctx(), "UCROWSET", WHD(), C2R())
	do QUERY^SQLA( msk, .WHD(), .WHM(), .C2R(), from, , 0, 0)

	type Number ln

	/* In case of dynamic select, only the SELECT list can be dynamic.
	   So this parameter and the standard 'vOff' parameter are passed into
	   the new version of vOpenN(). The call to vOpen0() from inside
	   vOpenN() will pass all  other parameters using the known literal
	   values.
	   Note that RDB dynamic select with literal FROM-clause will have a
	   different formal list than MDB dynamic select, but all dynamic
	   selects use the 'vOff' parameter, even in an MDB environment. */
	type Boolean bRdb = $$RsRdb^UCDBRT(from)
	type String fplist = $SELECT(bDyn:"(vSelect,vOff)",bRdb:"(vOff)",1:"()")

	#ACCEPT GROUP=ACCESS;CR=35741;DATE=2008-10-23;PGM=Frans S.C. Witte
	set PSL.return = $SELECT(bDyn!bRdb:($$getLevel^UCGM( var) - PSL.level + 1),1:"")
	set PSL.return = "("_ $SELECT(bDyn:select_",",1:"")_ PSL.return_ ")"

	type PSLBuffer sr = PSL.openBuffer( fplist, "PSLBOOT result set for "_ from)
	do sr.add("type public RowSet pslPrsr(,)")

	/* The call to the "normal" $$vOpen() cannot occur in PSL code, because
	   the PSL code will never see that function. Furthermore, if this code
	   is inserted in a CDM, the use of $$ is invalid at the PSL level.
	   The same is true for the call to $$vFetch() further, generated
	   further down in this block.
	   */
	do sr.add("#ACCEPT GROUP=BYPASS;CR=27800;PGM=Frans S.C. Witte;Date=2008-03-11")
	do sr.add("#BYPASS")
	if bDyn do {
		do sr.add("IF '$DATA(pslPrsr(""boot"","""_from_""")) QUIT $$vOpen"_seqnorm_"("_ $SELECT(bRdb:"",1:".exe,.vsql,")_"vSelect,"_from.addQuotes()_","_where.addQuotes()_","""","""","_parlist_",vOff+1)")
	}
	else  do sr.add("IF '$DATA(pslPrsr(""boot"","""_from_""")) QUIT $$vOpen"_seqnorm_$SELECT(bRdb:"(vOff+1)",1:"()"))
	do sr.add("#ENDBYPASS")
	do sr.add("type RowSet vRws = {RowSet}pslPrsr(""boot"","""_from_""")")
	do sr.add("type Number vOid=$O("_ PSL.oLvn_ "(""""),-1)+1")
	do sr.add("set "_ PSL.oLvn_ "(vOid,-1)=""ResultSet""")
	do sr.add("set "_ PSL.oLvn_ "(vOid,-5)=2")
	do sr.add("set "_ PSL.oLvn_ "(vOid,-2)=""$$"_ fetchLab_ "^""_$T(+0)")
	do sr.add("set "_ PSL.oLvn_ "(vOid,-3)="_ $SELECT(bDyn:"vSelect",1:sellist.addQuotes()))
	do sr.add("set "_ PSL.oLvn_ "(vOid,-4)="_ rsdes.piece(tab,6).addQuotes())
	do sr.add("set "_ PSL.oLvn_ "(vOid,0)=1")

	for ln=1:1:exe("").order(-1) do sr.add( $$selBootReplace( exe(ln), "vOid"))

	do sr.add("do vRws.beforeFirst()")
	do sr.add("#ACCEPT GROUP=BYPASS;CR=27800;PGM=Frans S.C. Witte;Date=2008-03-11")
	do sr.add("#BYPASS")
	do sr.add("IF $$"_ fetchLab_"(vOid) SET "_ PSL.oLvn_ "(vOid,0)=2")
	do sr.add("#ENDBYPASS")
	do sr.add("quit vOid")

	do sr.insert( openLab, "ResultSet")

	/* FETCH code ----------------------------------------------------------
	*/
	set sr = PSL.openBuffer( "(Number vOid)", "PSLBOOT fetch for "_ from)
	do sr.add("type public RowSet pslPrsr(,)")
	do sr.add("#ACCEPT GROUP=BYPASS;CR=27800;PGM=Frans S.C. Witte;Date=2008-03-11")
	do sr.add("#BYPASS")
	do sr.add("IF '$DATA(pslPrsr(""boot"","""_from_""")) QUIT $$vFetch"_seqnorm_"(vOid)")
	do sr.add("#ENDBYPASS")
	do sr.add("if "_ PSL.oLvn_"(vOid,0)=2 set "_ PSL.oLvn_"(vOid,0)=1 quit 1")
	do sr.add("type RowSet vRws = {RowSet}pslPrsr(""boot"","""_from_""")")
	do sr.add("type Row vR")
	if where.isNull() do {
		do sr.add("set "_ PSL.oLvn_"(vOid,0) = vRws.next()")
	}
	else  do {
		do sr.add("type Boolean vFnd = 0")
		do sr.add("while 'vFnd do {")
		do sr.add("  if 'vRws.next() set vFnd=1,"_ PSL.oLvn_"(vOid,0)=0 quit")
		do sr.add("  set vR=vRws.getRow()")

		for ln=1:1:WHM("").order(-1) do sr.add("  "_ $$selBootReplace( WHM(ln), "vOid"))
		do sr.add("  set vFnd=1")
		do sr.add("}")
	}
	type String line

	if select.isLiteral() do {
		do sr.add("set vR = vRws.getRow()")
		set line = "vR."_ sellist.piece(",").lowerCase()
		type Number n
		for n=2:1:sellist.length(",") set line = line_ "_9.char()_vR."_ sellist.piece(",",n).lowerCase()
		do sr.add("set "_ PSL.oLvn_"(vOid) = "_ line)
	}
	else  do {
		do sr.add("set vR = vRws.getRow()")
		do sr.add("type String vS = vR.toString()")
		do sr.add("type String vD = vR.getDelimiter()")
		do sr.add("type List vH = vR.getColumns()")
		do sr.add("type String vL = """" type Number vP1,vP2 type String vC")
		do sr.add("for vP1=1:1:"_select_".length("","") set vC="_select_".piece("","",vP1),vP2=vH.position(vC),vL = vL_9.char()_vS.piece(vD,vP2)")
		do sr.add("set "_ PSL.oLvn_"(vOid) = vL.extract(2, vL.length())")
	}

	do sr.add("quit "_ PSL.oLvn_"(vOid,0)")

	do sr.insert( fetchLab, "Boolean")

	/* trailing code: update struct(), turn optimize off, return method
	   result */
	set struct("s",subRou,varNew,var).piece(tab, seqpiece) = seq

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do setOpti^UCGM( var, var.scopeLevel, -1)
	set PSL.return = "$$"_openLab_ PSL.return

	quit

	// ---------------------------------------------------------------------
private selBootReplace( String code
		, String recInst
		)
	/* ---------------------------------------------------------------------
	Replace code line generated by SQL with code line to be used in PSL
	generated code. This subroutine performs the following replacements
	- I vsql(nnn)="" S ER=1,...
		This code and all code following it will be removed.
	- I vsql(nnn)="" S vsql=-1
		This code and all code following it will be removed.
	- vsql(nnn)
		Will be replaced by vobj(RecInst,nnn)
	- sqlcur
		Will be replaced by RecInst
	- ^DBTMP(%TOKEN
		Will be replaced by ^DBTMP($JOB 
		Note that this replacement is not supposed to occur in this
		context, because its use is tied to ORDER-BY or aggregates.
	- S vsql=nnn
		Will translate in a QUIT.
		This is based on the assumption that "jumps" that may be present
		in other SQL code will not occur here because only a single
		table is allowed.

	NOTES:
	. This code is very sensitive to changes in the code generated by the
		SQL engine !!
	. When the value of a HOSTVARs is the empty string, this code will treat
		it as a valid string. This differs from the behavior of the code
		in the exe() array, which will usually quit with vsql=-1 in that
		case. The problem here is that in some cases an argumentless
		QUIT would be in order, whereas in other cases either a QUIT
		with argument or a runtime exception would be in order.
	. 
	*/
	type literal String SETVSQL = "S vsql="
	type literal String SETVSQL2 = ",vsql="

	type String lbl
	type Number num,p1,p2

	if code?.ANP1" I vsql("1.N1")=""""".ANP, code.contains(" S ER=1,") ! code.contains(" S vsql=-1") do {
		set code = code.piece(" I vsql(")
		if code["$G(" set code = code.piece("$G(")_ code.piece("$G(",2), code = code.extract(1,code.length()-1)
	}
	else  if code["'?.N" set code=";"

	if code["sqlcur" set code = $$VarSub^UCPATCH( code, "sqlcur", recInst)

	if code["^DBTMP(%TOKEN" set code = $$VarSub^UCPATCH( code, "^DBTMP(%TOKEN", "^DBTMP($J")

	set p1 = 0
	for  set p1 =code.find( "vsql(", p1) quit:p1=0  set p2 = code.find( ")", p1) quit:p2=0  do {
		set num = code.extract( p1, p2 - 2)
		set code = code.extract( 1, p1 - 6)_ PSL.oLvn_ "("_ recInst_ ","_ num_ ")"_ code.extract( p2, code.length())
	}

	if code[SETVSQL do {
		set num = code.piece(SETVSQL, 2) + 1
		set code = code.piece(SETVSQL)_ "Q"
		if num>0 throw Class.new("Error", "%PSL-E-PSLBOOT,Cannot create /PSLBOOT code")
	}

	if code[SETVSQL2 do {	// and isAgFunc
		set num = SETVSQL2.piece( SETVSQL2, 2) + 1
		set code = code.piece("S vd")_"Q"
		if num>0 throw Class.new("Error", "%PSL-E-PSLBOOT,Cannot create /PSLBOOT code")
	}

	quit " "_ code

	// ---------------------------------------------------------------------
selCdAssign( PSLSubrou sr	// subroutine instance
		, Number nType		// 0 = fetch, 1 = open, 10/11 = dynamic
		, String prot()		// data item protection XECUTEs (*3)
		)	// Generate common fetch / open code
	/* ---------------------------------------------------------------------
	Generate common fetch / open code.
	The code to handle the returned values is common to Open and Fetch,
	except for the function return value:
	- Open: return the Object ID
	- Fetch: return end-of-result

	The generated code treats vEr=100 first. This causes vobj(vOid,0)=0.
	The API will already have closed the cursor, so there is no need to
	close it explicitly, but the call to vCloseRDBOpt^vResultSet() needs to
	be generated to ensure that local side-effects will occur.
	If vEr<0, then an exception will be thrown. Even in this case there is
	no need to call $$CLOSECUR^%DBAPI, because the API will do that on a
	fatal error as well.

	ARGUMENTS:
	(*3) prot() = protection XECUTEs
		For nType = 0 and nType = 1 (non-dynamic) the array shall
		contain the values returned by getExe^SQLPROT()
		For nType=10 or nType=11 (dynamic) at least one dummy entry
		shall be present to indicate the need to include runtime
		datitemprotection modification of the resultrow.
	*/
	type public String oLvn

	type String retVal
	if nType#10 set retVal="vOid"
	else  set retVal="0"

	do sr.addCode(" I vEr=100!(vEr<0) S "_ oLvn_ "(vOid,0)=0,"_oLvn_"(vOid)="""" D vCloseRDBOpt^vResultSet("_ oLvn_ "(vOid,1),0) Q:vEr=100 "_retVal_" S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)),$EC="",U1001,""")

	/* Insert data item protection code if applicable.
	   For dynamic code, execute the lines vobj(vOid,.1,1) through the value
	   specified by vobj(vOid,.1,0)
	   */
	if 'prot("").order().isNull() do { 
		if nType>9 do {
			do sr.addCode(" N v0 F v0=1:1:$O("_ oLvn_ "(vOid,.1,""""),-1) X "_ oLvn_ "(vOid,.1,v0) ;=noOpti")
			do sr.addCode(" S "_ oLvn_ "(vOid,.1)=$G(vi)")
		}
		else  do {
			type Number n = ""
			for  set n=prot(n).order() quit:n=""  do sr.addCode(" "_ prot(n))
			do sr.addCode(" S "_ oLvn_ "(vOid,.1)=$G(vi)")
		}
	}
	do sr.addCode(" S "_ oLvn_ "(vOid)=vd")
	quit

	// ---------------------------------------------------------------------
selSrFetch( PSLSubrou sr		// subroutine instance
		, String fetchLab	// label used for fetch function
		, Number mode		// 0 = normal mode, 10 = dynamic
		, String dipx()		// data item protection executes
		)	// Builds the fetch logic for the select methods
	/* ---------------------------------------------------------------------
	Builds the fetch logic for the select methods

	INPUTS:
	. fetcLabel = label for this fetch function
	. oLvn
	. var = ResultSet (DbSet) target variable

	OUTPUTS:
	. $$ = subscript in append() where code of vFetchN() subroutine starts
	. append() has been extended with vFetchN() code

	NOTES:
	. The MDB data item protection logic has hardcoded variable names "vd"
		and "vi". Even though we may be able to use different names for
		RDB calls, the code that deals with dynamic selects must be
		able to deal with both RDB and MDB tables, in which case it will
		need to used "vd" and "vi" anyway. For this reason, the RDB code
		will use these names as well.
	*/
	type public String oLvn

	do sr.addCode(" ;")
	do sr.addCode(fetchLab_"(vOid) ; Fetch Row for RDB ResulSet")

	do sr.addCode(" ;")
	do sr.addCode(" ;")
	do sr.addCode(" I "_ oLvn_ "(vOid,0)=0 Q 0")
	do sr.addCode(" I "_ oLvn_ "(vOid,0)=2 S "_ oLvn_ "(vOid,0)=1 Q 1")
	do sr.addCode(" N vEr,vRm,vd,vi ;=noOpti")

	do sr.addCode(" S vEr=$$FETCH^%DBAPI(0,"_ oLvn_ "(vOid,1),1,$C(9),.vd,.vRm)")
	do selCdAssign( sr, mode, dipx())

	do sr.addCode(" Q 1")

	quit

	// ---------------------------------------------------------------------
selSrOpen( noret PSLSubrou sr		// PSLSubrou instance
		, noret String fetchLab		//
		, ret   PSLExpression sql	// SELECT statement
		, noret String dipx()		// Data item protection XECUTES
		, noret String map(,)		// identifier map
		)
	/* ---------------------------------------------------------------------
	Generate code for vOpen()

	ARGUMENTS:
	. sql = sql statement
		To generate code for non-dynamic select, supply the SQL
		statement as returned by $$RsDyRt^UCDBRT()
		To generate code for dynamic select, supply the following
		string:
			"@,lvnSql,lvnMap"
		with:
		- lvnSql = the name of the variable that contains the SQL
			statement. This value will be added as pass-by-reference
			parameter in the call to $$RsMsXV^UCDBRT, and as
			pass-by-value parameter in the call to $$OPENCUR^%DBAPI
		- lvnMap = the name of the variable that contains the map(,)
			array. This value will be added as  pass-by-reference
			parameter in the call to $$RsMsXV^UCDBRT, and it will
			be used to contruct the code that sets vobj(vOid,-3) and
			vobj(vOid,-4).
	INPUTS:
	. sr has been instantiated (i.e. calls to sr.addCode() are valid)
	. oLvn

	OUTPUTS:
	. $$ = subscript in append() where vOpenN() code starts
	. append() has been extended with vOpenN() code

	NOTES:
	. see selSrFetch() for explanation for use of "vd" and "vi".
	*/
	type public String oLvn

	type literal String TAIL = ",$C(9),vList,.vCurID,.vd,.vRm)"

	do sr.addCode(" N vOid")

	do sr.addCode(" S vOid=$O("_ oLvn_ "(""""),-1)+1,"_ oLvn_ "(vOid,-1)=""ResultSet""")
	do sr.addCode(" N vCurID,vd,vEr,vi,vList,vRm ;=noOpti")

	/* Add code that assigns vList, and transform sql to its string rep.
	  If sql starts with "@", it is for dynamic open. */
	type String lvnSql,lvnMap,lvnDpx
	if sql.extract() = "@" do {
		set lvnSql = sql.piece( ",", 2), lvnMap = sql.piece( ",", 3)
		do sr.addCode(" S @(""vList=""_$$RsMsXV^UCDBRT(." _lvnMap_ ",."_ lvnSql_ "))")
	}
	else  do sr.addCode(" S vList="_ $$RsMsXV^UCDBRT(map(,),.sql))

	/* The length of the SQL statement (in sql) may exceed the maximum line
	   length supported for a GT.M routine. If that is the case, split the line
	   */
	if 'sql.fitsLineLength() do {
		do sr.addCode(" N vSql ;=noOpti")
		do setLong(sr, "vSql", sql)
		do sr.addCode(" S vEr=$$OPENCUR^%DBAPI(0,vSql"_ TAIL)
	}
	else  do sr.addCode(" S vEr=$$OPENCUR^%DBAPI(0,"_ $select(sql.extract()="@":lvnSql,1:sql.addQuotes())_ TAIL)

	/* Ensure that the variables needed to close the cursor are
	   assigned regardless of the result of $$OPENCUR^%DBAPI */
	do sr.addCode(" S "_ oLvn_ "(vOid,-5)=1")
	do sr.addCode(" S "_ oLvn_ "(vOid,1)=vCurID")
	do sr.addCode(" I vEr<0 S "_oLvn_"(vOid,0)=0 S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)),$EC="",U1001,""")
	do sr.addCode(" S "_ oLvn_ "(vOid,-2)=""$$"_ fetchLab_ "^""_$T(+0)")
	if sql.extract() = "@" do {
		do sr.addCode(" S "_ oLvn_ "(vOid,-3)="_ lvnMap_ "(""SELNAM"")")
		do sr.addCode(" S "_ oLvn_ "(vOid,-4)="_ lvnMap_ "(""SELTYP"")")

		/* Add code that gets the data item protection and inserts it
		   at vobj(vOid,.1,p) */
		if 'dipx.data() quit
		set lvnDpx = sql.piece( ",", 4)
		do sr.addCode(" I $D("_lvnDpx_ ") N v0,v1 S v0="""" F v1=1:1 S v0=$O("_lvnDpx_"(v0)) Q:v0=""""  S "_ oLvn_ "(vOid,.1,v1)="_ lvnDpx_ "(v0)")
	}
	else  do {
		do setLong(sr, oLvn_ "(vOid,-3)", map("SELNAM"))
		do setLong(sr, oLvn_ "(vOid,-4)", map("SELTYP"))
	}

	do selCdAssign( sr, $select(sql.extract()="@":11,1:1), dipx())

	do sr.addCode(" S "_ oLvn_ "(vOid,0)=2")
	do sr.addCode(" S vobjCurs(vCurID)=$STACK-$g(vOff)")
	do sr.addCode(" Q vOid")

	quit

	// ---------------------------------------------------------------------
private setLong( PSLSubrou sr		// the subroutine 
		, PSLIdentifier lvn	// the lvn to receive the long expr
		, PSLExpression lulit	// the long unquoted literal
		)	// insert code to assign "long" literal (using multiple code lines)
	/* ---------------------------------------------------------------------
	This subroutine generates the following assignment:
		"set lvn="_lulit.addQuotes()
	If the length of lulit exceeds the maximum specified by the constant
	PSL.maxLineLength, then the assignment will be split over multiple lines.
	The length of the supplied lvn shall be such that
		2 * lvn.length() + PSL.maxLineLength + 3 < maxRoutineLineLength
	With the current value of PSL.maxLineLength and the GT.M line length this leaves
	about 50 characters for lvn.
	
	If an assignment is always in order, then this code can be called
	unconditionally, because a single assignment will result if the length
	is within the limit.
	*/
	type Number part
	type PSLExpression split()
	do splitCode^UCGMC( lulit, 0, "", split())

	do sr.addCode(" S "_ lvn_ "="_ split(1).addQuotes())
	for part=2:1:split("").order(-1) do sr.addCode(" S "_ lvn_ "="_ lvn_ "_"_ split(part).addQuotes())
	quit

	// ---------------------------------------------------------------------
where( ret String table			// profile table name (*1)
		, String where		// WHERE-clause (*2)
		, String selmap(,)	// table, column, hostvar map (*3)
		)	// WHERE-clause of single table
	/* ---------------------------------------------------------------------
	This subroutine handles the WHERE clause of a single table. It can be
	used to decompose the conditions in Db.isDefined, Db.delete etc.
	If the table is a parent table, such as DEP or LN, then the table's
	DBTBL1.QID1 value will be added to the WHERE clause.

	ARGUMENTS:
	(*1) The Profile table name shall be supplied at input.
		On return, this variable will contain the internal (RDB) name(s)
		of the table(s) that are included in the WHERE clause.
	(*2) A valid WHERE clause, with HOSTVARs that are acceptable to the RDB
		API. This implies that Record.property references shall have been
		replaced by the caller (eg by calling $$mapPSLvar^UCDB()).
	(*3) as returned by $$RsMsCls^UCDBRT()
		To construct the hostvar mapping pass this array directly to
		$$RsMsXV^UCDBRT(), together with the result returned by this
		function.
	OUTPUTS:
	. $$ = WHERE clause that is acceptable to the RDB.
	. table = internal (RDB) tablename

	EXAMPLE:
	set modWhere=$$where^UCDBR(.table,where,.hvMap(,))
	do addCode(" N vEr,vList,vRm")
	do addCode(" S vList="_$$RsMsXV^UCDBRT(.hvMap(,),.modWhere))
	do addCode(" S vEr=$$EXECUTE^%DBAPI(0,""DELETE FROM "_table_" WHERE "_modWhere_",$C(9),vList,.vRm)")
	*/
	type String sqllit

	/* transform into SELECT primary,key FROM table WHERE where */
	type PSLTable td = PSL.getPSLTable(table)
	
	/* If child table, add VIEW condition to WHERE clause
	================ this is not needed. RsDyRT^UCDBRT() will take care of that
	if 'td.parentTable.isNull() do {
		type String qid1 = $$RsMsQID1^UCDBRT( table)
		if qid1.isNull() quit
		if where.isNull() set where = qid1 quit
		if where.translate("()","  ")[" OR " set where = "("_ where_ ")"
		set where = where _" AND "_qid1
	}
	================ */
	
	type String expr = $$RsDyRT^UCDBRT(td.primaryKeys, table, where, "", "", "", selmap(,))

	/* split return value:
	   - drop SELECT part
	   - put FROM part into table
	   - return WHERE part
	   Note that the FROM part is assumed to be a simple table list */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set expr = $$TOKEN^%ZS(expr,.sqllit,"'")
	set expr = expr.extract(expr.find(" FROM "),expr.length())

	set table = expr.piece(" WHERE ")

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	quit $$UNTOK^%ZS(expr.extract(expr.find(" WHERE "),expr.length()),.sqllit)

	// ---------------------------------------------------------------------
XvClose() //
	/* ---------------------------------------------------------------------
	This subroutine ensures that subroutine vClose will be included in all
	routines that contain a Db.select() or Db.selectDbSet() method.
	The vClose() subroutine will close the cursor, who's object id is passed
	to the subroutine. The object scope cleanup logic will ensure that
	vClose() is called when the object goes out of scope.
	To ensure that "CLOSECUR^%DBAPI is called only once, the generated code
	will check the value of vobj(vOid,0) before calling CLOSECUR^%DBAPI()
	The generated code includes a $D(vobj(vOid,0)) to protect against calls
	with vOid=0, or with uninitialized or erroneous objects.

	INPUTS:
	. methods("Object","killCasc","ResultSet")
		If this variable is already defined, then the vClose() code has
		already been included.

	OUTPUTS:
	. code for subroutine vClose(vOid) added
	. methods("Object","killCasc","ResultSet")="vClose"
		This node defines the subroutine that will be called when a
		ResultSet object goes out of scope.
	. methods("Object","killCasc","DbSet")="vClose"
		This node defines the subroutine that will be called when a
		DbSet object goes out of scope.

	NOTES:
	. Just like the close cursor operation that is implied by accessing the
		last row of the ResultSet, this subroutine will throw an
		exception if the call to $$CLOSECUR^%DBAPI() returns an error.
	*/
	type String VCLOSE = $$XvCloseName()

	type public String methods(,,)

	if methods("Object","killCasc","ResultSet").exists() quit

	// ResultSet and DbSet use the same procedure
	set methods("Object","killCasc","ResultSet") = VCLOSE
	set methods("Object","killCasc","DbSet") = VCLOSE

	// add vClose(oid) to code
	//type PSLSubrou sr = PSL.addSubrou( VCLOSE, "(vOid)", "Close any ResultSet")
	//do sr.addCode( " N vEr,vRm")
	//do sr.addCode( " I $G("_ PSL.oLvn_ "(vOid,-5))=1,"_ PSL.oLvn_ "(vOid,0)'=0 S vEr=$$CLOSECUR^%DBAPI(0,"_ PSL.oLvn_ "(vOid,1),.vRm),"_ PSL.oLvn_ "(vOid,0)=0 I vEr<0 S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)),$EC="",U1001,""")
	//do sr.addCode( " Q")

	quit

	// ---------------------------------------------------------------------
XvCloseC() //
	/* ---------------------------------------------------------------------
	This subroutine is called by UCPATCH when a ResultSet is optimized to
	use vos* variables instead of vobj(rs).
	This subroutine ensures that subroutine vCloseC will be included in the
	generated code.
	The generated vCloseC() procedure accepts 2 parameters:
	* type Number vState - the state variable
		This parameter is /MECH=REFNAM:W/REQ
	* type String vCurID - the cursorid of the cursor to be closed.
		This parameter is /MECH=VAL/REQ
	To ensure that "CLOSECUR^%DBAPI is called only once, the generated code
	will check the value of state before calling CLOSECUR^%DBAPI()

	INPUTS:
	. append("vCloseC")
		If this variable is already defined, then the vCloseC() code has
		already been included.

	OUTPUTS:
	. $$	"vCloseRDBOpt" (i.e. name of method to be called)
	. code for subroutine vCloseC(vOid) added

	NOTES:
	. see xvClose() on vEr/vRm and exceptions
	*/
	type literal String VCLOSEC = "vCloseRDBOpt^vResultSet"

	//if PSL.subrouExists(VCLOSEC) quit VCLOSEC

	//type PSLSubrou sr = PSL.addSubrou(VCLOSEC, "(vState,vCurID)", "Close optimized ResultSet")
	//do sr.addCode(" N vEr,vRm")
	//do sr.addCode(" I vState'=0 S vEr=$$CLOSECUR^%DBAPI(0,vCurID,.vRm),vState=0 I vEr<0 S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)),$EC="",U1001,""")
	//do sr.addCode(" Q")

	quit VCLOSEC
	// ---------------------------------------------------------------------
public XvCloseName() quit "vCloseRDB^vResultSet"
	/* ---------------------------------------------------------------------
	Support function that returns the name of the "standard" vClose method.
	Used here and by UCPATCH.
	*/
 #OPTION ResultClass ON
public String vSIG()	quit "61293^42411^Frans S.C. Witte^46304"	// Signature - LTD^TIME^USER^SIZE
