	/*
	ORIG: FSANCHEZ - 02/17/2003
	DESC: PSL String Method library

	---- Comments ----------------------------------------------------------
	A number of methods still use PSL.mExpr() to generate code.
	The advantage of usinf PSL.mExpr() is that it will perform constant
	propagation on the constructs that are created on the fly.
	The disadvantage is that if arguments are already constant, string
	arguments may end up with numeric or integer literals, which require
	under-the-cover transition:
		123.toString().endsWith(x)
	will end up with 123 as intlit, regardless of the .toString().

	---- Revision History --------------------------------------------------
	2009-03-11, Frans S.C. Witte, CR 35741/37572
		Corrected isEnd to not mix M and PSL code.

	2008-07-09, Frans S.C. Witte, CRs: 34739 / 35742 / 35741
		* Corrected code generated for String.justify()
		* Corrected code generated for String.lowerCase()
		* Corrected code generated for String.toDate()
		* Corrected code generated for String.toTime()

	05/10/07 - Frans S.C. Witte - CR 27800
		* Corrected code generated for String.isInteger()
		* All PSLBuffer.insert() calls now include a resultClass

	04/19/06 - Kevin Braun - CRs: 26723
		* Added String.contains and String.follows

	08/22/06 - Frans S.C. Witte - CRs: 22720 / 22274
		* Corrected String.extract(): empty parameter and absent
		  parameter shall be treated differently
		  (empty = 0, absent = 1).
		* Modified use of PSL.mExpr() in to wrap code elements that are
		  already compiled.

	05/23/06 - Frans S.C. Witte - CRs: 22060 / 22061
		* Replaced lvn bSubfield by bSubfld to stay within the 8 char
		  limit.
		* Removed old code that has been commented out before.
		* Replaced '255' by PSL.maxLitLength.
		* Added an optimization to code generated for String.isNumber().

	03/07/06 - Frans S.C. Witte - CRs: 20280 / 18164
		* Modified upCase and loCase to use lvns that conform to v*
		  naming convention.
		* Modified labels generated to use vStr instead of vstr.
		* All parameter lists to PSL.openBuffer are now properly typed
		* All #ACCEPTs corrected to contain all required fields and the
		  relevant GROUPs.

	01/31/06 - Frans S.C. Witte - CRs: 18163 / 18164
		* Fixed code generated for String.replace().
		* Optimized code generated for String.find().

	12/29/05 - Frans S.C. Witte - CRs: 19000
		* Fix code generated for String.justify()

	11/18/05 - Frans S.C. Witte - CRs: 18727 / 18728
		* Corrected code generated for String.justify(,,,1)
		* Code generated for String.toDate() will now use
		  pslPrsr( "mask", "Date") as the default mask.

	08/31/05 - Frans S.C. Witte - CRs: 17056 / 17057
		* Global: replaced this. by PSL., and actual() by PSL.actual()
		* Replaces type literal maxStringLength by PSL.maxStringLength
		  (2 occurrences).
		* Corrected String.toNumber() when all values literal
		* Added explicit typecasting for Number.piece()

	12/21/04 - Frans S.C. Witte - CRs: 15028 / 16039
		* Inserted quit before first subroutine.
		* Fixed String.find():
			if actual(1).isNull(), then max(1,+actual(1))
		* Subroutine GETSTRING: var is now declared as PSLExpression, and
		  bSubfld is now required.
		* Subroutine PUTSTRING: var is now declared as PSLExpression

	11/05/04 - Frans S.C. Witte - CRs: 11445 / 11446
		Added accessiblity of all methods.
		Subroutine blank is now expresses in terms of String.justify() and
		String.extract(). Added deprecation warning for this subroutine.
		Subroutine extract and subroutine piece: 32767 declared as literal
		(implied stringsize limit!)
		Removed subroutine reverse (now handled by psl2m^UCPRIM()).
		Fixed qadd and qsub when both values are known at complile time.
		Changed subroutine replace (and the code it generates) to
		return the object unchanged if 'count<0', and to support quoteChar.
		Changed subroutines find, piece, and replace to support quoteChar.
		Fixed subroutine piece when 5th parameter is supplied.
		Changed subroutine toNumber to discard format characters from
		positions 5 and up, remove character from position 3.
		Fixed subroutines isNum and isInt to generate code that accept
		only canonic values (no leading/trailing zeros, no exponent).
		Replaced .data() with .exists().
		Moved unpack^UCNUMBER and unpack2^UCNUMBER to this procedure (they
		implement String methods).

	11/04/04 - Frans S.C. Witte - CRs: 12994 / 12995
		Changed subroutines GETSUB and PUTSUB to support all possible cases
		of subfield definitions.

	05/12/04 - RussellDS - CR9676
		Move Profile04 version to Profile01 to support single code
		base for PSL.
   
	04/07/04 - RussellDS - CR9172
		   Fix compile errors.

	01/29/04 - KELLYP - 8051
		   Modified toDate to correct problem when $$^SCAJD is called in PSL
		   and no datemask is specified.  In this case the compiler assumes
		   that the date will be in MM/DD/YEAR format and if it isn't, errors
		   can occur in the date calculation performed by vStrJD.

	12/08/03 7240
		   fix toDate label, julian dates were not correct
	   
	12/08/03 - Spier
		   psl compiler warning message cleanup
	   
	10/14/03 - Frank Sanchez
		   Added support for additional date masks in todate method

	09/22/03 - Frank Sanchez - CR 6031,6032,6034  - arq 51423
		   Fixed bug in toDate when object is literal

        09/16/03 - Spier CR 6031,6032,6034  - arq 51423
        	   Retrofit of changes made in v7.0 up to this date into Profile01
        	   as well as release for v7.0

	*/
	#PACKAGE framework.psl

	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	// ---------------------------------------------------------------------
blank	// Method: String.blank(Number fieldLength, Boolean rightJustify)
	/* ---------------------------------------------------------------------
	Blank fill.

	Deprecated and replaced with String.justify()
	*/
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do WARNDEP^UCGM( 2.6, 3.2, "String.blank() - use String.justify()")

	if PSL.actual(2).isNull() set PSL.actual(2)=-1	// Default left justify
	
	type PSLExpression ap1 = $$tokenPush^UCPATCH( PSL.actual(1), "Number")
	type PSLExpression ap2 = $$tokenPush^UCPATCH( PSL.actual(2), "Boolean")

	set PSL.return = $$tokenPush^UCPATCH( PSL.objectName, "String")_ ".justify("_ ap1_ ","_ ap2_ ",,1).extract(1,"_ ap1_ ")"
	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( PSL.return), 3)
	quit


	// ---------------------------------------------------------------------
contains	// method: String.contains(String string)
	/* ---------------------------------------------------------------------
	returns true if the given string is contained in the object
	*/
	
	/*
	simple expressions don't need parens for correct order of evaluation
	other expressions need the parens
	Also, to make sure the contains method is treated with proper precedence over operators,
	the whole expression returned is put in parens
	*/
	if PSL.actual(1).isNull() set PSL.actual(1) = """"""
	
	if PSL.actual(1) = """""" set PSL.return = "1" quit

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte	
	if $$isSingle^UCGM(PSL.actual(1)) set PSL.return = "("_PSL.objectName_"["_PSL.actual(1)_")"
	else set PSL.return = "("_PSL.objectName_"[("_PSL.actual(1)_")"_")"
	
	if PSL.objectName.isLiteral() set PSL.return=$$toLit(PSL.return)
	quit


	// ---------------------------------------------------------------------
follows	// method: String.follows(String string)
	/* ---------------------------------------------------------------------
	returns true if the object follows the given string
	*/
	
	/*
	simple expressions don't need parens for correct order of evaluation
	other expressions need the parens
	Also, to make sure the contains method is treated with proper precedence over operators,
	the whole expression returned is put in parens
	*/
	if PSL.actual(1).isNull() set PSL.actual(1) = """"""
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if $$isSingle^UCGM(PSL.actual(1)) set PSL.return = "("_PSL.objectName_"]"_PSL.actual(1)_")"
	else set PSL.return = "("_PSL.objectName_"]("_PSL.actual(1)_")"_")"
	
	if PSL.objectName.isLiteral() set PSL.return=$$toLit(PSL.return)
	quit


	// ---------------------------------------------------------------------
extract	// method: String.extract(Number start,Number end)
	// returns a sub-string of a given string
	if PSL.actual(1).isNull() set PSL.actual(1) = 1			// Default to position 1
	if PSL.actual(2).isNull() set PSL.actual(2) = PSL.actual(1)	// Default to 1st parameter
	
	// Optimize this syntax by replacing with the maximum string length
	else  if PSL.actual(2)=("$L("_PSL.objectName_")") set PSL.actual(2) = PSL.maxStringLength

	if PSL.actual(1)=PSL.actual(2) set PSL.return="$E("_ PSL.objectName_ ","_ PSL.actual(1)_")"
	else  set PSL.return="$E("_PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"	

	if PSL.objectName.isLiteral() set PSL.return=$$toLit( PSL.return)

	quit

	// ---------------------------------------------------------------------
piece	// method: String.piece(String delimiter,Number start,Number end,String quoteChar)
	// Returns a sub-string of a given string

	if PSL.actual(4).isNull(1) do psl2m^UCPRIM(1,3) quit	// standard M
	
	/* Remaining code handles the case that a quote character is specified.
	   Test for assignment (not supported), and handle defaults:
	   * start position defaults to 1
	   * end position defaults to start position.
		However this must be handled with care: If start position is not
		literal, substituting will result in evaluating that expression
		twice. Since the result of evaluating the expression may not be
		the same for two consecutive times (e.g. Number.random()), the
		assignment must be postponed until runtime.
	*/
	
	if PSL.fset do PSL.error("Assignment function is not supported") quit

	if PSL.actual(2).isNull(1) set PSL.actual(2)=1
	if PSL.actual(2).isLiteral(), PSL.actual(3).isNull(1) set PSL.actual(3)=PSL.actual(2)
	
	// Optimize this syntax by replacing with the maximum string length
	if PSL.actual(3)=("$L("_ PSL.objectName_")") set PSL.actual(3) = PSL.maxStringLength

		/*
		if actual(2)=actual(3) set PSL.return="$P("_PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
		else  set PSL.return="$P("_PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_")"

		if PSL.objectName.isLiteral() set PSL.return=$$toLit(PSL.return)
	}
	*/
	type literal String label="vStrPce"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(String object,String p1,Number p2,Number p3,String qt)","String.piece")

		do buf.add("if 'p3.exists() set p3=p2")
		do buf.add("if '(object[qt)!qt.isNull() quit object.piece(p1,p2,p3)")
		do buf.add("")
		/*
		Finding the "real" start is based on the observation that for
		each separator inside quotes, 1 shall be added to both p2 and
		p3. Note that multiple quoted occurrences may be present in the
		pieces 1 to p2-1.
		*/
		do buf.add("if object.piece(p1,1,p2-1)[qt do { // find real start")
		do buf.add(" type Number p,o=0")
		do buf.add(" for p=1:1:object.length(p1) quit:p=(p2+o)  s o=(object.piece(p1,1,p).length(qt)#2=0)+o")
		do buf.add(" set p2=p2+o,p3=p3+o")
		do buf.add("}")
		//do buf.add("if object.piece(p1,1,p2-1).length(qt)#2=0 do {")
		//do buf.add(" for p2=p2+1:1:object.length() set p3=p3+1 if object.piece(p1,1,p2-1).length(qt)#2 quit")
		//do buf.add("}")
		/*
		Finding the "real" end is based on the observation that for each
		separator nside quotes, one shall be added to p3. Note that the
		initial value of p3 may be inside a quoted string, and that
		multiple quoted occurrences may be present in the pieces p2 to p3.
		The end condition on the FOR command ensures that the loop
		terminates when the pieces p2 to the end contain an odd number of
		quote characters.
		The quit condition ((p=p3)&'o) can be read as "the requested end
		has been reached while not inside quoted string".		
		The algorithm below is eledgible for opimization.
		*/
		do buf.add("if object.piece(p1,p2,p3)[qt do { // find real end")
		do buf.add(" type Number p,o")
		do buf.add(" for p=p2:1:object.length(p1) set o=(object.piece(p1,p2,p).length(qt)#2=0),p3=o+p3 quit:(p=p3)&'o")
		//do buf.add(" set p3=p3-1")
		//do buf.add(" for p3=p3+1:1:object.length() if object.piece(p1,p2,p3).length(qt)#2=0 quit")
		do buf.add("}")
		do buf.add("quit object.piece(p1,p2,p3)")

		do buf.insert(label, "String")
	}
	
	set PSL.return="$$"_label_"("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_","_ PSL.actual(4)_")"
	quit
	
	// ---------------------------------------------------------------------
justify	// Method: String.justify(Number fieldLength,Number option,String padCharacter,Boolean truncate)
	/* ---------------------------------------------------------------------
	Returns justified string
	*/
	
	if PSL.actual(1).isNull(1) set PSL.return = PSL.objectName quit

	if PSL.actual(2).isNull(1) set PSL.actual(2)=1		// Default RightJustify
	if PSL.actual(3).isNull(1) set PSL.actual(3)=""" """	// Default spacePad
	else  if PSL.actual(3)="$C(32)" set PSL.actual(3)=""" """
	if PSL.actual(4).isNull(1) set PSL.actual(4)=0		// Default noTruncate

	type PSLExpression obj = $$tokenPush^UCPATCH( PSL.objectName, "String")
	type PSLExpression ap1 = $$tokenPush^UCPATCH( PSL.actual(1),  "Number")
	type PSLExpression ap2 = $$tokenPush^UCPATCH( PSL.actual(2),  "Number")
	type PSLExpression ap3 = $$tokenPush^UCPATCH( PSL.actual(3),  "String")
	type PSLExpression ap4 = $$tokenPush^UCPATCH( PSL.actual(4),  "Boolean")
	
	type String code = "$J("""","_ ap1_"-"_ PSL.objectName_".length())"
	if ap3'=""" """ set code=code_".translate("" "","_ ap3_")"

	if ap2.isLiteral() do {	// justification is known

		type Number option = ap2.stripQuotes()

		if option<0 set code = PSL.objectName_"_"_code
		else  if option=0 set code="$$CJ^%ZTEXT("_ PSL.objectName_","_ ap1_")"
		else  do {
			if ap3=""" """ set code="$J("_ PSL.objectName_","_ ap1_")"
			else  set code=code_"_"_ PSL.objectName
		}

	}
	else  set code="$S("_ ap2_">0:"_code_"_"_ PSL.objectName_","_ ap2_"<0:"_ PSL.objectName_"_"_code_",1:$$CJ^%ZTEXT("_ PSL.objectName_","_ ap1_"))"

	/* add or apply truncation. Since it applies to the previous result,
	   use parenthesis around "code". */
	if 'ap4.isLiteral() set code="$S("_ ap4_":("_code_").extract(1,"_ ap1_"),1:"_code_")"
	else  if ap4.stripQuotes() set code = "("_ code_ ").extract(1,"_ ap1_")"

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( code), 5)

	if PSL.objectName.isLiteral() set PSL.return=$$toLit( PSL.return)

	quit

	// ---------------------------------------------------------------------
insert	// method: String.insert(String string,Number offSet,String padCharacter,Boolean displace)
	/* ---------------------------------------------------------------------
	Insert a string into a string
	*/

	if PSL.actual(2).isNull(1) set PSL.actual(2)=1		// Default insert position
	if PSL.actual(3).isNull(1) set PSL.actual(3)=""" """	// Default spacePad
	if PSL.actual(4).isNull(1) set PSL.actual(4)=0		// Default overstrike

	// if inserting in position one, optimize into simple expression
	if PSL.actual(2).stripQuotes()=1, PSL.actual(4).isLiteral() do { quit		

		if PSL.actual(4).stripQuotes() set PSL.return = PSL.actual(1)_"_"_ PSL.objectName
		else  do {
			type PSLExpression obj = $$tokenPush^UCPATCH( PSL.objectName, "String")
			type PSLExpression ap1 = $$tokenPush^UCPATCH( PSL.actual(1),  "String")
			set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( ap1_ "_"_ obj_ ".extract("_ ap1_ ".length()+1,"_ obj_ ".length())"), 2)
		}

		if PSL.objectName.isLiteral() set PSL.return = $$toLit( PSL.return)
	}

	// Optimize when literal string length is less than the insert position
	if PSL.objectName.isLiteral(), PSL.actual(2).isLiteral(), PSL.actual(2).stripQuotes() > PSL.objectName.stripQuotes().length() do { quit

		type PSLExpression ap1 = $$tokenPush^UCPATCH( PSL.actual(1),  "String")
		type PSLExpression ap3 = $$tokenPush^UCPATCH( PSL.actual(1),  "String")

		set PSL.return = PSL.objectName_ "_"""".justify("_ PSL.actual(2)_ "+1-"_ PSL.objectName.length()_ ")"
		if ap3 '= """ """ set PSL.return = PSL.return_ ".translate("" "","_ ap3_ ")"
		set PSL.return = PSL.return_ "_"_ ap1
		set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( PSL.return), 2)
		set PSL.return = $$toLit( PSL.return)
	}

	type String label="vStrIns"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(String object,String p1,Number p2,String p3,Boolean p4)","String.insert")

		do buf.add("set p2=p2-1")
		do buf.add("if object.length()<p2 set object=object_$S(p3="" "":"""".justify(p2-object.length()),1:"""".justify(p2-object.length()).translate("" "",p3))")
		do buf.add("quit object.extract(1,p2)_p1_object.extract($S(p4:0,1:p1.length())+p2+1,object.length()))")

		do buf.insert(label, "String")
	}

	set PSL.return="$$"_label_"("_PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_","_ PSL.actual(4)_")"

	quit

	// ---------------------------------------------------------------------
find	// Method: String.find(String string,Number start,Boolean ignoreCase,String quoteChar)
	// Find an expression within a string

	if PSL.actual(2).isNull() set PSL.actual(2)= PSL.actual(2).addQuotes()
	if PSL.actual(3).isNull() set PSL.actual(3)= PSL.actual(3).addQuotes()
	if PSL.actual(4).isNull() set PSL.actual(4)= PSL.actual(4).addQuotes()


	if PSL.actual(3).isNull(1), PSL.actual(4).isNull(1) do { quit

		if PSL.actual(2).isNull(1) set PSL.return="$F("_ PSL.objectName_","_ PSL.actual(1)_")"
		else  set PSL.return="$F("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
		if PSL.objectName.isLiteral() set PSL.return = $$toLit( PSL.return)
	}

	// Special case: "find the empty string" always returns 1
	if PSL.actual(1).isNull(1), PSL.actual(2).isNull(1) do { quit
		type Number pos = PSL.actual(2).stripQuotes().toNumber()
		if pos<1 set PSL.return=1
		else  set PSL.return = +PSL.actual(2)
	}

	type String label="vStrFnd"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(String object,String p1,Number p2,Boolean p3,String qt)","String.find")

		do buf.add("")
		do buf.add("if p1.isNull() quit $select(p2<1:1,1:+p2)")
		do buf.add("if p3 set object=object.upperCase(),p1=p1.upperCase()")
		do buf.add("set p2=object.find(p1,p2)")
		do buf.add("if 'qt.isNull(),object.extract(1,p2-1).length(qt)#2=0 do {")
		do buf.add(" for  set p2=object.find(p1,p2) quit:p2=0!(object.extract(1,p2-1).length(qt)#2)")
		do buf.add("}")
		do buf.add("quit p2")

		do buf.insert(label, "Number")
	}

	set PSL.return="$$"_label_"("_PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_","_ PSL.actual(4)_")"

	quit

	// ---------------------------------------------------------------------
replace	// Method: String.replace(String expr1,String expr2,Number count,Boolean ignoreCase,String quoteChar)
	/* ---------------------------------------------------------------------
	Replace occurences of one string with another
	*/

	if PSL.actual(1).isNull(1) set PSL.return = PSL.objectName quit

	if PSL.actual(2).isNull()  set PSL.actual(2) = PSL.actual(2).addQuotes()
	if PSL.actual(3).isNull(1) set PSL.actual(3) = 0	// default: all occurrences
	if PSL.actual(4).isNull(1) set PSL.actual(4) = 0	// default: not ignore case
	if PSL.actual(5).isNull()  set PSL.actual(5)= PSL.actual(5).addQuotes()

	// If parameters are identical - exit
	if PSL.actual(1)= PSL.actual(2) set PSL.return=PSL.objectName quit

	/* If parameter 3 is literal, take its value, otherwise use arbitrary 
	   positive value. Any positive value will prevent optimization */
	type Number count = $$toVal^UCPRIM( PSL.actual(3),1)
	
	/* If count < 0, no replacements are to be made */
	if count < 0 set PSL.return=PSL.objectName quit

	/* If parameter 4 is literal, take its value, otherwise use 1, which 
	   will prevent optimization */
	type Boolean ignCase = $$toVal^UCPRIM( PSL.actual(4),1)

	/* If the first string is a single character and the second string
	   is a single character or NULL and all the parameters are literal
	   then optimize usinq the character translate method */

	type Number len1="",len2=2
	if PSL.actual(1).isLiteral() set len1= PSL.actual(1).stripQuotes().length()
	else  if PSL.actual(1)?1"$C("1.N1")" set len1=1		// $C(ascii)

	if PSL.actual(2).isLiteral() set len2= PSL.actual(2).stripQuotes().length()
	else  if PSL.actual(2)?1"$C("1.N1")" set len2=1		// $C(ascii)

	if len1=1, len2<2, count=0, 'ignCase, PSL.actual(5).isNull(1) do { quit
		type PSLExpression obj = $$tokenPush^UCPATCH( PSL.objectName, "String")
		type PSLExpression ap1 = $$tokenPush^UCPATCH( PSL.actual(1),  "String")
		type PSLExpression ap2 = $$tokenPush^UCPATCH( PSL.actual(2),  "String")

		set PSL.return = obj_ ".translate("_ ap1_ ","_ ap2_ ")"
		set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( PSL.return), 3)
		if PSL.objectName.isLiteral() set PSL.return = $$toLit( PSL.return)
	}

	type String label="vStrRep"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(String object,String p1,String p2,Number p3,Boolean p4,String qt)","String.replace")

		do buf.add("")
		do buf.add("if p3<0 quit object")
		do buf.add("if p1.length()=1,p2.length()<2,'p3,'p4,qt.isNull() quit object.translate(p1,p2)")
		do buf.add("")
		do buf.add("type Number y=0")
		do buf.add("for  set y=object.find(p1,y,p4,qt) quit:y=0  do {")
		do buf.add(" set object=object.extract(1,y-p1.length()-1)_p2_object.extract(y,object.length())")
		do buf.add(" set y=y+p2.length()-p1.length()")
		do buf.add(" if p3 set p3=p3-1 if p3=0 set y=object.length()+1")
		do buf.add("}")
		do buf.add("quit object")

		do buf.insert(label, "String")
	}

	set PSL.return="$$"_label_"("_PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_","_ PSL.actual(4)_","_ PSL.actual(5)_")"

	quit

	// ---------------------------------------------------------------------
toLit(String expr)	// Execute an expression and return a literal
	/* --------------------------------------------------------------------- 
	if the object is a literal string and all the parameters are also
	either literal strings or NULL or UNDEFINED, then execute the code
	expression.  If the resulting expression is not a number quote it.

	If the expression is large (as defined by PSL.maxLitLength), return the
	original expression. This is to prevent program lines from exceeding the
	length limit for the file system (usually 1 or 2K).
	
	INPUTS:
	* PSL.actual() = all actual parameters.
		All parameters will be checked for either isNull(1) or isLiteral()
		If neither, 'expr' cannot be replaced by its compile time value.
	*/
	type Number i
	type String result

	for i=1:1 quit:'PSL.actual(i).exists()  if '(PSL.actual(i).isNull(1)!PSL.actual(i).isLiteral()) quit
	if PSL.actual(i).exists() quit expr

	catch xMaxStr {
		if xMaxStr.ident["MAXSTR" set xMaxStr.context = expr.translate(",","~")
		throw xMaxStr
	}
	#ACCEPT PGM=spier;date=12/8/03;CR=unknown;GROUP=XECUTE
	xecute "S result="_expr

	// note: order of if-statements is relevant !!
	if result.length()>PSL.maxLitLength quit expr
	if result'=+result set result=result.addQuotes()
	quit result

	// ---------------------------------------------------------------------
unpack	// Method: String.unpack - returns unpack data based on position
	
	if PSL.actual(1).isNull(1) do PSL.error("Length required") quit
	
	set PSL.return="$$UNPACK^%ZFUNC("_PSL.objectName_","_ PSL.actual(1)_")"

	if PSL.objectName.isLiteral() set PSL.return=$$toLit^UCSTRING(PSL.return)

	quit

	// ---------------------------------------------------------------------
unpack2	// Method String.complexUnpack - returns unpack complex data
	
	if PSL.actual(1).isNull(1) do PSL.error("Length required")
	if PSL.actual(2)>1!(PSL.actual(2)<0) do PSL.error($$^MSG(7609))
	if PSL.actual(2).isNull(1) do PSL.error("Signed indicator required")
	if PSL.actual(3).isNull(1) do PSL.error("Left nibble position required")
	
	set PSL.return="$$UNPACK2^%ZFUNC("_PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_")"
	quit
	
	// ---------------------------------------------------------------------
zero	// Method String.zero(Number length,Number decimal,Boolean implied,Boolean sign)
	// Return zero fill.  Save here for legacy support

	do zero^UCNUMBER quit

	// ---------------------------------------------------------------------
getSub	// Method: String.getSub(String tag,String MajorDelim,String SubDelim,Number position)
	/* Generates code for String.getSub(). To generate the code, it calls
	   $$GETSUB() with bSubfld=0 (i.e. the string variant)
	*/

	set PSL.return = $$GETSUB( PSL.actual(1), PSL.actual(2), PSL.actual(3), PSL.actual(4), PSL.objectName, 0)

	if PSL.objectName.isLiteral(),PSL.return'["vStr" set PSL.return = $$toLit( PSL.return)

	quit

	// ---------------------------------------------------------------------
GETSUB( String tag,	// tag
	String sfd1,		// major delimiter or its ASCII code
	String sfd2,		// sub delimiter ot its ASCII code
	Number sfp,		// position
	PSLExpression var,	// object variable / expression
	Boolean bSubfld)	// parameters passed as stored for DQ subfield?
	/*----------------------------------------------------------------------
	Generate code for String.getSub().
	This function is also called by UCCOLUMN
	The getSub() method exhibits the following behavior:
	1) If tag and majorDelim are both empty, then this method returns
	   exactly the same value as StringObject.extract(position). The value
	   of subDelim is ignored in this case.
	2) If tag is the empty string, and majorDelim is not the empty string,
	   then this method returns exactly the same value as
	   StringObject.piece(majorDelim, position).
	   The value of subDelim is ignored in this case as well.
	3) If tag is not the empty string, then majorDelim.length() shall be 1.
	   If subDelim is not the empty string, then subDelim.length() shall also
	   be 1. In this case the method locates a majorDelim delimited field,
	   that starts with tag (followed by subDelim). It then returns the
	   subDelim delimited subfield following tag specified by position.
	   If tag occurs more than once, then the leftmost occurrence will be
	   used.

	NOTES:
	. This code still uses PSL.mExpr() without tokenizing the "arguments".
		This will work as long as PSL.objectName and all PSL.actual()s
		contain only M constructs that are also PSL constructs.
	*/
	if sfd1.isNull() set sfd1 = sfd1.addQuotes()
	if sfd2.isNull() set sfd2 = sfd2.addQuotes()
	if sfp.isNull(1) set sfp = 1	// default value = 1

	// case 1) label and majorDelim both empty
	if tag.isNull(1),sfd1.isNull(1) quit PSL.mExpr(var_".extract("_sfp_")")

	// if parameters passed in DQ subfield format, then add code for $CHAR()
	type String prefix, postfix
	
	if bSubfld set prefix = "$CHAR(", postfix = ")"
	else  set prefix = "", postfix = ""
	
	// case 2) label empty
	if tag.isNull(1) quit PSL.mExpr(var_".piece("_prefix_sfd1_postfix_","_sfp_")")

	// remaining code handles case 3 or defers to runtime
	type Boolean bMajor = sfd1.isLiteral()
	if bMajor, sfd2.isNull(1) set sfd2 = sfd1

	type Boolean bSub = sfd2.isLiteral()

	// If all parameters are literal, then the last runtime check can be done
	// here, and if OK, the M code can be returned directly
	// Note that the indvidual components may be optimized by .piece()
	type String expr
	if bMajor,bSub,({String}sfp).isLiteral() do {  quit PSL.mExpr( expr)
		if 'bSubfld do {
			if sfd1.stripQuotes().length() > 1 do PSL.error("String.getSub delimiter shall be single character")
			if sfd2.stripQuotes().length() > 1 do PSL.error("String.getSub delimiter shall be single character")
		}
		if sfp>1,sfd1=sfd2 do PSL.error("String.getSub position shall be 1")
		set sfd1 = prefix_sfd1_postfix
		set sfd2 = prefix_sfd2_postfix
		set expr = "("_sfd1_"_"_var_").piece("_sfd1_"_"_tag_"_"_sfd2_",2)"
		set expr = expr_".piece("_sfd1_",1).piece("_sfd2_","_sfp_")"
	}

	// At least one parameter value is not literal. All checking must be
	// postponed until runtime. Generate a function that does the checking
	// and returns the runtime value. The name and generated code depend on
	// the value of bSubfld
	type String label
	if bSubfld do {
		set label="vStrGSub"

		if 'PSL.subrouExists(label) do {
			type literal String PARAMS  = "(String object,String tag,Number del1,Number del2,Number pos)"
			type literal String COMMENT = "String.getSub passing Numbers"

			type PSLBuffer buf=PSL.openBuffer(PARAMS,COMMENT)

			do buf.add("if pos.isNull() set pos=1")
			do buf.add("if tag.isNull(),del1.isNull() quit object.extract(pos)")
			do buf.add("set del1 = $CHAR(del1)")
			do buf.add("if tag.isNull() quit object.piece(del1,pos)")
			do buf.add("set del2 = $CHAR(del2)")
			do buf.add("if del1=del2,pos>1 throw Class.new(""Error"",""%PSL-E-STRGETSUB"")")
			do buf.add("quit (del1_object).piece(del1_tag_del2,2).piece(del1,1).piece(del2,pos)")

			do buf.insert(label, "String")
		}
	}
	else  do {
		set label="vStrGSUB"

		if 'PSL.subrouExists(label) do {
			type literal String PARAMS  = "(String object,String tag,String del1,String del2,Number pos)"
			type literal String COMMENT = "String.getSub passing Strings"

			type PSLBuffer buf=PSL.openBuffer(PARAMS,COMMENT)

			do buf.add("if pos.isNull() set pos=1")
			do buf.add("if tag.isNull(),del1.isNull() quit object.extract(pos)")
			do buf.add("if del1.length()>1 throw Class.new(""Error"",""%PSL-E-STRGETSUB"")")
			do buf.add("if tag.isNull() quit object.piece(del1,pos)")
			do buf.add("if del2.isNull() set del2 = del1")
			do buf.add("if del2.length()>1 throw Class.new(""Error"",""%PSL-E-STRGETSUB"")")
			do buf.add("if del1=del2,pos>1 throw Class.new(""Error"",""%PSL-E-STRGETSUB"")")
			do buf.add("quit (del1_object).piece(del1_tag_del2,2).piece(del1,1).piece(del2,pos)")

			do buf.insert(label, "String")
		}
	}

	quit "$$"_label_"("_var_","_tag_","_sfd1_","_sfd2_","_sfp_")"	

	// ---------------------------------------------------------------------
putSub	// Method: String.putSub(String insert,String tag,String majorDelim,String subDelim,Number position)
	/* Generates code for String.putSub(). The putSub() method acts as the
	   "inverse" of the getSub() method. It returns an edited form of the
	   ObjectString in which the subfield denoted by String.getSub() is
	   replaced by the value of the 'insert' parameter.

	NOTES:
	. Unlike String.getSub(), this subroutine always generates a function
		(either vStrPSUB or vStrPsub) so the only possibility to
		return a compile-time value is by checking (once more) that
		all values are literal, and invoke the method here.
	*/
	set PSL.return = $$PUTSUB( PSL.actual(1), PSL.actual(2), PSL.actual(3), PSL.actual(4), PSL.actual(5), PSL.objectName, 0)

	quit

	// ---------------------------------------------------------------------
PUTSUB( String ins,	// value to insert
	String tag,		// tag
	String sfd1,		// major delimiter or its ASCII value
	String sfd2,		// sub delimiter or its ASCII value
	Number sfp,		// position
	PSLExpression var,	// object variable / expression
	Boolean bSubfld)	// parameters passed as stored for DQ subfield?
	/* generate code for String.putSub().
	   This function is also called by UCCOLUMN to generate code to assign
	   values to subfields. In this case, all parameters that are used have
	   explicit values. This is especially used for del2 where the generated
	   code uses an unconditional "set del2=$CHAR(del2)", and no code is
	   included to set del2=del1 when del2="".
	*/

 	if ins.isNull()  set ins  = ins.addQuotes()
	if tag.isNull()  set tag  = tag.addQuotes()
	if sfd1.isNull() set sfd1 = sfd1.addQuotes()
	if sfd2.isNull() set sfd2 = sfd2.addQuotes()	
	if sfp.isNull(1) set sfp  = 1

	// perform as much compile time checking as possible
	if 'tag.isNull(1) do {
		type Boolean bMajor = sfd1.isLiteral()
		if bMajor, sfd2.isNull(1) set sfd2 = sfd1

		type Boolean bSub = sfd2.isLiteral() & bMajor

		if bMajor,bSub,({String}sfp).isLiteral() do {
			type literal String ERRTXT = "String.getSub delimiter shall be single character"
			if 'bSubfld do {
				if sfd1.stripQuotes().length() > 1 do PSL.error(ERRTXT)
				if sfd2.stripQuotes().length() > 1 do PSL.error(ERRTXT)
			}
			if sfd1=sfd2,sfp>1 do PSL.error("String.getSub position shall be 1")
		}
	}

	// name and generated code depend on bSubfld
	type String label
	type literal String RTERROR = "%PSL-E-STRPUTSUB".addQuotes()
	if bSubfld do {
		set label="vStrPSub"	

		if 'PSL.subrouExists(label) do {
			type literal String PARAMS  = "(String object,String ins,String tag,Number del1,Number del2,Number pos)"
			type literal String COMMENT = "String.putSub passing Numbers"

			type PSLBuffer buf=PSL.openBuffer(PARAMS,COMMENT)  

			do buf.add("if pos.isNull() set pos=1")
			do buf.add("if tag.isNull(),del1.isNull() set object.extract(pos) = ins quit object")
			do buf.add("set del1 = $CHAR(del1)")
			do buf.add("if tag.isNull() set object.piece(del1,pos) = ins quit object.trim(1,del1)")
			do buf.add("set del2 = $CHAR(del2)")
			do buf.add("if del1 = del2, pos > 1 throw Class.new(""Error"", "_RTERROR_")")
			do buf.add("if object.isNull() set object.piece(del2,pos) = ins quit tag_del2_object")
			do buf.add("type String field = (del1_object).piece((del1_tag_del2),2).piece(del1,1)")
			do buf.add("if 'field.isNull() do {")	// code to remove "old" value
			do buf.add("  type String z = del1_tag_del2_field")
			do buf.add("  set object = (del1_object).piece(z,1)_(del1_object).piece(z,2)")
			do buf.add("  if object.extract() = del1 set object = object.extract(2,object.length())")
			do buf.add("}")
			do buf.add("set field.piece(del2,pos) = ins")
			do buf.add("if object.isNull() quit tag_del2_field")
			do buf.add("quit object_del1_tag_del2_field")

			do buf.insert(label, "String")
		}
	}
	else  do {
		set label="vStrPSUB"	

		if 'PSL.subrouExists(label) do {
			type literal String PARAMS  = "(String object,String ins,String tag,String del1,String del2,Number pos)"
			type literal String COMMENT = "String.putSub passing Strings"

			type PSLBuffer buf=PSL.openBuffer(PARAMS,COMMENT)  

			do buf.add("if pos.isNull() set pos=1")
			do buf.add("if tag.isNull(),del1.isNull() set object.extract(pos) = ins quit object")
			do buf.add("if del1.length()>1 throw Class.new(""Error"", "_RTERROR_")")
			do buf.add("if tag.isNull() set object.piece(del1,pos) = ins quit object.trim(1,del1)")
			do buf.add("if del2.isNull() set del2 = del1")
			do buf.add("if del2.length()>1 throw Class.new(""Error"", "_RTERROR_")")
			do buf.add("if del1 = del2, pos > 1 throw Class.new(""Error"", "_RTERROR_")")
			do buf.add("if object.isNull() set object.piece(del2,pos) = ins quit tag_del2_object")
			do buf.add("type String field = (del1_object).piece((del1_tag_del2),2).piece(del1,1)")
			do buf.add("if 'field.isNull() do {")	// code to remove "old" value
			do buf.add("  type String z = del1_tag_del2_field")
			do buf.add("  set object = (del1_object).piece(z,1)_(del1_object).piece(z,2)")
			do buf.add("  if object.extract() = del1 set object = object.extract(2,object.length())")
			do buf.add("}")
			do buf.add("set field.piece(del2,pos) = ins")
			do buf.add("if object.isNull() quit tag_del2_field")
			do buf.add("quit object_del1_tag_del2_field")

			do buf.insert(label, "String")
		}
	}

	quit "$$"_label_"("_var_","_ins_","_tag_","_sfd1_","_sfd2_","_sfp_")"	

	// ---------------------------------------------------------------------
loCase	// Method: String.lowerCase(Boolean capitalizeFirstChar)
	/* ---------------------------------------------------------------------
	Generates vStrLC() that returns the lowercase translation of the object

	NOTES:
	. The generated code assumes that $$UC^%CHARSET() and $$LC^%CHARSET()
		return the characters in such a way that the positions of the
		corresponding uppercase and lowercase characters are equal.
		If there are uppercase characters that do not map directly to a
		lowercase character, then that uppercase character will be
		dropped from the result.
	*/
	type literal String label = "vStrLC"

	type String option= PSL.actual(1)
	if option.isNull(1) set option=0			; Default to 0

	if PSL.objectName.isLiteral(),option.isLiteral() set PSL.return=PSL.objectName.stripQuotes().lowerCase(option) quit

	if 'PSL.subrouExists( label) do {
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		type String uc=$$UC^%CHARSET().addQuotes()

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		type String lc=$$LC^%CHARSET().addQuotes()
		type PSLBuffer buf=PSL.openBuffer("(String vObj,Boolean v1)","String.lowerCase")  

		do buf.add("set vObj=vObj.translate("_uc_","_lc_")")
		do buf.add("if v1 set vObj=vObj.extract().upperCase()_vObj.extract(2,vObj.length())")
		do buf.add("quit vObj")

		do buf.insert( label, "String")
	}

	set PSL.return = "$$"_ label_ "("_ PSL.objectName_ ","_ option_")"
	quit
	
	// ---------------------------------------------------------------------
upCase // Method: String.upCase	 Returns an upper case string
	/* ---------------------------------------------------------------------
	Generates vStrLC() that returns the uppercase translation of the object

	NOTES:
	. The generated code assumes that $$UC^%CHARSET() and $$LC^%CHARSET()
		return the characters in such a way that the positions of the
		corresponding uppercase and lowercase characters are equal.
		If there are lowercase characters that do not map directly to an
		uppercase character, then that lowercase character will be
		dropped from the result.
	*/
	type literal String label="vStrUC"	

	if PSL.objectName.isLiteral() set PSL.return=PSL.objectName.upperCase() quit


	if 'PSL.subrouExists( label) do {
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		type String uc = $$UC^%CHARSET.addQuotes()

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		type String lc = $$LC^%CHARSET.addQuotes()
		type PSLBuffer buf = PSL.openBuffer("(String vObj)","String.upperCase")

		do buf.add("quit vObj.translate("_lc_","_uc_")")
		do buf.insert( label, "String")
	}

	set PSL.return = "$$"_ label_ "("_ PSL.objectName_ ")"
	quit
	
	// ---------------------------------------------------------------------
trim	// Method: String.trim(Number Option, String character)
	// Trims white space from a string
	
	if PSL.actual(1).isNull(1) set PSL.actual(1)=0		// Trim both sides
	if PSL.actual(2).isNull(1) set PSL.actual(2)=""" """

	if PSL.actual(1).isLiteral(), PSL.actual(1).stripQuotes()=1 do { quit
	
		set PSL.return="$$RTCHR^%ZFUNC("_ PSL.objectName_","_ PSL.actual(2)_")"
		if PSL.objectName.isLiteral() set PSL.return = $$toLit( PSL.return)
		}

	type String label="vStrTrim"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(String object, Number p1, String p2)","String.trim")

		do buf.add("if p1'<0 set object=object.trim(1,p2)")
		do buf.add("if p1'>0 for  quit:object.extract()'=p2  set object=object.extract(2,object.length())")
		do buf.add("quit object")
		do buf.insert(label, "String")
	}

	set PSL.return = "$$"_label_"("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
	quit

	// ---------------------------------------------------------------------
isBegin	// Method: String.beginsWith(String string,Boolean ignoreCase)
	/* ---------------------------------------------------------------------
	String begins with (boolean)

	NOTES:
	. This code still uses PSL.mExpr() without tokenizing the "arguments".
		This will work as long as PSL.objectName and all PSL.actual()s
		contain only M constructs that are also PSL constructs.
	*/

	//if actual(1).isNull(1) set PSL.return="("_PSL.objectName_"="""")" quit
	if PSL.actual(2).isNull() set PSL.actual(2)= PSL.actual(2).addQuotes()

	if 'PSL.actual(2).isLiteral() do { quit

		type String label="vStrBeg"

		if 'PSL.subrouExists(label) do {

			type PSLBuffer buf=PSL.openBuffer("(String object,String p1,Boolean p2)","String.beginsWith")

			do buf.add("if p2 set object=object.upperCase(),p1=p1.upperCase()")
			do buf.add("quit object.beginsWith(p1)")

			do buf.insert(label, "Boolean")
		}

		set PSL.return="$$"_label_"("_PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
	}

	// actual(2) is literal
	type Boolean isIgnore= PSL.actual(2).stripQuotes()

	set PSL.return = $$tokenPush^UCPATCH( PSL.objectName, "String")
	type PSLExpression ap1 = $$tokenPush^UCPATCH( PSL.actual(1), "String")

	if isIgnore set PSL.return = PSL.return_".upperCase()"
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if '(PSL.actual(1).isLiteral()!$$isVar^UCGM( PSL.actual(1))) set ap1="("_ ap1_ ")"

	set PSL.return = "("_ PSL.return_ ".extract(1,"_ ap1_".length())="_ ap1_ $select(isIgnore:".upperCase()",1:"")_ ")"
	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( PSL.return), 2)

	if PSL.objectName.isLiteral() set PSL.return=$$toLit( PSL.return)

	quit
	
	// ---------------------------------------------------------------------
isEnd	// Method: String.endsWith(String string,Boolean ignoreCase)
	/* ---------------------------------------------------------------------
	String ends with (boolean)

	NOTES:
	. This code calls $$tokenPush/$$tokenPop
		This will work as long as PSL.objectName and all PSL.actual()s
		contain only M constructs that are also PSL constructs.
	*/

	//if actual(1).isNull(1) set PSL.return="("_PSL.objectName_"="""")" quit
	if PSL.actual(2).isNull() set PSL.actual(2) = PSL.actual(2).addQuotes()

	if 'PSL.actual(2).isLiteral() do { quit

		type String label="vStrEnd"

		if 'PSL.subrouExists(label) do {
		
			type PSLBuffer buf=PSL.openBuffer("(String object,String p1,Boolean p2)","String.endsWith")

			do buf.add("if p2 set object=object.upperCase(),p1=p1.upperCase()")
			do buf.add("quit object.endsWith(p1)")

			do buf.insert(label, "Boolean")
		}

		set PSL.return = "$$"_label_"("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
	}

	// PSL.actual(2) is literal
	set PSL.return = $$tokenPush^UCPATCH( PSL.objectName, "String")
	type PSLExpression ap1 = $$tokenPush^UCPATCH( PSL.actual(1), "String")

	type String lstr = PSL.mExpr( ap1_".length()")
	type String lobj = PSL.return_".length()"

	type Boolean isIgnore= PSL.actual(2).stripQuotes()
	if isIgnore set ap1 = ap1_ ".upperCase()", PSL.return = PSL.return_".upperCase()"
	
	if lstr=1 set PSL.return = PSL.return_".extract("_lobj_")"
	else  set PSL.return = PSL.return_".extract("_lobj_"-"_lstr_"+1,"_lobj_")"
	
	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr("("_ PSL.return_"="_ ap1_")"), 2)

	if PSL.objectName.isLiteral() set PSL.return = $$toLit( PSL.return)

	quit

	// ---------------------------------------------------------------------
isLike	// Method: String.isLike(String likeExpr,Boolean ignoreCase)
	/* ---------------------------------------------------------------------
	String like (boolean)

	NOTES:
	. This code still uses PSL.mExpr() without tokenizing the "arguments".
		This will work for the current version of the compiler because
		the code that uses PSL.mExpr() deals with the case that both
		actuals are known at compile time AND because it is not needed
		to call $$tokenPush/$$tokenPop for PSL.objectName.
	*/
	
	if PSL.actual(1).isNull(1) set PSL.return = "("_ PSL.return_"="""")" quit
	if PSL.actual(2).isNull()  set PSL.actual(2) = PSL.actual(2).addQuotes()

	if '(PSL.actual(1).isLiteral()&PSL.actual(2).isLiteral()) do { quit

		type String label="vStrLike"

		if 'PSL.subrouExists(label) do {
		
			type PSLBuffer buf=PSL.openBuffer("(String object,String p1,Boolean p2)","String.isLike")

			do buf.add("if p1.isNull() quit object.isNull()")
			do buf.add("if p2 set object=object.upperCase(),p1=p1.upperCase()")
			do buf.add("if p1.beginsWith(""%""),p1.endsWith(""%"") quit object[p1.extract(2,p1.length()-1)")
			do buf.add("if p1.beginsWith(""%"") quit object.endsWith(p1.extract(2,p1.length()))")
			do buf.add("if p1.endsWith(""%"") quit object.beginsWith(p1.extract(1,p1.length()-1))")
			do buf.add("quit object=p1")

			do buf.insert(label, "Boolean")
		}

		set PSL.return = "$$"_label_"("_PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
	}

	// Both PSL.actual(1) and PSL.actual(2) are literal.
	type String str= PSL.actual(1).stripQuotes()
	type Boolean isIgnore= PSL.actual(2).stripQuotes()		// Ignore Case

	/* Under the current implementation of the compiler, there in no need to
	   call $$tokenPush/$$tokenPop */
	set PSL.return = PSL.objectName

	if str.beginsWith("%"),str.endsWith("%") do {

		set str=str.extract(2,str.length()-1).addQuotes()
		if isIgnore set str=str_".upperCase()",PSL.return=PSL.return_".upperCase()"
		set PSL.return="("_PSL.return_"["_str_")"
	}

	else  if str.beginsWith("%") do {

		set str=str.extract(2,str.length()).addQuotes()
		set PSL.return="("_PSL.return_".endsWith("_str_","_ PSL.actual(2)_"))"
	}

	else  if str.endsWith("%") do {

		set str=str.extract(1,str.length()-1).addQuotes()
		set PSL.return="("_PSL.return_".beginsWith("_str_","_ PSL.actual(2)_"))"
	}

	else  do {

		if isIgnore set PSL.actual(1) = PSL.actual(1)_".upperCase()", PSL.return = PSL.return_".upperCase()"
		set PSL.return = "("_ PSL.return_"="_ PSL.actual(1)_")"
	}

	set PSL.return = PSL.mExpr( PSL.return)

	if PSL.objectName.isLiteral() set PSL.return = $$toLit( PSL.return)

	quit

	// ---------------------------------------------------------------------
length	// Method: String.length(String delimiter)
	// Return the length of a string, or number of occurrances of parameter

	type String char = PSL.actual(1)

	if char.isNull() do {
	
		/*if char.isNull() set char=char.addQuotes()*/
		set PSL.return="$L("_ PSL.objectName_")"
	}

	else  set PSL.return = "$L("_ PSL.objectName_","_char_")"

	if PSL.objectName.isLiteral() set PSL.return = $$toLit( PSL.return)

	quit

	// ---------------------------------------------------------------------
qsub	// Method: String.stripQuotes(String character)
	
	type String quote= PSL.actual(1)
	if quote.isNull(1) set quote=""""""""""		// literal for string of 4 quotes

	if PSL.objectName.isLiteral(),quote.isLiteral() do {
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte,FUNCTION
		set PSL.return = $$QSUB^%ZS(PSL.objectName.stripQuotes(),quote.stripQuotes()).addQuotes()
	}
	else  set PSL.return="$$QSUB^%ZS("_PSL.objectName_","_quote_")"
	quit
	
	// ---------------------------------------------------------------------
qadd	// Method: String.addQuotes(String character)
	
	type String quote= PSL.actual(1)
	if quote.isNull(1) set quote = """"""""""

	if PSL.objectName.isLiteral(),quote.isLiteral() do {
		//set PSL.return = (PSL.objectName.stripQuotes().addQuotes($$toVal^UCPRIM(quote))).addQuotes()
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte,FUNCTION
		set PSL.return = $$QADD^%ZS(PSL.objectName.stripQuotes(),quote.stripQuotes()).addQuotes()
	}
	else  do {
		set PSL.return="$$QADD^%ZS("_PSL.objectName_","_quote_")"

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if $$isSimple^UCGM( PSL.objectName), $$isSimple^UCGM( quote) set PSL.return = "$S("_ PSL.objectName_ "'["_ quote_ ":"_ quote_ "_"_ PSL.objectName_ "_"_ quote_ ",1:"_ PSL.return_ ")"
	}
	quit
	
	// ---------------------------------------------------------------------
isLit	// Method: String.isLit - String is a literal string (boolean)
	
	if PSL.objectName.isLiteral() set PSL.return=1
	else  set PSL.return="$$isLit^UCGM("_PSL.objectName_")"
	quit

	// ---------------------------------------------------------------------
isNum	// Method: String.isNum	- String is a Number string (boolean)
	/* ---------------------------------------------------------------------
	If the method is applied to a literal (declared or implicit), then the
	subroutine will return the calculated value.
	Else, if objectName is a simple variable, it will return object=+object
	ELse, it generates code that uses a separate subroutine to compare
	object to its numeric interpretation. This ensures that the generated
	code will evaluate objectName only once (as the programmer expects).
	Generating in-line code to compare object=+object in this case will
	evaluate "object" twice, which may lead to different values.
	*/
	//if PSL.objectName.isLiteral() set PSL.return=$$isNum^UCGM(PSL.objectName.stripQuotes())
	//set PSL.return="$$isNum^UCGM("_PSL.objectName_")"
	if PSL.objectName.isLiteral() do {
		type String val = PSL.objectName.stripQuotes()
		set PSL.return = (val = +val)
	}
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	else  if $$isSimple^UCGM( PSL.objectName) do {
		set PSL.return = "("_ PSL.objectName_ "=+"_ PSL.objectName_ ")"
	}
	else  do {
		type literal String subrtn = "vStrIsNum"
		set PSL.return="$$"_subrtn_"("_PSL.objectName_")"
		if 'PSL.subrouExists(subrtn) do {
			type PSLSubrou sub = PSL.addSubrou( subrtn, "(vStr)", "String.isNumber")
			do sub.addCode(" Q vStr=+vStr")
		}
	}
	quit

	// ---------------------------------------------------------------------
isInt	// Method: String.isInt	 String is an Integer string (boolean)
 	
	//if PSL.objectName.isLiteral() set PSL.return=$$isInt^UCGM(PSL.objectName.stripQuotes())
	//else  set PSL.return="$$isInt^UCGM("_PSL.objectName_")"
	if PSL.objectName.isLiteral() do {
		type String val = PSL.objectName.stripQuotes()
		set PSL.return=(val = +val)&(val '[ ".")
	}
	else  do {
		type literal String subrtn = "vStrIsInt"
		set PSL.return="$$"_subrtn_"("_PSL.objectName_")"
		if 'PSL.subrouExists(subrtn) do {
			type PSLSubrou sub = PSL.addSubrou( subrtn, "(vStr)", "String.isInteger")
			do sub.addCode(" I vStr=+vStr,vStr'[""."" Q 1")
			do sub.addCode(" Q 0")
		}
	}
	quit

	// ---------------------------------------------------------------------
toNumber	// Method: String.toNumber(String mask,Boolean stripSpace)

	/* Converts a formatted string to a number
	
	Uses mask syntax from $$NUM^%ZM as 2nd parameter
		Byte#1 = Decimal character
		Byte#2 = Thousand separator character
		Byte#3 = Negative value format (Supported by $FN)
		Byte#4 = Prefix character
		Byte#5 = Indian syntax (discarded)
	*/

	if PSL.objectName.isNull(1) set PSL.return="""""" quit

	if PSL.actual(1).isNull(1) set PSL.actual(1)="""."""	// default decimal dot
	if PSL.actual(2).isNull(1) set PSL.actual(2)=0		// default 0 (don't strip)

	type String mask = $$toVal^UCPRIM( PSL.actual(1),"var").extract(1,4)
	type String strip = $$toVal^UCPRIM( PSL.actual(2), 1)	// worst case default

	/* All instance and both parameters are literal, convert at compile time */
	if PSL.objectName.isLiteral(), PSL.actual(1).isLiteral(), PSL.actual(2).isLiteral() do { quit

		/* Simple M numeric interpretation */
		if mask=".",'strip set PSL.return = +(PSL.objectName.stripQuotes())

		else  set PSL.return = (PSL.objectName.stripQuotes()).toNumber(mask,strip)
	}

	/* Combination of both literal parameters known to be simple unary plus */
	if PSL.actual(1)=""".""",'strip set PSL.return = "+"_ PSL.objectName quit
	
	/* Other combinations of both parameters are literal */
	type String neg = mask.extract(3)
	if PSL.actual(1).isLiteral(), PSL.actual(2).isLiteral(),neg'="T",neg'="P" do { quit

		set mask=mask.extract(1,2)_mask.extract(4)
		if strip,mask'[" " set mask=mask_" "
		set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "+"_ $$tokenPush^UCPATCH( PSL.objectName, "String")_ ".translate("_ mask.addQuotes()_ ",""."")"), 1)
	}

	type String label="vStrToNu"

	if 'PSL.subrouExists(label) do {
		
		type PSLBuffer buf=PSL.openBuffer("(String object,String p1,Boolean p2)","String.toNumber")

		do buf.add("if object.isNull() quit """"")
		do buf.add("")
		do buf.add("if p1.isNull() set p1="".""")
 		do buf.add("type String neg=p1.extract(3).upperCase()")
		do buf.add("set p1=p1.extract(1,2)_p1.extract(4)")
		do buf.add("if neg=""T"",object.endsWith(""-"") set neg=1,p1=p1_""-""")
		do buf.add("else  if neg=""P"" set p1=p1_"" "" if object.endsWith("")"") set neg=1,p1=p1_""()""")
		do buf.add("else  set neg=0")
		do buf.add("if p2,p1'["" "" set p1=p1_"" """)
		do buf.add("set object=object.translate(p1,""."")")
		do buf.add("quit $S(neg:-object,1:+object)")
		do buf.insert(label, "Number")
	}

	set PSL.return="$$"_label_"("_PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"

	quit

	// ---------------------------------------------------------------------
toDate	// Method: String.toDate(String mask)
	// Convert a string to a julian date
	type public PSLParser pslPrsr

	if PSL.objectName.isNull(1) set PSL.return="""""" quit

	type String mask= PSL.actual(1)

	if mask.isNull(1) set mask= pslPrsr.getSetting("PSL","DateMask","").addQuotes()	// Default

	if PSL.objectName.isLiteral(),mask.isLiteral() set PSL.return=PSL.objectName.stripQuotes().toDate(mask.stripQuotes()) quit

	type String label="vStrJD"

	if 'PSL.subrouExists(label) do {
		
		type PSLBuffer buf=PSL.openBuffer("(String string,String mask)","String.toDate")

		do buf.add("if string.isNull() quit """"")
 		do buf.add("")
		do buf.add("type Number m,d,y")
		do buf.add("")
		do buf.add("set d=mask.find(""DD"")")
		do buf.add("set m=mask.find(""MM"")")
		do buf.add("if string?5N quit string")
		do buf.add("if '(m&d) quit $$^SCAJD(string,mask)")
		do buf.add("set m=string.extract(m-2,m-1),d=string.extract(d-2,d-1)")
		do buf.add("if (m?1.N)'&(d?1.N) quit $$^SCAJD(string,mask)")
		do buf.add("")
		do buf.add("set y=mask.find(""YEAR"")")
		do buf.add("if y set y=string.extract(y-4,y-1)")
		do buf.add("else  set y=mask.find(""YY"") if y set y=string.extract(y-2,y-1)")
		do buf.add("else  quit $$^SCAJD(string,mask)")
		do buf.add("")
		do buf.add("if m<1!(m>12) Q -1")
		do buf.add("if y<100 set y=y+$S(y>50:1900,1:2000)")
		do buf.add("if (y#4=0)&('(y#100=0)!(y#400=0)) set m=""0,31,60,91,121,152,182,213,244,274,305,335,366"".piece("","",m,m+1)")
		do buf.add("else  set m=""0,31,59,90,120,151,181,212,243,273,304,334,365"".piece("","",m,m+1)")
		do buf.add("if ({String}m).piece("","",2)-({String}m).piece("","",1)<d quit -1")
        	do buf.add("set d=d+({String}m).piece("","",1)+((y-1841)*365)")
		do buf.add("set d=d+((y-1841)\4)")
		do buf.add("set d=d-(((y-1)\100)-18)")
		do buf.add("set d=d+(((y-1)\400)-4)")
		do buf.add("quit d") 

		do buf.insert(label, "Date")
		}

	set PSL.return="$$"_label_"("_PSL.objectName_","_mask_")"

	quit

	// ---------------------------------------------------------------------
toRow	// Method: String.toRow(List elements,String delimiter)
	
	set PSL.actual(3) = PSL.actual(2), PSL.actual(2) = PSL.actual(1)
	do classNew^UCROW
	set PSL.return = PSL.objectName

	quit

	// ---------------------------------------------------------------------
toTime	// Method: String.toTime - Convert a string to Time (seconds past midnight)
	type literal String label="vStrTM"

	if PSL.objectName.isNull(1) set PSL.return="""""" quit
	if PSL.objectName.isLiteral() set PSL.return = PSL.objectName.stripQuotes().toTime() quit

	if 'PSL.subrouExists(label) do {
		
		type PSLBuffer buf=PSL.openBuffer("(String object)","String.toTime")

		do buf.add("if object.isNull() quit """"")
		do buf.add("if object[""P"",object<12 set object.piece("":"",1)=object.piece("":"",1)+12")
		do buf.add("else  if object[""A"",object.piece("":"",1)=12 set object.piece("":"",1)=0")
		do buf.add("if object[""-""!(object.piece("":"",1)>23)!(object.piece("":"",2)>59)!(object.piece("":"",3)>59) quit """"")
		do buf.add("quit object.piece("":"",1)*60+object.piece("":"",2)*60+object.piece("":"",3)")

		do buf.insert(label, "Time")
		}

	set PSL.return="$$"_label_"("_PSL.objectName_")"

	quit
 #OPTION ResultClass ON
public String vSIG()	quit "61450^51791^Frans S.C. Witte^55343"	// Signature - LTD^TIME^USER^SIZE
