	/*
	ORIG: Frans S.C. Witte - 2006-12-20
	DESC: PSL compiler, Insensitive Group - #CLASSDEF for PSLTokenizer

	---- Comments ----------------------------------------------------------
	The PSLTokenizer class is used to decompose a source structure into
	individual tokens.

	The decomposition part is modeled along the lines of the Java class
	java.io.StreamTokenizer, but is tailored to PSL: there are limited means
	to set the comment character, the quote character, and other character
	properties.

	In normal cases, the source code to be tokenized will be obtained from
	the file specified by the IO instance passed to Class.new().
	Furthermore, an array of source code can be appended by calling the
	PSLTokenizer.appendSrc() method, and individual lines can be appended by
	calling the PSLTokenizer.appendLine() method.

	---- Revision History --------------------------------------------------
	2009-04-02, Frans S.C. Witte, CR 39242
		Turned most methods into 'final' methods.

	2008-10-13, Frans S.C. Witte, CR 35741/35918
		Corrected nextStrD and nextStrJ when no terminating quote is
		found (resulted in end-less loop).

	09/19/07 - Frans S.C. Witte - CR 27800
		* Initial version (2006-12-20), compiled as SCM.
		* modified to CDM after classTypePRIMITIVE was supported
	*/
	#PACKAGE  framework.psl

	#CLASSDEF extends=Primitive public delimiter=9

	// ---------------------------------------------------------------------
	#PROPERTYDEF charComment	class=List public node="charComment"
		/* -------------------------------------------------------------
		Comment pairs as first:last, with
		first = delimiter sequence that starts the comment
		last = delimiter sequnece that ends the comment.
		If last is absent, the comment extends to end of line.
		Examples:
		- Standard SQL: "--"
		- Standard M: ";"
		- Standard PSL: "//,;,/"_"*:*"_"/"
		*/

	// ---------------------------------------------------------------------
	#PROPERTYDEF charEscape		class=String public node="charEscape"
		/* -------------------------------------------------------------
		Escape character inside string literals.
		If empty, the tokenizer assumes that string literals do not
		contain special escape sequences, and the quote character itself
		is represented by two consecutive occurrences (like in M, PSL and
		SQL).
		If not empty, then the tokenize assumes that the string contains
		(JSON) escape sequences. In that case the standard JSON escape
		sequences are recognized and interpreted.
		*/
	// ---------------------------------------------------------------------
	#PROPERTYDEF charQuote		class=String public node="charQuote"
		/* -------------------------------------------------------------
		The quote charater that starts and ends a string literal.
		*/

	// ---------------------------------------------------------------------
	#PROPERTYDEF charSymbol		class=String public node="charSymbol"
		/* -------------------------------------------------------------
		The charaters that are to be reported as symbols.
		Note that the default set excludes the dollar sign, the up-arrow,
		and the dot. As a result, constructs like label^routine,
		$Mfunction, and instance.method will be returned as a single
		"word".
		Also note that a construct like #CLASSDEF will be returned as 2
		tokens: "#" and "CLASSDEF".
		*/

	// ---------------------------------------------------------------------
	#PROPERTYDEF srcChar		class=Number public readonly node="srcChar"
		/* -------------------------------------------------------------
		The source character pointer. This property and the srcLine
		property provide a unique pointer to the last character that has
		been parsed.
		*/

	// ---------------------------------------------------------------------
	#PROPERTYDEF srcFile		class=String public readonly node="srcFile"
		/* -------------------------------------------------------------
		The full name of the source file that was used to load
		this.srcCode().
		*/

	// ---------------------------------------------------------------------
	#PROPERTYDEF srcLast		class=Number public readonly node="srcLast"
		/* -------------------------------------------------------------
		The highest line number in use by srcCode().
		*/
	// ---------------------------------------------------------------------
	#PROPERTYDEF srcLine		class=Number public readonly node="srcLine"
		/* -------------------------------------------------------------
		The source line pointer. This property and the srcChar property
		provide a unique pointer to the last character that has been
		parsed.
		*/

	// ---------------------------------------------------------------------
	#PROPERTYDEF srcCode()		class=String public readonly node="srcCode"
		/* -------------------------------------------------------------
		The source code as an array of lines.
		*/

	// ---------------------------------------------------------------------
	#PROPERTYDEF tknIgnCMT		class=Number public node="tknIgnCMT"
		/* -------------------------------------------------------------
		This read-write property indicates whether comment shall be
		ignored or be returned as a separate token. The default setting
		is tknIgnCMTBLOCK
		*/
		#PROPERTYDEF tknIgnCMTALL   = 2		public literal
		#PROPERTYDEF tknIgnCMTBLOCK = 1		public literal
		#PROPERTYDEF tknIgnCMTNONE  = 0		public literal

	// ---------------------------------------------------------------------
	#PROPERTYDEF tknIgnEOL		class=Boolean public node="tknIgnEOL"
		/* -------------------------------------------------------------
		This read-write property indicates whether EOL shall be ignored
		or be returned as a separate token. The default setting is false.
		*/

	// ---------------------------------------------------------------------
	#PROPERTYDEF tknPushBack	class=Boolean public readonly node="tknPushBack"
		/* -------------------------------------------------------------
		The pushback indicator.
		*/

	// ---------------------------------------------------------------------
	#PROPERTYDEF tknTree()		class=String public readonly node="tknTree"
		/* -------------------------------------------------------------
		Each token that is returned by $$nextToken() will aslo be added
		as a leaf to the token tree.
		The class provides methods to add 'branches' to the tree.

		If no calls are made to treeAdd(), the tree will just contain
		the tokenized input, with tknTree(1) the first token and
		tknTree($$treeRoot()) the last token.

		If the calling parser adds branches for every grammer rule,
		then the tree will contain a complete syntax tree, with
		tknTree($$treeRoot()) as the root of the tree.
		*/

	// ---------------------------------------------------------------------
	#PROPERTYDEF tknType		class=Number public readonly node="tknType"
		/* -------------------------------------------------------------
		The type of the last token that has been returned by nextToken()
		The value tknTypeXRL defines the lowest value that is reserved
		for PSLTokenizer. Values less than tknTypeXRL are available to
		identify rules that are added to the token tree.

		One of:
		*/
		#PROPERTYDEF tknTypeCMT = 59	public literal
		#PROPERTYDEF tknTypeEOF = -1	public literal
		#PROPERTYDEF tknTypeEOL = 10	public literal
		#PROPERTYDEF tknTypeMTD = -4	public literal
		#PROPERTYDEF tknTypeNUM = -2	public literal
		#PROPERTYDEF tknTypeSTR = 34	public literal
		#PROPERTYDEF tknTypeWRD = -3	public literal
		#PROPERTYDEF tknTypeWSP = 32	public literal
		#PROPERTYDEF tknTypeXRL = -9	public literal

	// ---------------------------------------------------------------------
	#PROPERTYDEF tknValue		class=String public readonly node="tknValue"
		/* -------------------------------------------------------------
		The value of the last token that has been returned by nextToken()
		Depends largely on tknType:
		tknTypeCMT: the comment string (text only, no delimiters)
		tknTypeEOF: empty string
		tknTypeEOL: the line number of the line that ends
		tknTypeMTD: the first word of the declaration. This could be a
				keyword, the ResultClass, or the methodname
		tknTypeNUM: the non-canonic number as found in the source
		tknTypeSTR: the string literal, excluding quotes
		tknTypeWRD: the exact character sequence
		tknTypeWSP: the comment string (text only, no delimiters)
		*/

	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************

	/* ================================================================== */
	/* Initializer							      */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
private void initialize( Object initObj)	// constructor
	/* ---------------------------------------------------------------------
	The initialize method will cast the initObj to an IO object, and
	interpret it as the descriptor of the source file.
	The IO-properties directory, fileName, and encoding shall
	be initialized before the IO instance is passed to this method.
	
	This will set the openParams property to READ, before it reads the
	input into the srcCode() property.
	*/
	do this.reset()

	type IO rSrc = {IO}initObj
	type Number ln = 1

	set rSrc.openParams = "READ"
	set rSrc.recordSize = PSL.maxStringLength
	do {
		catch rEx {
			do rSrc.close()
			if rEx.type'["%PSL-E-IO" throw rEx
		}
		do rSrc.open()
		set this.srcFile = rSrc.device
		for ln=1:1 set this.srcCode(ln) = rSrc.read().translate( 9.char()_ 10.char()_ 13.char(), "   ")
	}
	set this.srcLast = ln-1
	quit

	/* ================================================================== */
	/* non local static methods					      */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
public static Boolean isLogEOL( Number tkn)
	/* ---------------------------------------------------------------------
	Return if this token is a logical end of line, which is the case if it
	is one of the following token types:
	- tknTypeCMT
	- tknTypeEOF
	- tknTypeEOL
	*/

	quit ({List}(PSLTokenizer.tknTypeCMT_","_PSLTokenizer.tknTypeEOF_","_PSLTokenizer.tknTypeEOL)).contains( tkn)

	// ---------------------------------------------------------------------
public static String tokenType( Number tkn)
	/* ---------------------------------------------------------------------
	Return verbal description of token
	*/

	if tkn < PSLTokenizer.tknTypeXRL quit "rule"_tkn.toString()
	if tkn = PSLTokenizer.tknTypeCMT quit "comment"
	if tkn = PSLTokenizer.tknTypeEOF quit "end-of-file"
	if tkn = PSLTokenizer.tknTypeEOL quit "end-of-line"
	if tkn = PSLTokenizer.tknTypeMTD quit "method declaration"
	if tkn = PSLTokenizer.tknTypeNUM quit "number"
	if tkn = PSLTokenizer.tknTypeSTR quit "string"
	if tkn = PSLTokenizer.tknTypeWRD quit "word"
	if tkn = PSLTokenizer.tknTypeWSP quit "whitespace"
	quit "symbol '"_ tkn.char()_ "'"

	/* ================================================================== */
	/* non local instance methods					      */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
public final void appendSrc( String src())
	/* ---------------------------------------------------------------------
	Append the code from the supplied src() array to the srcCode() property.
	The FOR loop used by this method ensures that lines are numbered
	sequentially.
	SP will replace TAB, LF and CR when moving the line into srcCode().
	*/
	type Number lp = this.srcLast, sp = ""
	for lp = lp+1:1 set sp = src(sp).order() quit:sp=""  set this.srcCode(lp) = src(sp).translate( 9.char()_ 10.char()_ 13.char(), "   ")
	set this.srcLast = lp-1

	quit

	// ---------------------------------------------------------------------
public final void appendLine( String line)
	/* ---------------------------------------------------------------------
	Append a single line to the srcCode() property.
	SP will replace TAB, LF and CR when moving the line into srcCode().
	*/
	type Number lp = this.srcLast + 1
	set this.srcLast = lp, this.srcCode( lp) = line.translate( 9.char()_ 10.char()_ 13.char(), "   ")

	quit

	// ---------------------------------------------------------------------
public final Number chkEOL()
	/* ---------------------------------------------------------------------
	Check that we are at end-of-line.
	The end-of-line may be preceded by comment (both block and eol)

	RETURNS:
	. the current token type

	THROWS:
	. %PSL-E-SYNTAX
		If a token other than tknTypeCMT, tknTypeEOF, tknTypeEOL, or
		tknTypeWSP is found

	NOTES:
	. comment and whitespace tokens are ignored while checking for end-of-line.
	*/

	type Number ign, tkn = this.tknType
	while (tkn = this.tknTypeWSP) set tkn = this.nextToken()
	if tkn = this.tknTypeCMT set tkn = this.nextToken()
	if tkn '= this.tknTypeEOL, tkn '= this.tknTypeEOF set ign = this.skip2EOL() throw Class.new("Error", "%PSL-E-SYNTAX,invalid "_ this.tokenType( tkn)_ " before end-of-line")
	quit tkn

	// ---------------------------------------------------------------------
final String nextLine() // Return the next line from the token stream or "" for EOF
	/* ---------------------------------------------------------------------
	This is a temporary function that is used by "old" compiler modules that
	use to work on an entire line of PSL code. Callers are UCGM and UCGMC.

	OUTPUT:
	. remainder of current line (if not at start-of-line on entry)
	. current line (if at start of line)
		It may end in un-terminated block comment !
	. "" if at end of source

	NOTES:
	. This function can be combined with calls to $$nextToken, provided the
		caller is aware of the following:
		- the first call of $$nextLine() after calling $$nextToken()
			will return the remainder of the current line
		- comment blocks at the start of the line will be handled here
			but if the line ends with an un-terminated block-comment
			this will not be detected, and a call to $$nextToken()
			will return nonsense.
		- this.tknType / this.tknValue will be as the same as when
			tknTypeEOL (or tknTypeEOF) is be returned by
			$$nextToken()
	*/
	type Number cp = this.srcChar, lp = this.srcLine, tkn

	// skip leading whitespace
	if cp = 0 set cp = 1, lp = lp+1 if 'this.srcCode( lp).exists() do this.saveSrc( 0, lp)  set tkn = this.saveTkn( this.tknTypeEOF, "") quit ""
	type String code = this.srcCode( lp)

	/* If end-of-line is ignored, and we are at end-of line, skip all empty
	   lines at once.
	   */
	if this.tknIgnEOL, code.extract(cp, PSL.maxStringLength)?." " { if code?." "  do this.saveSrc( 0, lp+1) set tkn = this.saveTkn( this.tknTypeEOF, "") quit ""
		set cp=1
		for lp=lp+1:1:this.srcCode( "").order(-1) set code = this.srcCode( lp) quit:code'?." "
	}

	// Comment
	type Number cc = cp
	if code.extract( cc) = " " for cc=cc+1:1 quit:code.extract(cc)'=" "
	set cc = this.nextCmt( cc, lp) if cc>0 quit this.nextLine()

	do this.saveSrc( 0, lp)
	set tkn = this.saveTkn( this.tknTypeEOL, lp.toString())

	if cp = 1 quit code
	quit code.extract( cp, code.length())

	// ---------------------------------------------------------------------
public final Number nextToken()
	/* ---------------------------------------------------------------------
	Obtain the next token from the srcCode() property, and return an Integer
	value to indicate the kind of token:
	- if a comment is found: tknType will be tknTypeCMT or tknTypeWSP, and
		tknValue will be the text of the comment between, but not
		including, the start-of-comment and the (implied) end-of-comment
		sequences.
	- if a string literal is found: tknType will be tknTypeSTR, and tknValue
		will contain the strlit, excluding the quotes.
	- if a numeric literal is found: tknType will be tknTypeNUM, and
		tknValue will contain the number as it occured in the PSL source
		code. It is up to the caller to turn the number into a canonic
		number if required.
	- if an end-of-line is found: tknType will be tknTypeEOL and tknValue
		will be the line number. If nextToken() is called when the
		tknIgnEOL property is true, then this value will not be returned.
	- if an end-of-file is found: tknType will be tknTypeEOF and tknValue
		will be the empty string
	- if a SYMBOL is found: tknType will be SYMBOL.ascii() and tknValue will
		be the SYMBOL
	- if a "word" is found that starts at the first position of the line,
		then tknType will be set to tknTypeMTD and tknValue will contain
		the word. It is up to the caller to decide if the distinction
		between tknTypeMTD and tknTypeWRD is relevant and appropriate in
		the particular context.
	- if none of the above applies, tknType will be set to tknTypeWRD, and
		tknValue will contain the sequence of characters. The sequence
		of characters will end at the first occurrence of a SYMBOL, the
		QUOTE character, a SPACE, or end-of-line.
	THROWS:
	. %PSL-E-SYNTAX
		If a string literal was started on the current line, but not
		terminated. In that case, the token value will contain the
		complete string from the starting position until the end-of-line
		and a comment terminatator will be addended for block comments.
		The token pointer advances to the end of the line, so the next
		call to $$nextToken() will return tknTypeEOL.

	NOTES:
	. The special characters are all configurable:
		- comment pairs by this.charComment
		- string quote character by this.charQuote
		- symbols by this.charSymbol
	. The decomposition of M/PSL pattern specifications requires additional
		attention: "simple" patterns like 1"("3N1")"3N1"-"4N will be
		returned as a single word, but pattern specifications that
		contain alternations such as (3A,2.4N), will be returned as
		5 separate tokens: "(", "3A", ",", "2.4N", and ")".
	. This method treats all whitespace as if a single space delimited the
		token. This allows whitespace in a lot more places than in M,
		or even in earlier PSL. For example the construct:
			SET : somecondition     var = value
		will be parsed exacatly the same as:
			SET:somecondition var=value
		It also implies that the nextToken() method cannot be used to
		detect an argumentless command, except if it occurs at the end
		of the line. The PSL-to-Java version of the language limits the
		number of argumentless commands considerably: FOR, LOCK and QUIT
		are the only statements that can occur with or without argument.
		In particular the QUIT statement is tricky because it also
		accepts a postconditional, which may be separated from the
		commandword by a space ...
	. Matters are further complicated by the fact that the same word can
		either be a commandword or a variable name. This implies that
		whitespace is very significant.
		The QUIT argument is an expression. In its simplest form this
		could be a single variable.
			quit  for  set x=3
		and
			quit for  set x=3
		have a very different meaning, and this meaning can only be
		correctly asserted if the number of SPaces is taken into account
		whenever appropriate.
	. As another example of the relevance of whitespace, the following
		constructs can only be parsed correctly if the programmer and
		the compiler are both adhering to the M programming conventions:
			quit:A!B +C+D  set x=3
		versus
			quit:A!B+C +D  set x=3
		versus
			quit:A!B+C+D  set x=3
		This problem is inherent to the fact that "+" (and "-") can be
		used as binaryop and as unaryop, and applies to all commands
		that allow a postcondition and have an expression as their
		argument (or something that looks like an expression such as
		LOCK +nref).
		Inside $$nextExpr()^UCGM this is handled as follows for "+" and
		"-":
		- if only leading whitespace occurs, then unaryop is assumed
		- in all other cases (no whitespace, trailing whitespace, and
			whitespace on bot sides), binaryop is assumed
		Note that this leads to different rules for "+" and "-"
		compared to all other binaryops.
	. If called with tknIgnEOL = true, ALL comments will be discarded, and
		tknTypeCMT will never be returned. This is particularly useful
		to parse a method declaration, which may occupy multiple lines
		with //-comment to describe an individual parameter.
	*/

	// if token has been pushed back, turn off pushback indicator, return
	// what we have now
	if this.tknPushBack set this.tknPushBack = false quit this.tknType

	type Number cp = this.srcChar, lp = this.srcLine

	// skip leading whitespace
	if cp = 0 set cp = 1, lp = lp+1 if 'this.srcCode( lp).exists() do this.saveSrc( 0, lp)  quit this.saveTkn( this.tknTypeEOF, "")
	type String code = this.srcCode( lp)

	/* If end-of-line is ignored, and we are at end-of line, skip all empty
	   lines at once.
	   */
	if this.tknIgnEOL, code.extract(cp, PSL.maxStringLength)?." " { if code?." "  do this.saveSrc( 0, lp+1)  quit this.saveTkn( this.tknTypeEOF, "")
		set cp=1
		for lp=lp+1:1:this.srcCode( "").order(-1) set code = this.srcCode( lp) quit:code'?." "
	}

	if code.extract( cp) = " " for cp=cp+1:1 quit:code.extract(cp)'=" "
	
	set code = code.extract(cp, PSL.maxStringLength)

	// code now starts with the first relevant character.
	type String c = code.extract()

	/* If we find end-of-line here, then tknIgnEOL must be false, otherwise
	   it would have been skipped iby the code above.
	   Now that we have "seen" the EOL, advance to the first char of the
	   next line */
	if c.isNull() do this.saveSrc( 0, lp) quit this.saveTkn( this.tknTypeEOL, lp.toString())

	// Comment
	type Number ce = this.nextCmt( cp, lp)
	if ce>0 quit $SELECT(ce'>this.tknIgnCMT:this.nextToken(),ce=2:this.tknTypeCMT,1:this.tknTypeWSP)
	//if $$isComment(this(,), cp, lp) quit this.tknTypeCMT

	// numbers AND single '-' shall be handled by $$nextNumlit(), except
	// when in first position (numeric label)
	if "-+.0123456789" [ c,cp>1 quit this.nextNumlit( code, cp, lp)

	// strlit shall be handled be $$nextStrlit()
	if c = this.charQuote quit this.nextStrlit( code, cp, lp)

	// symbols
	type String s = this.charSymbol
	if s[c do this.saveSrc( cp+1, lp) quit this.saveTkn( c.ascii(), c)

	// word (delimited by SPace, symbol, or quote character)
	set s = code.translate( s_this.charQuote, "".justify( s.length() + 1))
	set ce = s.find(" ")-2

	if ce < 0 set ce = code.length()

	/* In case token contains embedded strlit (may occur in patexpr)
	   look for next symbol that is outside strlit(s)
	   >>>> THIS NEEDS ATTENTION FOR NON-PSL QUOTE CHARS <<<<
	   */
	//if code.extract(1, ce).length("""")#2=0 for  set ce=s.find(" ",ce) set:ce=0 ce=s.length()+2 if code.extract(1, ce-2).length("""")#2=1 set ce=ce-2 quit

	do this.saveSrc( cp + ce, lp)

	quit this.saveTkn( $SELECT(cp=1:this.tknTypeMTD,1:this.tknTypeWRD), code.extract( 1, ce))

	// ---------------------------------------------------------------------
public final String nextWhitespace()
	/* ---------------------------------------------------------------------
	Obtain the whitespace preceding the next token in srcCode().
	Call this method to find out if a command is argumentless. Calling this
	method is the only way to detect an argumentless command "in the middle"
	of a line.
	*/
	type Number cp = this.srcChar

	if cp=0 quit ""	// at end-of-line there is no whitespace

	type String code = this.srcCode( this.srcLine)
	type Number cp1
	for cp1=cp:1 quit:code.extract(cp1)'=" "

	quit code.extract( cp, cp1 - 1)

	// ---------------------------------------------------------------------
public final void preParse()
	/* ---------------------------------------------------------------------
	Apply pre-parser to source code. This method will create a parse tree
	that contains all the tokens from the srcCode().

	NOTES:
	. See nextToken() about complications with respect to the handling of
		whitespace in PSL constructs. Especially the inherent ambiguity
		due to the role of "+" and "-" in unary and binaray operation
		prevents whitespace reduction as part of the pre-parsing
		process.
	*/

	type Number ign, tt

	do this.saveSrc( 0, 0)
	set this.tknIgnEOL = false
	kill this.tknTree()

	for  set tt = this.nextToken(), ign = this.treeAdd( this.tknType, this.tknValue) quit:tt = this.tknTypeEOF

	quit

	// ---------------------------------------------------------------------
public final void pushBack()
	/* ---------------------------------------------------------------------
	Push back the token that was returned by the last call to nextToken().
	*/
	set this.tknPushBack = true
	quit

	// ---------------------------------------------------------------------
public final void rewind()	// reset source code pointer
	/* ---------------------------------------------------------------------
	*/
	set this.srcChar = 0
	set this.srcLine = 0
	quit

	// ---------------------------------------------------------------------
public final void showSrc()
	/* ---------------------------------------------------------------------
	Show the token decomposition on System.out
	*/

	type Number tt
	do this.saveSrc( 0, 0)
	set this.tknIgnEOL = false

	for  {  quit:tt = this.tknTypeEOF
		set tt=this.nextToken()
		if tt = this.tknTypeMTD write "*** START OF METHOD ***",!

		if (tt = this.tknTypeEOL) write "*EOL*",!?8
		else if tt = this.tknTypeSTR write this.tknValue.addQuotes()," "
		else if tt = this.tknTypeWSP write "/* "_ this.tknValue _ " */ "
		else if tt = this.tknTypeCMT write "// "_ this.tknValue
		else write this.tknValue," "
	}
	write "*EOF*"
	quit

	// ---------------------------------------------------------------------
public final Number skip2EOL()
	/* ---------------------------------------------------------------------
	Skip tokens until end-of-line
	*/
	do this.saveSrc( 0, this.srcLine)
	quit this.saveTkn(this.tknTypeEOL, this.srcLine.toString())

	// ---------------------------------------------------------------------
public final Number skip2SYM( Number sym)
	/* ---------------------------------------------------------------------
	Skip tokens until next occurrence of requested symbol.
	The search will honor tknIgnEOL.
	If the symbol is not found, then tknTypeEOL (tknIgnEOL is true) or
	tknTypeEOF (tknIgnEOL is true) will be returned.
	*/
	type Number tkn

	for  set tkn=this.nextToken() quit:tkn=this.tknTypeEOL&'this.tknIgnEOL!(tkn=this.tknTypeEOF)!(tkn=sym)
	quit tkn

	// ---------------------------------------------------------------------
public final Number skip2WRD( List words, Boolean ignCase)
	/* ---------------------------------------------------------------------
	Skip tokens until next word in supplied list
	The search will honor tknIgnEOL.
	If the symbol is not found, then tknTypeEOL (tknIgnEOL is true) or
	tknTypeEOF (tknIgnEOL is true) will be returned.
	*/
	type Number tkn

	for  set tkn=this.nextToken() quit:tkn=this.tknTypeEOL&'this.tknIgnEOL!(tkn=this.tknTypeEOF)  if tkn=this.tknTypeWRD, words.contains(this.tknValue,,ignCase) quit
	quit tkn

	// ---------------------------------------------------------------------
public final String addQuotes( String str)
	/* ---------------------------------------------------------------------
	Replacement for String.addQuotes() that deals with Java/JSON type of
	quoted strings. This method uses this.charQuote and this.charEscape to
	produce the result:
	- If this.charEscape.isNull() then it will return
		str.addQuotes(this.charQuote)
	- Else it will produce the inverse of nextStrJ()
	*/
	type String ce = this.charEscape
	type String cq = this.charQuote

	if ce.isNull() quit str.addQuotes( cq)

	set str = str.replace( ce, ce_ ce)
	set str = str.replace( 8.char(), ce_ "b")
	set str = str.replace( 9.char(), ce_ "t")
	set str = str.replace( 10.char(), ce_ "n")
	set str = str.replace( 12.char(), ce_ "f")
	set str = str.replace( 13.char(), ce_ "r")
	set str = str.replace( cq, ce_ cq)
	quit cq_ str_ cq

	// ---------------------------------------------------------------------
public final Number treeAdd( Number rule, Primitive branch)
	/* ---------------------------------------------------------------------
	Append the supplied rule and 
	return the leaf number.
	*/
	type Number root = this.tknTree( "").order(-1).toNumber() + 1
	set this.tknTree( root) = rule_ 9.char()_ branch
	quit root

	// ---------------------------------------------------------------------
public final void treeRemove( Number at	// (*1)
		)	// remove tree entry at specified node
	/* ---------------------------------------------------------------------
	Remove the token value or rule at the specified node in the tokentree

	ARGUMENTS:
	(*1) at = position using the following conventions:
		at > 0 then this.tknTree(at)
		at = 0 then this.tknTree( this.treeRoot())
		at < 0 then this.tknTree( this.treeRoot() + at) 
	*/
	type Number sub = $SELECT(at>0:at,at=0:this.tknTree("").order(-1).toNumber(),1:this.tknTree("").order(-1).toNumber()+at)
	kill this.tknTree(sub)
	quit

	// ---------------------------------------------------------------------
public final Number treeRoot()
	/* ---------------------------------------------------------------------
	General support function that returns the root (highest subscript) of
	the PSLParseTree.
	*/
	quit this.tknTree("").order(-1).toNumber()

	// ---------------------------------------------------------------------
public final Number treeType( Number at)	// (*1)
	/* ---------------------------------------------------------------------
	Return the token type at the specified node in the token tree

	ARGUMENTS:
	(*1) at = position using the following conventions:
		at > 0 then this.tknTree(at)
		at = 0 then this.tknTree( this.treeRoot())
		at < 0 then this.tknTree( this.treeRoot() + at) 
	*/
	quit this.tknTree( $SELECT(at>0:at,at=0:this.tknTree("").order(-1).toNumber(),1:this.tknTree("").order(-1).toNumber()+at)).toNumber()


	// ---------------------------------------------------------------------
public final Primitive treeValue( Number at)	// (*1)
	/* ---------------------------------------------------------------------
	Return the token value or rule at the specified node in the tokentree

	ARGUMENTS:
	(*1) at = position using the following conventions:
		at > 0 then this.tknTree(at)
		at = 0 then this.tknTree( this.treeRoot())
		at < 0 then this.tknTree( this.treeRoot() + at) 
	*/
	quit this.tknTree( $SELECT(at>0:at,at=0:this.tknTree("").order(-1).toNumber(),1:this.tknTree("").order(-1).toNumber()+at)).piece( 9.char(), 2, PSL.maxStringLength)


	/* ================================================================== */
	/* local static methods						      */
	/* ****************************************************************** */

	/* ================================================================== */
	/* local instance methods					      */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
private Number nextCmt( Number cp, Number lp)
	/* ---------------------------------------------------------------------
	Check if the current position starts a comment. If so decode it.
	This may be either a comment-to-end-of-line or a block comment.

	OUTPUTS:
	* $$ = type of comment
		0 = not comment
		1 = block comment
		2 = end-of-line comment
	* this.tknType = tknTypeCMT
	* this.tknValue = comment text.
		If the comment spans multiple lines, 10.char() will be inserted
		as the end-of-line marker.
	*/
	type Number elm = 0
	type List cmtPairs = this.charComment
	type String cmt, cmtBgn = "", cmtEnd = ""
	type String code = this.srcCode(lp).extract(cp, PSL.maxStringLength)

	for elm = 1:1:cmtPairs.count() set cmt = cmtPairs.elementAt(elm).piece(":") if code.beginsWith(cmt) set cmtBgn=cmt, cmtEnd=cmtPairs.elementAt(elm).piece(":",2) quit

	/* if not start of comment, tell caller and quit */
	if cmtBgn.isNull() quit 0

	/* Comment-to-end-fo-line, store and tell caller */
	if cmtEnd.isNull() do this.saveSrc( 0, lp) set elm = this.saveTkn( this.tknTypeCMT, code.extract( cmtBgn.length()+1, code.length())) quit 2

	/* Block comment. Look for cmtEnd on current line. If found, store and
	   tell caller. */
	type Number pos = code.find(cmtEnd)
	if pos>0 do this.saveSrc( cp + pos, lp) set elm = this.saveTkn( this.tknTypeCMT, code.extract( cmtBgn.length()+1, pos-cmtEnd.length()-1)) quit 1

	/* multiple lines. Advance until cmtEnd is found */
	set cmt = code.extract( cmtBgn.length() + 1, code.length())
	for lp = lp+1:1:this.srcLast { quit:pos>0
		set code = this.srcCode(lp), pos = code.find(cmtEnd)
		if 'pos set cmt = cmt_ 10.char()_ code quit
		set cmt = cmt_ 10.char()_ code.extract( 1, pos - 1 - cmtEnd.length())
	}
	do this.saveSrc( pos, lp) set elm = this.saveTkn( this.tknTypeCMT, cmt)
	quit 1

	// ---------------------------------------------------------------------
private Number nextNumlit( String code, Number cp, Number lp)
	/* ---------------------------------------------------------------------
	Decode the numeric literal or symbol '-' at the current position.

	This method decodes a M / PSL / SQL numeric literal.
	It will accept a single sign. 
	*/

	type String num = code.extract()
	if num="-"!(num="+"),".0123456789"'[code.extract(2) do this.saveSrc( cp+1, lp) quit this.saveTkn( num.ascii(), num)
	if num=".","0123456789"'[code.extract(2) do this.saveSrc( cp+1, lp) quit this.saveTkn( ".".ascii(), ".")

	type Number ce

	// integer part (including leading "-"
	for ce=2:1 quit:code.extract( ce)'?1N

	// fraction (only if dot followed by at least one digit)
	if code.extract(ce)=".", code.extract(ce+1)?1N for ce=ce+1:1 quit:code.extract(ce)'?1N

	// exponent
	if code.extract(ce)="E" {
		type Number ce1 = ce+1
		if code.extract(ce1)="+"!(code.extract(ce1)="-") set ce1 = ce1+1
		if code.extract(ce1)?1N for ce=ce1+1:1 quit:code.extract(ce)'?1N
	}
	set ce=ce-1
	do this.saveSrc( cp + ce, lp)
	quit this.saveTkn( this.tknTypeNUM, code.extract(1, ce).toNumber())

	// ---------------------------------------------------------------------
private Number nextStrD( String code, Number cp, Number lp)
	/* ---------------------------------------------------------------------
	Decode a strlit that doubles the quote character.

	This function handles M / PSL / SQL strlits, in which there are no
	embedded escape characters, and in which occurrences of the quote
	character itself inside the literal is coded by two consecutive quote
	characters.

	Note that this.tknValue is set to the value of the string, not the
	literal.
	*/

	type Number ce = 2
	type String qt = this.charQuote
	for  set ce=code.find(qt,ce) quit:code.extract(ce)'=qt
	set ce=ce-1 if ce<0 set ce = this.saveTkn( this.tknTypeSTR, code_qt) do this.saveSrc(0,lp) throw Class.new("Error", "%PSL-E-SYNTAX,missing quote")
	do this.saveSrc( cp + ce, lp)
	quit this.saveTkn( this.tknTypeSTR, code.extract(1, ce).stripQuotes(qt))

	// ---------------------------------------------------------------------
private Number nextStrJ( String code, Number cp, Number lp)
	/* ---------------------------------------------------------------------
	Decode a strlit at the curent position.

	This function handles JSON / Java strlits, in which an escape character
	introduces one of the following special sequences:
	\\ - the backslash character
	\" - the quote character
	\b - the backspace character (8.char())
	\t - the tab character (9.char())
	\n - the newline character (10.char())
	\f - the formfeed character (12.char())
	\r - the carriage return character (13.char())

	Note that this.tknValue is set to the value of the string, not the
	literal.
	*/

	type literal String ESCCODES = """\/bfnrt"
	type literal String CHRCODES = """\/"_8.char()_12.char()_10.char()_13.char()_9.char()
	type Number ce = 2
	type String qt = this.charQuote
	type String es = this.charEscape
	type String c = ""

	/* Find the terminating quote (the one that is NOT preceded by the
	   escape character), and update the pointer. */
	for  set ce=code.find(qt,ce) quit:code.extract(ce - 2)'=es
	if ce=0 set ce = this.saveTkn( this.tknTypeSTR, code_es_qt) do this.saveSrc(0,lp) throw Class.new("Error", "%PSL-E-SYNTAX,missing quote")
 	do this.saveSrc( cp + ce - 1, lp)

	/* Res contains the characters "inside" the quotes, which may still
	   include escape sequences. Replace the escape sequences. */
	type String res = code.extract( 2, ce - 2)
	set ce = 1

	for  set ce = res.find( es, ce) quit:ce=0  {
		set c = res.extract( ce)
		if c="u" {
			// to come: replace \uxxxx by its Unicode character
			type Number d = 0, i = 0
			for i = 1:1:4 set d = d * 16 + "0123456789abcdef".find( res.extract(ce+i).lowerCase()) - 2
			set res = res.extract(1,ce-2)_ d.char()_ res.extract(ce+5, res.length())
		}
		else  if ESCCODES[c set res = res.extract(1,ce-2)_ c.translate( ESCCODES, CHRCODES)_ res.extract(ce+1, res.length()) quit
	}

	quit this.saveTkn( this.tknTypeSTR, res)

	// ---------------------------------------------------------------------
private Number nextStrlit( String code, Number cp, Number lp)
	/* ---------------------------------------------------------------------
	Decode a strlit at the curent position.

	If this.charEscape.isNull(), then $$nextStrD() will be called for
	standard M / PSL / SQL string literals, else $$nextStrJ() will be
	called.

	Note that this.tknValue is set to the value of the string, not the
	literal.

	Token parsers that need to deal with a different strlit representation
	shall override this method.
	*/
	if this.charEscape.isNull() quit this.nextStrD( code, cp, lp)
	quit this.nextStrJ( code, cp, lp)

	// ---------------------------------------------------------------------
private void reset()	// reset all pointers
	/* ---------------------------------------------------------------------
	*/

	set this.charEscape = ""
	set this.charComment = Class.new("List", ";,//,/*:*/")
	set this.charQuote = """"
	set this.charSymbol = "_+-*/\#=<>&!?'@()[]{},.;:"

	set this.srcChar = 0
	set this.srcFile = ""
	set this.srcLast = 0
	set this.srcLine = 0
	kill this.srcCode()

	set this.tknIgnCMT = this.tknIgnCMTBLOCK	// ignore block-comment
	set this.tknIgnEOL = false			// do not ignore EOL
	set this.tknPushBack = false
	set this.tknType = this.tknTypeEOL
	set this.tknValue = ""
	kill this.tknTree()

	quit

	// ---------------------------------------------------------------------
private void saveSrc( Number cp, Number lp)
	/* ---------------------------------------------------------------------
	Save character pointer and line pointer
	*/
	set this.srcChar = cp, this.srcLine = lp
	quit

	// ---------------------------------------------------------------------
private Number saveTkn( Number typ, String val)
	/* ---------------------------------------------------------------------
	Save token type and token value in this.tknType, this.tknValue,
	and this.tknTree().
	*/
	//type Number leaf = this.tknTree("").order(-1).toNumber() + 1
	//set this.tknTree( leaf) = typ_ 9.char()_ val
	set this.tknType = typ, this.tknValue = val
	quit typ
 #OPTION ResultClass ON
public String vSIG()	quit "61461^42883^Frans S.C. Witte^38936"	// Signature - LTD^TIME^USER^SIZE
