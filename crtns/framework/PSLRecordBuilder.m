 ; 
 ; **** Routine compiled from DATA-QWIK Procedure PSLRecordBuilder ****
 ; 
 ; 02/24/2010 18:22 - pip
 ; 
 ;  #PACKAGE framework.psl
 ;  #CLASSDEF extends=Primitive delimiter=9 public
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF tableName class=String position=2 public readonly
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF tableNameLC class=String position=3 public readonly
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF delimiterStr class=String position=4 private
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF triggerSeq = 1 class=Number position=5 private
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF indexSeq = 1 class=Number position=6 private
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF checkAccessRights class=List position=7 private
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF auditLog class=List position=8 private
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF hasMoB class=Boolean position=9 private
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF children class=List position=10 private
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF td class=SchemaTable node="td" private
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF sections class=List node="sections" private
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF triggerAllIfConds() class=String node="trigAllIf" private
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF trigBI   = 1 class=Number private literal
 ;  #PROPERTYDEF trigBU   = 2 class=Number private literal
 ;  #PROPERTYDEF trigBD   = 3 class=Number private literal
 ;  #PROPERTYDEF trigAI   = 4 class=Number private literal
 ;  #PROPERTYDEF trigAU   = 5 class=Number private literal
 ;  #PROPERTYDEF trigAD   = 6 class=Number private literal
 ;  #PROPERTYDEF trigDESC = "BI,BU,BD,AI,AU,AD" class=String private literal
 ;
 ; ---------------------------------------------------------------------
 ;  #PROPERTYDEF oLvn = "vobj" class=String public literal
 ;
 ; ---------------------------------------------------------------------
initialize(this,tableName) ; Constructor
 ;
 N delimStr
 ;
 N td S td=$$getSchTbl^UCXDD(tableName)
 ;
 S this("td")=td
 ;
 S $P(this,$C(9),2)=tableName
 S $P(this,$C(9),3)=$ZCONVERT(tableName,"L")
 ;
 ; Set delimiterStr
 I (($P(td,"|",10)<32)!($P(td,"|",10)>127)) S delimStr=($P(td,"|",10)_".char()")
 E  S delimStr=$$QADD^%ZS($char($P(td,"|",10)),"""")
 S $P(this,$C(9),4)=delimStr
 ;
 S $P(this,$C(9),7)=$$checkAccessRights^UCXDD(td,1)
 I $$usingAuditLog^SQLAUDIT S $P(this,$C(9),8)=$$getLogging^UCXDD(td,1)
 E  S $P(this,$C(9),8)=0
 ;
 ; Init sections list
 D getSections(.this)
 ;
 S $P(this,$C(9),9)=(($P(td,"|",5)["M")!($P(td,"|",5)["B"))
 ;
 ; Get children, if any
 S $P(this,$C(9),10)=""
 ;
 N rs,vos1,vos2,vos3,vos4  N V1 S V1=$P(this,$C(9),2) S rs=$$vOpen1()
 ;
 F  Q:'$$vFetch1()  S $P(this,$C(9),10)=$S(($P(this,$C(9),10)=""):rs,1:$P(this,$C(9),10)_","_rs)
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
 ;
buildAll() ; 
 ; ---------------------------------------------------------------------
 ;
 N errCnt S errCnt=0
 ;
 N rs,vos1,vos2,vos3,vos4 S rs=$$vOpen2()
 ;
 F  Q:'$$vFetch2()  S errCnt=errCnt+$$run^PSLC("--element=Record"_rs_"~Filer Record"_rs)
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
 ;
build(this,tknzr) ; polymorphism dispatch
 N vC S vC=$P($G(this),$C(9))
 I $D(vPslPoly(vC,"build")) D v0build^@vPslPoly(vC,"build")(.this,.tknzr) Q
 D v0build(.this,.tknzr) Q
v0build(this,tknzr) ; Tokenizer to contain code
 ; ---------------------------------------------------------------------
 ;
 N source ; For use by various build methods
 N tableName S tableName=$P(this,$C(9),2)
 ;
 ; Needed by calls from it, e.g., UCDB
 N oLvn S oLvn="vobj"
 ;
 D appendLine^PSLTokenizer(.tknzr,"")
 D appendLine^PSLTokenizer(.tknzr," // Record Class code for table "_tableName)
 D appendLine^PSLTokenizer(.tknzr,"")
 D appendLine^PSLTokenizer(.tknzr," // Generated by PSLRecordBuilder on "_$$vdat2str($P($H,",",1),"MM/DD/YEAR")_" at "_$$vtim2str($P($H,",",2),"24:60")_" by "_$get(%UID))
 D appendLine^PSLTokenizer(.tknzr,"")
 ;
 I '($P(this("td"),"|",8)'="GTM"),($P(this("td"),"|",2)="") D addLine(.source," // No global - no class") Q 
 ;
 D buildnew(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 D buildgetRecord(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 D buildbypassSave(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 D buildsave(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 D buildcheckAccessRights(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 I '($P(this("td"),"|",8)'="GTM") D
 .	;
 .	D buildlogMethods(.this,.source)
 .	D appendSrc^PSLTokenizer(.tknzr,.source)
 .	Q 
 ;
 D buildcolumnLists(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 D buildvlegacy(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 D buildhasLiterals(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 D buildmiscValidations(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 D buildupdateDB(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 D builddelete(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 I ((","_this("sections")_",")[",defaults,") D
 .	;
 .	D buildsetDefaults(.this,.source)
 .	D appendSrc^PSLTokenizer(.tknzr,.source)
 .	Q 
 ;
 I ((","_this("sections")_",")[",required,") D
 .	;
 .	D buildchkRequired(.this,.source)
 .	D appendSrc^PSLTokenizer(.tknzr,.source)
 .	Q 
 ;
 I ((","_this("sections")_",")[",foreignKeys,") D
 .	;
 .	D buildforeignKeys(.this,.source)
 .	D appendSrc^PSLTokenizer(.tknzr,.source)
 .	Q 
 ;
 I ((","_this("sections")_",")[",triggers,") D
 .	;
 .	D buildtriggers(.this,.source,.tknzr)
 .	D appendSrc^PSLTokenizer(.tknzr,.source)
 .	Q 
 ;
 I ($P(this("td"),"|",4)>1) D
 .	;
 .	D buildforceLoad(.this,.source)
 .	D appendSrc^PSLTokenizer(.tknzr,.source)
 .	Q 
 ;
 D buildvalidateDD(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 I ((","_this("sections")_",")[",journals,") D
 .	;
 .	D buildjournals(.this,.source,.tknzr)
 .	D appendSrc^PSLTokenizer(.tknzr,.source)
 .	Q 
 ;
 I ((","_this("sections")_",")[",indexes,") D
 .	;
 .	D buildindexes(.this,.source,.tknzr)
 .	D appendSrc^PSLTokenizer(.tknzr,.source)
 .	Q 
 ;
 I $$getArchivable^DBARCHIVE(this("td")) D
 .	;
 .	D buildarchiveMethods(.this,.source)
 .	D appendSrc^PSLTokenizer(.tknzr,.source)
 .	Q 
 ;
 D buildkeyChanged(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 I ((","_this("sections")_",")[",cascadeDelete,") D
 .	;
 .	D buildcascadeDelete(.this,.source)
 .	D appendSrc^PSLTokenizer(.tknzr,.source)
 .	Q 
 ;
 D builderror(.this,.source)
 D appendSrc^PSLTokenizer(.tknzr,.source)
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildarchive(this,source,tdarch,keyNames,keyTypes,keyValues,formalParams,comment,isNotArchived) ; Build "shell" method
 ;
 N included S included=$$getArchiveIncluded^DBARCHIVE(tdarch)
 N i N maxrecs
 N keycnt S keycnt=$S((keyNames=""):0,1:$L(keyNames,","))
 N archiveKey S archiveKey=$piece(keyNames,",",keycnt)
 N archiveTable S archiveTable=$P(tdarch,"|",1)
 N archKeyType S archKeyType=$piece(keyTypes,",",keycnt)
 N code N globalKeys N globalRef N includedRefs N lvpm N where
 ;
 ; If archive key is date, use it, otherwise find serial value column
 I $piece(keyTypes,",",keycnt)="Date" S where=$piece(keyNames,",",keycnt)
 E  D
 .	;
 .	; If serial column specified, use that, otherwise, use first one
 .	N rsarch,vos1,vos2,vos3,vos4  N V1 S V1=archiveTable S rsarch=$$vOpen3()
 .	;
 . I '$G(vos1) S where=""
 . E  I $$vFetch3() S where=rsarch
 .	;
 .	I (where="") D
 ..		;
 ..		N rs,vos5,vos6,vos7,vos8,vos9  N V2 S V2=archiveTable S rs=$$vOpen4()
 ..		;
 ..  I $$vFetch4() S where=rs
 ..		; Archivable tables must have bottom date key or a serial column and cannot be a sub-table of another archivable table
 ..		E  S $ZE="0,"_$ZPOS_","_"%PSL-E-INVALID,"_$$^MSG(6891,archiveTable),$EC=",U1001,"
 ..  Q 
 . Q 
 ;
 ; Maximum records to process between commits and index updates
 I (keycnt=1) S maxrecs=1
 E  S maxrecs=100
 ;
 S where=where_" <= :archiveDate"
 ;
 I (keycnt>1) D
 .	;
 .	N topWhere S topWhere=""
 .	;
 .	F i=1:1:keycnt-1 D
 ..		;
 ..		N key S key=$piece(keyNames,",",i)
 ..		;
 ..		I (i>1) S topWhere=topWhere_" AND "
 ..		S topWhere=topWhere_key_" = :key"_i
 ..		Q 
 .	;
 .	S where=topWhere_" AND "_where
 .	Q 
 ;
 ; Save at least the last record
 S where=where_" AND "_archiveKey_" < :maxVal"
 ;
 F i=1:1:(keycnt-1) S lvpm(i_"*")="key"_i
 S lvpm(keycnt)="archiveKey"
 S globalRef=$$getGbl^UCXDD(tdarch,"",.lvpm)
 S globalRef=$E(globalRef,2,$L(globalRef)-1)_")"
 ;
 S globalKeys="("_$piece(globalRef,"(",2,1048575)
 ;
 F i=1:1:$S((included=""):0,1:$L(included,",")) D
 .	;
 .	N incltbl S incltbl=$piece(included,",",i)
 .	N ref
 .	;
 .	N tdincl S tdincl=$$getPslTbl^UCXDD(incltbl,0)
 .	;
 .	S ref=$P(tdincl,"|",2)
 .	S ref=$piece($E(ref,2,1048575),"(",1)_globalKeys
 .	;
 .	S includedRefs(i)=ref
 .	Q 
 ;
 D addLine(.source,"")
 S code="public static Number archive(String archiveDir, Number archiveNum,"
 S code=code_" Date archiveDate"
 I (keycnt>1) S code=code_", "_formalParams
 S code=code_")"
 D addLine(.source,code)
 ;
 I isNotArchived D addLine(.source," quit 0 // Shell method") Q 
 ;
 I (keycnt>1) D addLine(.source,"  // "_comment)
 I (keycnt=1) D addLine(.source," type public String %INTRPT()")
 ;
 D addLine(.source," type Boolean isDone")
 D addLine(.source," type Number i, n, recordCnt")
 D addLine(.source," type "_archKeyType_" archiveKey")
 ;
 S code=" type "_archKeyType_" maxVal"
 F i=1:1:$S((included=""):0,1:$L(included,",")) S code=code_", maxVal"_$piece(included,",",i)
 D addLine(.source,code)
 ;
 ; Get maximum values for main and included tables to ensure keep at least one record
 D addLine(.source," #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
 D addLine(.source," #BYPASS")
 ;
 F i=1:1:$S((included=""):0,1:$L(included,",")) D addLine(.source," new last"_$piece(included,",",i)_" set last"_$piece(included,",",i)_"=""""")
 ;
 D addLine(.source," set archiveKey=""""")
 D addLine(.source," set maxVal=$O(^"_globalRef_",-1)")
 D addLine(.source," if maxVal="""" quit 0")
 F i=1:1:$S((included=""):0,1:$L(included,",")) D addLine(.source," set maxVal"_$piece(included,",",i)_"=$O(^"_includedRefs(i)_",-1)")
 D addLine(.source," #ENDBYPASS")
 ;
 D addLine(.source," type ResultSet rs = Db.select("""_archiveKey_""", """_archiveTable_""", """_where_""", """_archiveKey_" ASC"")")
 ;
 D addLine(.source," if rs.isEmpty() quit 0")
 ;
 D addLine(.source," set recordCnt = 0")
 D addLine(.source," set isDone = false")
 D addLine(.source," while 'isDone do {")
 ;
 D addLine(.source,"  type String records()")
 ;
 D addLine(.source,"  for i = 1:1:"_maxrecs_" do { quit:isDone")
 ;
 D addLine(.source,"   if rs.next() set records(i) = rs.getCol("""_archiveKey_""")")
 D addLine(.source,"   else  set isDone = true")
 D addLine(.source,"  }")
 ;
 D addLine(.source,"  quit:'records(1).exists()")
 ;
 D addLine(.source,"  do Runtime.start(""BA"")")
 D addLine(.source,"  for i=1:1:100 quit:'records(i).exists()  do {")
 ;
 D addLine(.source,"   set recordCnt = recordCnt + 1")
 D addLine(.source,"   set archiveKey = records(i)")
 ;
 D addLine(.source,"   // Archive main record and sub-tables. Save index")
 D addLine(.source,"   #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
 D addLine(.source,"   #BYPASS")
 D addLine(.source,"   merge ^|archiveDir|"_globalRef_"=^"_globalRef)
 D addLine(.source,"   kill ^"_globalRef)
 ;
 ; Deal with included tables
 F i=1:1:$S((included=""):0,1:$L(included,",")) D
 .	;
 .	N incltbl S incltbl=$piece(included,",",i)
 .	;
 .	D addLine(.source,"   ;")
 .	D addLine(.source,"   ; Related table "_incltbl)
 .	D addLine(.source,"   if (archiveKey<maxVal"_incltbl_") do")
 .	D addLine(.source,"   . merge ^|archiveDir|"_incltbl_"=^"_includedRefs(i))
 .	D addLine(.source,"   . kill ^"_includedRefs(i))
 .	D addLine(.source,"   . set last"_incltbl_"=archiveKey")
 .	Q 
 ;
 D addLine(.source,"   #ENDBYPASS")
 D addLine(.source,"  }")
 ;
 D addLine(.source,"  // Update index for current archive number with last "_archiveKey)
 D addLine(.source,"  #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
 D addLine(.source,"  #BYPASS")
 ;
 ; Update index for primary table, then included tables
 D addLine(.source,"  set n=$O(^DBARCHX("""_archiveTable_""","_keyValues_",""""),-1)")
 D addLine(.source,"  if n'="""",^(n)=archiveNum kill ^(n)")
 D addLine(.source,"  set ^DBARCHX("""_archiveTable_""","_keyValues_",archiveKey)=archiveNum")
 D addLine(.source,"  ;")
 ;
 F i=1:1:$S((included=""):0,1:$L(included,",")) D
 .	;
 .	N incltbl S incltbl=$piece(included,",",i)
 .	;
 .	D addLine(.source,"  if (last"_incltbl_"'="""") do")
 .	D addLine(.source,"   . set n=$O(^DBARCHX("""_incltbl_""","_keyValues_",""""),-1)")
 .	D addLine(.source,"   . if (n'=""""),(^(n)=archiveNum) kill ^(n)")
 .	D addLine(.source,"   . set ^DBARCHX("""_incltbl_""","_keyValues_",archiveKey)=archiveNum")
 .	D addLine(.source,"   . if (archiveKey'<last"_incltbl_") set last"_incltbl_"=""""")
 .	D addLine(.source,"  ;")
 .	Q 
 ;
 D addLine(.source,"  #ENDBYPASS")
 ;
 D addLine(.source,"  do Runtime.commit()")
 ;
 I (keycnt=1) D
 .	;
 .	D addLine(.source,"  if %INTRPT.data() > 1 do INTRPT^IPCMGR")
 .	D addLine(.source,"  if '%INTRPT.get().isNull() do {")
 .	;
 .	D addLine(.source,"   if %INTRPT = ""STOP"" set isDone = true")
 .	D addLine(.source,"   else  set %INTRPT = """"")
 .	D addLine(.source,"  }")
 .	Q 
 ;
 D addLine(.source," }")
 ;
 D addLine(.source," quit recordCnt")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildarchiveMethods(this,source) ; Build code into source
 ;
 N isNotArchived
 N archiveKeys
 N delim N i N keycnt
 N archiveKey N archiveTable N comment N formalParams N keyNames N keyTypes N keyValues
 ;
 K source
 ;
 S archiveTable=$$getArchiveTable^DBARCHIVE(this("td"))
 ;
 I (archiveTable="") D
 .	;
 .	S archiveTable=$P(this,$C(9),2)
 .	S isNotArchived=1
 .	Q 
 E  S isNotArchived=0
 ;
 N tdarch S tdarch=$$getPslTbl^UCXDD(archiveTable,0)
 ;
 S delim=$P(tdarch,"|",10)
 S archiveKeys=$P(tdarch,"|",3)
 S keycnt=$$getArchiveKey^DBARCHIVE(tdarch,0)
 S archiveKey=$piece(archiveKeys,",",keycnt)
 ;
 S (formalParams,keyNames,keyTypes,keyValues)=""
 S comment=""
 F i=1:1:keycnt D
 .	;
 .	N cd S cd=$$getSchCln^UCXDD(archiveTable,$piece(archiveKeys,",",i))
 .	;
 .	S keyNames=keyNames_$P(cd,"|",2)_","
 .	S keyTypes=keyTypes_$$getClass^UCXDD(cd)_","
 .	;
 .	I (i<keycnt) D
 ..		;
 ..		S formalParams=formalParams_$$getClass^UCXDD(cd)_" key"_i_", "
 ..		S keyValues=keyValues_"key"_i_"_"_delim_".char()_"
 ..		S comment=comment_"key"_i_" = "_$P(cd,"|",2)_", "
 ..		Q 
 .	E  S comment=comment_"archiveKey = "_$P(cd,"|",2)
 .	Q 
 ;
 S formalParams=$E(formalParams,1,$L(formalParams)-2)
 S keyNames=$E(keyNames,1,$L(keyNames)-1)
 S keyTypes=$E(keyTypes,1,$L(keyTypes)-1)
 S keyValues=$E(keyValues,1,$L(keyValues)-($L(delim)+9))
 ;
 I (keyValues="") S keyValues="0"
 ;
 ; Generate code for RecordTABLE.archive() method if a primary archive table
 I ($P(this,$C(9),2)=archiveTable) D buildarchive(.this,.source,.tdarch,keyNames,keyTypes,keyValues,formalParams,comment,isNotArchived)
 ;
 ; Generate code for RecordTABLE.getArchiveFile() method
 D buildgetArchiveFile(.this,.source,.tdarch,keyNames,keyTypes,keyValues,formalParams,comment,isNotArchived)
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildbypassSave(this,source) ; Build code into source
 ;
 N code
 ;
 ;  #ACCEPT Date=06/10/2008; Pgm=RussellDS; CR=30801; Group=ACCESS
 N bypassQual S bypassQual=$$bypassQual^UCRECORD
 ;
 K source
 ;
 D addLine(.source,"")
 ;
 I ($P(this,$C(9),10)="") S code="final "
 E  S code=""
 ;
 D addLine(.source,"public "_code_"void vBypassSave()")
 ;
 ; bypassSave always from PSL, so auditLogSeq can be zero
 D addLine(.source," do this.vSave("_$S(bypassQual'["""":""""_bypassQual_"""",1:$$QADD^%ZS(bypassQual,""""))_",0)")
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildcascadeDelete(this,source) ; Build code into source
 ;
 N fkeys N fktblKeys N ptkeys
 N i N rsseq
 N code N ermsg N table N tbl1ffid N where
 ;
 K source
 ;
 S ptkeys=$ZCONVERT($P(this("td"),"|",3),"L")
 ;
 D addLine(.source,"")
 D addLine(.source,"private void vRCcascadeDelete(List vRCparams)")
 ;
 S rsseq=0
 S table=$P(this,$C(9),2)
 ;
 F  Q:'('(table=""))  D
 .	;
 .	N rs,vos1,vos2,vos3,vos4,vos5,vos6  N V1 S V1=table S rs=$$vOpen5()
 .	;
 .	F  Q:'$$vFetch5()  D
 ..		;
 ..  S tbl1ffid=$P(rs,$C(9),1)
 ..		;
 ..		I '$$isTable^UCXDD(tbl1ffid) S $ZE="0,"_$ZPOS_","_"%PSL-E-INVALID,Aborted - invalid foreign key table "_tbl1ffid,$EC=",U1001,"
 ..		;
 ..  S fkeys=$P(rs,$C(9),2)
 ..		;
 ..		N tdfd S tdfd=$$getPslTbl^UCXDD(tbl1ffid,0)
 ..		;
 ..		S fktblKeys=$P(tdfd,"|",3)
 ..		;
 ..		S where=""
 ..		F i=1:1:$S((fkeys=""):0,1:$L(fkeys,",")) S where=where_$piece(fkeys,",",i)_"=:this."_$$colName($piece(ptkeys,",",i),"LC",1)_" AND "
 ..		S where=$E(where,1,$L(where)-5)
 ..		;
 ..  I '$P(rs,$C(9),3) D  ; Restricted
 ...			;
 ...			; Referential integrity error ~p1
 ...			S ermsg="$$^MSG(8563, """_tbl1ffid_"("_fkeys_") -> "_$P(this,$C(9),2)_"("_$P(this("td"),"|",3)_")"").replace("","",""~"")"
 ...			;
 ...			S code=" if Db.isDefined("""_tbl1ffid_""","_$S(where'["""":""""_where_"""",1:$$QADD^%ZS(where,""""))_",1)"
 ...			S code=code_" do this.throwError("_ermsg_")"
 ...			D addLine(.source,code)
 ...			Q 
 ..		E  D  ; Cascade
 ...			;
 ...			S code=" do Db.delete("""_tbl1ffid_""","_$S(where'["""":""""_where_"""",1:$$QADD^%ZS(where,""""))_", vRCparams)"
 ...			D addLine(.source,code)
 ...			;
 ...			I (",ACN,CIF,DEP,LN,"[(","_tbl1ffid_",")) D
 ....				;
 ....				Q 
 ...			Q 
 ..		Q 
 .	;
 .	N td2 S td2=$$getPslTbl^UCXDD(table,0)
 .	;
 .	S table=$P(td2,"|",7)
 . Q 
 ;
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildcheckAccessRights(this,source) ; Build code into source
 ;
 N deleterts N insertrts N selectrts N updaterts
 N deleteRestrict N insertRestrict N selectRestrict N updateRestrict
 ;
 K source
 ;
 D addLine(.source,"")
 D addLine(.source,"public static List vcheckAccessRights()")
 ;
 D addLine(.source," quit "_$$QADD^%ZS($P(this,$C(9),7),""""))
 ;
 S (deleteRestrict,insertRestrict,selectRestrict,updateRestrict)=""
 ;
 I ($P(this,$C(9),7)="") S (insertrts,updaterts,deleterts,selectrts)=1
 E  D
 .	;
 .	N rs,vos1,vos2,vos3,vos8,vos4,vos5,vos6,vos7  N V1 S V1=$P(this,$C(9),2) S rs=$$vOpen6()
 .	;
 . I '$G(vos1) S (insertrts,updaterts,deleterts,selectrts)=0
 .	E  I $$vFetch6() D
 ..		;
 ..  S insertRestrict=$P(rs,$C(9),5)
 ..  S updateRestrict=$P(rs,$C(9),6)
 ..  S deleteRestrict=$P(rs,$C(9),7)
 ..  S selectRestrict=$P(rs,$C(9),8)
 ..		;
 ..  I ($P(rs,$C(9),1)&'(insertRestrict="")) S insertrts=2
 ..  E  I $P(rs,$C(9),1) S insertrts=1
 ..		E  S insertrts=0
 ..		;
 ..  I ($P(rs,$C(9),2)&'(updateRestrict="")) S updaterts=2
 ..  E  I $P(rs,$C(9),2) S updaterts=1
 ..		E  S updaterts=0
 ..		;
 ..  I ($P(rs,$C(9),3)&'(deleteRestrict="")) S deleterts=2
 ..  E  I $P(rs,$C(9),3) S deleterts=1
 ..		E  S deleterts=0
 ..		;
 ..  I ($P(rs,$C(9),4)&'(selectRestrict="")) S selectrts=2
 ..  E  I $P(rs,$C(9),4) S selectrts=1
 ..		E  S selectrts=0
 ..		Q 
 . Q 
 ;
 D addCheckRightsCode(.this,.source,"INSERT",insertrts,insertRestrict)
 D addCheckRightsCode(.this,.source,"UPDATE",updaterts,updateRestrict)
 D addCheckRightsCode(.this,.source,"DELETE",deleterts,deleteRestrict)
 D addCheckRightsCode(.this,.source,"SELECT",selectrts,selectRestrict)
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
addCheckRightsCode(this,source,operation,publicRight,publicRestrict) ; Restrict clause for PUBLIC
 ;
 N isSelect S isSelect=(operation="SELECT")
 N withRts S withRts=""
 N withRestrict S withRestrict=""
 N operationLC S operationLC=$ZCONVERT(operation,"L")
 N restrictByUcls
 N where
 ;
 D addLine(.source,"")
 ;
 I 'isSelect D
 .	;
 .	D addLine(.source,"public static Number v"_operationLC_"Access( String userclass)")
 .	Q 
 E  D
 .	;
 .	D addLine(.source,"public static Number vselectAccess( String userclass, ret String restrict, ret String from)")
 .	;
 .	D addLine(.source," set (restrict, from) = """"")
 .	Q 
 ;
 S where="USERCLASS <> 'PUBLIC' AND TABLENAME='"_$P(this,$C(9),2)_"'"
 ;
 ; rights depend on individual userclass, so return 0 unless a userclass has rights
 I (publicRight=0) D
 .	;
 .	N select S select="USERCLASS,"_operation_"RTS,"_$E(operation,1,3)_"RESTRICT"
 .	;
 .	S where=where_" AND "_operation_"RTS > 0"
 .	;
 .	;   #ACCEPT Date=03/16/2008; Pgm=RussellDS; CR=30801; Group=Dynamic
 .	N rs,exe,sqlcur,vd,vi,vsql,vsub S rs=$$vOpen0(.exe,.vsql,select,"DBACCRTS",where,"","","",1)
 .	;
 .	F  Q:'$$vFetch0(rs)  D
 ..		;
 ..		I '($P(vobj(rs),$C(9),3)="") D
 ...			;
 ...			S withRestrict=$S((withRestrict=""):$P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")),1:withRestrict_","_$P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")))
 ...			I isSelect D addSelectRestrict(.this,.source,$P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")),$P(vobj(rs),$C(9),3))
 ...			S restrictByUcls($P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")))=$P(vobj(rs),$C(9),3)
 ...			Q 
 ..		E  S withRts=$S((withRts=""):$P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")),1:withRts_","_$P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")))
 ..		Q 
 .	;
 .	I ($S((withRts=""):0,1:$L(withRts,","))>1) D addLine(.source," if {List}("""_withRts_""").contains(userclass) quit 1")
 .	E  I ($S((withRts=""):0,1:$L(withRts,","))=1) D addLine(.source," if (userclass = """_withRts_""") quit 1")
 .	;
 .	I ($S((withRestrict=""):0,1:$L(withRestrict,","))>1) D addLine(.source," if {List}("""_withRestrict_""").contains(userclass) quit 2")
 .	E  I ($S((withRestrict=""):0,1:$L(withRestrict,","))=1) D addLine(.source," if (userclass = """_withRestrict_""") quit 2")
 .	;
 .	D addLine(.source," quit 0")
 .	K vobj(+$G(rs)) Q 
 ;
 ; rights are 1 except for userclasses with restrict clauses, which are 2
 E  I (publicRight=1) D
 .	;
 .	N select S select="USERCLASS,"_$E(operation,1,3)_"RESTRICT"
 .	;
 .	S where=where_" AND "_$E(operation,1,3)_"RESTRICT IS NOT NULL"
 .	;
 .	;   #ACCEPT Date=03/16/2008; Pgm=RussellDS; CR=30801; Group=Dynamic
 .	N rs,exe,sqlcur,vd,vi,vsql,vsub S rs=$$vOpen0(.exe,.vsql,select,"DBACCRTS",where,"","","",1)
 .	;
 .	F  Q:'$$vFetch0(rs)  D
 ..		;
 ..		S withRestrict=$S((withRestrict=""):$P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")),1:withRestrict_","_$P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")))
 ..		I isSelect D addSelectRestrict(.this,.source,$P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")),$P(vobj(rs),$C(9),2))
 ..		S restrictByUcls($P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")))=$P(vobj(rs),$C(9),2)
 ..		Q 
 .	;
 .	I ($S((withRestrict=""):0,1:$L(withRestrict,","))>1) D addLine(.source," if {List}("""_withRestrict_""").contains(userclass) quit 2")
 .	E  I ($S((withRestrict=""):0,1:$L(withRestrict,","))=1) D addLine(.source," if (userclass = """_withRestrict_""") quit 2")
 .	;
 .	D addLine(.source," quit 1")
 .	K vobj(+$G(rs)) Q 
 ;
 ; rights are 2, except for userclasses that are 1, without restrict clauses
 E  D
 .	;
 .	N select S select="USERCLASS,"_operation_"RTS,"_$E(operation,1,3)_"RESTRICT"
 .	;
 .	S where=where_" AND "_operation_"RTS > 0"
 .	;
 .	;   #ACCEPT Date=03/16/2008; Pgm=RussellDS; CR=30801; Group=Dynamic
 .	N rs,exe,sqlcur,vd,vi,vsql,vsub S rs=$$vOpen0(.exe,.vsql,select,"DBACCRTS",where,"","","",1)
 .	;
 .	S restrictByUcls("PUBLIC")=publicRestrict
 .	;
 .	; Initialize from/restrict to PUBLIC value
 .	I isSelect D addSelectRestrict(.this,.source,"PUBLIC",publicRestrict)
 .	;
 .	F  Q:'$$vFetch0(rs)  D
 ..		;
 ..		I '($P(vobj(rs),$C(9),3)="") S restrictByUcls($P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")))=$P(vobj(rs),$C(9),3)
 ..		E  S withRts=$S((withRts=""):$P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")),1:withRts_","_$P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")))
 ..		;
 ..		; Set from/restrict based on this userclass - restrict may be null
 ..		I isSelect D addSelectRestrict(.this,.source,$P(vobj(rs),$C(9),$$vRsGetCol(rs,"USERCLASS")),$P(vobj(rs),$C(9),3))
 ..		Q 
 .	;
 .	I ($S((withRts=""):0,1:$L(withRts,","))>1) D addLine(.source," if {List}("""_withRts_""").contains(userclass) quit 1")
 .	E  I ($S((withRts=""):0,1:$L(withRts,","))=1) D addLine(.source," if (userclass = """_withRts_""") quit 1")
 .	;
 .	D addLine(.source," quit 2")
 .	K vobj(+$G(rs)) Q 
 ;
 ; Build OK() method for check restrict access by userclass
 D addRightsOKCode(.this,.source,operationLC,publicRight,withRts,.restrictByUcls)
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
addLogSQLCode(this,source,operation) ; insert, update, delete
 ;
 N isPositiveList
 N userclasses
 ;
 I $$shouldLog^SQLAUDIT($P(this,$C(9),2),operation,"log",.userclasses,.isPositiveList) D
 .	;
 .	N code N gblRef N uclsCheck
 .	;
 .	; Build global reference for UPDATE (main and detail) and DELETE (detail)
 .	I (operation'="insert") D
 ..		;
 ..		S gblRef=$$getGbl^UCXDD(this("td"),"this")
 ..		S gblRef=$$vStrRep(gblRef,oLvn_"(this,","origdata(",0,0,"")
 ..		;
 ..		I '($$getArchiveTable^DBARCHIVE(this("td"))="") S gblRef="^|"_oLvn_"(this,-99)|"_$E(gblRef,2,1048575)
 ..		I ($E(gblRef,$L(gblRef))=",") S gblRef=$E(gblRef,1,$L(gblRef)-1)
 ..		Q 
 .	;
 .	S code=$$getAuditUCLSChk(.this,userclasses,isPositiveList)
 .	I '(code="") S code=", "_code
 .	;
 .	; If auditLog sequence is zero, hasn't been logged yet
 .	D addLine(.source,"  if (vauditLogSeq.get() '> 0)"_code_" do {")
 .	;
 .	I $P(this,$C(9),9) D
 ..		;
 ..		D addLine(.source,"   type Number n")
 ..		D addLine(.source,"   type String x")
 ..		Q 
 .	D addLine(.source,"   type String map(), origdata(), SQL()")
 .	;
 .	D addLine(.source,"   do this.getColumnMap(map())")
 .	;
 .	I (operation="update") D
 ..		;
 ..		I '($P(this("td"),"|",3)="") D
 ...			;
 ...			N keys S keys=$P(this("td"),"|",3)
 ...			N i
 ...			;
 ...			F i=1:1:$S((keys=""):0,1:$L(keys,",")) D addLine(.source,"   set origdata("_(-i-2)_") = this."_$ZCONVERT($piece(keys,",",i),"L")_".oldVal")
 ...			Q 
 ..		;
 ..		D addLine(.source,"   #ACCEPT Date=06/02/2008; Pgm=RussellDS; CR=30801; Group=BYPASS")
 ..		D addLine(.source,"   #BYPASS")
 ..		D addLine(.source,"   N N,NODE")
 ..		D addLine(.source,"   I $D(vobj(this))#2 S origdata(-1)=$G("_gblRef_"))")
 ..		D addLine(.source,"   S N=-1")
 ..		D addLine(.source,"   F  S N=$O(vobj(this,N)) Q:N=""""  D")
 ..		;
 ..		I $P(this,$C(9),9) D
 ...			;
 ...			D addLine(.source,"   . I $D(vobj(this,N,1)) D  Q")
 ...			D addLine(.source,"   ..  N M,MBREF")
 ...			D addLine(.source,"   ..  S MBREF=N_"",1"",(M,origdata(MBREF))=""""")
 ...			D addLine(.source,"   ..  F  S M=$O("_gblRef_",N,M)) Q:M=""""  S origdata(MBREF)=origdata(MBREF)_^(M)")
 ...			Q 
 ..		;
 ..		D addLine(.source,"   . I N?1""v""1.N S NODE=-$E(N,2,$L(N))")
 ..		D addLine(.source,"   . E  S NODE=N")
 ..		D addLine(.source,"   . S origdata(N)=$G("_gblRef_",NODE))")
 ..		D addLine(.source,"   #ENDBYPASS")
 ..		Q 
 .	;
 .	D addLine(.source,"   do buildSQL^SQLAUDIT(this, "_$P(this,$C(9),4)_", map(), origdata(), SQL())")
 .	;
 .	D addLine(.source,"   set vauditLogSeq = $$auditLog^SQLAUDIT("""_$ZCONVERT(operation,"U")_""", """_$P(this,$C(9),2)_""", SQL(1), """")")
 .	;
 .	I $P(this,$C(9),9) D addLine(.source,"   for n = 2:1 quit:'SQL(n).exists()  set x = $$auditLog^SQLAUDIT(""update"", """_$P(this,$C(9),2)_""", SQL(n), """")")
 .	;
 .	D addLine(.source,"  }")
 .	;
 .	; Deal with detail logging
 .	S userclasses=""
 .	I (operation'="insert"),$$shouldLog^SQLAUDIT($P(this,$C(9),2),operation,"detail",.userclasses,.isPositiveList) D
 ..		;
 ..		N isPositiveList2 N logData
 ..		N userclasses2
 ..		;
 ..		S logData=$$shouldLog^SQLAUDIT($P(this,$C(9),2),operation,"detail+",.userclasses2,.isPositiveList2)
 ..		;
 ..		S code=$$getAuditUCLSChk(.this,userclasses,isPositiveList)
 ..		D addLine(.source,"  // Audit log - detail")
 ..		I '(code="") S code="if "_code_" "
 ..		D addLine(.source,"  "_code_"do {")
 ..		;
 ..		D addLine(.source,"   type Number RECSEQ")
 ..		D addLine(.source,"   type String keys")
 ..		I logData D addLine(.source,"   type String origdata()")
 ..		;
 ..		S code=""
 ..		;
 ..		I '($P(this("td"),"|",3)="") D
 ...			;
 ...			N keys S keys=$P(this("td"),"|",3)
 ...			N i
 ...			;
 ...			F i=1:1:$S((keys=""):0,1:$L(keys,",")) D
 ....				;
 ....				I logData D
 .....					;
 .....					D addLine(.source,"   set origdata("_(-i-2)_") = this."_$$colName($piece(keys,",",i),"LC",1)_".oldVal")
 .....					S code=code_""""_$piece(keys,",",i)_"=""_ origdata("_(-i-2)_")"
 .....					Q 
 ....				E  S code=code_""""_$piece(keys,",",i)_"=""_this."_$$colName($piece(keys,",",i),"LC",1)_".oldVal"
 ....				;
 ....				N cd S cd=$$getPslCln^UCXDD($P(this,$C(9),2),$piece(keys,",",i))
 ....				;
 ....				I (",T,U,F,"[(","_$P(cd,"|",6)_",")) S code=code_".addQuotes(""'"")"
 ....				S code=code_"_ "",""_ "
 ....				Q 
 ...			;
 ...			S code=$E(code,1,$L(code)-7)
 ...			Q 
 ..		;
 ..		D addLine(.source,"   set keys = "_code)
 ..		;
 ..		D addLine(.source,"   set RECSEQ = $$auditLogDetail^SQLAUDIT(vauditLogSeq, keys)")
 ..		;
 ..		I logData D
 ...			;
 ...			N space S space=""
 ...			;
 ...			I '((isPositiveList=isPositiveList2)&(userclasses=userclasses2)) D
 ....				;
 ....				S space=" "
 ....				;
 ....				S code=$$getAuditUCLSChk(.this,userclasses2,isPositiveList2)
 ....				D addLine(.source,"   if "_code_" do {")
 ....				Q 
 ...			;
 ...			D addLine(.source,space_"   #ACCEPT Date=06/02/2008; Pgm=RussellDS; CR=30801; Group=BYPASS")
 ...			D addLine(.source,space_"   #BYPASS")
 ...			D addLine(.source,space_"   merge ^DBAUDITLOG(+$H,$J,vauditLogSeq,RECSEQ,""*"")="_gblRef_")")
 ...			D addLine(.source,space_"   #ENDBYPASS")
 ...			;
 ...			I (space=" ") D addLine(.source,"   }")
 ...			Q 
 ..		;
 ..		D addLine(.source,"  }")
 ..		Q 
 .	Q 
 ;
 Q 
 ;
getAuditUCLSChk(this,userclasses,isPositiveList) ; List is positive or negative
 ;
 N uclsCheck
 ;
 I ($S((userclasses=""):0,1:$L(userclasses,","))=0) S uclsCheck="" ; No check necessary, do them all
 E  I ($S((userclasses=""):0,1:$L(userclasses,","))=1) S uclsCheck="(%UserClass = "_$S(userclasses'["""":""""_userclasses_"""",1:$$QADD^%ZS(userclasses,""""))_")"
 E  S uclsCheck="({List}"_$S(userclasses'["""":""""_userclasses_"""",1:$$QADD^%ZS(userclasses,""""))_").contains(%UserClass)"
 ;
 I 'isPositiveList,'(uclsCheck="") S uclsCheck="'"_uclsCheck
 ;
 Q uclsCheck
 ;
 ; ---------------------------------------------------------------------
addRightsOKCode(this,source,operationLC,publicRight,withRts,restrictByUcls) ; restrict clauses by userclass
 ;
 N isSelectOptm S isSelectOptm=(operationLC="selectOptm") ; Optimized select
 N i
 N seq S seq=0
 N code N comment N optmApl
 N objRef S objRef="this"
 N optmFpl S optmFpl=""
 N ucls S ucls=""
 N restrictCode
 ;
 D addLine(.source,"")
 ;
 I isSelectOptm D
 .	;
 .	S objRef="Record"_$P(this,$C(9),2)
 .	;
 .	S optmApl=$P(this,$C(9),3) ; Actual parameters
 .	S optmFpl="String userclass, " ; Formal parameters
 .	S optmFpl=optmFpl_objRef_" "_$P(this,$C(9),3)
 .	F i=1:1:$S(($P(this("td"),"|",3)=""):0,1:$L($P(this("td"),"|",3),",")) D
 ..		;
 ..		S optmApl=optmApl_", vkey"_i
 ..		S optmFpl=optmFpl_", String vkey"_i
 ..		Q 
 .	Q 
 ;
 I (publicRight=0) S comment="none"
 E  I (publicRight=1) S comment="allowed, no restrict clause"
 E  S comment="allowed, with restrict clause"
 S code=" Boolean v"_operationLC_"OK("
 I 'isSelectOptm D
 .	;
 .	I ($P(this,$C(9),10)="") S code=" final"_code
 .	S code="public"_code_"String userclass)"
 .	Q 
 E  S code="public static"_code_optmFpl_")"
 D addLine(.source,code_"  // PUBLIC access is "_comment)
 ;
 ; Build dispatch code for restrict(s) and info to build OKn() methods
 F  S ucls=$order(restrictByUcls(ucls)) Q:(ucls="")  I (ucls'="PUBLIC") D
 .	;
 .	S seq=seq+1
 .	S code=" if (userclass = """_ucls_""") quit "_objRef_"."_operationLC_"OK"_seq_"("
 .	I 'isSelectOptm S code=code_")"
 .	E  S code=code_optmApl_")"
 .	S restrictCode(seq)=code_$char(9)_ucls_$char(9)_restrictByUcls(ucls)
 .	Q 
 ;
 I (publicRight=0) D
 .	;
 .	; Add any userclasses with restrict clauses
 .	F i=1:1:seq D addLine(.source,$piece(restrictCode(i),$char(9),1))
 .	;
 .	; Handle any userclasses with rights, but no restrict clause
 .	I ($S((withRts=""):0,1:$L(withRts,","))>1) D addLine(.source," if {List}("""_withRts_""").contains(userclass) quit true")
 .	I ($S((withRts=""):0,1:$L(withRts,","))=1) D addLine(.source," if (userclass = """_withRts_""") quit true")
 .	;
 .	; Any remaining follow PUBLIC and don't have access
 .	D addLine(.source," quit false")
 .	Q 
 ;
 E  I (publicRight=1) D
 .	;
 .	; Add any userclasses with restrict clauses
 .	F i=1:1:seq D addLine(.source,$piece(restrictCode(i),$char(9)))
 .	;
 .	; Any remaining follow PUBLIC and have access
 .	D addLine(.source," quit true")
 .	Q 
 ;
 E  D
 .	;
 .	; Handle any userclasses with rights, but no restrict clause
 .	I ($S((withRts=""):0,1:$L(withRts,","))>1) D addLine(.source," if {List}("""_withRts_""").contains(userclass) quit true")
 .	I ($S((withRts=""):0,1:$L(withRts,","))=1) D addLine(.source," if (userclass = """_withRts_""") quit true")
 .	;
 .	; Add remaining PUBLIC restrict clause
 .	S seq=seq+1
 .	S code=" quit "_objRef_"."_operationLC_"OK"_seq_"("
 .	I 'isSelectOptm S code=code_")"
 .	E  S code=code_optmApl_")"
 .	S restrictCode(seq)=code_$char(9)_"PUBLIC"_$char(9)_restrictByUcls("PUBLIC")
 .	;
 .	; Add any userclasses with restrict clauses
 .	F i=1:1:seq D addLine(.source,$piece(restrictCode(i),$char(9)))
 .	Q 
 ;
 F i=1:1:seq D
 .	;
 .	N otherTables S otherTables=0
 .	N n N seq
 .	N input N pslobj N pslqry N tableRef N tables
 .	N from S from=$P(this,$C(9),2)
 .	N pad S pad=" "
 .	N where S where=$piece(restrictCode(i),$char(9),3)
 .	;
 .	D addLine(.source,"")
 .	;
 .	S code="Boolean "_operationLC_"OK"_i_"("
 .	I 'isSelectOptm S code="private "_code_optmFpl_")"
 .	E  S code="private static "_code_$piece(optmFpl,",",2,1048575)_")" ; Strip userclass
 .	D addLine(.source,code)
 .	;
 .	D addLine(.source," // Userclass = "_$piece(restrictCode(i),$char(9),2))
 .	D addLine(.source," // restrict = "_where)
 .	;
 .	I ($E(where,1,6)="[FROM ") D
 ..		;
 ..		S from=$piece($piece(where,"[FROM ",2),"]",1)
 ..		S where=$$vStrTrim($piece(where,"]",2,1048575),0," ")
 ..		Q 
 .	;
 .	I (where[":") D
 ..		;
 ..		N cnt N ptr
 ..		N atom N newwhere N tok
 ..		;
 ..		;    #ACCEPT Date=06/10/2008; Pgm=RussellDS; CR=30801; Group=ACCESS
 ..		S where=$$TOKEN^%ZS(where,.tok)
 ..		S newwhere=where
 ..		;
 ..		S (cnt,ptr)=0
 ..		;    #ACCEPT Date=06/10/2008; Pgm=RussellDS; CR=30801; Group=ACCESS
 ..		F  S atom=$$ATOM^%ZS(where,.ptr,"*/+-|,()<=>",1) D  Q:(ptr=0) 
 ...			;
 ...			I ($E(atom,1)=":") D
 ....				;
 ....				S cnt=cnt+1
 ....				D addLine(.source," type String VAR"_cnt_" = "_$E(atom,2,1048575))
 ....				S newwhere=$$vStrRep(newwhere,atom,":VAR"_cnt,0,0,"")
 ....				Q 
 ...			Q 
 ..		;
 ..		;    #ACCEPT Date=06/10/2008; Pgm=RussellDS; CR=30801; Group=ACCESS
 ..		S where=$$UNTOK^%ZS(newwhere,tok)
 ..		Q 
 .	;
 .	S input("WHERE")=where
 .	S input("FROM")=from
 .	;
 .	I (operationLC="update") S tableRef="this.oldVal"
 .	E  I 'isSelectOptm S tableRef="this"
 .	E  S tableRef=$P(this,$C(9),3)
 .	;
 .	D ^UCQRYBLD(.input,$P(this,$C(9),2)_"="_tableRef,.tables,.pslobj,.pslqry)
 .	;
 .	I ($D(pslobj)>0) D
 ..		;
 ..		S otherTables=1
 ..		S pad="  "
 ..		D addLine(.source," type Boolean accessOK = true")
 ..		D addLine(.source," do {")
 ..		D addLine(.source,"  catch "_operationLC_i_"OKerr {")
 ..		D addLine(.source,"   set accessOK = false")
 ..		D addLine(.source,"  }")
 ..		;
 ..		; Insert object instantiation code for any other tables referenced.
 ..		S (n,seq)=""
 ..		F  S n=$order(pslobj(n)) Q:(n="")  D
 ...			F  S seq=$order(pslobj(n,seq)) Q:(seq="")  D addLine(.source,pad_pslobj(n,seq))
 ...			Q 
 ..		Q 
 .	;
 .	; Insert query logic
 .	S seq=""
 .	F  S seq=$order(pslqry(seq)) Q:(seq="")  D
 ..		;
 ..		D addLine(.source,pad_"if "_pslqry(seq))
 ..		I 'otherTables D addLine(.source,pad_"else  quit false")
 ..		I otherTables D addLine(.source,pad_"else  set accessOK = false quit")
 ..		Q 
 .	;
 .	I otherTables D
 ..		;
 ..		D addLine(.source," }")
 ..		D addLine(.source," quit accessOK")
 ..		Q 
 .	E  D addLine(.source," quit true")
 .	Q 
 ;
 I 'isSelectOptm,operationLC="select",($D(restrictByUcls)>-1) D addRightsOKCode(.this,.source,"selectOptm",publicRight,withRts,.restrictByUcls)
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
addSelectRestrict(this,source,userclass,restrict) ; Restrict clause
 ;
 N code S code=""
 N from S from=""
 ;
 I ($E(restrict,1,6)="[FROM ") D
 .	;
 .	S from=$piece($piece(restrict,"[FROM ",2),"]",1)
 .	S restrict=$$vStrTrim($piece(restrict,"]",2,1048575),0," ")
 .	Q 
 ;
 I (userclass'="PUBLIC") S code=" if (userclass = """_userclass_""")"
 ;
 D addLine(.source,code_" set restrict = """_restrict_""", from = """_from_"""")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildchkRequired(this,source) ; Build code into source
 ;
 N keys S keys=$P(this("td"),"|",3)
 N required S required=$P(this("td"),"|",30)
 N i N nodcnt
 N rectype S rectype=$P(this("td"),"|",4)
 N column N columnLC N nod N pos N sort N spaces
 ;
 K source
 ;
 D addLine(.source,"")
 ;
 ; Build insert section first
 D addLine(.source,"private void vRCchkReqForInsert()")
 ;
 F i=1:1:$S((required=""):0,1:$L(required,",")) D
 .	;
 .	S column=$piece(required,",",i)
 .	S columnLC=$ZCONVERT(column,"L")
 .	;
 .	Q:$$isLit^UCGM(column)  ; Legacy literal keys
 .	;
 .	N cd S cd=$$getSchCln^UCXDD($P(this,$C(9),2),column)
 .	Q:'($P(cd,"|",14)="")  ; Computeds aren't required
 .	;
 .	D addLine(.source," if this."_$$colName(columnLC,"LC",1)_".isNull() do this.vRCrequiredErr("_$$QADD^%ZS($$colName(column,"UC",0),"""")_")")
 .	;
 .	; For multi-node global, build array sorted by node for use by update section
 .	I (rectype>1) D
 ..		;
 ..		S nod=$$getOldNode^UCXDD(cd,1)
 ..		;
 ..		S pos=+$P(cd,"|",4)
 ..		I '($P(cd,"|",10)="") S pos=pos_"~"_$P(cd,"|",10)
 ..		S sort(nod,pos)=columnLC
 ..		S nodcnt(nod)=$get(nodcnt(nod))+1
 ..		Q 
 .	Q 
 ;
 D addLine(.source," quit")
 D addLine(.source,"")
 ;
 ; Build update section
 D addLine(.source,"private void vRCchkReqForUpdate()")
 ;
 D addLine(.source," type public String vobj(,,,)")
 ;
 F i=1:1:$S((keys=""):0,1:$L(keys,",")) D
 .	;
 .	S column=$piece(keys,",",i)
 .	D addLine(.source," if this."_$$colName(column,"LC",1)_".isNull() do this.vRCrequiredErr("_$$QADD^%ZS($$colName(column,"UC",0),"""")_")")
 .	Q 
 ;
 S (nod,pos)=""
 F  S nod=$order(sort(nod)) Q:(nod="")  D
 .	;
 .	I (nodcnt(nod)>1) D
 ..		;
 ..		D addLine(.source," if (vobj(this,-100,"_nod_").data() > 9) do {")
 ..		S spaces="  "
 ..		Q 
 .	E  D
 ..		;
 ..		D addLine(.source," // Node "_nod_" - only one required column")
 ..		S spaces=" "
 ..		Q 
 .	;
 .	F  S pos=$order(sort(nod,pos)) Q:(pos="")  D
 ..		;
 ..		S column=sort(nod,pos)
 ..		D addLine(.source,spaces_"if this.isChanged("_$$QADD^%ZS($$colName(column,"UC",0),"""")_"), this."_$$colName(column,"LC",1)_".isNull() do this.vRCrequiredErr("_$$QADD^%ZS($$colName(column,"UC",0),"""")_")")
 ..		Q 
 .	;
 .	I (nodcnt(nod)>1) D addLine(.source," }")
 .	Q 
 ;
 I ($P(this("td"),"|",4)=1) F i=1:1:$S((required=""):0,1:$L(required,",")) D
 .	;
 .	S column=$piece(required,",",i)
 .	;
 .	I '((","_keys_",")[(","_column_",")) D addLine(.source," if this.isChanged("_$$QADD^%ZS($$colName(column,"UC",0),"""")_"), this."_$$colName(column,"LC",1)_".isNull() do this.vRCrequiredErr("_$$QADD^%ZS($$colName(column,"UC",0),"""")_")")
 .	Q 
 ;
 D addLine(.source," quit")
 D addLine(.source,"")
 ;
 ; This method will call throwError to set up verrors() array
 D addLine(.source,"private static void vRCrequiredErr(String column)")
 ;
 D addLine(.source," type Boolean ER = false")
 D addLine(.source," type String RM = """"")
 ;
 D addLine(.source," do Runtime.setErrMSG("""_$P(this,$C(9),2)_""", 1767, """_$P(this,$C(9),2)_".""_ column)")
 D addLine(.source," if ER do Record"_$P(this,$C(9),2)_".throwError(RM.get())")
 ;
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildcolumnLists(this,source) ; Build code into source
 ;
 N isAuditLog S isAuditLog='($P(this,$C(9),8)="")
 N columns S columns=""
 N columnsBM S columnsBM=""
 N columnsCMP S columnsCMP=""
 N CMP N DI N map N SFD N sorted N TYP
 ;
 K source
 ;
 N rs,vos1,vos2,vos3,vos4,vos5  N V1 S V1=$P(this,$C(9),2) S rs=$$vOpen7()
 ;
 F  Q:'$$vFetch7()  I '$$isLit^UCGM($P(rs,$C(9),1)) S sorted($P(rs,$C(9),1))=$P(rs,$C(9),2)_"|"_$P(rs,$C(9),3)_"|"_$P(rs,$C(9),4)
 ;
 S DI=""
 F  S DI=$order(sorted(DI)) Q:(DI="")  D
 .	;
 .	S TYP=$piece(sorted(DI),"|",1)
 .	S SFD=$piece(sorted(DI),"|",2)
 .	S CMP=$translate($piece(sorted(DI),"|",3)," ","") ; Blobs and Memos have CMP = " "
 .	;
 .	I '(CMP="") S columnsCMP=columnsCMP_DI_","
 .	E  I (",B,M,"[(","_TYP_",")) S columnsBM=columnsBM_DI_","
 .	E  S columns=columns_DI_","
 .	;
 .	I isAuditLog,(CMP="") D
 ..		;
 ..		N cd S cd=$$getPslCln^UCXDD($P(this,$C(9),2),DI)
 ..		N nod S nod=$$getCurNode^UCXDD(cd,0)
 ..		;
 ..		; Skip masterfields (sub-fields will handle the data)
 ..		I ($P(cd,"|",15)=0) D
 ...			;
 ...			N colInfo S colInfo=$P(cd,"|",2)_":"_$P(cd,"|",6)_":"_$P(cd,"|",4)
 ...			;
 ...			I '(SFD="") S colInfo=colInfo_":"_SFD
 ...			;
 ...			I (nod<0) S map(nod)=colInfo
 ...			E  I (nod="") S map(-1)=$get(map(-1))_colInfo_";"
 ...			E  S map(nod)=$get(map(nod))_colInfo_";"
 ...			Q 
 ..		Q 
 .	Q 
 ;
 S columns=$E(columns,1,$L(columns)-1)
 S columnsBM=$E(columnsBM,1,$L(columnsBM)-1)
 S columnsCMP=$E(columnsCMP,1,$L(columnsCMP)-1)
 ;
 D addLine(.source,"")
 D addLine(.source,"public static List columnList()")
 ;
 I ($L(columns,",")'>20) D
 .	;
 .	D addLine(.source," quit {List}("""_columns_""".replace("","", 9.char()))")
 .	Q 
 E  D
 .	;
 .	D addLine(.source," type String columns = """"")
 .	;
 .	F  Q:'('(columns=""))  D
 ..		;
 ..		D addLine(.source," set columns = columns_ """_$piece(columns,",",1,20)_",""")
 ..		S columns=$piece(columns,",",21,$L(columns,","))
 ..		Q 
 .	;
 .	D addLine(.source," quit {List}(columns.extract(1, columns.length() - 1).replace("","", 9.char()))")
 .	Q 
 ;
 D addLine(.source,"")
 D addLine(.source,"public static List columnListBM()")
 ;
 I (columnsBM="") D
 .	;
 .	D addLine(.source," quit {List}""""")
 .	Q 
 E  D addLine(.source," quit {List}("""_columnsBM_""".replace("","", 9.char()))")
 ;
 D addLine(.source,"")
 D addLine(.source,"public static List columnListCMP()")
 ;
 I ($L(columnsCMP,",")'>20) D
 .	;
 .	D addLine(.source," quit {List}("""_columnsCMP_""".replace("","", 9.char()))")
 .	Q 
 E  D
 .	;
 .	D addLine(.source," type String columns = """"")
 .	;
 .	F  Q:'('(columnsCMP=""))  D
 ..		;
 ..		D addLine(.source," set columns = columns_ """_$piece(columnsCMP,",",1,20)_",""")
 ..		S columnsCMP=$piece(columnsCMP,",",21,$L(columnsCMP,","))
 ..		Q 
 .	;
 .	D addLine(.source," quit {List}(columns.extract(1, columns.length() - 1).replace("","", 9.char()))")
 .	Q 
 ;
 ; Build getColumnMap()
 I isAuditLog D
 .	;
 .	N i
 .	N n
 .	;
 .	D addLine(.source,"")
 .	D addLine(.source,"private static void getColumnMap(String map())")
 .	D addLine(.source,"")
 .	;
 .	S n=""
 .	F  S n=$order(map(n)) Q:(n="")  D
 ..		;
 ..		N node S node=n
 ..		;
 ..		I '(node=+node) S node=$S(node'["""":""""_node_"""",1:$$QADD^%ZS(node,""""))
 ..		;
 ..		S map(n)=$E(map(n),1,$L(map(n))-1)
 ..		;
 ..		D addLine(.source," set map("_node_") = "_$$QADD^%ZS($E(map(n),1,200),""""))
 ..		F i=(200+1):200 Q:($E(map(n),i,i+(200-1))="")  D addLine(.source," set map("_node_") = map("_node_")_ "_$$QADD^%ZS($E(map(n),i,i+(200-1)),""""))
 ..		Q 
 .	;
 .	D addLine(.source," quit")
 .	Q 
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
builddelete(this,source) ; Build code into source
 ;
 N keys S keys=$P(this("td"),"|",3)
 ;
 K source
 ;
 D addLine(.source,"")
 D addLine(.source,"private void vRCdelete(List vRCparams, String vRCaudit(), Boolean isKeyChange)")
 ;
 I ($P(this("td"),"|",8)'="GTM") D
 .	;
 .	N code S code=" type String keyVals"
 .	;
 .	I '(keys="") D
 ..		;
 ..		N i
 ..		;
 ..		F i=1:1:$S((keys=""):0,1:$L(keys,",")) S code=code_", vkey"_i
 ..		Q 
 .	;
 .	D addLine(.source,code_", retVal")
 .	Q 
 ;
 I ($P(this("td"),"|",4)>1) D addLine(.source," if 'isKeyChange.get(), this.isChanged() do this.throwError(""Deleted object cannot be modified"")")
 ;
 I ((","_this("sections")_",")[",cascadeDelete,") D addLine(.source," if vRCparams.contains(""CASDEL"", ""/"") do this.vRCcascadeDelete(vRCparams)")
 I ((","_this("sections")_",")[",indexes,") D addLine(.source," if vRCparams.contains(""INDEX"", ""/"") do this.updateIndexes(3, vRCaudit())")
 I ((","_this("sections")_",")[",journals,") D addLine(.source," if vRCparams.contains(""JOURNAL"", ""/"") do this.vRCjournals(3, vRCaudit())")
 ;
 I $P(this("td"),"|",16) D addLine(.source," if 'vRCparams.contains(""NOLOG"", ""/"") do ^DBSLOGIT(this, 3)")
 ;
 I '($P(this("td"),"|",8)'="GTM") D
 .	;
 .	N code S code=" kill "
 .	N globalRef S globalRef=$$getGbl^UCXDD(this("td"),"this")
 .	;
 .	I ($P(this("td"),"|",4)<10),'$P(this,$C(9),9) S code=" ZWI "
 .	;
 .	D addLine(.source," #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS")
 .	D addLine(.source," #BYPASS")
 .	;
 .	; Cannot depend on key count (see table CMSOPT, for example)
 .	I ($E(globalRef,$L(globalRef))=",") S globalRef=$E(globalRef,1,$L(globalRef)-1)_")"
 .	E  S globalRef=$E(globalRef,1,$L(globalRef)-1)
 .	;
 .	D addLine(.source,code_globalRef)
 .	;
 .	D addLine(.source," #ENDBYPASS")
 .	Q 
 ; RDB
 E  D
 .	;
 .	N i
 .	N sql
 .	;
 .	I (keys="") D
 ..		;
 ..		D addLine(.source," set keyVals = """"")
 ..		Q 
 .	E  D
 ..		;
 ..		N code S code=""
 ..		;
 ..		F i=1:1:$S((keys=""):0,1:$L(keys,",")) D
 ...			;
 ...			N isNum S isNum=0
 ...			N key S key=$piece(keys,",",i)
 ...			N keyLC S keyLC=$ZCONVERT(key,"L")
 ...			;
 ...			N cd S cd=$$getSchCln^UCXDD($P(this,$C(9),2),key)
 ...			;
 ...			I (",N,$,L,"[(","_$P(cd,"|",6)_",")) S isNum=1
 ...			;
 ...			I '(code="") S code=code_"_ "_$P(this,$C(9),4)_"_ "
 ...			S code=code_"this."_keyLC
 ...			D addLine(.source," set vkey"_i_" = this."_$$colName(keyLC,"LC",1))
 ...			Q 
 ..		;
 ..		D addLine(.source," set keyVals = "_code_"_ "_$P(this,$C(9),4))
 ..		Q 
 .	;
 .	I (keys="") S sql(1)="DELETE FROM "_$P(this,$C(9),2)
 .	E  D
 ..		;
 ..		N nattable S nattable=""
 ..		N whereKeyNat
 ..		;
 ..		S whereKeyNat=$$getWhereKey(.this,"",1,.nattable)
 ..		;
 ..		; Handle wide tables (one table split into multiple)
 ..		F i=1:1:$S((nattable=""):0,1:$L(nattable,",")) S sql(i)="DELETE FROM "_$piece(nattable,",",i)_" WHERE "_whereKeyNat
 ..		Q 
 .	;
 .	; If we get error on delete, catch and re-throw as DBFILER error
 .	D addLine(.source," catch delError {")
 .	D addLine(.source,"  do this.throwError(delError.description)")
 .	D addLine(.source," }")
 .	;
 .	F i=1:1 Q:'($D(sql(i))#2)  D addLine(.source," set retVal = $$EXECUTESQL^%DBAPI("""","_$S(sql(i)'["""":""""_sql(i)_"""",1:$$QADD^%ZS(sql(i),""""))_","_$P(this,$C(9),4)_", keyVals)")
 .	Q 
 ;
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
builderror(this,source) ; Build code into source
 ;
 K source
 ;
 D addLine(.source,"")
 D addLine(.source,"private static void throwError(String MSG)")
 ;
 D addLine(.source," throw Class.new(""Error"", ""%PSL-E-DBFILER,""_ MSG.replace("","",""~""))")
 ;
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildforceLoad(this,source) ; Build code into source
 ;
 K source
 ;
 D addLine(.source,"")
 D addLine(.source,"private void vRCforceLoad()")
 ;
 I '($P(this("td"),"|",8)'="GTM") D
 .	;
 .	N hasNegNodes S hasNegNodes=($P(this("td"),"|",15)["""v")
 .	N code N globalRef
 .	;
 .	S globalRef=$$getGbl^UCXDD(this("td"),"this")_"n)"
 .	;
 .	D addLine(.source," type String n = """"")
 .	I hasNegNodes D addLine(.source," type String vn")
 .	D addLine(.source," #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS")
 .	D addLine(.source," #BYPASS")
 .	;
 .	S code=" for  set n=$order("_globalRef_") quit:n=""""  "
 .	I hasNegNodes S code=code_"s vn=$S(n<0:""v""_-n,1:n) if '$D(vobj(this,vn)),$D("_globalRef_")#2 set vobj(this,vn)=^(n)"
 .	E  S code=code_"if '$D(vobj(this,n)),$D("_globalRef_")#2 set vobj(this,n)=^(n)"
 .	D addLine(.source,code)
 .	;
 .	D addLine(.source," #ENDBYPASS")
 .	D addLine(.source," quit")
 .	Q 
 ;
 E  D
 .	;
 .	D addLine(.source," type String X")
 .	;
 .	N rs,vos1,vos2,vos3,vos4,vos5,vos6,vos7,vos8,vOid  N V1 S V1=$P(this,$C(9),2) S rs=$$vOpen8()
 .	F  Q:'$$vFetch8()  D
 ..		;
 ..  N rtbl S rtbl=rs
 ..		;
 ..		N rs2,vos9,vos10,vos11,vos12,vos13,vos14,vos15  N V2,V3 S V2=$P(this,$C(9),2),V3=rtbl S rs2=$$vOpen9()
 ..		;
 ..  I $$vFetch9() D addLine(.source," set X = this."_rs2)
 ..  Q 
 .	;
 .	D addLine(.source," quit")
 . Q 
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildforeignKeys(this,source) ; Build code into source
 ;
 N requiredList
 N fkey N fkeys N table
 ;
 K source
 ;
 ; load all the foreign key definitions for this table and it's ancestors into the fkeys() array
 S table=$P(this,$C(9),2)
 F  Q:'('(table=""))  D
 .	;
 .	N rs,vos1,vos2,vos3,vos4,vos5,vos6  N V1 S V1=table S rs=$$vOpen10()
 . F  Q:'$$vFetch10()  S fkeys($P(rs,$C(9),1))=$P(rs,$C(9),2)
 .	;
 .	I $P(this,$C(9),2)=table S table=$P(this("td"),"|",7)
 .	E  D
 ..		;
 ..		N td2 S td2=$$getPslTbl^UCXDD(table,0)
 ..		S table=$P(td2,"|",7)
 ..		Q 
 . Q 
 ;
 D addLine(.source,"")
 ;
 ; Build set foreign key logic used by SQLBUF first
 D addLine(.source,"private void vRCsetForeignKeys()")
 ;
 D addLine(.source," type public String vfkey()")
 ;
 S fkey=""
 F  S fkey=$order(fkeys(fkey)) Q:(fkey="")  D
 .	;
 .	N fknum N i
 .	N code N fktable N globalKeys N lastKey N newKeys N tok
 .	;
 .	S fktable=fkeys(fkey)
 .	;
 .	N tdfk S tdfk=$$getPslTbl^UCXDD(fktable,0)
 .	;
 .	S globalKeys=$piece($P(tdfk,"|",2),"(",2,99)
 .	;
 .	; Add node checking logic
 .	I '($P(tdfk,"|",12)="") S globalKeys=globalKeys_","_$P(tdfk,"|",12)
 .	;
 .	; Tokenize to prevent problems with quoted strings containing commas
 .	;   #ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
 .	S globalKeys=$$TOKEN^%ZS(globalKeys,.tok)
 .	S newKeys=""
 .	S fknum=1
 .	F i=1:1:$L(globalKeys,",") D  ; Map each key
 ..		;
 ..		N key S key=$piece(globalKeys,",",i)
 ..		;
 ..		; Deal with literals
 ..		I (key=+key) ; Leave numbers alone
 ..		;    #ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
 ..		E  I ($E(key,1,$L($char(0)))=$char(0)) S key=$$QADD^%ZS($$UNTOK^%ZS(key,tok),"""")
 ..		; Deal with foreign keys - replace with this.column reference
 ..		E  D
 ...			;
 ...			S key=$piece(fkey,",",fknum)
 ...			S fknum=fknum+1
 ...			S lastKey=key
 ...			S key="""""""""_"_"this."_$$colName(key,"LC",1)_"_"""""""""
 ...			Q 
 ..		S newKeys=newKeys_key_"_"",""_"
 ..		Q 
 .	;
 .	S newKeys=$E(newKeys,1,$L(newKeys)-5)
 .	;
 .	S code=" if 'this."_$$colName(lastKey,"LC",1)_".isNull()"
 .	S code=code_" set vfkey("""_$piece($P(tdfk,"|",2),"(",1)_"(""_"_newKeys_"_"")"")="
 .	S code=code_""""_$P(this,$C(9),2)_"("_fkey_") -> "_fktable_""""
 .	;
 .	D addLine(.source,code)
 .	Q 
 ;
 D addLine(.source," quit")
 D addLine(.source,"")
 ;
 ; Build check foreign key logic used when not under SQL buffer
 D addLine(.source,"private void vRCcheckForeignKeys()")
 ;
 S requiredList=$P(this("td"),"|",30)
 ;
 S fkey=""
 F  S fkey=$order(fkeys(fkey)) Q:(fkey="")  D
 .	;
 .	N fktableKeys
 .	N i
 .	N code N fktable N newKeys N noreqKeys
 .	;
 .	S fktable=fkeys(fkey)
 .	;
 .	N fktbl S fktbl=$$getPslTbl^UCXDD(fktable,0)
 .	;
 .	S fktableKeys=$P(fktbl,"|",3)
 .	;
 .	S (newKeys,noreqKeys)=""
 .	F i=1:1:$L(fkey,",") D
 ..		;
 ..		N key S key=$piece(fkey,",",i)
 ..		;
 ..		S newKeys=newKeys_$piece(fktableKeys,",",i)_"=:this."_$$colName(key,"LC",1)_","
 ..		;
 ..		I '((","_requiredList_",")[(","_key_",")) S noreqKeys=noreqKeys_"'this."_$$colName(key,"LC",1)_".isNull(),"
 ..		Q 
 .	;
 .	S code=" if 'Db.isDefined("""_fktable_""","_$$QADD^%ZS($E(newKeys,1,$L(newKeys)-1),"""")_")"
 .	; Referential integrity error ~p1
 .	S code=code_" do Record"_$P(this,$C(9),2)_".throwError($$^MSG(8563,"""_$P(this,$C(9),2)_"("_fkey_") -> "_fktable_"""))"
 .	I '(noreqKeys="") S code=" if "_$E(noreqKeys,1,$L(noreqKeys)-1)_code
 .	;
 .	D addLine(.source,code)
 .	Q 
 ;
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildgetArchiveFile(this,source,tdarch,keyNames,keyTypes,keyValues,formalParams,comment,isNotArchived) ; Build "shell" method
 ;
 N isOneTable S isOneTable=0
 N archincl S archincl=$$getArchiveIncluded^DBARCHIVE(tdarch)
 N archsubs S archsubs=$$getArchiveSubs^DBARCHIVE(tdarch)
 N i
 N keycnt S keycnt=$S((keyTypes=""):0,1:$L(keyTypes,","))
 N archiveTable S archiveTable=$P(tdarch,"|",1)
 N code N indexTable N throwcode
 ;
 I (archsubs=""),(archincl="") S isOneTable=1
 ;
 D addLine(.source,"")
 S code="public static String getArchiveFile(String archiveTable, Number option, "
 I (keycnt>1) S code=code_formalParams_", "
 D addLine(.source,code_$piece(keyTypes,",",keycnt)_" archiveKey)")
 ;
 I isNotArchived D addLine(.source," quit """" // Shell method") Q 
 ;
 D addLine(.source," // "_comment)
 ;
 D addLine(.source," type Number archiveNum")
 ;
 S code=" type String "
 I 'isOneTable S code=code_"indexTable, "
 S code=code_"archiveFile, keyValues"
 D addLine(.source,code)
 ;
 ; ~p1 is not an archived table
 S throwcode="throw Class.new(""Error"", ""%DQ-E-DBFILER,""_ $$^MSG(6901, archiveTable).replace("","",""~""))"
 ;
 ; Just the primary
 I isOneTable D
 .	;
 .	S indexTable=$S(archiveTable'["""":""""_archiveTable_"""",1:$$QADD^%ZS(archiveTable,""""))
 .	;
 .	S code=" if (archiveTable '= "_indexTable_") "_throwcode
 .	D addLine(.source,code)
 .	Q 
 ;
 E  D
 .	;
 .	S indexTable="indexTable"
 .	;
 .	D addLine(.source," // Primary table")
 .	D addLine(.source," if (archiveTable = """_archiveTable_""") set indexTable = """_archiveTable_"""")
 .	;
 .	I '(archsubs="") D
 ..		;
 ..		D addLine(.source," // Sub-table of primary")
 ..		I ($S((archsubs=""):0,1:$L(archsubs,","))=1) S code=" else  if """_archsubs_""" = archiveTable set indexTable = """_archiveTable_""""
 ..		E  S code=" else  if ({List}"""_archsubs_""").contains(archiveTable) set indexTable = """_archiveTable_""""
 ..		D addLine(.source,code)
 ..		Q 
 .	I '(archincl="") D
 ..		;
 ..		N addCmt S addCmt=1
 ..		N i
 ..		;
 ..		D addLine(.source," // Included With (related) table")
 ..		I ($S((archincl=""):0,1:$L(archincl,","))=1) S code=" else  if """_archincl_""" = archiveTable set indexTable = archiveTable"
 ..		E  S code=" else  if ({List}"""_archincl_""").contains(archiveTable) set indexTable = archiveTable"
 ..		D addLine(.source,code)
 ..		;
 ..		F i=1:1:$S((archincl=""):0,1:$L(archincl,",")) D
 ...			;
 ...			N inclsubs
 ...			N incltbl
 ...			;
 ...			S incltbl=$piece(archincl,",",i)
 ...			;
 ...			N tdincl S tdincl=$$getPslTbl^UCXDD(incltbl,1)
 ...			;
 ...			S inclsubs=$$getArchiveSubs^DBARCHIVE(tdincl)
 ...			;
 ...			I '(inclsubs="") D
 ....				;
 ....				I addCmt D addLine(.source," // Sub-tables of related tables")
 ....				S addCmt=0
 ....				I ($S((inclsubs=""):0,1:$L(inclsubs,","))=1) S code=" else  if """_inclsubs_""" = archiveTable set indexTable = """_incltbl_""""
 ....				E  S code=" else  if {List}"""_inclsubs_""".contains(archiveTable) set indexTable = """_incltbl_""""
 ....				D addLine(.source,code)
 ....				Q 
 ...			Q 
 ..		Q 
 .	;
 .	D addLine(.source," else  throw Class.new(""Error"", ""%DQ-E-DBFILER,""_ $$^MSG(6901, archiveTable).replace("","",""~""))")
 .	Q 
 ;
 D addLine(.source," set keyValues = "_keyValues)
 ;
 D addLine(.source," // Find archive this record would be in")
 D addLine(.source," if (option = 0) do { quit archiveFile")
 D addLine(.source,"  type Number n")
 ;
 D addLine(.source," #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
 D addLine(.source," #BYPASS")
 D addLine(.source," set n=$O(^DBARCHX("_indexTable_",keyValues,archiveKey-1E-10))")
 D addLine(.source," if n="""" set archiveFile=""""")
 D addLine(.source," else  do")
 D addLine(.source," .  set archiveNum=^DBARCHX("_indexTable_",keyValues,n)")
 D addLine(.source," .  set archiveFile=$ZTRNLNM(""SCAU_ARCHIVE_""_archiveNum)")
 D addLine(.source," #ENDBYPASS")
 D addLine(.source," }")
 ;
 D addLine(.source," // Find next/previous archive")
 D addLine(.source," #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
 D addLine(.source," #BYPASS")
 D addLine(.source," if (option=1),(archiveKey'=""""),'$D(^DBARCHX("_indexTable_",keyValues,archiveKey)) set archiveKey=$O(^DBARCHX("_indexTable_",keyValues,archiveKey))")
 D addLine(.source," set archiveKey=$O(^DBARCHX("_indexTable_",keyValues,archiveKey),option)")
 D addLine(.source," if archiveKey="""" set archiveFile=""""")
 D addLine(.source," else  do")
 D addLine(.source," .  set archiveNum=^DBARCHX("_indexTable_",keyValues,archiveKey)")
 D addLine(.source," .  set archiveFile=$ZTRNLNM(""SCAU_ARCHIVE_""_archiveNum)")
 D addLine(.source," #ENDBYPASS")
 D addLine(.source,"")
 D addLine(.source," quit archiveFile")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildgetRecord(this,source) ; polymorphism dispatch
 N vC S vC=$P($G(this),$C(9))
 I $D(vPslPoly(vC,"buildgetRecord")) D v0buildgetRecord^@vPslPoly(vC,"buildgetRecord")(.this,.source) Q
 D v0buildgetRecord(.this,.source) Q
v0buildgetRecord(this,source) ; Build code into source
 ;
 N i
 N code S code=$$getRecSrCode^UCDB(this("td"),"vOid")
 ;
 K source
 ;
 F i=1:1:$L(code,$char(9)) D addLine(.source,$piece(code,$char(9),i))
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildhasLiterals(this,source) ; Build code into source
 ;
 N code S code="public static Boolean vhasLiterals() quit "
 ;
 K source
 ;
 D addLine(.source,"")
 ;
 I ((","_this("sections")_",")[",literals,") S code=code_"true"
 E  S code=code_"false"
 ;
 D addLine(.source,code)
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildindexes(this,source,tknzr) ; Tokenizer object
 ;
 N i N j
 N code N indexes
 ;
 K source
 ;
 ; Add indexes to tknzr source and build indexes() info.
 N rs,vos1,vos2,vos3,vos4,vos5  N V1 S V1=$P(this,$C(9),2) S rs=$$vOpen11()
 ;
 F  Q:'$$vFetch11()  D getIndexCode(.this,.indexes,$P(rs,$C(9),1),$P(rs,$C(9),2),$P(rs,$C(9),3),$P(rs,$C(9),4),$P(rs,$C(9),5),.tknzr)
 ;
 D addLine(.source,"")
 ;
 D addLine(.source,"public static void rebuildIndexesAllRecs(List indexList)")
 ;
 D addLine(.source," type String audit()")
 ;
 D addLine(.source," if indexList.isNull() set indexList = ""*""") ; Build all
 ;
 D addLine(.source," type DbSet ds=Db.selectDbSet("""_$P(this,$C(9),2)_""")")
 ;
 D addLine(.source," while ds.next() do {")
 D addLine(.source,"  type Record"_$P(this,$C(9),2)_" "_$P(this,$C(9),3)_" = ds.getRecord("""_$P(this,$C(9),2)_""")")
 ;
 D addLine(.source,"  if indexList.contains(""*"") do "_$P(this,$C(9),3)_".updateIndexes(0, audit()) quit")
 ;
 F i=1:1:$P(this,$C(9),6)-1 D addLine(.source,"  if indexList.contains("""_$piece(indexes(i),"|",1)_""") do "_$P(this,$C(9),3)_".vRCIdx"_i_"(0)")
 ;
 D addLine(.source," }")
 D addLine(.source," quit")
 ;
 D addLine(.source,"")
 ;
 I ($P(this,$C(9),10)="") S code="final "
 E  S code=""
 ;
 D addLine(.source,"public "_code_"void rebuildIndexes(List indexList)")
 ;
 D addLine(.source," type String audit()")
 ;
 D addLine(.source," if indexList.contains(""*"") do this.updateIndexes(0, audit()) quit")
 ;
 F i=1:1:$P(this,$C(9),6)-1 D addLine(.source,"  if indexList.contains("""_$piece(indexes(i),"|",1)_""") do this.vRCIdx"_i_"(0)")
 ;
 D addLine(.source," quit")
 ;
 D addLine(.source,"")
 D addLine(.source,"private void updateIndexes(Number processMode, String audit())")
 ;
 D addLine(.source," if (processMode = 1) do {")
 ;
 I ($P(this,$C(9),6)<10) D
 .	;
 .	N column
 .	;
 .	F i=1:1:$P(this,$C(9),6)-1 D
 ..		;
 ..		N nonKeys S nonKeys=$piece(indexes(i),"|",2)
 ..		N code S code=""
 ..		;
 ..		F j=1:1:$S((nonKeys=""):0,1:$L(nonKeys,",")) D
 ...			;
 ...			S column=$piece(nonKeys,",",j)
 ...			;
 ...			I '(column="") D
 ....				;
 ....				S code=code_"this.isChanged("_$$QADD^%ZS($$colName(column,"UC",0),"""")_") or "
 ....				Q 
 ...			Q 
 ..		;
 ..		I '(code="") D
 ...			;
 ...			S code="  if "_$E(code,1,$L(code)-4)
 ...			S code=code_" do this.vRCIdx"_i_"(1)"
 ...			;
 ...			D addLine(.source,code)
 ...			Q 
 ..		Q 
 .	Q 
 E  D
 .	;
 .	N nonKeys
 .	N code S code=""
 .	N columns
 .	;
 .	D addLine(.source,"  type Number idxnum, ptr")
 .	D addLine(.source,"  type String column, map")
 .	;
 .	F i=1:1:$P(this,$C(9),6)-1 D
 ..		;
 ..		S nonKeys=$piece(indexes(i),"|",2)
 ..		S columns=""
 ..		;
 ..		; Remove nulls from nonKeys list
 ..		F j=1:1:$S((nonKeys=""):0,1:$L(nonKeys,",")) I '($piece(nonKeys,",",j)="") S columns=columns_$piece(nonKeys,",",j)_","
 ..		;
 ..		S code=code_","_columns_",~"_i_"~|"
 ..		Q 
 .	;
 .	F i=1:400:$L(code) D
 ..		;
 ..		N setmap S setmap="  set map = "
 ..		;
 ..		I (+i'=+1) S setmap=setmap_"map_ "
 ..		;
 ..		D addLine(.source,setmap_$$QADD^%ZS($E(code,i,i+399),""""))
 ..		Q 
 .	;
 .	D addLine(.source,"  set ptr = 0")
 .	D addLine(.source,"  set column = """"")
 .	D addLine(.source,"  for  set column = audit(column).order() quit:column=""""  do {")
 .	D addLine(.source,"   for  set ptr = map.find(("",""_ column_ "",""), ptr) quit:(ptr = 0)  do {")
 .	D addLine(.source,"    set idxnum = map.extract(ptr, PSL.maxStringLength).piece(""~"", 2)")
 .	D addLine(.source,"    set map.piece(""|"", idxnum) = """"")
 .	;
 .	F i=1:1:$P(this,$C(9),6)-1 D addLine(.source,"     if (idxnum = "_i_") do this.vRCIdx"_i_"(1) quit")
 .	;
 .	D addLine(.source,"   }")
 .	D addLine(.source,"  }")
 .	Q 
 ;
 D addLine(.source," }")
 D addLine(.source," else  do {")
 ;
 F i=1:1:$P(this,$C(9),6)-1 D addLine(.source,"  do this.vRCIdx"_i_"(processMode)")
 ;
 D addLine(.source," }")
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildjournals(this,source,tknzr) ; Tokenizer object
 ;
 N hasIfConds S hasIfConds=0
 N ifConds N journals N sort
 ;
 K source
 ;
 D addLine(.source,"")
 D addLine(.source,"private void vRCjournals(Number processMode, String vRCaudit())")
 ;
 D addLine(.source," type public String %TSRC")
 D addLine(.source," type String TSRC")
 ;
 D addLine(.source," if %TSRC.get().isNull() set TSRC = ""O""")
 D addLine(.source," else  set TSRC = %TSRC")
 ;
 D getJournalCode(.this,.journals,.sort,.hasIfConds,.ifConds,.tknzr)
 ;
 N hasMultiPrio N hitMode N hitTrantype N setQuit
 N incol N prio
 N code N efdopt N jrnid N mode N trantype N ws
 ;
 S (efdopt,mode,prio,trantype)=""
 S ws=" "
 ;
 S hitMode=0
 F  S mode=$order(sort(mode)) Q:(mode="")  D
 .	;
 .	I hasIfConds,'(ifConds(mode)="") D addLine(.source," #IF "_ifConds(mode))
 .	;
 .	I (mode'="I,U,D") D
 ..		;
 ..		S code="if (processMode = "_$translate(mode,"IUD","013")_") do { quit"
 ..		D addLine(.source,ws_code)
 ..		S ws=ws_" "
 ..		S hitMode=1
 ..		Q 
 .	;
 .	S hitTrantype=0
 .	F  S trantype=$order(sort(mode,trantype)) D  Q:(trantype="") 
 ..		;
 ..		; Close structured do from mode, if necessary
 ..		I (trantype="") D  Q 
 ...			;
 ...			I hitMode D addLine(.source," }")
 ...			S ws=" "
 ...			Q 
 ..		;
 ..		I hasIfConds,'(ifConds(mode_"-"_trantype)="") D addLine(.source,ws_"#IF "_ifConds(mode_"-"_trantype))
 ..		;
 ..		I (trantype'="F,O,B") D
 ...			;
 ...			S code="if (TSRC = """_trantype_""") do { quit"
 ...			D addLine(.source,ws_code)
 ...			S ws=ws_" "
 ...			S hitTrantype=1
 ...			Q 
 ..		;
 ..		F  S efdopt=$order(sort(mode,trantype,efdopt)) D  Q:(efdopt="") 
 ...			;
 ...			; Close structured do from trantype, if necessary
 ...			I (efdopt="") D  Q 
 ....				;
 ....				S ws=$E(ws,1,$L(ws)-1)
 ....				I hitTrantype D addLine(.source,ws_"}")
 ....				Q 
 ...			;
 ...			I hasIfConds,'(ifConds(mode_"-"_trantype_"-"_efdopt)="") D addLine(.source,ws_"#IF "_ifConds(mode_"-"_trantype_"-"_efdopt))
 ...			;
 ...			I (efdopt'="N,E") D
 ....				;
 ....				I (efdopt="E") S code="%EffectiveDate.get()"
 ....				E  S code="(%EffectiveDate.get() '> 0)"
 ....				;
 ....				S code="if "_code_" do {"
 ....				D addLine(.source,ws_code)
 ....				S ws=ws_" "
 ....				Q 
 ...			;
 ...			S setQuit=0
 ...			S hasMultiPrio=($order(sort(mode,trantype,efdopt,""))'=$order(sort(mode,trantype,efdopt,""),-1))
 ...			;
 ...			S prio=""
 ...			F  S prio=$order(sort(mode,trantype,efdopt,prio)) Q:(prio="")  D
 ....				;
 ....				N moreLvl0 S moreLvl0=0
 ....				;
 ....				I hasMultiPrio D
 .....					;
 .....					N x S x=prio
 .....					;
 .....					F  S x=$order(sort(mode,trantype,efdopt,x)) Q:(x="")  I ($D(sort(mode,trantype,efdopt,x,0))>0) S moreLvl0=1
 .....					Q 
 ....				;
 ....				S incol=""
 ....				F  S incol=$order(sort(mode,trantype,efdopt,prio,incol)) Q:(incol="")  D
 .....					;
 .....					N columnDeclared S columnDeclared=0
 .....					;
 .....					I (incol>0),'moreLvl0,'setQuit D
 ......						;
 ......						D addLine(.source,ws_"quit:(vRCaudit.data() '> 0)")
 ......						S setQuit=1 ; Only add one quit on vRCaudit at EFD level
 ......						Q 
 .....					;
 .....					S jrnid=""
 .....					F  S jrnid=$order(sort(mode,trantype,efdopt,prio,incol,jrnid)) Q:(jrnid="")  D
 ......						;
 ......						N addEndIf S addEndIf=0
 ......						N incolumn S incolumn=sort(mode,trantype,efdopt,prio,incol,jrnid)
 ......						;
 ......						I '($piece(journals(jrnid),$char(9),3)="") D
 .......							;
 .......							D addLine(.source,ws_"#IF "_$piece(journals(jrnid),$char(9),3))
 .......							S addEndIf=1
 .......							Q 
 ......						;
 ......						S code="do this.vRCJrn"_$piece(journals(jrnid),$char(9),1)_"(vRCaudit()"
 ......						;
 ......						I (incol=0) S code=code_")"
 ......						; If INCOLUMN(s), pass added parameter
 ......						E  D
 .......							;
 .......							I (incolumn[",") D
 ........								;
 ........								S code=code_", column)"
 ........								I ($piece(journals(jrnid),$char(9),2)="") S code=code_" quit"
 ........								Q 
 .......							E  S code=code_", """_incolumn_""")"
 .......							Q 
 ......						;
 ......						S code=code_"  // JRNID="_jrnid
 ......						S code=code_" Mode="_mode
 ......						S code=code_" Tran="_trantype
 ......						S code=code_" EFD="_efdopt
 ......						S code=code_" Seq="_prio
 ......						;
 ......						; Add testing for column changes before journal call
 ......						I (incol=1) D
 .......							;
 .......							; Only one column included
 .......							I '(incolumn[",") S code="if this.isChanged("_$$QADD^%ZS($$colName(incolumn,"UC",0),"""")_") "_code
 .......							E  D
 ........								;
 ........								N i
 ........								N morecode S morecode="for column = "
 ........								;
 ........								I 'columnDeclared D
 .........									;
 .........									D addLine(.source,ws_"type String column")
 .........									S columnDeclared=1
 .........									Q 
 ........								;
 ........								F i=1:1:$L(incolumn,",") S morecode=morecode_$$QADD^%ZS($piece(incolumn,",",i),"""")_", "
 ........								S code=$E(morecode,1,$L(morecode)-2)_" if vRCaudit(column).exists() "_code
 ........								Q 
 .......							Q 
 ......						;
 ......						D addLine(.source,ws_code)
 ......						;
 ......						I addEndIf D addLine(.source,ws_"#ENDIF")
 ......						Q 
 .....					Q 
 ....				Q 
 ...			;
 ...			I (efdopt'="N,E") D  ; Close this EFD loop
 ....				;
 ....				S ws=$E(ws,1,$L(ws)-1)
 ....				D addLine(.source,ws_"}")
 ....				Q 
 ...			;
 ...			I hasIfConds,'(ifConds(mode_"-"_trantype_"-"_efdopt)="") D addLine(.source,ws_"#ENDIF")
 ...			Q 
 ..		;
 ..		I hasIfConds,'(ifConds(mode_"-"_trantype)="") D addLine(.source,ws_"#ENDIF")
 ..		Q 
 .	;
 .	I hasIfConds,'(ifConds(mode)="") D addLine(.source," #ENDIF")
 .	Q 
 ;
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildkeyChanged(this,source) ; Build code into source
 ;
 N hasIndex S hasIndex=((","_this("sections")_",")[",indexes,")
 N keysLC S keysLC=$ZCONVERT($P(this("td"),"|",3),"L")
 N i N keycnt
 N nattable
 N newkeys S newkeys=""
 ;
 K source
 ;
 S keycnt=$S((keysLC=""):0,1:$L(keysLC,","))
 ;
 D addLine(.source,"")
 D addLine(.source,"private void vRCkeyChanged(List vRCparams, String vRCaudit())")
 ;
 I (keycnt=0) D addLine(.source," quit") Q 
 ;
 D addLine(.source," type String newkeys, oldkeys, vRCauditIns()")
 ;
 ; If there are after update triggers, save parameters
 I ((","_this("sections")_",")[",AU,") D addLine(.source," type String oldparams = vRCparams")
 ;
 ; Save old and new key values (regardless if particular ones have changed)
 F i=1:1:keycnt D
 .	;
 .	D addLine(.source," type String newKey"_i_" = this."_$$colName($piece(keysLC,",",i),"LC",1)_".curVal")
 .	D addLine(.source," type String oldKey"_i_" = this."_$$colName($piece(keysLC,",",i),"LC",1)_".oldVal")
 .	;
 .	S newkeys=newkeys_"newKey"_i_"_"",""_"
 .	Q 
 ;
 ; Make sure "new" record doesn't already exist
 D addLine(.source," if Db.isDefined("""_$P(this,$C(9),2)_""","_$$QADD^%ZS($$getWhereKey(.this,"this",0,.nattable),"""")_") do this.throwError($$^MSG(2327))")
 ;
 ; Build newkey and oldkey string for use by CASUPD^DBSEXECU
 S newkeys=$E(newkeys,1,$L(newkeys)-5)
 D addLine(.source," set newkeys = "_newkeys)
 D addLine(.source," set oldkeys = "_$$vStrRep(newkeys,"new","old",0,0,""))
 ;
 ; Move old keys into record
 F i=1:1:keycnt D addLine(.source," set this."_$$colName($piece(keysLC,",",i),"LC",1)_" = oldKey"_i)
 ;
 ; Switch index off
 I '($P(this("td"),"|",8)'="GTM") D addLine(.source," set vRCparams = $$setPar^UCUTILN(vRCparams, ""NOINDEX"")")
 ;
 ; Ensure all data is loaded locally
 I ($P(this("td"),"|",4)>1) D addLine(.source," do this.vRCforceLoad()")
 ;
 I '($P(this("td"),"|",8)'="GTM"),((","_this("sections")_",")[",required,") D addLine(.source," if vRCparams.contains(""VALREQ"", ""/"") do this.vRCchkReqForInsert()")
 ;
 ; If before update triggers (non-key or key columns), handle
 I ((","_this("sections")_",")[",BU,") D addLine(.source," if vRCparams.contains(""TRIGBEF"", ""/"") do this.vRCbeforeUpdTrigs(vRCparams, vRCaudit())")
 ;
 D addLine(.source," if vRCparams.contains(""VALDD"", ""/"") do this.vRCvalidateDD(1)")
 D addLine(.source," do this.vRCmiscValidations(vRCparams, 1)")
 D addLine(.source," do this.vRCupdateDB(1, vRCparams, vRCaudit(), vRCauditIns())")
 ;
 ; Move new keys into record
 F i=1:1:keycnt D addLine(.source," set this."_$$colName($piece(keysLC,",",i),"LC",1)_" = newKey"_i)
 ;
 ; Create new copy to insert
 D addLine(.source," type Record"_$P(this,$C(9),2)_" newrec = this.copy()")
 D addLine(.source," do newrec.setMode(0)")
 D addLine(.source," do newrec.save($$initPar^UCUTILN(""/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/""))")
 ;
 D addLine(.source," do {")
 ;
 D addLine(.source,"  type Number %ProcessMode = 1")
 D addLine(.source,"  type Boolean ER = false")
 D addLine(.source,"  type String RM = """"")
 D addLine(.source,"  #ACCEPT Date=10/24/2008; Pgm=RussellDS; CR=30801; Group=ACCESS")
 D addLine(.source,"  do CASUPD^DBSEXECU("""_$P(this,$C(9),2)_""", oldkeys , newkeys)")
 D addLine(.source,"  if ER do this.throwError(RM.get())")
 D addLine(.source," }")
 ;
 F i=1:1:keycnt D addLine(.source," set this."_$$colName($piece(keysLC,",",i),"LC",1)_" = oldKey"_i)
 ;
 D addLine(.source," set vRCparams = $$initPar^UCUTILN(""/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/"")")
 D addLine(.source," do this.vRCdelete(vRCparams, vRCaudit(), true)")
 ;
 ; Reset keys to new value (once again) so that vobj is correct
 F i=1:1:keycnt D addLine(.source," set this."_$$colName($piece(keysLC,",",i),"LC",1)_" = newKey"_i)
 ;
 ; If after update triggers (non-key or key columns), handle
 I ((","_this("sections")_",")[",AU,") D
 .	;
 .	D addLine(.source," set vRCparams = oldparams")
 .	D addLine(.source," if vRCparams.contains(""TRIGAFT"", ""/"") do this.vRCafterUpdTrigs(vRCparams)")
 .	Q 
 ;
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildlogMethods(this,source) ; Build code into source
 ;
 N isPositiveList
 N userclasses
 N operation
 ;
 K source
 ;
 ; Build getLogging() method
 D addLine(.source,"")
 ;
 D addLine(.source,"public static List vgetLogging()")
 ;
 D addLine(.source," quit "_$$QADD^%ZS($P(this,$C(9),8),""""))
 D addLine(.source,"")
 ;
 D addLine(.source,"public static Boolean logUserclass(String operation)")
 F operation="INSERT","UPDATE","DELETE","SELECT" D
 .	;
 .	N isPositiveList
 .	N code N test N userclasses
 .	;
 .	S code=" if (operation = """_operation_""")"
 .	I (operation'="INSERT") S code=" else "_code
 .	;
 .	I $$shouldLog^SQLAUDIT($P(this,$C(9),2),operation,"log",.userclasses,.isPositiveList) D
 ..		;
 ..		S test=$$getAuditUCLSChk(.this,userclasses,isPositiveList)
 ..		I '(test="") S code=code_", "_test
 ..		S code=code_" quit true"
 ..		Q 
 .	E  S code=code_" quit false"
 .	;
 .	D addLine(.source,code)
 .	Q 
 D addLine(.source," quit false")
 ;
 D addLine(.source,"")
 ;
 D addLine(.source,"public static Number vlogSelect(String statement, String using)")
 ;
 I $$shouldLog^SQLAUDIT($P(this,$C(9),2),"SELECT","log",.userclasses,.isPositiveList) D
 .	;
 .	N code S code=" quit $$auditLog^SQLAUDIT(""SELECT"", """_$P(this,$C(9),2)_""", statement, using)"
 .	N test S test=$$getAuditUCLSChk(.this,userclasses,isPositiveList)
 .	;
 .	I '(test="") D
 ..		;
 ..		D addLine(.source," if "_test_code)
 ..		D addLine(.source," quit 0")
 ..		Q 
 .	E  D addLine(.source,code)
 .	Q 
 E  D addLine(.source," quit 0")
 D addLine(.source,"")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildmiscValidations(this,source) ; Build code into source
 ;
 N code N nattable
 ;
 K source
 ;
 D addLine(.source,"")
 D addLine(.source,"private void vRCmiscValidations(List vRCparams, Number processMode)")
 ;
 ; Validate mode versus current DB state
 S code=" if vRCparams.contains(""VALST"", ""/"") if '(''Db.isDefined("""_$P(this,$C(9),2)_""","
 S code=code_$$QADD^%ZS($$getWhereKey(.this,"this",0,.nattable),"""")_") = ''processMode) do {"
 D addLine(.source,code)
 ;
 D addLine(.source,"  type String errmsg")
 D addLine(.source,"  if (processMode <> 0) set errmsg = $$^MSG(7932)") ; Record not defined
 D addLine(.source,"  else  set errmsg = $$^MSG(2327)") ; Record already exists
 ;
 D addLine(.source,"  do this.throwError(errmsg)")
 D addLine(.source," }")
 ;
 I ((","_this("sections")_",")[",foreignKeys,") D
 .	;
 .	D addLine(.source," if vRCparams.contains(""VALFK"", ""/"") do this.vRCcheckForeignKeys()")
 .	D addLine(.source," if vRCparams.contains(""VALRI"", ""/"") do this.vRCsetForeignKeys()")
 .	Q 
 ;
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildnew(this,source) ; polymorphism dispatch
 N vC S vC=$P($G(this),$C(9))
 I $D(vPslPoly(vC,"buildnew")) D v0buildnew^@vPslPoly(vC,"buildnew")(.this,.source) Q
 D v0buildnew(.this,.source) Q
v0buildnew(this,source) ; Build code into source
 ;
 N i
 N code S code=$$getNewMethodCode^UCXDD(this("td"),"vcdmNew")
 ;
 K source
 ;
 D addLine(.source,"")
 F i=1:1:$L(code,$char(9)) D addLine(.source,$piece(code,$char(9),i))
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildsetDefaults(this,source) ; Build code into source
 ;
 N dftList S dftList=$P(this("td"),"|",29)
 N keys S keys=$P(this("td"),"|",3)
 N i
 ;
 K source
 ;
 D addLine(.source,"")
 D addLine(.source,"private void vRCsetDefaults()")
 ;
 F i=1:1:$S((dftList=""):0,1:$L(dftList,",")) D
 .	;
 .	N column S column=$piece(dftList,",",i)
 .	N columnLC S columnLC=$ZCONVERT(column,"L")
 .	N defaultValue
 .	;
 .	N cd S cd=$$getSchCln^UCXDD($P(this,$C(9),2),column)
 .	;
 .	Q:($P(cd,"|",19)="") 
 .	Q:'($P(cd,"|",14)="")  ; Computeds can't have default values
 .	;
 .	S defaultValue=$$translateKeyWords(this("td"),$P(cd,"|",19),$P(cd,"|",6),1)
 .	;
 .	I '(defaultValue="") D addLine(.source," if this."_$$colName(columnLC,"LC",1)_".isNull() set this."_$$colName(columnLC,"LC",1)_" = "_defaultValue)
 .	Q 
 ;
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildsave(this,source) ; Build code into source
 ;
 N addIf
 N isParent S isParent=0
 N checkRights S checkRights=$P(this,$C(9),7)
 N i
 N code N nattable
 ;
 K source
 ;
 D addLine(.source,"")
 ;
 I ($P(this,$C(9),10)="") S code="final "
 E  S code=""
 ;
 D addLine(.source,"public "_code_"void vSave(List vRCparams, Number vauditLogSeq)")
 ;
 F i=1:1:$S(($P(this,$C(9),10)=""):0,1:$L($P(this,$C(9),10),",")) D
 .	;
 .	N childTbl S childTbl=$piece($P(this,$C(9),10),",",i)
 .	N mcode
 .	;
 .	I 'isParent D
 ..		;
 ..		D addLine(.source," #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
 ..		D addLine(.source," #BYPASS")
 ..		S isParent=1
 ..		Q 
 .	;
 .	S mcode=" I "_"vobj"_"(this,-1)=""Record"_childTbl_""" D vSave^Record"_childTbl_"(this,vRCparams,.vauditLogSeq) Q"
 .	D addLine(.source,mcode)
 .	Q 
 I isParent D addLine(.source," #ENDBYPASS")
 ;
 D addLine(.source," type public String verrors()")
 ;
 D addLine(.source," type String vRCaudit(), vRCauditIns()") ; Audit column arrays
 ;
 ; Note - eventually replace following with public type new %ProceesMode
 D addLine(.source," type Number %ProcessMode = this.getMode()") ; Used by triggers
 ;
 D addLine(.source," if vRCparams.get().isNull() set vRCparams = "_$$fileQual^UCDB("Record.save",""))
 ;
 I '($P(this("td"),"|",8)'="GTM"),'($$getArchiveTable^DBARCHIVE(this("td"))="") D
 .	;
 .	N archTable S archTable=$$getArchiveTable^DBARCHIVE(this("td"))
 .	N archRecRef S archRecRef="Record"_archTable
 .	;
 .	N archtd S archtd=$$getPslTbl^UCXDD(archTable,1)
 .	;
 .	N acckeys S acckeys=$P(this("td"),"|",3)
 .	N keycnt S keycnt=$$getArchiveKey^DBARCHIVE(archtd,0)
 .	N archkey S archkey=$piece(acckeys,",",keycnt)
 .	N i
 .	;
 .	D addLine(.source," if (%ProcessMode '= 2), 'vRCparams.contains(""NOUPDATE"", ""/"") do {")
 .	;
 .	I ($P(this,$C(9),2)=archTable) S archRecRef="this"
 .	E  D addLine(.source,"  type static "_archRecRef)
 .	;
 .	S code="  if "_archRecRef_".getArchiveFile("""_$P(this,$C(9),2)_""", 0,"
 .	;
 .	F i=1:1:keycnt-1 S code=code_"this."_$$colName($piece(acckeys,",",i),"LC",1)_", "
 .	S code=code_"this."_$$colName(archkey,"LC",1)_")"
 .	;
 .	; Cannot modify records in archive file
 .	S code=code_" do this.throwError($$^MSG(6906))"
 .	;
 .	D addLine(.source,code)
 .	D addLine(.source," }")
 .	Q 
 ;
 ; Create record
 D addLine(.source," if (%ProcessMode = 0) do {")
 ;
 ; Handle audit logging
 I ((","_$P(this,$C(9),8)_",")[",insert,") D addLogSQLCode(.this,.source,"insert")
 ;
 D addLine(.source,"  do AUDIT^UCUTILN(this, vRCauditIns(), "_$P(this("td"),"|",4)_", "_$P(this,$C(9),4)_")")
 I ((","_this("sections")_",")[",defaults,") D addLine(.source,"  do this.vRCsetDefaults()")
 I ((","_this("sections")_",")[",BI,") D
 .	;
 .	I '(this("trigAllIf",1)="") S addIf=1
 .	E  S addIf=0
 .	;
 .	I addIf D addLine(.source,"  #IF "_this("trigAllIf",1))
 .	D addLine(.source,"  if vRCparams.contains(""TRIGBEF"", ""/"") do this.vRCbeforeInsTrigs(vRCparams)")
 .	I addIf D addLine(.source,"  #ENDIF")
 .	Q 
 ; No access rights for table ~p1
 I (((","_checkRights_",")[",insert,")!((","_checkRights_",")[",insertRestrict,")) D addLine(.source,"  if 'this.vinsertOK(%UserClass) throw Class.new(""Error"", ""%PSL-E-ACCESS,""_ $$^MSG(6754,"""_$P(this,$C(9),2)_"""))")
 I ((","_this("sections")_",")[",required,") D addLine(.source,"  if vRCparams.contains(""VALREQ"", ""/"") do this.vRCchkReqForInsert()")
 D addLine(.source,"  if vRCparams.contains(""VALDD"", ""/"") do this.vRCvalidateDD(%ProcessMode)")
 D addLine(.source,"  do this.vRCmiscValidations(vRCparams, %ProcessMode)")
 D addLine(.source,"  do this.vRCupdateDB(%ProcessMode, vRCparams, vRCaudit(), vRCauditIns())")
 I ((","_this("sections")_",")[",AI,") D
 .	;
 .	I '(this("trigAllIf",4)="") S addIf=1
 .	E  S addIf=0
 .	;
 .	I addIf D addLine(.source,"  #IF "_this("trigAllIf",4))
 .	D addLine(.source,"  if vRCparams.contains(""TRIGAFT"", ""/"") do this.vRCafterInsTrigs(vRCparams)")
 .	I addIf D addLine(.source,"  #ENDIF")
 .	Q 
 ;
 I ((","_this("sections")_",")[",literals,"),($$getSetting^PSLCC(.pslPrsr,"boot","restrictionlevel","")'=-1) D addLine(.source,"  do SET^UCLREGEN("""_$P(this,$C(9),2)_""", ""*"")")
 ;
 D addLine(.source," }")
 ;
 ; Update record
 D addLine(.source," else  if (%ProcessMode = 1) do {")
 I ($P(this("td"),"|",4)>1) D addLine(.source,"  quit:'this.isChanged()")
 ;
 ; Handle audit logging
 I ((","_$P(this,$C(9),8)_",")[",update,") D addLogSQLCode(.this,.source,"update")
 ;
 D addLine(.source,"  do AUDIT^UCUTILN(this, vRCaudit(), "_$P(this("td"),"|",4)_", "_$P(this,$C(9),4)_")")
 ;
 I '($P(this("td"),"|",3)="") D
 .	;
 .	N keys S keys=$P(this("td"),"|",3)
 .	N i
 .	;
 .	S code="  if "
 .	F i=1:1:$S((keys=""):0,1:$L(keys,",")) S code=code_"this.isChanged("_$$QADD^%ZS($$colName($piece(keys,",",i),"UC",0),"""")_") or "
 .	S code=$E(code,1,$L(code)-4)
 .	;
 .	D addLine(.source,code_" do this.vRCkeyChanged(vRCparams, vRCaudit()) quit")
 .	Q 
 I ((","_this("sections")_",")[",BU,"),'((","_this("sections")_",")[",BUKO,") D
 .	;
 .	I '(this("trigAllIf",2)="") S addIf=1
 .	E  S addIf=0
 .	;
 .	I addIf D addLine(.source,"  #IF "_this("trigAllIf",2))
 .	D addLine(.source,"  if vRCparams.contains(""TRIGBEF"", ""/"") do this.vRCbeforeUpdTrigs(vRCparams, vRCaudit())")
 .	I addIf D addLine(.source,"  #ENDIF")
 .	Q 
 ; No access rights for table ~p1
 I (((","_checkRights_",")[",update,")!((","_checkRights_",")[",updateRestrict,")) D addLine(.source,"  if 'this.vupdateOK(%UserClass) throw Class.new(""Error"", ""%PSL-E-ACCESS,""_ $$^MSG(6754,"""_$P(this,$C(9),2)_"""))")
 I ((","_this("sections")_",")[",required,") D addLine(.source,"  if vRCparams.contains(""VALREQ"", ""/"") do this.vRCchkReqForUpdate()")
 D addLine(.source,"  if vRCparams.contains(""VALDD"", ""/"") do this.vRCvalidateDD1()")
 D addLine(.source,"  do this.vRCmiscValidations(vRCparams, %ProcessMode)")
 D addLine(.source,"  do this.vRCupdateDB(%ProcessMode, vRCparams, vRCaudit(), vRCauditIns())")
 I ((","_this("sections")_",")[",AU,"),'((","_this("sections")_",")[",AUKO,") D
 .	;
 .	I '(this("trigAllIf",5)="") S addIf=1
 .	E  S addIf=0
 .	;
 .	I addIf D addLine(.source,"  #IF "_this("trigAllIf",5))
 .	D addLine(.source,"  if vRCparams.contains(""TRIGAFT"", ""/"") do this.vRCafterUpdTrigs(vRCparams)")
 .	I addIf D addLine(.source,"  #ENDIF")
 .	Q 
 I ((","_this("sections")_",")[",literals,"),($$getSetting^PSLCC(.pslPrsr,"boot","restrictionlevel","")'=-1) D
 .	;
 .	D addLine(.source,"  do {")
 .	D addLine(.source,"   type ResultSet rslits = Db.select(""DISTINCT COLUMN"", ""SYSMAPLITDTA"", ""TABLE='"_$P(this,$C(9),2)_"'"")")
 .	D addLine(.source,"   while rslits.next() if vRCaudit(rslits.getCol(1)).exists() do SET^UCLREGEN("""_$P(this,$C(9),2)_""", rslits.getCol(1))")
 .	D addLine(.source,"  }")
 .	Q 
 D addLine(.source," }")
 ;
 ; Verify record
 D addLine(.source," else  if (%ProcessMode = 2) do {")
 I ((","_this("sections")_",")[",required,") D addLine(.source,"  if vRCparams.contains(""VALREQ"", ""/"") do this.vRCchkReqForInsert()")
 D addLine(.source,"  if vRCparams.contains(""VALDD"", ""/"") do this.vRCvalidateDD(%ProcessMode)")
 D addLine(.source,"  do this.vRCmiscValidations(vRCparams, 2)")
 I ((","_this("sections")_",")[",indexes,") D addLine(.source,"  if vRCparams.contains(""INDEX"", ""/"") do this.updateIndexes(%ProcessMode, vRCaudit())")
 I ((","_this("sections")_",")[",AI,") D
 .	;
 .	I '(this("trigAllIf",4)="") S addIf=1
 .	E  S addIf=0
 .	;
 .	I addIf D addLine(.source,"  #IF "_this("trigAllIf",4))
 .	D addLine(.source,"  if vRCparams.contains(""TRIGAFT"", ""/"") do this.vRCafterInsTrigs(vRCparams)")
 .	I addIf D addLine(.source,"  #ENDIF")
 .	Q 
 D addLine(.source," }")
 ;
 ; Delete record
 D addLine(.source," else  if (%ProcessMode = 3) do {")
 ; No record exists
 D addLine(.source,"  quit:'Db.isDefined("""_$P(this,$C(9),2)_""","_$$QADD^%ZS($$getWhereKey(.this,"this",0,.nattable),"""")_")")
 ;
 ; Handle audit logging
 I ((","_$P(this,$C(9),8)_",")[",delete,") D addLogSQLCode(.this,.source,"delete")
 ;
 I ((","_this("sections")_",")[",BD,") D
 .	;
 .	I '(this("trigAllIf",3)="") S addIf=1
 .	E  S addIf=0
 .	;
 .	I addIf D addLine(.source,"  #IF "_this("trigAllIf",3))
 .	D addLine(.source,"  if vRCparams.contains(""TRIGBEF"", ""/"") do this.vRCbeforeDelTrigs(vRCparams)")
 .	I addIf D addLine(.source,"  #ENDIF")
 .	Q 
 ; No access rights for table ~p1
 I (((","_checkRights_",")[",delete,")!((","_checkRights_",")[",deleteRestrict,")) D addLine(.source,"  if 'this.vdeleteOK(%UserClass) throw Class.new(""Error"", ""%PSL-E-ACCESS,""_ $$^MSG(6754,"""_$P(this,$C(9),2)_"""))")
 D addLine(.source,"  do this.vRCdelete(vRCparams, vRCaudit(), false)")
 I ((","_this("sections")_",")[",AD,") D
 .	;
 .	I '(this("trigAllIf",6)="") S addIf=1
 .	E  S addIf=0
 .	;
 .	I addIf D addLine(.source,"  #IF "_this("trigAllIf",6))
 .	D addLine(.source,"  if vRCparams.contains(""TRIGAFT"", ""/"") do this.vRCafterDelTrigs(vRCparams)")
 .	I addIf D addLine(.source,"  #ENDIF")
 .	Q 
 ;
 I ((","_this("sections")_",")[",literals,"),($$getSetting^PSLCC(.pslPrsr,"boot","restrictionlevel","")'=-1) D addLine(.source,"  do SET^UCLREGEN("""_$P(this,$C(9),2)_""", ""*"")")
 D addLine(.source," }")
 ;
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildtriggers(this,source,tknzr) ; Tokenizer object
 ;
 N keys S keys=$P(this("td"),"|",3)
 N i
 N code N dispatch N ifConds
 ;
 K source
 ;
 N rs,vos1,vos2,vos3,vos4,vos5  N V1 S V1=$P(this,$C(9),2) S rs=$$vOpen12()
 ;
 F  Q:'$$vFetch12()  D getTriggerCode(.this,.dispatch,.ifConds,$P(rs,$C(9),1),$P(rs,$C(9),2),$P(rs,$C(9),3),$P(rs,$C(9),4),$P(rs,$C(9),5),$P(rs,$C(9),6),$P(rs,$C(9),7),$P(rs,$C(9),8),$P(rs,$C(9),9),$P(rs,$C(9),10),.tknzr)
 ;
 ; Build dispatch sections
 F i=1:1:6 I ($D(dispatch(i))>0) D
 .	;
 .	N isUpdate S isUpdate=((i=2)!(i=5))
 .	N j N n
 .	;
 .	I (i=1) S code="beforeInsTrigs(List vRCparams)"
 .	E  I (i=2) S code="beforeUpdTrigs(List vRCparams, String vRCaudit())"
 .	E  I (i=3) S code="beforeDelTrigs(List vRCparams)"
 .	E  I (i=4) S code="afterInsTrigs(List vRCparams)"
 .	E  I (i=5) S code="afterUpdTrigs(List vRCparams)"
 .	E  I (i=6) S code="afterDelTrigs(List vRCparams)"
 .	;
 .	D addLine(.source,"")
 .	D addLine(.source,"private void vRC"_code)
 .	;
 .	D addLine(.source," type Boolean ER = false")
 .	D addLine(.source," type Boolean vRCfire")
 .	D addLine(.source," type String RM = """"")
 .	;
 .	F j=1:1:$S((keys=""):0,1:$L(keys,",")) I '($piece(keys,",",j)["_") D addLine(.source," type String "_$piece(keys,",",j)_" = this."_$ZCONVERT($piece(keys,",",j),"L"))
 .	;
 .	; For update triggers, if no changes, just quit
 .	I isUpdate D addLine(.source," quit:'this.isChanged()")
 .	;
 .	; Non-column related triggers first
 .	S n=""
 .	F  S n=$order(dispatch(i,1,n)) Q:(n="")  D
 ..		;
 ..		I ($D(ifConds(n))#2) D addLine(.source," #IF "_ifConds(n))
 ..		D addLine(.source," do this.vRCTrig"_n_"(this, vRCparams) if ER do this.throwError(RM.get())")
 ..		I ($D(ifConds(n))#2) D addLine(.source," #ENDIF")
 ..		Q 
 .	;
 .	; Then column related triggers
 .	F  S n=$order(dispatch(i,2,n)) Q:(n="")  D
 ..		;
 ..		N columns S columns=n
 ..		N triggers S triggers=dispatch(i,2,n)
 ..		N j
 ..		;
 ..		I isUpdate D
 ...			;
 ...			D addLine(.source," set vRCfire = false")
 ...			;
 ...			F j=1:1:$S((columns=""):0,1:$L(columns,",")) D
 ....				;
 ....				S code=""
 ....				I (j=1) S code=" if "
 ....				E  S code=" else  if "
 ....				;
 ....				D addLine(.source,code_"this.isChanged("""_$piece(columns,",",j)_""") set vRCfire = true")
 ....				Q 
 ...			;
 ...			S code=" if vRCfire"
 ...			Q 
 ..		E  S code=""
 ..		;
 ..		I isUpdate,($S((triggers=""):0,1:$L(triggers,","))>1) D
 ...			;
 ...			D addLine(.source,code_" do {")
 ...			S code=" "
 ...			Q 
 ..		F j=1:1:$S((triggers=""):0,1:$L(triggers,",")) D
 ...			;
 ...			N trigSeq S trigSeq=$piece(triggers,",",j)
 ...			;
 ...			I ($D(ifConds(trigSeq))#2) D addLine(.source," #IF "_ifConds(trigSeq))
 ...			D addLine(.source,code_" do this.vRCTrig"_trigSeq_"(this, vRCparams) if ER do this.throwError(RM.get())")
 ...			I ($D(ifConds(trigSeq))#2) D addLine(.source," #ENDIF")
 ...			Q 
 ..		I isUpdate,($S((triggers=""):0,1:$L(triggers,","))>1) D addLine(.source," }")
 ..		Q 
 .	;
 .	; Before update triggers may change values to be used by other triggers
 .	I (i=2) D addLine(.source," do AUDIT^UCUTILN(this, vRCaudit(), 10, "_$P(this,$C(9),4)_")")
 .	;
 .	D addLine(.source," quit")
 .	Q 
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildupdateDB(this,source) ; Build code into source
 ;
 N cdate S cdate=$$getLogCode(.this,$P(this("td"),"|",22),$P(this("td"),"|",20),"D")
 N ctime S ctime=$$getLogCode(.this,$P(this("td"),"|",23),$P(this("td"),"|",20),"T")
 N cuser S cuser=$$getLogCode(.this,$P(this("td"),"|",24),$P(this("td"),"|",20),"U")
 N udate S udate=$$getLogCode(.this,$P(this("td"),"|",25),$P(this("td"),"|",20),"D")
 N utime S utime=$$getLogCode(.this,$P(this("td"),"|",26),$P(this("td"),"|",20),"T")
 N uuser S uuser=$$getLogCode(.this,$P(this("td"),"|",27),$P(this("td"),"|",20),"U")
 ;
 K source
 ;
 D addLine(.source,"")
 D addLine(.source,"private void vRCupdateDB(Number processMode, List vRCparams, String vRCaudit(), String vRCauditIns())")
 ;
 D addLine(.source," if 'vRCparams.contains(""NOUPDATE"", ""/"") do {")
 ;
 ; If the same column is used for new and update, just do it once for either condition
 I '(cdate=""),(cdate=udate) D
 .	;
 .	D addLine(.source," "_cdate)
 .	S (cdate,udate)=""
 .	Q 
 I '(ctime=""),(ctime=utime) D
 .	;
 .	D addLine(.source," "_ctime)
 .	S (ctime,utime)=""
 .	Q 
 I '(cuser=""),(cuser=uuser) D
 .	;
 .	D addLine(.source," "_cuser)
 .	S (cuser,uuser)=""
 .	Q 
 ;
 I '(cdate="") D addLine(.source,"  if (processMode = 0)"_cdate)
 I '(ctime="") D addLine(.source,"  if (processMode = 0)"_ctime)
 I '(cuser="") D addLine(.source,"  if (processMode = 0)"_cuser)
 I '(udate="") D addLine(.source,"  if (processMode = 1)"_udate)
 I '(utime="") D addLine(.source,"  if (processMode = 1)"_utime)
 I '(uuser="") D addLine(.source,"  if (processMode = 1)"_uuser)
 ;
 I $P(this("td"),"|",16) D
 .	;
 .	D addLine(.source,"  if 'vRCparams.contains(""NOLOG"", ""/"") do {")
 .	;
 .	D addLine(.source,"   if (processMode = 1) do ^DBSLOGIT(this, 1, vRCaudit()) quit")
 .	D addLine(.source,"   do ^DBSLOGIT(this, 0, vRCauditIns())")
 .	;
 .	D addLine(.source,"  }")
 .	Q 
 ;
 I ($P(this("td"),"|",8)'="GTM") D addRDBsaveCode(.this,.source)
 I '($P(this("td"),"|",8)'="GTM") D addMsaveCode(.this,.source)
 ;
 I ((","_this("sections")_",")[",journals,") D addLine(.source,"  if vRCparams.contains(""JOURNAL"", ""/"") do this.vRCjournals(processMode, vRCaudit())")
 D addLine(.source," }")
 ;
 I ((","_this("sections")_",")[",indexes,") D addLine(.source," if vRCparams.contains(""INDEX"", ""/""), ((processMode = 0) or this.isChanged()) do this.updateIndexes(processMode, vRCaudit())")
 ;
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildvalidateDD(this,source) ; Build code into source
 ;
 N isDo S isDo=0
 N keys S keys=$P(this("td"),"|",3)
 N seq
 N column N code N lookupTbl N lastKey N node N pattern N table N typ
 N source2
 ;
 N columnsByNode
 ;
 K source
 ;
 D addLine2(.source,.source2,"")
 D addLine(.source,"private void vRCvalidateDD(Number processMode)")
 D addLine(.source2,"private void vRCvalidateDD1()")
 ;
 D addLine2(.source,.source2," type public Cache %CACHE()")
 D addLine2(.source,.source2," type Boolean ER = false")
 D addLine2(.source,.source2," type String RM = """"")
 D addLine2(.source,.source2," type String errmsg, X")
 ;
 I ($P(this("td"),"|",4)>1) D addLine(.source," if (processMode = 2) do this.vRCforceLoad()")
 ;
 S table=$P(this,$C(9),2)
 N rs,vos1,vos2,vos3,vos4,vos5,vos6  N V1 S V1=table S rs=$$vOpen13()
 ;
 F  Q:'$$vFetch13()  D
 .	;
 . S column=rs
 .	;
 .	I '$$isLit^UCGM(column) D
 ..		;
 ..		N cd S cd=$$getSchCln^UCXDD(table,column)
 ..		;
 ..		S columnsByNode($P(cd,"|",3),column)=cd
 ..		Q 
 .	Q 
 ;
 S lastKey=$piece(keys,",",$S((keys=""):0,1:$L(keys,",")))
 S isDo=0
 ;
 S (node,column)=""
 F  S node=$order(columnsByNode(node)) Q:(node="")  D
 .	;
 .	N ws S ws="" ; White space
 .	;
 .	I isDo D addLine2(.source,.source2," }") ; Close the do block
 .	S isDo=0
 .	;
 .	I ($P(this("td"),"|",4)>1),'($E(node,$L(node))="*") D
 ..		;
 ..		S isDo=1
 ..		S ws=" "
 ..		;
 ..		I ($P(this("td"),"|",4)=11),(node=lastKey) D
 ...			;
 ...			D addLine2(.source,.source2," if vobj(this).exists() or 'vobj(this,"""").order().isNull() do {")
 ...			Q 
 ..		E  D
 ...			;
 ...			N x
 ...			;
 ...			I (node=+node) D
 ....				;
 ....				I (node<0) S x=$$QADD^%ZS(("v"_-node),"""")
 ....				E  S x=node
 ....				Q 
 ...			E  S x=$S(node'["""":""""_node_"""",1:$$QADD^%ZS(node,""""))
 ...			;
 ...			D addLine2(.source,.source2," if vobj(this,"_x_").exists() do {")
 ...			Q 
 ..		Q 
 .	;
 .	F  S column=$order(columnsByNode(node,column)) Q:(column="")  D
 ..		;
 ..		N colref S colref=$$colName(column,"LC",1)
 ..		N cd S cd=columnsByNode(node,column)
 ..		;
 ..		S lookupTbl=$P(cd,"|",21)
 ..		S typ=$P(cd,"|",6)
 ..		;
 ..		I '(lookupTbl="") D
 ...			;
 ...			I (lookupTbl[":NOVAL") S lookupTbl="" Q 
 ...			;
 ...			I ($E(lookupTbl,1)="["),(lookupTbl?1"["1A.AN1"]".E)!(lookupTbl?1"[%".AN1"]".E) D  Q 
 ....				;
 ....				N lutblKeys
 ....				N isDefRef S isDefRef="Db" ; or Cache, if CTBL/STBL/UTBL table
 ....				N QRY S QRY=""
 ....				;
 ....				I (lookupTbl[":QU") S QRY=$piece($piece(lookupTbl,":QU",2)," ",2,1048575)
 ....				;
 ....				S lookupTbl=$piece($piece(lookupTbl,"[",2),"]",1)
 ....				;
 ....				I ((lookupTbl=table)!(lookupTbl=$P(this("td"),"|",7))) S lookupTbl="" Q 
 ....				;
 ....				I '$$isTable^UCXDD(lookupTbl) S $ZE="0,"_$ZPOS_","_"%PSL-E-INVALID,Aborted - invalid table linkage for column "_column,$EC=",U1001,"
 ....				;
 ....				N tdlookup S tdlookup=$$getPslTbl^UCXDD(lookupTbl,0)
 ....				;
 ....				I (($E($P(tdlookup,"|",2),1,5)="^CTBL")!($E($P(tdlookup,"|",2),1,5)="^STBL")!($E($P(tdlookup,"|",2),1,5)="^UTBL")) D
 .....					;
 .....					N modIO S modIO=$$vClVobj($ST,"IO")
 .....					I $$locate^UCIO(modIO,$$packageDirs^PSLC("",""),":","Record"_lookupTbl_".pslx",0) S isDefRef="%CACHE("""_lookupTbl_""")"
 .....					K vobj(+$G(modIO)) Q 
 ....				;
 ....				S lutblKeys=$P(tdlookup,"|",3)
 ....				;
 ....				; If more than a single key, try to use query info
 ....				I ($S((lutblKeys=""):0,1:$L(lutblKeys,","))>1) D
 .....					;
 .....					N i
 .....					N key N keyname N keys N keyval N TOK
 .....					;
 .....					I (QRY="") S lookupTbl="" Q 
 .....					;
 .....					S QRY=$$QSUB^%ZS(QRY,"""")
 .....					;       #ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
 .....					S QRY=$$TOKEN^%ZS(QRY,.TOK)
 .....					;
 .....					S keys=""
 .....					F i=1:1:$S((lutblKeys=""):0,1:$L(lutblKeys,","))-1 D  Q:(lookupTbl="") 
 ......						;
 ......						S keyname=$piece(lutblKeys,",",i)
 ......						S key="["_lookupTbl_"]"_keyname_"="
 ......						;
 ......						I (QRY'[key) S lookupTbl=""
 ......						E  D
 .......							;
 .......							S keyval=$piece(QRY,key,2)
 .......							;         #ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
 .......							S keyval=$$ATOM^%ZS(keyval,0,",:&",TOK,0)
 .......							I (keyval="") S lookupTbl=""
 .......							E  I '((keyval=+keyval)!(keyval?1"""".E1"""")) S lookupTbl=""
 .......							E  D
 ........								;
 ........								I ($E(keyval,1)="""") S keyval=$$QADD^%ZS($$QSUB^%ZS(keyval,""""),"'")
 ........								S keys=keys_keyname_"="_keyval_","
 ........								Q 
 .......							Q 
 ......						Q 
 .....					;
 .....					; Handle last key
 .....					I '(lookupTbl="") D
 ......						;
 ......						S keyname=$piece(lutblKeys,",",$S((lutblKeys=""):0,1:$L(lutblKeys,",")))
 ......						S keys=keys_keyname_"=:X"
 ......						S lookupTbl=isDefRef_".isDefined("""_lookupTbl_""", """_keys_""")"
 ......						Q 
 .....					;
 .....					Q 
 ....				E  S lookupTbl=isDefRef_".isDefined("""_lookupTbl_""", """_lutblKeys_"=:X"")"
 ....				Q 
 ...			;
 ...			; Ignore indirection or local arrays
 ...			I ($E(lookupTbl,1)="@") S lookupTbl=""
 ...			E  I (lookupTbl?1A.AN1"(") S lookupTbl=""
 ...			; Picklist
 ...			E  I ($E(lookupTbl,1)=",") D
 ....				;
 ....				N newList N tbltok
 ....				N i
 ....				N tok
 ....				;
 ....				;      #ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
 ....				S tbltok=$$TOKEN^%ZS($E(lookupTbl,2,1048575),.tok)
 ....				S newList=""
 ....				F i=1:1:$S((tbltok=""):0,1:$L(tbltok,",")) S newList=$S((newList=""):$piece($piece(tbltok,",",i),"#",1),1:newList_","_$piece($piece(tbltok,",",i),"#",1))
 ....				;
 ....				;      #ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
 ....				S lookupTbl="{List}"_$$QADD^%ZS($$UNTOK^%ZS(newList,tok),"""")_".contains(X)"
 ....				Q 
 ...			;
 ...			I ($E(lookupTbl,1)="^") S $ZE="0,"_$ZPOS_","_"%PSL-E-INVALID,Aborted - invalid global reference for table look-up on column "_column,$EC=",U1001,"
 ...			;
 ...			I (lookupTbl=""!(lookupTbl="""""")) S lookupTbl=""
 ...			Q 
 ..		;
 ..		S code=" set X = this."_colref_" if 'X.isNull()"
 ..		;
 ..		I '(lookupTbl="") S code=code_", '"_lookupTbl_" do this.vRCvalidateDDerr("""_column_""", $$^MSG(1485, X))"
 ..		E  I (typ="F") D
 ...			;
 ...			S code=code_" do DBSEDT^UFRE(""["_table_"]"_column_""", false)"
 ...			S code=code_" if ER do this.vRCvalidateDDerr("""_column_""", RM)"
 ...			Q 
 ..		E  D
 ...			;
 ...			N min S min=$P(cd,"|",27)
 ...			N max S max=$P(cd,"|",28)
 ...			N pattern S pattern=$P(cd,"|",22)
 ...			;
 ...			I ((typ="$")!(typ="N")) D
 ....				;
 ....				N trimcode S trimcode="'this."_colref_".isNull(), '(+this."_colref_" = this."_colref_") set this."_colref_" = this.vRCtrimNumber(this."_colref_")"
 ....				;
 ....				; Trim any leading or trailing (after decimal point) zeros
 ....				D addLine(.source,ws_" if "_trimcode)
 ....				D addLine(.source2," if this.isChanged("_$$QADD^%ZS($ZCONVERT(colref,"U"),"""")_"), "_trimcode)
 ....				Q 
 ...			;
 ...			I ((typ="T")!(typ="U")),(min=""),(max=""),(pattern="") D
 ....				;
 ....				I (typ="U") D
 .....					;
 .....					; Invalid syntax - use UPPERCASE characters
 .....					S code=" if (this."_colref_" '= this."_colref_".upperCase()) do this.vRCvalidateDDerr("""_column_""", $$^MSG(1476))"
 .....					;
 .....					D addLine2(.source,.source2,ws_code)
 .....					Q 
 ....				;
 ....				I ($P(this("td"),"|",8)'="GTM") S code=""
 ....				; Field length (~p1) exceeded
 ....				E  S code=" if (this."_colref_".length() > "_$P(cd,"|",7)_") do this.vRCvalidateDDerr("""_column_""", $$^MSG(1076, "_$P(cd,"|",7)_"))"
 ....				Q 
 ...			E  I ((typ="$")!(typ="N")),($P(cd,"|",8)'>0) D
 ....				;
 ....				; Data type is defined as ~p1
 ....				I ($P(cd,"|",7)=1) S code=code_", (X '? 1N) do this.vRCvalidateDDerr("""_column_""", $$^MSG(742, ""N""))"
 ....				E  S code=code_", (X '? 1."_$P(cd,"|",7)_"N), (X '? 1""-""1."_($P(cd,"|",7)-1)_"N) do this.vRCvalidateDDerr("""_column_""", $$^MSG(742, ""N""))"
 ....				Q 
 ...			E  I ((typ="B")!(typ="M")) D
 ....				;
 ....				I ($P(this("td"),"|",8)'="GTM") S code=""
 ....				; Field length (~p1) exceeded
 ....				E  S code=" if (this."_colref_".length() > "_$P(cd,"|",7)_") do this.vRCvalidateDDerr("""_column_""", $$^MSG(1076, "_$P(cd,"|",7)_"))"
 ....				Q 
 ...			; Data type is defined as ~p1
 ...			E  I (typ="D") S code=code_", (X '? 1.5N) do this.vRCvalidateDDerr("""_column_""", $$^MSG(742, ""D""))"
 ...			E  I (typ="C") S code=code_", (X '? 1.5N) do this.vRCvalidateDDerr("""_column_""", $$^MSG(742, ""C""))"
 ...			E  I (typ="L") S code=" if '((this."_column_" = true) or (this."_column_" = false)) do this.vRCvalidateDDerr("""_column_""", $$^MSG(742, ""L""))"
 ...			; Use DBSVER
 ...			E  D
 ....				;
 ....				N x
 ....				;
 ....				I '(min="") S min=$$translateKeyWords(this("td"),min,typ,1)
 ....				I '(max="") S max=$$translateKeyWords(this("td"),max,typ,1)
 ....				;
 ....				; Build a parameter string to pass to DBSVER
 ....				S x=$S(typ'["""":""""_typ_"""",1:$$QADD^%ZS(typ,""""))
 ....				S $piece(x,",",2)=$P(cd,"|",7)
 ....				S $piece(x,",",3)=$P(cd,"|",29)
 ....				S $piece(x,",",6)=min
 ....				S $piece(x,",",7)=max
 ....				S $piece(x,",",8)=$P(cd,"|",8)
 ....				; Add last, since may contain commas
 ....				I '(pattern="") S $piece(x,",",5)=$S(pattern'["""":""""_pattern_"""",1:$$QADD^%ZS(pattern,""""))
 ....				;
 ....				; Error ~p1
 ....				S code=code_" set errmsg = $$VAL^DBSVER("_x_") if 'errmsg.isNull() do this.vRCvalidateDDerr("""_column_""", $$^MSG(979, """_table_"."_column_"""_"" ""_errmsg))"
 ....				Q 
 ...			Q 
 ..		;
 ..		I '(code="") D
 ...			;
 ...			D addLine(.source,ws_code)
 ...			D addLine(.source2,ws_" if this.isChanged("_$$QADD^%ZS($ZCONVERT(colref,"U"),"""")_") "_code)
 ...			Q 
 ..		Q 
 .	Q 
 ;
 I isDo D addLine2(.source,.source2," }")
 ;
 D addLine2(.source,.source2," quit")
 ;
 D addLine2(.source,.source2,"")
 ;
 ; Add source2() to bottom of source()
 S seq=""
 F  S seq=$order(source2(seq)) Q:(seq="")  D addLine(.source,source2(seq))
 ;
 ; Add error handling method for validation errors
 D addLine(.source,"private static void vRCvalidateDDerr(String column, String errmsg)")
 ;
 D addLine(.source," type Boolean ER = false")
 D addLine(.source," type String RM = """"")
 D addLine(.source," do Runtime.setErrMSG("""_table_""", 979, """_table_".""_ column_ "" ""_ errmsg)")
 D addLine(.source," if ER do Record"_table_".throwError(RM.get())")
 D addLine(.source," quit")
 ;
 ; Add method to trim leading and trailing (after decimal) from N & $ data types
 D addLine(.source,"")
 D addLine(.source,"private static String vRCtrimNumber(String str)")
 ;
 D addLine(.source," if str.beginsWith(""0"") set str = str.trim(-1, ""0"") if str.isNull() set str = ""0""")
 D addLine(.source," if (str [ "".""), str.endsWith(""0"") set str = str.trim(1, ""0"") if str.endsWith(""."") set str = str.extract(1, str.length() - 1) if str.isNull() set str = ""0""")
 ;
 D addLine(.source," quit str")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
buildvlegacy(this,source) ; Build code into source
 ;
 N keys S keys=$P(this("td"),"|",3)
 N i
 N code N codekeys
 ;
 K source
 ;
 D addLine(.source,"")
 ;
 D addLine(.source,"public static void vlegacy(Number processMode, String params)")
 ;
 I (keys["_") D addLine(.source," quit") Q 
 ;
 D addLine(.source," if (processMode = 2) do {")
 ;
 S codekeys=""
 F i=1:1:$S((keys=""):0,1:$L(keys,",")) D
 .	;
 .	N key S key=$piece(keys,",",i)
 .	;
 .	D addLine(.source,"  type public String "_key)
 .	S codekeys=codekeys_key_"=:"_key_","
 .	Q 
 S codekeys=$E(codekeys,1,$L(codekeys)-1)
 ;
 S code="  type Record"_$P(this,$C(9),2)_" "_$P(this,$C(9),3)_" = Db.getRecord("""_$P(this,$C(9),2)_""""
 ;
 ; 0 keys = CUVAR-like tables
 I ($S((keys=""):0,1:$L(keys,","))>0) S code=code_", """_codekeys_""""
 ;
 S code=code_")"
 ;
 D addLine(.source,code)
 D addLine(.source,"  do "_$P(this,$C(9),3)_".setMode(2)")
 D addLine(.source,"  do "_$P(this,$C(9),3)_".save(params)")
 D addLine(.source," }")
 ;
 D addLine(.source," quit")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
addMsaveCode(this,source) ; Build code into source (*1)
 ;
 N mbNodes S mbNodes="" ; Memo & blob, nodes have special handling
 ;
 ; Get list of memo and blob nodes
 I $P(this,$C(9),9) D
 .	;
 .	N rs,vos1,vos2,vos3,vos4,vos5,vos6  N V1 S V1=$P(this,$C(9),2) S rs=$$vOpen14()
 .	;
 . F  Q:'$$vFetch14()  S mbNodes=$S(((","_mbNodes_",")[(","_rs_",")):mbNodes,1:$S((mbNodes=""):rs,1:mbNodes_","_rs))
 . Q 
 ;
 I ($P(this("td"),"|",4)>1) D
 .	;
 .	N negNodes S negNodes=""
 .	N i
 .	;
 .	; Get list of negative nodes
 .	I ($P(this("td"),"|",15)["""v") D
 ..		;
 ..		N rs,vos7,vos8,vos9,vos10,vos11,vos12,vos13  N V1 S V1=$P(this,$C(9),2) S rs=$$vOpen15()
 ..		;
 ..		F  Q:'$$vFetch15()  D
 ...			;
 ...   I ($E($P(rs,$C(9),1),1)="-") D
 ....				;
 ....    N colrec S colrec=$$getPslCln^UCXDD($P(this,$C(9),2),$P(rs,$C(9),2))
 ....				;
 ....				S negNodes=$S(((","_negNodes_",")[(","_$$getCurNode^UCXDD(colrec,1)_",")):negNodes,1:$S((negNodes=""):$$getCurNode^UCXDD(colrec,1),1:negNodes_","_$$getCurNode^UCXDD(colrec,1)))
 ....				Q 
 ...			Q 
 ..  Q 
 .	;
 .	D addLine(.source,"  type String n")
 .	;
 .	; Handle memos and blobs first
 .	F i=1:1:$S((mbNodes=""):0,1:$L(mbNodes,",")) D
 ..		;
 ..		N col S col=$piece(mbNodes,",",i)
 ..		;
 ..		N colrec S colrec=$$getSchCln^UCXDD($P(this,$C(9),2),col)
 ..		;
 ..		D addLine(.source,"  if vobj(this,"_$$getOldNode^UCXDD(colrec,0)_").exists() do {")
 ..		D addLine(.source,"   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
 ..		D addLine(.source,"   #BYPASS")
 ..		D addLine(.source,"  "_$$getSavCode^UCXDD(this("td"),"this","*"_col,-1))
 ..		D addLine(.source,"   #ENDBYPASS")
 ..		D addLine(.source,"  }")
 ..		Q 
 .	;
 .	D addLine(.source,"  set n = -1")
 .	D addLine(.source,"  for  set n = vobj(this, n).order() quit:n.isNull()  do {")
 .	;
 .	; Handle negative nodes
 .	F i=1:1:$S((negNodes=""):0,1:$L(negNodes,",")) D
 ..		;
 ..		D addLine(.source,"   if n = "_$piece(negNodes,",",i)_" do { quit")
 ..		D addLine(.source,"   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
 ..		D addLine(.source,"   #BYPASS")
 ..		D addLine(.source,"   "_$$getSavCode^UCXDD(this("td"),"this",$piece(negNodes,",",i),-1))
 ..		D addLine(.source,"   #ENDBYPASS")
 ..		D addLine(.source,"   }")
 ..		Q 
 .	;
 .	D addLine(.source,"   quit:'vobj(this,n).exists()")
 .	;
 .	; Handle "non-special" nodes
 .	D addLine(.source,"   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
 .	D addLine(.source,"   #BYPASS")
 .	D addLine(.source,"  "_$$getSavCode^UCXDD(this("td"),"this","n",-1))
 .	D addLine(.source,"   #ENDBYPASS")
 .	D addLine(.source,"  }")
 .	;
 .	; Top level for type 11
 .	I ($P(this("td"),"|",4)=11) D
 ..		;
 ..		; Allow global reference and M source code
 ..		D addLine(.source,"  #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
 ..		D addLine(.source,"  #BYPASS")
 ..		D addLine(.source,"  if $D(vobj(this))"_$$getSavCode^UCXDD(this("td"),"this","",-1))
 ..		D addLine(.source,"  #ENDBYPASS")
 ..		Q 
 .	Q 
 E  I ($P(this("td"),"|",4)=1) D
 .	;
 .	D addLine(.source,"  #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
 .	D addLine(.source,"  #BYPASS")
 .	D addLine(.source,"  if $D(vobj(this))"_$$getSavCode^UCXDD(this("td"),"this","",-1))
 .	D addLine(.source,"  #ENDBYPASS")
 .	;
 .	I '(mbNodes="") D
 ..		;
 ..		; Will only be a single column
 ..		N colrec S colrec=$$getSchCln^UCXDD($P(this,$C(9),2),$piece(mbNodes,",",1))
 ..		;
 ..		D addLine(.source,"   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
 ..		D addLine(.source,"   #BYPASS")
 ..		D addLine(.source,"   if $D(vobj(this,"_$$getCurNode^UCXDD(colrec,1)_"))"_$$getSavCode^UCXDD(this("td"),"this","*"_$piece(mbNodes,",",1),-1))
 ..		D addLine(.source,"   #ENDBYPASS")
 ..		Q 
 .	Q 
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
addRDBsaveCode(this,source) ; Build code into source (*1)
 ;
 N saveLabel N where
 ;
 I $$isOneNode^UCXDD(this("td")),'$$isParent^UCXDD(this("td")) S saveLabel="rdbSaveS"
 E  S saveLabel="rdbSaveC"
 ;
 S where=$$getPrimaryKeyWhere^UCXDD(this("td"))
 ;
 I $P(this,$C(9),9) D addLine(.source,"  if 'vobj(this,-152).exists()"_$$getUpdKey^UCXDD(this("td"),"this"))
 ;
 D addLine(.source,"  do "_saveLabel_"^UCDBRT(this,"_$P(this,$C(9),4)_","_$S(where'["""":""""_where_"""",1:$$QADD^%ZS(where,""""))_")")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
findTableRef(this,ref,tableList,primTable,makeThis,doLC) ; Make table.column lowercase
 ;
 N ptr S ptr=0
 N atom N atomUC
 N delimiters S delimiters=",()+-*/\#'=><[]\*_:"
 N return S return=""
 N tok S tok=""
 ;
 ;  #ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
 S ref=$$TOKEN^%ZS(ref,.tok)
 ;
 F  D  Q:(ptr=0) 
 .	;
 .	;   #ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
 .	S atom=$$ATOM^%ZS(ref,.ptr,delimiters,.tok,1)
 .	;
 .	I (atom?1A.AN.E1".".E.AN) D  ; table.column
 ..		;
 ..		N table S table=$piece(atom,".",1)
 ..		;
 ..		; Ignore NEXTVAL - will be handled at journal construction
 ..		I '(atom["NEXTVAL") D
 ...			;
 ...			N isOld S isOld=(table="OLD")
 ...			N isNew S isNew=(table="NEW")
 ...			N col S col=$piece(atom,".",2)
 ...			;
 ...			I ((table=primTable)!isOld!isNew),makeThis D
 ....				;
 ....				S table="this"
 ....				S col=$$colName(col,"LC",1)
 ....				Q 
 ...			E  S tableList=$S(((","_tableList_",")[(","_$ZCONVERT(table,"U")_",")):tableList,1:$S((tableList=""):$ZCONVERT(table,"U"),1:tableList_","_$ZCONVERT(table,"U")))
 ...			;
 ...			; Replace table.column reference with object reference
 ...			S atom=$ZCONVERT((table_"."_col),"U")
 ...			I doLC S atom=$ZCONVERT(atom,"L")
 ...			;
 ...			I isOld S atom=atom_".oldVal"
 ...			E  I isNew S atom=atom_".curVal"
 ...			Q 
 ..		Q 
 .	;
 .	; Ignore delimiters and quoted strings
 .	E  I ($L(atom)>1),'($E(atom,1,$L($char(0)))=$char(0)) S atom=$$translateKeyWords(this("td"),atom,"",0)
 .	;
 .	; Retain whitespace around and, or, not
 .	I ($L(atom)>1) D
 ..		;
 ..		S atomUC=$ZCONVERT(atom,"U")
 ..		I (",AND,OR,NOT,"[(","_atomUC_",")) S atom=" "_atom_" "
 ..		Q 
 .	S return=return_atom
 .	Q 
 ;
 ;  #ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
 I '(tok="") S return=$$UNTOK^%ZS(return,tok)
 ;
 Q return
 ;
 ; ---------------------------------------------------------------------
getIndexCode(this,indexes,indexnm,idxdesc,global,orderby,isUpcase,tknzr) ; Tokenizer object
 ;
 N isAllKeys S isAllKeys=1
 N keys
 N i N indexSeq
 N code N indexCode N indexKey N indexKeys N nonKeys
 ;
 S indexSeq=$P(this,$C(9),6)
 S $P(this,$C(9),6)=indexSeq+1
 ;
 S keys=$P(this("td"),"|",3)
 S (indexKeys,nonKeys)=""
 ;
 D addLine(.indexCode,"")
 D addLine(.indexCode,"private void vRCIdx"_indexSeq_"(Number processMode) // "_indexnm_" ("_idxdesc_")")
 ;
 I isUpcase D addLine(.indexCode," type Boolean deleteOK = false")
 ;
 ; Analyze order by keys, build map of non-keys, and generate assignment code.
 ;
 F i=1:1:$S((orderby=""):0,1:$L(orderby,",")) D
 .	;
 .	S indexKey=$piece(orderby,",",i)
 .	;
 .	I $$isLit^UCGM(indexKey) S indexKeys=indexKeys_indexKey_","
 .	E  D
 ..		;
 ..		N isKey S isKey=0
 ..		;
 ..		N cd S cd=$$getPslCln^UCXDD($P(this,$C(9),2),indexKey)
 ..		;
 ..		I '($P(cd,"|",14)="") S $ZE="0,"_$ZPOS_","_"%PSL-E-INVALID,Aborted - Index "_indexnm_" uses computed column "_indexKey,$EC=",U1001,"
 ..		;
 ..		I ((","_keys_",")[(","_indexKey_",")) S isKey=1
 ..		E  D
 ...			;
 ...			S isAllKeys=0
 ...			S $piece(nonKeys,",",i)=indexKey
 ...			Q 
 ..		;
 ..		S indexKeys=indexKeys_"ikey"_i_","
 ..		;
 ..		; Assign variable
 ..		S code=" type String "_"ikey"_i_" = this."_$$colName(indexKey,"LC",1)
 ..		I $P(cd,"|",9),(($P(cd,"|",6)="N")!($P(cd,"|",6)="$")) S code=code_".toNumber().toString()"
 ..		I isUpcase,(($P(cd,"|",6)="F")!($P(cd,"|",6)="T")) S code=code_".upperCase()"
 ..		;
 ..		D addLine(.indexCode,code)
 ..		;
 ..		; If not a key in primary table, assign default for null value
 ..		I 'isKey D addLine(.indexCode," if "_"ikey"_i_".isNull() set "_"ikey"_i_" = 254.byte()")
 ..		Q 
 .	Q 
 ;
 S indexKeys=$E(indexKeys,1,$L(indexKeys)-1)
 ;
 ; Define global name
 I (global="") S global="^XDBREF("""_$P(this,$C(9),2)_"."_indexnm_""","_indexKeys_")"
 E  S global="^"_global_"("_indexKeys_")"
 ;
 ; Add processing code - processMode = 2 is integrity check mode
 D addLine(.indexCode," if (processMode = 2) do { quit")
 ;
 D addLine(.indexCode,"  #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
 D addLine(.indexCode,"  #BYPASS")
 I (+$P(this("td"),"|",4)'=+1) S code="  if '$D("_global_") "
 E  D
 .	;
 .	N globalRef S globalRef=$$getGbl^UCXDD(this("td"),"this")
 .	;
 .	I ($E(globalRef,$L(globalRef))=",") S globalRef=$E(globalRef,1,$L(globalRef)-1)
 .	;
 .	S code="  if $D("_globalRef_"))#2,'$D("_global_") "
 .	Q 
 ;
 S code=code_"do SETERR^DBSEXECU("""_$P(this,$C(9),2)_""",""MSG"",1225,"""_$P(this,$C(9),2)_"."_indexnm_""")"
 ;
 D addLine(.indexCode,code)
 D addLine(.indexCode,"  #ENDBYPASS")
 D addLine(.indexCode," }")
 ;
 D addLine(.indexCode," #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
 D addLine(.indexCode," #BYPASS")
 ;
 S code=" if (processMode<2) set "_global_"="""" "
 ;
 I isAllKeys S code=code_"quit" ; No old entry to remove
 ;
 D addLine(.indexCode,code)
 D addLine(.indexCode," #ENDBYPASS")
 ;
 D addLine(.indexCode," quit:(processMode = 0)")
 ;
 I isUpcase D addLine(.indexCode," if (processMode = 3) set deleteOK = true")
 ;
 ; Remove old entry
 F i=1:1:$L(nonKeys,",") S indexKey=$piece(nonKeys,",",i) I '(indexKey="") D
 .	;
 .	N var S var="ikey"_i
 .	;
 .	D addLine(.indexCode," if this.isChanged("_$$QADD^%ZS($$colName(indexKey,"UC",0),"""")_") do {")
 .	S code="  set "_var_" = this."_$$colName(indexKey,"LC",1)_".oldVal"
 .	I isUpcase S code=code_".upperCase()"
 .	D addLine(.indexCode,code)
 .	D addLine(.indexCode,"  if "_var_".isNull() set "_var_" = 254.byte(")
 .	I isUpcase D addLine(.indexCode,"  if ("_var_" '= this."_$$colName(indexKey,"LC",1)_".upperCase()) set deleteOK = true")
 .	D addLine(.indexCode," }")
 .	Q 
 ;
 I isUpcase D addLine(.indexCode," quit:'deleteOK") ; Only case changed
 ;
 D addLine(.indexCode," #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
 D addLine(.indexCode," #BYPASS")
 D addLine(.indexCode," kill "_global)
 D addLine(.indexCode," #ENDBYPASS")
 ;
 D addLine(.indexCode," quit")
 ;
 D appendSrc^PSLTokenizer(.tknzr,.indexCode) ; Add index code
 ;
 ; Save list of non-key columns for optimization in IDXOPT
 S indexes(indexSeq)=indexnm_"|"_nonKeys
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
getJournalCode(this,journals,sort,hasIfConds,ifConds,tknzr) ; Tokenizer object
 ;
 N i N jrnseq
 N code N column N primTable N value
 ;
 S primTable=$P(this,$C(9),2)
 ;
 N rs,vos1,vos2,vos3,vos4,vos5  N V1 S V1=$P(this,$C(9),2) S rs=$$vOpen16()
 ;
 S jrnseq=0
 F  Q:'$$vFetch16()  D
 .	;
 .	N isDo S isDo=0
 . N incolumn S incolumn=$P(rs,$C(9),6)
 .	N jrnkeys
 .	N oldNewFM S oldNewFM=""
 .	N tableList S tableList=""
 . N jrnid S jrnid=$P(rs,$C(9),1)
 . N mode S mode=$P(rs,$C(9),7)
 .	N columnMap N jrnCode N jrnTableLC N jrnTableUC N key N lastkey
 .	N ws S ws=" "
 .	;
 . S jrnTableUC=$P(rs,$C(9),11)
 .	S jrnTableLC=$ZCONVERT(jrnTableUC,"L")
 .	;
 .	I '$$isTable^UCXDD(jrnTableUC) S $ZE="0,"_$ZPOS_","_"%PSL-E-INVALID,Aborted - invalid table name ("_jrnTableUC_") for journal "_$P(this,$C(9),2)_" - "_jrnid,$EC=",U1001,"
 .	;
 .	N tdjrn S tdjrn=$$getPslTbl^UCXDD(jrnTableUC,0)
 .	;
 .	S jrnkeys=$P(tdjrn,"|",3)
 .	S lastkey=$piece(jrnkeys,",",$S((jrnkeys=""):0,1:$L(jrnkeys,",")))
 .	;
 .	; Build MAP and determine if any other tables involved
 .	N rs9d,vos6,vos7,vos8,vos9,vos10,vos11  N V2,V3 S V2=$P(this,$C(9),2),V3=jrnid S rs9d=$$vOpen17()
 .	;
 .	; Only save map for columns that are mapped to some value
 .	S tableList=$P(this,$C(9),2)
 .	;
 . F  Q:'$$vFetch17()  I $P(rs9d,$C(9),2)'="" D
 ..		;
 ..  S value=$P(rs9d,$C(9),2)
 ..		;
 ..		I (value["OldValue") S oldNewFM=$S(((","_oldNewFM_",")[",old,"):oldNewFM,1:$S((oldNewFM=""):"old",1:oldNewFM_","_"old"))
 ..		I (value["NewValue") S oldNewFM=$S(((","_oldNewFM_",")[",new,"):oldNewFM,1:$S((oldNewFM=""):"new",1:oldNewFM_","_"new"))
 ..		I (value["FmTable") S oldNewFM=$S(((","_oldNewFM_",")[",fm,"):oldNewFM,1:$S((oldNewFM=""):"fm",1:oldNewFM_","_"fm"))
 ..		;
 ..		; Get other tables and translate keywords
 ..		S value=$$findTableRef(.this,value,.tableList,primTable,1,1)
 ..  S columnMap($P(rs9d,$C(9),1))=value
 ..		Q 
 .	;
 .	S jrnseq=jrnseq+1
 . S journals(jrnid)=jrnseq_$char(9)_oldNewFM_$char(9)_$P(rs,$C(9),5)
 . S sort(mode,$P(rs,$C(9),12),$P(rs,$C(9),3),$P(rs,$C(9),10),'(incolumn=""),jrnid)=incolumn
 . I '($P(rs,$C(9),5)="") S hasIfConds=1
 .	;
 .	D addLine(.jrnCode,"")
 .	S code="private void vRCJrn"_jrnseq_"(String vRCaudit()"
 .	;
 .	; If INCOLUMN, then include parameter passed as well
 .	I '(incolumn="") S code=code_", String column"
 .	;
 .	D addLine(.jrnCode,code_")")
 . D addLine(.jrnCode," // "_jrnid_" - "_$P(rs,$C(9),2))
 .	;
 .	I (mode="U"),(incolumn="") D addLine(.jrnCode," type String column = """"")
 .	D addLine(.jrnCode," type String lastkey")
 .	;
 .	I ($S((jrnkeys=""):0,1:$L(jrnkeys,","))>1) D
 ..		;
 ..		S code=" type String "
 ..		F i=1:1:$S((jrnkeys=""):0,1:$L(jrnkeys,","))-1 S code=code_"key"_i_", "
 ..		D addLine(.jrnCode,$E(code,1,$L(code)-2))
 ..		Q 
 .	;
 .	; If queries or multiple tables, add code to load other objects and execute queries
 . D getJrnQueryCode(.this,.jrnCode,tableList,$P(rs,$C(9),8),$P(rs,$C(9),9))
 .	;
 .	; Assign key values
 .	I ($S((jrnkeys=""):0,1:$L(jrnkeys,","))>1) F i=1:1:$S((jrnkeys=""):0,1:$L(jrnkeys,","))-1 D addLine(.jrnCode," set key"_i_" = "_columnMap($piece(jrnkeys,",",i)))
 .	;
 .	; If update mode, generate journal for each change
 .	I (mode="U") D
 ..		;
 ..  N excolumn S excolumn=$P(rs,$C(9),4)
 ..		;
 ..		; No include or exclude - do them all
 ..		I (incolumn=""),(excolumn="") D
 ...			;
 ...			S code=" for  set column = vRCaudit(column).order() quit:column.isNull()  do {"
 ...			I (oldNewFM="") S code=code_" quit"
 ...			;
 ...			D addLine(.jrnCode,code)
 ...			;
 ...			S isDo=1
 ...			Q 
 ..		E  I '(excolumn="") D
 ...			;
 ...			S code=" for  set column = vRCaudit(column).order() quit:column.isNull()"
 ...			;
 ...			; Piece 3 of vx = 1 indicates journal flag off for this column
 ...			S code=code_"  if 'vRCaudit(column).piece(""|"",3)"
 ...			;
 ...			S code=code_", '({List}"""_excolumn_""").contains(column) do {"
 ...			I (oldNewFM="") S code=code_" quit"
 ...			;
 ...			D addLine(.jrnCode,code)
 ...			;
 ...			S isDo=1
 ...			Q 
 ..		;
 ..		I isDo S ws="  "
 ..		Q 
 .	;
 .	; Set up lastkey
 .	I (columnMap(lastkey)["NEXTVAL") D
 ..		;
 ..		N value
 ..		;
 ..		S code=""
 ..		F i=1:1:$S((jrnkeys=""):0,1:$L(jrnkeys,","))-1 D
 ...			;
 ...			S key=$piece(jrnkeys,",",i)
 ...			S value=columnMap(key)
 ...			I '$$isLit^UCGM(value) S value=":"_value
 ...			S code=code_key_"="_value_","
 ...			Q 
 ..		I ($E(code,$L(code))=",") S code=$E(code,1,$L(code)-1)
 ..		S code="Db.nextVal("""_jrnTableUC_""","_$S(code'["""":""""_code_"""",1:$$QADD^%ZS(code,""""))_")"
 ..		Q 
 .	E  S code=columnMap(lastkey)
 .	;
 .	D addLine(.jrnCode,ws_"set lastkey = "_code)
 .	;
 .	S code="type Record"_jrnTableUC_" "_jrnTableLC_" = Db.getRecord("""_jrnTableUC_""", """
 .	F i=1:1:$S((jrnkeys=""):0,1:$L(jrnkeys,","))-1 S code=code_$piece(jrnkeys,",",i)_"=:key"_i_","
 .	S code=code_lastkey_"=:lastkey"", true)"
 .	;
 .	D addLine(.jrnCode,ws_code)
 .	;
 .	; Set values into non-key columns
 .	S column=""
 .	F  S column=$order(columnMap(column)) Q:(column="")  I '((","_jrnkeys_",")[(","_column_",")) D
 ..		;
 ..		S code="set "_jrnTableLC_"."_$$colName(column,"LC",1)_" = "_columnMap(column)
 ..		D addLine(.jrnCode,ws_code)
 ..		Q 
 .	;
 .	D addLine(.jrnCode,ws_"do "_jrnTableLC_".save(""/NOVALFK/NOVALDD/NOVALRI"")")
 .	;
 .	I isDo D addLine(.jrnCode," }")
 .	;
 .	D addLine(.jrnCode," quit")
 .	;
 .	D appendSrc^PSLTokenizer(.tknzr,.jrnCode) ; Add journal code
 . Q 
 ;
 ; All journals processed, finish final processing on sort
 D setJournalSort(.this,.sort)
 ;
 I hasIfConds D
 .	;
 .	N withIf
 .	N efdopt N incol N jrnid N mode N mteStr N mtStr N prio N trantype N x
 .	;
 .	S (efdopt,incol,jrnid,mode,prio,trantype)=""
 .	;
 .	F  S mode=$order(sort(mode)) Q:(mode="")  D
 ..		S withIf(mode)=""
 ..		F  S trantype=$order(sort(mode,trantype)) Q:(trantype="")  D
 ...			S mtStr=mode_"-"_trantype
 ...			S withIf(mtStr)=""
 ...			F  S efdopt=$order(sort(mode,trantype,efdopt)) Q:(efdopt="")  D
 ....				S mteStr=mode_"-"_trantype_"-"_efdopt
 ....				S withIf(mteStr)=""
 ....				F  S prio=$order(sort(mode,trantype,efdopt,prio)) Q:(prio="")  D
 .....					F  S incol=$order(sort(mode,trantype,efdopt,prio,incol)) Q:(incol="")  D
 ......						F  S jrnid=$order(sort(mode,trantype,efdopt,prio,incol,jrnid)) Q:(jrnid="")  D
 .......							;
 .......							I ($piece(journals(jrnid),$char(9),3)="") S x="*"
 .......							E  S x=jrnid
 .......							;
 .......							S withIf(mode)=$S(((","_withIf(mode)_",")[(","_x_",")):withIf(mode),1:$S((withIf(mode)=""):x,1:withIf(mode)_","_x))
 .......							S withIf(mtStr)=$S(((","_withIf(mtStr)_",")[(","_x_",")):withIf(mtStr),1:$S((withIf(mtStr)=""):x,1:withIf(mtStr)_","_x))
 .......							S withIf(mteStr)=$S(((","_withIf(mteStr)_",")[(","_x_",")):withIf(mteStr),1:$S((withIf(mteStr)=""):x,1:withIf(mteStr)_","_x))
 .......							Q 
 ......						Q 
 .....					Q 
 ....				Q 
 ...			Q 
 ..		Q 
 .	;
 .	S x=""
 .	F  S x=$order(withIf(x)) Q:(x="")  D
 ..		;
 ..		I ((","_withIf(x)_",")[",*,") S ifConds(x)=""
 ..		E  D
 ...			;
 ...			N i
 ...			N code S code=""
 ...			;
 ...			F i=1:1:$S((withIf(x)=""):0,1:$L(withIf(x),",")) S code=code_"("_$piece(journals($piece(withIf(x),",",i)),$char(9),3)_") and "
 ...			;
 ...			S ifConds(x)=$E(code,1,$L(code)-5)
 ...			Q 
 ..		Q 
 .	Q 
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
getJrnQueryCode(this,jrnCode,tableList,query1,query2) ; dbtbl9d.query2
 ;
 N isDummyQry S isDummyQry=0
 N isVarInsert S isVarInsert=0
 N qrybldTbls S qrybldTbls=""
 N i
 N varSeq S varSeq=0
 N code N input N pslobj N pslqry N query N varSub
 ;
 ; Nothing to add
 Q:((query1="")&(query2="")&($S((tableList=""):0,1:$L(tableList,","))'>1)) 
 ;
 I ((query1="")&(query2="")) S query=""
 E  D
 .	;
 .	N tok
 .	;
 .	I (query1=""),'(query2="") S query=query2
 .	E  I (query2="") S query=query1
 .	E  S query="("_query1_") and ("_query2_")"
 .	;
 .	I (query["<<") S isVarInsert=1
 .	;
 .	S query=$$findTableRef(.this,query,.tableList,$P(this,$C(9),2),isVarInsert,isVarInsert)
 .	;
 .	;   #ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
 .	S query=$$TOKEN^%ZS(query,.tok)
 .	;
 .	I isVarInsert D
 ..		;
 ..		N expression
 ..		N newquery S newquery=""
 ..		;
 ..		F  Q:'('(query=""))  D
 ...			;
 ...			S newquery=newquery_$piece(query,"<<",1)_"<<"
 ...			S expression=$piece($piece(query,"<<",2),">>",1)
 ...			; Handled "less than", e.g., X<<<$$^ABC>>
 ...			I ($E(expression,1)="<") D
 ....				;
 ....				S newquery=newquery_"<"
 ....				S expression=$E(expression,2,1048575)
 ....				Q 
 ...			;
 ...			S varSeq=varSeq+1
 ...			;     #ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
 ...			S varSub(varSeq)=$$UNTOK^%ZS(expression,tok)
 ...			S newquery=newquery_"QRY"_varSeq_">>"
 ...			;
 ...			; Add declaration for this variable
 ...			D addLine(.jrnCode," type String QRY"_varSeq)
 ...			;
 ...			S query=$piece(query,">>",2,1048575)
 ...			I '(query["%<<%") D
 ....				;
 ....				S newquery=newquery_query
 ....				S query=""
 ....				Q 
 ...			Q 
 ..		;
 ..		S query=newquery
 ..		Q 
 .	;
 .	;   #ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
 .	S query=$$UNTOK^%ZS(query,tok)
 .	Q 
 ;
 ; If all we are dealing with is a need to load other table info use a dummy query
 I (query=""),($S((tableList=""):0,1:$L(tableList,","))>1) D
 .	;
 .	S isDummyQry=1
 .	S query="1>0"
 .	Q 
 ;
 ; Convert to SQL FROM and WHERE to allow call to UCQRYBLD
 ;  #ACCEPT Date=06/10/2008; Pgm=RussellDS; CR=30801; Group=ACCESS
 S input("WHERE")=$$WHERE^SQLCONV(query,tableList)
 ;  #ACCEPT Date=06/10/2008; Pgm=RussellDS; CR=30801; Group=ACCESS
 S input("FROM")=$$DQJOIN^SQLCONV(tableList)
 ;
 D ^UCQRYBLD(.input,$P(this,$C(9),2)_"=this",,.pslobj,.pslqry)
 ;
 I ($D(pslobj)>0) D
 .	;
 .	N n N seq
 .	;
 .	S (n,seq)=""
 .	F  S n=$order(pslobj(n)) Q:(n="")  D
 ..		F  S seq=$order(pslobj(n,seq)) Q:(seq="")  D
 ...			;
 ...			S code=pslobj(n,seq)
 ...			;
 ...			I (seq=1) D
 ....				;
 ....				N qrybldObj S qrybldObj=$$vStrTrim($piece($piece(code,"=",1)," ",3),0," ")
 ....				N table S table=$ZCONVERT($piece(pslobj(n),"|",1),"L")
 ....				;
 ....				S code=$$vStrRep(code,qrybldObj,table,0,0,"")
 ....				S qrybldTbls=$S(((","_qrybldTbls_",")[(","_(qrybldObj_"|"_table)_",")):qrybldTbls,1:$S((qrybldTbls=""):(qrybldObj_"|"_table),1:qrybldTbls_","_(qrybldObj_"|"_table)))
 ....				;
 ....				; Add 3rd parameter
 ....				S code=$E(code,1,$L(code)-1)_", true)"
 ....				Q 
 ...			D addLine(.jrnCode," "_code)
 ...			Q 
 ..		Q 
 .	Q 
 ;
 ; If any variable substition for queries, set it
 I (varSeq>0) F i=1:1:varSeq D addLine(.jrnCode," set QRY"_varSeq_" = "_varSub(i))
 ;
 ; Insert query logic - for tables instantiated by query logic, replace object names
 I 'isDummyQry D
 .	;
 .	N seq
 .	N qrybldTbl N table
 .	;
 .	S seq=""
 .	F  S seq=$order(pslqry(seq)) Q:(seq="")  D
 ..		;
 ..		F i=1:1:$S((qrybldTbls=""):0,1:$L(qrybldTbls,",")) D
 ...			;
 ...			S qrybldTbl=$piece($piece(qrybldTbls,",",i),"|",1)
 ...			S table=$piece($piece(qrybldTbls,",",i),"|",2)
 ...			;
 ...			S pslqry(seq)=$$vStrRep(pslqry(seq),qrybldTbl,table,0,0,"")
 ...			Q 
 ..		D addLine(.jrnCode," if "_pslqry(seq))
 ..		D addLine(.jrnCode," else  quit")
 ..		Q 
 .	Q 
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
setJrnSortSplit(this,sort,mode,modeval,trantype,trantypeval,efdopt,efdoptval) ; Individual efdopt value
 ;
 N incol N jrnid N prio
 ;
 S (incol,jrnid,prio)=""
 F  S prio=$order(sort(mode,trantype,efdopt,prio)) Q:(prio="")  D
 .	F  S incol=$order(sort(mode,trantype,efdopt,prio,incol)) Q:(incol="")  D
 ..		F  S jrnid=$order(sort(mode,trantype,efdopt,prio,incol,jrnid)) Q:(jrnid="")  D
 ...			S sort(modeval,trantypeval,efdoptval,prio,incol,jrnid)=sort(mode,trantype,efdopt,prio,incol,jrnid)
 ...			Q 
 ..		Q 
 .	Q 
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
getLogCode(this,column,system,typ) ; data type
 ;
 N code S code=""
 ;
 I '(column=""),$$isColumn^UCXDD($P(this,$C(9),2),column) D
 .	;
 .	S code=" set this."_$$colName(column,"LC",1)_" = "
 .	I (typ="D") S code=code_$S(system="PBS":"%SystemDate",1:"%CurrentDate")
 .	E  I (typ="T") S code=code_"%CurrentTime"
 .	E  I (typ="U") D
 ..		;
 ..		N cd S cd=$$getPslCln^UCXDD($P(this,$C(9),2),$ZCONVERT(column,"U"))
 ..		;
 ..		; Ensure truncate value in case too long
 ..		S code=code_$S(system="DBS":"%UserName",1:"%UserID")_".extract(1, "_$P(cd,"|",7)_")"
 ..		;
 ..		; For DBS, allow change from external interfaces
 ..		I (system="DBS") S code=" if 'this.isChanged("_$$QADD^%ZS($$colName(column,"UC",0),"""")_", ""USER"")"_code
 ..		Q 
 .	Q 
 ;
 Q code
 ;
 ; ---------------------------------------------------------------------
getSections(this) ; 
 ;
 N hasTrigger N hasTriggerKO N isDone
 N keys S keys=$P(this("td"),"|",3)
 N i
 N ifCond
 ;
 S this("sections")=""
 ;
 S isDone=0
 ;
 I '($P(this("td"),"|",8)'="GTM") D
 .	;
 .	N table
 .	;
 .	N rsi,vos1,vos2,vos3,vos4,vos5  N V1 S V1=$P(this,$C(9),2) S rsi=$$vOpen18()
 . I ''$G(vos1) S this("sections")=$S((this("sections")=""):"indexes",1:this("sections")_","_"indexes")
 .	;
 .	I '($P(this("td"),"|",30)="") S this("sections")=$S((this("sections")=""):"required",1:this("sections")_","_"required")
 .	;
 .	; Check for foreign keys, this table plus all ancestors
 .	S table=$P(this,$C(9),2)
 .	F  Q:'('(table=""))  D
 ..		;
 ..		N rsfk,vos6,vos7,vos8,vos9,vos10,vos11  N V2 S V2=table S rsfk=$$vOpen19()
 ..  I ''$G(vos6) D  Q 
 ...			;
 ...			S this("sections")=$S((this("sections")=""):"foreignKeys",1:this("sections")_","_"foreignKeys")
 ...			S table="" ; We're done
 ...			Q 
 ..		;
 ..		; Check ancestor
 ..		I $P(this,$C(9),2)=table S table=$P(this("td"),"|",7)
 ..		E  D
 ...			;
 ...			N td2 S td2=$$getPslTbl^UCXDD(table,0)
 ...			S table=$P(td2,"|",7)
 ...			Q 
 ..  Q 
 . Q 
 ;
 F i=1:1:$S(($P(this("td"),"|",29)=""):0,1:$L($P(this("td"),"|",29),",")) D  Q:isDone 
 .	;
 .	N cd S cd=$$getSchCln^UCXDD($P(this,$C(9),2),$piece($P(this("td"),"|",29),",",i))
 .	;
 .	I '($P(cd,"|",19)=""),($P(cd,"|",14)="") D
 ..		;
 ..		S this("sections")=$S((this("sections")=""):"defaults",1:this("sections")_","_"defaults")
 ..		S isDone=1
 ..		Q 
 .	Q 
 ;
 N rsj,vos12,vos13,vos14,vos15  N V1 S V1=$P(this,$C(9),2) S rsj=$$vOpen20()
 I ''$G(vos12) S this("sections")=$S((this("sections")=""):"journals",1:this("sections")_","_"journals")
 ;
 N rscd,vos16,vos17,vos18,vos19,vos20  N V2 S V2=$P(this,$C(9),2) S rscd=$$vOpen21()
 I ''$G(vos16) S this("sections")=$S((this("sections")=""):"cascadeDelete",1:this("sections")_","_"cascadeDelete")
 ;
 F i=1:1:6 S hasTrigger(i)=0 ; Any triggers of this type?
 F i=1:1:6 S hasTriggerKO(i)=1 ; Only triggers on keys?
 F i=1:1:6 S ifCond(i)="" ; All conditional code
 ;
 N rst,vos21,vos22,vos23,vos24,vos25  N V3 S V3=$P(this,$C(9),2) S rst=$$vOpen22()
 F  Q:'$$vFetch22()  D
 .	;
 .	N ifcond N triggers
 .	;
 . S triggers=$P(rst,$C(9),1)_","_$P(rst,$C(9),2)_","_$P(rst,$C(9),3)_","_$P(rst,$C(9),4)_","_$P(rst,$C(9),5)_","_$P(rst,$C(9),6)
 . S ifcond=$P(rst,$C(9),8)
 .	;
 .	F i=1:1:6 I $piece(triggers,",",i) D
 ..		;
 ..		S hasTrigger(i)=1
 ..		;
 ..		I (ifcond="") S ifCond(i)="*" ; All don't have ifcond
 ..		E  S ifCond(i)=ifCond(i)_"("_ifcond_") and "
 ..		;
 ..		; Check if trigger involves keys only (BU and AU only)
 ..		I ((i=2)!(i=5)),hasTriggerKO(i) D
 ...			;
 ...   N columns S columns=$P(rst,$C(9),7)
 ...			N j
 ...			;
 ...			I ($S((columns=""):0,1:$L(columns,","))=0) S hasTriggerKO(i)=0 ; Applies to all columns
 ...			E  F j=1:1:$S((columns=""):0,1:$L(columns,",")) I '((","_keys_",")[(","_$piece(columns,",",j)_",")) S hasTriggerKO(i)=0 Q 
 ...			Q 
 ..		Q 
 .	Q 
 ;
 I hasTrigger(1) S this("sections")=$S((this("sections")=""):"BI",1:this("sections")_","_"BI")
 I hasTrigger(2) S this("sections")=$S((this("sections")=""):"BU",1:this("sections")_","_"BU")
 I hasTrigger(3) S this("sections")=$S((this("sections")=""):"BD",1:this("sections")_","_"BD")
 I hasTrigger(4) S this("sections")=$S((this("sections")=""):"AI",1:this("sections")_","_"AI")
 I hasTrigger(5) S this("sections")=$S((this("sections")=""):"AU",1:this("sections")_","_"AU")
 I hasTrigger(6) S this("sections")=$S((this("sections")=""):"AD",1:this("sections")_","_"AD")
 ;
 F i=1:1:6 I hasTrigger(i) S this("sections")=$S((this("sections")=""):"triggers",1:this("sections")_","_"triggers") Q 
 ;
 I hasTrigger(2),hasTriggerKO(2) S this("sections")=$S((this("sections")=""):"BUKO",1:this("sections")_","_"BUKO")
 I hasTrigger(5),hasTriggerKO(5) S this("sections")=$S((this("sections")=""):"AUKO",1:this("sections")_","_"AUKO")
 ;
 F i=1:1:6 S this("trigAllIf",i)=""
 F i=1:1:6 I '(ifCond(i)=""),(ifCond(i)'="*") D
 .	;
 .	S this("trigAllIf",i)=$E(ifCond(i),1,$L(ifCond(i))-5)
 .	Q 
 ;
 N rslit,vos26,vos27,vos28,vos29  N V4 S V4=$P(this,$C(9),2) S rslit=$$vOpen23()
 I ''$G(vos26) S this("sections")=$S((this("sections")=""):"literals",1:this("sections")_","_"literals")
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
getTriggerCode(this,dispatch,ifConds,trgid,actbi,actbu,actbd,actai,actau,actad,columns,des,ifcond,tknzr) ; Tokenizer object
 ;
 N hasTrigger
 N i N lastLine N trigSeq
 N code N trigCode
 ;
 S trigSeq=$P(this,$C(9),5)
 S $P(this,$C(9),5)=trigSeq+1
 ;
 S hasTrigger(1)=actbi
 S hasTrigger(2)=actbu
 S hasTrigger(3)=actbd
 S hasTrigger(4)=actai
 S hasTrigger(5)=actau
 S hasTrigger(6)=actad
 ;
 F i=1:1:6 I hasTrigger(i) D
 .	;
 .	N isInsOrDel S isInsOrDel='((i=2)!(i=5))
 .	;
 .	I ((columns="")!isInsOrDel) S dispatch(i,1,trigSeq)=""
 .	E  D
 ..		;
 ..		I '($D(dispatch(i,2,columns))#2) S dispatch(i,2,columns)=trigSeq
 ..		E  S dispatch(i,2,columns)=dispatch(i,2,columns)_","_trigSeq
 ..		Q 
 .	Q 
 ;
 I '(ifcond="") S ifConds(trigSeq)=ifcond
 ;
 D addLine(.trigCode,"")
 S code="private void vRCTrig"_trigSeq_"(Record"_$P(this,$C(9),2)_" "_$P(this,$C(9),3)_", String vpar)"
 S code=code_" // Trigger "_trgid_" - "_des_" - "
 F i=1:1:6 I hasTrigger(i) S code=code_$piece("BI,BU,BD,AI,AU,AD",",",i)_" "
 D addLine(.trigCode,code)
 ;
 I hasTrigger(2) D
 .	D addLine(.trigCode," do this.setAuditFlag(true)")
 .	D addLine(.trigCode," do "_$P(this,$C(9),3)_".setAuditFlag(true)")
 .	Q 
 ;
 N rs,vos1,vos2,vos3,vos4,vos5,vos6,vos7  N V1,V2 S V1=$P(this,$C(9),2),V2=trgid S rs=$$vOpen24()
 ;
 F  Q:'$$vFetch24()  D
 .	;
 . N line S line=$$vStrRep(rs,$char(9)," ",0,0,"")
 .	;
 .	I ($E(line,1)?1AN.E) D
 ..		;
 ..		N p3 S p3=$piece($piece(line," ",3),"(",1)
 ..		;
 ..		I '($E(line,1,7)="private") S $ZE="0,"_$ZPOS_","_"%PSL-E-INVALID,Aborted - method in trigger must be private ("_trgid_")",$EC=",U1001,"
 ..		;
 ..		I ($ZCONVERT(p3,"U")'=p3) S $ZE="0,"_$ZPOS_","_"%PSL-E-INVALID,Aborted - method name "_p3_" in trigger must be upper case ("_trgid_")",$EC=",U1001,"
 ..		Q 
 .	;
 .	D addLine(.trigCode,line)
 .	Q 
 ;
 S lastLine=$order(trigCode(""),-1)
 F i=lastLine:-1:1 Q:'($$vStrTrim(trigCode(i),0," ")="") 
 I '($E($$vStrTrim(trigCode(i),0," "),1,4)="quit") D addLine(.trigCode," quit")
 ;
 D appendSrc^PSLTokenizer(.tknzr,.trigCode) ; Add trigger code
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
getWhereKey(this,objName,asNATIVE,nattable) ; Native database table name
 ;
 N ER S ER=0
 N keys S keys=$P(this("td"),"|",3)
 N i
 N col N colLC N ret
 ;
 I asNATIVE D  ; Remap table
 .	;
 .	S nattable=$S(((","_nattable_",")[(","_$P(this,$C(9),2)_",")):nattable,1:$S((nattable=""):$P(this,$C(9),2),1:nattable_","_$P(this,$C(9),2)))
 .	D MAP^DBMAP(%DB,.nattable)
 .	Q 
 ;
 I (keys="") Q ""
 ;
 S ret=""
 ;
 F i=1:1:$S((keys=""):0,1:$L(keys,",")) D
 .	;
 .	I (i>1) S ret=ret_" and "
 .	S col=$piece(keys,",",i)
 .	;
 .	I ($P(this("td"),"|",8)'="GTM"),asNATIVE D
 ..		;
 ..		D MAP^DBMAP(%DB,$P(this,$C(9),2),.col)
 ..		;
 ..		I ER S $ZE="0,"_$ZPOS_","_"%PSL-E-INVALID,Aborted - "_$P(this,$C(9),2)_"."_col_" not in DBMAP",$EC=",U1001,"
 ..		Q 
 .	;
 .	I '(objName="") S ret=ret_col_"=:"_objName_"."_$$colName(col,"LC",1)
 .	E  S ret=ret_col_"=:vkey"_i
 .	Q 
 ;
 Q ret
 ;
 ; ---------------------------------------------------------------------
setJournalSort(this,sort) ; Sort array
 ;
 N i
 N efdopt N mode N prio N trantype
 ;
 ; Break up modes
 I (($order(sort(""))'="I,U,D")!($order(sort(""),-1)'="I,U,D")) D
 .	;
 .	N modeval
 .	;
 .	S (efdopt,mode,trantype)=""
 .	F  S mode=$order(sort(mode)) Q:(mode="")  I (mode[",") D
 ..		F i=1:1:$L(mode,",") S modeval=$piece(mode,",",i) D
 ...			F  S trantype=$order(sort(mode,trantype)) Q:(trantype="")  D
 ....				F  S efdopt=$order(sort(mode,trantype,efdopt)) Q:(efdopt="")  D setJrnSortSplit(.this,.sort,mode,modeval,trantype,trantype,efdopt,efdopt)
 ....				Q 
 ...			Q 
 ..		;
 ..		K sort(mode) ; Remove this level, since now broken into components
 ..		Q 
 .	Q 
 ;
 S (efdopt,mode,prio,trantype)=""
 F  S mode=$order(sort(mode)) Q:(mode="")  D
 .	;
 .	; Break up trantypes
 .	I (($order(sort(mode,""))'="F,O,B")!($order(sort(mode,""),-1)'="F,O,B")) D
 ..		;
 ..		N trantypeval
 ..		;
 ..		S (efdopt,trantype)=""
 ..		F  S trantype=$order(sort(mode,trantype)) Q:(trantype="")  I (trantype[",") D
 ...			F i=1:1:$L(trantype,",") S trantypeval=$piece(trantype,",",i) D
 ....				F  S efdopt=$order(sort(mode,trantype,efdopt)) Q:(efdopt="")  D setJrnSortSplit(.this,.sort,mode,mode,trantype,trantypeval,efdopt,efdopt)
 ....				Q 
 ...			;
 ...			K sort(mode,trantype)
 ...			Q 
 ..		Q 
 .	;
 .	F  S trantype=$order(sort(mode,trantype)) Q:(trantype="")  D
 ..		;
 ..		; Break up efdopts
 ..		I (($order(sort(mode,trantype,""))'="N,E")!($order(sort(mode,trantype,""),-1)'="N,E")) D
 ...			;
 ...			N efdoptval
 ...			;
 ...			S efdopt=""
 ...			F  S efdopt=$order(sort(mode,trantype,efdopt)) Q:(efdopt="")  I (efdopt[",") D
 ....				F i=1:1:$L(efdopt,",") S efdoptval=$piece(efdopt,",",i) D setJrnSortSplit(.this,.sort,mode,mode,trantype,trantype,efdopt,efdoptval)
 ....				;
 ....				K sort(mode,trantype,efdopt)
 ....				Q 
 ...			Q 
 ..		Q 
 .	Q 
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
translateKeyWords(td,input,typ,addQuotes) ; Add quotes [*4]
 N vret
 ;
 N isVarin S isVarin=0 ; Variable insert syntax << >>
 N return S return=""
 ;
 I ($E(input,1,2)="<<"),($E(input,$L(input)-2+1,1048575)=">>") D
 .	;
 .	S isVarin=1
 .	S input=$E(input,3,$L(input)-2)
 .	Q 
 ;
 I (input="") Q ""
 I (input=+input) Q input
 ;
 I ($E(input,1,2)="$$") D  I '(return="") Q return
 .	;
 .	I (input="$$USERNAM^%ZFUNC") S return="%UserName"
 .	E  I (input="$$TLO^UTLO") S return="%UserStation"
 .	E  I ($E(input,1,9)="$$^CUVAR(") S return="CUVAR."_$piece($piece(input,"(""",2),""")",1)
 .	Q 
 I ($E(input,1,2)="$$") Q input
 I ($E(input,1)="""") Q input
 ;
 ; Already a valid keyword
 N rskeywrd,vos1,vos2,vos3  N V1 S V1=input S rskeywrd=$$vOpen25()
 I ''$G(vos1) Q input
 ;
 N rsjrn,vos4,vos5,vos6,vos7  N V2 S V2=input S rsjrn=$$vOpen26()
 ;
 I $$vFetch26() S vret=rsjrn Q vret
 ;
 S return=""
 ;
 I (input="ColName") S return="column"
 E  I (input="FmTable") S return="vRCaudit(column).piece(""|"", 11)"
 E  I (input="NewValue") S return="vRCaudit(column).piece(""|"", 2)"
 E  I (input="OldValue") S return="vRCaudit(column).piece(""|"", 1)"
 E  I (input="TableName") S return=$$QADD^%ZS($P(td,"|",1),"""")
 ;
 I '(return="") Q return
 ;
 I (input=+input) Q input
 ;
 ; Handle various legacy values
 I ((input="%UID")!(input="$G(%UID)")) Q "%UserID"
 I (input="TJD") Q "%SystemDate"
 I ((input="+$H")!(input="+$P($H,"","",1)")) Q "%CurrentDate"
 I (input="$P($H,"","",2)") Q "%CurrentTime"
 I (input="$I") Q "%UserStation"
 ;
 I ($E(input,1,6)="CUVAR.") Q $ZCONVERT(input,"U")
 ;
 I (typ="D") D
 .	;
 .	I (input="T") S return="%SystemDate"
 .	E  I (input="C") S return="%CurrentDate"
 .	Q 
 E  I (typ="C") D
 .	;
 .	I (input="C") S return="%CurrentTime"
 .	Q 
 E  I (typ="L") D
 .	;
 .	I (input="Y") S return=1
 .	E  S return=0
 .	Q 
 ;
 I '(return="") Q return
 ;
 I addQuotes Q $S(input'["""":""""_input_"""",1:$$QADD^%ZS(input,""""))
 ;
 Q input
 ;
 ; ---------------------------------------------------------------------
colName(columnName,case,addQ) ; Add quotes for _?
 ;
 I (columnName["_") D  Q $ZCONVERT(columnName,"U")
 .	;
 .	I addQ S columnName=$S(columnName'["""":""""_columnName_"""",1:$$QADD^%ZS(columnName,""""))
 .	Q 
 ;
 I (case="UC") Q $ZCONVERT(columnName,"U")
 ;
 Q $ZCONVERT(columnName,"L")
 ;
 ; ---------------------------------------------------------------------
addLine(srcarr,code,lineNo) ; Line number added
 ;
 S lineNo=$order(srcarr(""),-1)+1
 ;
 S srcarr(lineNo)=code
 ;
 Q 
 ;
 ; ---------------------------------------------------------------------
addLine2(srcarr,srcarr2,code,lineNo) ; Line number added (primary)
 ;
 S lineNo=$order(srcarr2(""),-1)+1
 S srcarr2(lineNo)=code
 ;
 S lineNo=$order(srcarr(""),-1)+1
 S srcarr(lineNo)=code
 ;
 Q 
 ;  #OPTION ResultClass ON
vSIG(this) ; polymorphism dispatch
 N vC S vC=$P($G(this),$C(9))
 I $D(vPslPoly(vC,"vSIG")) Q $$v0vSIG^@vPslPoly(vC,"vSIG")(.this)
 Q $$v0vSIG(.this)
v0vSIG(this) ; 
 Q "61523^1911^Dan Russell^192755" ; Signature - LTD^TIME^USER^SIZE
 ; ----------------
 ;  #OPTION ResultClass 1
vdat2str(vo,mask) ; Date.toString
 ;
 ;  #OPTIMIZE FUNCTIONS OFF
 I (vo="") Q ""
 I (mask="") S mask="MM/DD/YEAR"
 N cc N lday N lmon
 I mask="DL"!(mask="DS") D  ; Long or short weekday
 .	;    #ACCEPT PGM=FSCW;DATE=2007-03-30;CR=27800;GROUP=GLOBAL
 .	S cc=$get(^DBCTL("SYS","DVFM")) ; Country code
 .	I (cc="") S cc="US"
 .	;    #ACCEPT PGM=FSCW;DATE=2007-03-30;CR=27800;GROUP=GLOBAL
 .	S lday=$get(^DBCTL("SYS","*DVFM",cc,"D",mask))
 .	S mask="DAY" ; Day of the week
 .	Q 
 I mask="ML"!(mask="MS") D  ; Long or short month
 .	;    #ACCEPT PGM=FSCW;DATE=2007-03-30;CR=27800;GROUP=GLOBAL
 .	S cc=$get(^DBCTL("SYS","DVFM")) ; Country code
 .	I (cc="") S cc="US"
 .	;    #ACCEPT PGM=FSCW;DATE=2007-03-30;CR=27800;GROUP=GLOBAL
 .	S lmon=$get(^DBCTL("SYS","*DVFM",cc,"D",mask))
 .	S mask="MON" ; Month of the year
 .	Q 
 ;  #ACCEPT PGM=FSCW;DATE=2007-03-30;CR=27800;GROUP=BYPASS
 ;*** Start of code by-passed by compiler
 set cc=$ZD(vo,mask,$G(lmon),$G(lday))
 ;*** End of code by-passed by compiler ***
 Q cc
 ; ----------------
 ;  #OPTION ResultClass 1
vtim2str(vo,vm) ; Time.toString
 ;
 ;  #OPTIMIZE FUNCTIONS OFF
 I (vo="") Q ""
 I (vm="") S vm="24:60:SS"
 N cc
 ;  #ACCEPT PGM=FSCW;DATE=2007-03-30;CR=27800;GROUP=BYPASS
 ;*** Start of code by-passed by compiler
 SET cc=$ZDATE(","_vo,vm)
 ;*** End of code by-passed by compiler ***
 Q cc
 ; ----------------
 ;  #OPTION ResultClass 1
vRsGetCol(object,column) ; Runtime ResultSet.getCol()
 ;
 ;  #OPTIMIZE FUNCTIONS OFF
 ;
 I (column="") Q ""
 I column Q column
 ;
 N select S select=$piece(vobj(object,-3)," FROM ")
 N pos S pos=$L($piece((","_select_","),","_column_",",1),",")
 Q pos
 ; ----------------
 ;  #OPTION ResultClass 1
vStrRep(object,p1,p2,p3,p4,qt) ; String.replace
 ;
 ;  #OPTIMIZE FUNCTIONS OFF
 ;
 I p3<0 Q object
 I $L(p1)=1,$L(p2)<2,'p3,'p4,(qt="") Q $translate(object,p1,p2)
 ;
 N y S y=0
 F  S y=$$vStrFnd(object,p1,y,p4,qt) Q:y=0  D
 .	S object=$E(object,1,y-$L(p1)-1)_p2_$E(object,y,1048575)
 .	S y=y+$L(p2)-$L(p1)
 .	I p3 S p3=p3-1 I p3=0 S y=$L(object)+1
 .	Q 
 Q object
 ; ----------------
 ;  #OPTION ResultClass 1
vStrTrim(object,p1,p2) ; String.trim
 ;
 ;  #OPTIMIZE FUNCTIONS OFF
 I p1'<0 S object=$$RTCHR^%ZFUNC(object,p2)
 I p1'>0 F  Q:$E(object,1)'=p2  S object=$E(object,2,1048575)
 Q object
 ; ----------------
 ;  #OPTION ResultClass 1
vStrFnd(object,p1,p2,p3,qt) ; String.find
 ;
 ;  #OPTIMIZE FUNCTIONS OFF
 ;
 I (p1="") Q $S(p2<1:1,1:+p2)
 I p3 S object=$ZCONVERT(object,"U") S p1=$ZCONVERT(p1,"U")
 S p2=$F(object,p1,p2)
 I '(qt=""),$L($E(object,1,p2-1),qt)#2=0 D
 .	F  S p2=$F(object,p1,p2) Q:p2=0!($L($E(object,1,p2-1),qt)#2) 
 .	Q 
 Q p2
 ;
vClVobj(vSt,vCls) ; Create a new object
 ;
 N vOid
 S vOid=$O(vobj(""),-1)+1,vobj(vOid,-1)=vCls_$C(9)_vSt
 Q vOid
 ;
vOpen0(exe,vsql,vSelect,vFrom,vWhere,vOrderby,vGroupby,vParlist,vOff) ; Dynamic MDB ResultSet
 ;
 N vOid
 N ER,vExpr,mode,RM,vOpen,vTok S ER=0 ;=noOpti
 ;
 S vExpr="SELECT "_vSelect_" FROM "_vFrom
 I vWhere'="" S vExpr=vExpr_" WHERE "_vWhere
 I vOrderby'="" S vExpr=vExpr_" ORDER BY "_vOrderby
 I vGroupby'="" S vExpr=vExpr_" GROUP BY "_vGroupby
 S vExpr=$$UNTOK^%ZS($$SQL^%ZS(vExpr,.vTok),vTok)
 ;
 S sqlcur=$O(vobj(""),-1)+1
 ;
 I $$FLT^SQLCACHE(vExpr,vTok,.vParlist)
 E  S vOpen=$$OPEN^SQLM(.exe,vFrom,vSelect,vWhere,vOrderby,vGroupby,vParlist,,1,,sqlcur) I 'ER D SAV^SQLCACHE(vExpr,.vParlist) s vsql=vOpen
 I ER S $ZE="0,"_$ZPOS_",%PSL-E-SQLFAIL,"_$TR($G(RM),$C(10,44),$C(32,126)),$EC=",U1001,"
 ;
 S vOid=sqlcur
 S vobj(vOid,0)=vsql
 S vobj(vOid,-1)="ResultSet"
 S vobj(vOid,-2)="$$vFetch0^"_$T(+0)
 S vobj(vOid,-3)=$$RsSelList^UCDBRT(vSelect)
 S vobj(vOid,-4)=$G(vsql("D"))
 S vobj(vOid,-5)=0
 Q vOid
 ;
vFetch0(vOid) ; MDB dynamic FETCH
 ;
 ; type public String exe(),sqlcur,vd,vi,vsql()
 ;
 I vsql=0 S vobj(vOid)="" Q 0
 S vsql=$$^SQLF(.exe,.vd,.vi,.sqlcur)
 S vobj(vOid)=vd
 S vobj(vOid,0)=vsql
 S vobj(vOid,.1)=$G(vi)
 Q vsql
 ;
vOpen1() ; FID FROM DBTBL1 WHERE %LIBS='SYSDEV' AND PARFID=:V1
 ;
 ;
 S vos1=2
 D vL1a1
 Q ""
 ;
vL1a0 S vos1=0 Q
vL1a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="",'$D(V1) G vL1a0
 S vos4=""
vL1a4 S vos4=$O(^DBINDX("SYSDEV","PARFID",vos3,vos4),1) I vos4="" G vL1a0
 Q
 ;
vFetch1() ;
 ;
 ;
 I vos1=1 D vL1a4
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rs="" Q 0
 ;
 S rs=$S(vos4=vos2:"",1:vos4)
 ;
 Q 1
 ;
vOpen10() ; FKEYS,TBLREF FROM DBTBL1F WHERE FID = :V1 AND TBLREF IS NOT NULL
 ;
 ;
 S vos1=2
 D vL10a1
 Q ""
 ;
vL10a0 S vos1=0 Q
vL10a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="" G vL10a0
 S vos4=""
vL10a4 S vos4=$O(^DBINDX(vos4),1) I vos4="" G vL10a0
 S vos5=""
vL10a6 S vos5=$O(^DBINDX(vos4,"FKPTR",vos5),1) I vos5="" G vL10a4
 I '(vos5'=$ZCH(254)) G vL10a6
 S vos6=""
vL10a9 S vos6=$O(^DBINDX(vos4,"FKPTR",vos5,vos3,vos6),1) I vos6="" G vL10a6
 Q
 ;
vFetch10() ;
 ;
 ;
 I vos1=1 D vL10a9
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rs="" Q 0
 ;
 S rs=$S(vos6=vos2:"",1:vos6)_$C(9)_$S(vos5=vos2:"",1:vos5)
 ;
 Q 1
 ;
vOpen11() ; INDEXNM,IDXDESC,GLOBAL,ORDERBY,UPCASE FROM DBTBL8 WHERE %LIBS='SYSDEV' AND FID = :V1
 ;
 ;
 S vos1=2
 D vL11a1
 Q ""
 ;
vL11a0 S vos1=0 Q
vL11a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="" G vL11a0
 S vos4=""
vL11a4 S vos4=$O(^DBTBL("SYSDEV",8,vos3,vos4),1) I vos4="" G vL11a0
 Q
 ;
vFetch11() ;
 ;
 ;
 I vos1=1 D vL11a4
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rs="" Q 0
 ;
 S vos5=$G(^DBTBL("SYSDEV",8,vos3,vos4))
 S rs=$S(vos4=vos2:"",1:vos4)_$C(9)_$P(vos5,"|",5)_$C(9)_$P(vos5,"|",2)_$C(9)_$P(vos5,"|",3)_$C(9)_$P(vos5,"|",14)
 ;
 Q 1
 ;
vOpen12() ; TRGID,ACTBI,ACTBU,ACTBD,ACTAI,ACTAU,ACTAD,COLUMNS,DES,IFCOND FROM DBTBL7 WHERE %LIBS='SYSDEV' AND TABLE = :V1
 ;
 ;
 S vos1=2
 D vL12a1
 Q ""
 ;
vL12a0 S vos1=0 Q
vL12a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="" G vL12a0
 S vos4=""
vL12a4 S vos4=$O(^DBTBL("SYSDEV",7,vos3,vos4),1) I vos4="" G vL12a0
 Q
 ;
vFetch12() ;
 ;
 ;
 I vos1=1 D vL12a4
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rs="" Q 0
 ;
 S vos5=$G(^DBTBL("SYSDEV",7,vos3,vos4))
 S rs=$S(vos4=vos2:"",1:vos4)_$C(9)_$P(vos5,"|",2)_$C(9)_$P(vos5,"|",3)_$C(9)_$P(vos5,"|",4)_$C(9)_$P(vos5,"|",5)_$C(9)_$P(vos5,"|",6)_$C(9)_$P(vos5,"|",7)_$C(9)_$P(vos5,"|",8)_$C(9)_$P(vos5,"|",1)_$C(9)_$P(vos5,"|",12)
 ;
 Q 1
 ;
vOpen13() ; DI FROM DBTBL1D WHERE FID = :V1 AND CMP IS NULL AND TYP NOT IN ('M','B')
 ;
 ;
 S vos1=2
 D vL13a1
 Q ""
 ;
vL13a0 S vos1=0 Q
vL13a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="" G vL13a0
 S vos4=""
vL13a4 S vos4=$O(^DBTBL(vos4),1) I vos4="" G vL13a0
 S vos5=""
vL13a6 S vos5=$O(^DBTBL(vos4,1,vos3,9,vos5),1) I vos5="" G vL13a4
 S vos6=$G(^DBTBL(vos4,1,vos3,9,vos5))
 I '($P(vos6,"|",16)="") G vL13a6
 I '($P(vos6,"|",9)'="M"&($P(vos6,"|",9)'="B")) G vL13a6
 Q
 ;
vFetch13() ;
 ;
 ;
 I vos1=1 D vL13a6
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rs="" Q 0
 ;
 S vos6=$G(^DBTBL(vos4,1,vos3,9,vos5))
 S rs=$S(vos5=vos2:"",1:vos5)
 ;
 Q 1
 ;
vOpen14() ; DI FROM DBTBL1D WHERE FID = :V1 AND TYP ='B' OR TYP = 'M'
 ;
 ;
 S vos1=2
 D vL14a1
 Q ""
 ;
vL14a0 S vos1=0 Q
vL14a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="" G vL14a0
 S vos4=""
vL14a4 S vos4=$O(^DBTBL(vos4),1) I vos4="" G vL14a0
 S vos5=""
vL14a6 S vos5=$O(^DBTBL(vos4,1,vos3,9,vos5),1) I vos5="" G vL14a4
 S vos6=$G(^DBTBL(vos4,1,vos3,9,vos5))
 I '($P(vos6,"|",9)="B"!($P(vos6,"|",9)="M")) G vL14a6
 Q
 ;
vFetch14() ;
 ;
 ;
 I vos1=1 D vL14a6
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rs="" Q 0
 ;
 S vos6=$G(^DBTBL(vos4,1,vos3,9,vos5))
 S rs=$S(vos5=vos2:"",1:vos5)
 ;
 Q 1
 ;
vOpen15() ; NOD,DI FROM DBTBL1D WHERE FID = :V1 AND NOD<'0'
 ;
 ;
 S vos7=2
 D vL15a1
 Q ""
 ;
vL15a0 S vos7=0 Q
vL15a1 S vos8=$$BYTECHAR^SQLUTL(254)
 S vos9=$G(V1) I vos9="" G vL15a0
 S vos10=""
vL15a4 S vos10=$O(^DBINDX(vos10),1) I vos10="" G vL15a0
 S vos11=""
vL15a6 S vos11=$O(^DBINDX(vos10,"STR",vos9,vos11),1) I vos11=""!("0"']]vos11) G vL15a4
 S vos12=""
vL15a8 S vos12=$O(^DBINDX(vos10,"STR",vos9,vos11,vos12),1) I vos12="" G vL15a6
 S vos13=""
vL15a10 S vos13=$O(^DBINDX(vos10,"STR",vos9,vos11,vos12,vos13),1) I vos13="" G vL15a8
 Q
 ;
vFetch15() ;
 ;
 ;
 I vos7=1 D vL15a10
 I vos7=2 S vos7=1
 ;
 I vos7=0 S rs="" Q 0
 ;
 S rs=$S(vos11=vos8:"",1:vos11)_$C(9)_$S(vos13=vos8:"",1:vos13)
 ;
 Q 1
 ;
vOpen16() ; JRNID,DES,EFD,EXCOLUMN,IFCOND,INCOLUMN,MODE,QUERY1,QUERY2,SEQ,SUBTABLE,TRANTYPE FROM DBTBL9 WHERE %LIBS='SYSDEV' AND PRITABLE=:V1
 ;
 ;
 S vos1=2
 D vL16a1
 Q ""
 ;
vL16a0 S vos1=0 Q
vL16a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="" G vL16a0
 S vos4=""
vL16a4 S vos4=$O(^DBTBL("SYSDEV",9,vos3,vos4),1) I vos4="" G vL16a0
 Q
 ;
vFetch16() ;
 ;
 ;
 I vos1=1 D vL16a4
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rs="" Q 0
 ;
 S vos5=$G(^DBTBL("SYSDEV",9,vos3,vos4))
 S rs=$S(vos4=vos2:"",1:vos4)_$C(9)_$P(vos5,"|",1)_$C(9)_$P(vos5,"|",3)_$C(9)_$P(vos5,"|",6)_$C(9)_$P(vos5,"|",15)_$C(9)_$P(vos5,"|",7)_$C(9)_$P(vos5,"|",5)_$C(9)_$P(vos5,"|",11)_$C(9)_$P(vos5,"|",12)_$C(9)_$P(vos5,"|",8)
 S rs=rs_$C(9)_$P(vos5,"|",2)_$C(9)_$P(vos5,"|",4)
 ;
 Q 1
 ;
vOpen17() ; COLNAM,MAP FROM DBTBL9D WHERE %LIBS='SYSDEV' AND PRITABLE=:V2 AND JRNID=:V3
 ;
 ;
 S vos6=2
 D vL17a1
 Q ""
 ;
vL17a0 S vos6=0 Q
vL17a1 S vos7=$$BYTECHAR^SQLUTL(254)
 S vos8=$G(V2) I vos8="" G vL17a0
 S vos9=$G(V3) I vos9="" G vL17a0
 S vos10=""
vL17a5 S vos10=$O(^DBTBL("SYSDEV",9,vos8,vos9,vos10),1) I vos10="" G vL17a0
 Q
 ;
vFetch17() ;
 ;
 ;
 I vos6=1 D vL17a5
 I vos6=2 S vos6=1
 ;
 I vos6=0 S rs9d="" Q 0
 ;
 S vos11=$G(^DBTBL("SYSDEV",9,vos8,vos9,vos10))
 S rs9d=$S(vos10=vos7:"",1:vos10)_$C(9)_$P(vos11,"|",1)
 ;
 Q 1
 ;
vOpen18() ; FID FROM DBTBL8 WHERE FID = :V1
 ;
 ;
 S vos1=2
 D vL18a1
 Q ""
 ;
vL18a0 S vos1=0 Q
vL18a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="" G vL18a0
 S vos4=""
vL18a4 S vos4=$O(^DBTBL(vos4),1) I vos4="" G vL18a0
 S vos5=""
vL18a6 S vos5=$O(^DBTBL(vos4,8,vos3,vos5),1) I vos5="" G vL18a4
 Q
 ;
vFetch18() ;
 ;
 ;
 I vos1=1 D vL18a6
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rsi="" Q 0
 ;
 S rsi=vos3
 ;
 Q 1
 ;
vOpen19() ; FKEYS FROM DBTBL1F WHERE FID = :V2 AND TBLREF IS NOT NULL
 ;
 ;
 S vos6=2
 D vL19a1
 Q ""
 ;
vL19a0 S vos6=0 Q
vL19a1 S vos7=$$BYTECHAR^SQLUTL(254)
 S vos8=$G(V2) I vos8="" G vL19a0
 S vos9=""
vL19a4 S vos9=$O(^DBINDX(vos9),1) I vos9="" G vL19a0
 S vos10=""
vL19a6 S vos10=$O(^DBINDX(vos9,"FKPTR",vos10),1) I vos10="" G vL19a4
 I '(vos10'=$ZCH(254)) G vL19a6
 S vos11=""
vL19a9 S vos11=$O(^DBINDX(vos9,"FKPTR",vos10,vos8,vos11),1) I vos11="" G vL19a6
 Q
 ;
vFetch19() ;
 ;
 ;
 I vos6=1 D vL19a9
 I vos6=2 S vos6=1
 ;
 I vos6=0 S rsfk="" Q 0
 ;
 S rsfk=$S(vos11=vos7:"",1:vos11)
 ;
 Q 1
 ;
vOpen2() ; FID FROM DBTBL1
 ;
 ;
 S vos1=2
 D vL2a1
 Q ""
 ;
vL2a0 S vos1=0 Q
vL2a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=""
vL2a3 S vos3=$O(^DBTBL(vos3),1) I vos3="" G vL2a0
 S vos4=""
vL2a5 S vos4=$O(^DBTBL(vos3,1,vos4),1) I vos4="" G vL2a3
 Q
 ;
vFetch2() ;
 ;
 ;
 I vos1=1 D vL2a5
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rs="" Q 0
 ;
 S rs=$S(vos4=vos2:"",1:vos4)
 ;
 Q 1
 ;
vOpen20() ; JRNID FROM DBTBL9 WHERE %LIBS='SYSDEV' AND PRITABLE=:V1
 ;
 ;
 S vos12=2
 D vL20a1
 Q ""
 ;
vL20a0 S vos12=0 Q
vL20a1 S vos13=$$BYTECHAR^SQLUTL(254)
 S vos14=$G(V1) I vos14="" G vL20a0
 S vos15=""
vL20a4 S vos15=$O(^DBTBL("SYSDEV",9,vos14,vos15),1) I vos15="" G vL20a0
 Q
 ;
vFetch20() ;
 ;
 ;
 I vos12=1 D vL20a4
 I vos12=2 S vos12=1
 ;
 I vos12=0 S rsj="" Q 0
 ;
 S rsj=$S(vos15=vos13:"",1:vos15)
 ;
 Q 1
 ;
vOpen21() ; FID FROM DBTBL1F WHERE %LIBS='SYSDEV' AND TBLREF=:V2
 ;
 ;
 S vos16=2
 D vL21a1
 Q ""
 ;
vL21a0 S vos16=0 Q
vL21a1 S vos17=$$BYTECHAR^SQLUTL(254)
 S vos18=$G(V2) I vos18="",'$D(V2) G vL21a0
 S vos19=""
vL21a4 S vos19=$O(^DBINDX("SYSDEV","FKPTR",vos18,vos19),1) I vos19="" G vL21a0
 S vos20=""
vL21a6 S vos20=$O(^DBINDX("SYSDEV","FKPTR",vos18,vos19,vos20),1) I vos20="" G vL21a4
 Q
 ;
vFetch21() ;
 ;
 ;
 I vos16=1 D vL21a6
 I vos16=2 S vos16=1
 ;
 I vos16=0 S rscd="" Q 0
 ;
 S rscd=$S(vos19=vos17:"",1:vos19)
 ;
 Q 1
 ;
vOpen22() ; ACTBI,ACTBU,ACTBD,ACTAI,ACTAU,ACTAD,COLUMNS,IFCOND FROM DBTBL7 WHERE %LIBS='SYSDEV' AND TABLE=:V3
 ;
 ;
 S vos21=2
 D vL22a1
 Q ""
 ;
vL22a0 S vos21=0 Q
vL22a1 S vos22=$$BYTECHAR^SQLUTL(254)
 S vos23=$G(V3) I vos23="" G vL22a0
 S vos24=""
vL22a4 S vos24=$O(^DBTBL("SYSDEV",7,vos23,vos24),1) I vos24="" G vL22a0
 Q
 ;
vFetch22() ;
 ;
 ;
 I vos21=1 D vL22a4
 I vos21=2 S vos21=1
 ;
 I vos21=0 S rst="" Q 0
 ;
 S vos25=$G(^DBTBL("SYSDEV",7,vos23,vos24))
 S rst=$P(vos25,"|",2)_$C(9)_$P(vos25,"|",3)_$C(9)_$P(vos25,"|",4)_$C(9)_$P(vos25,"|",5)_$C(9)_$P(vos25,"|",6)_$C(9)_$P(vos25,"|",7)_$C(9)_$P(vos25,"|",8)_$C(9)_$P(vos25,"|",12)
 ;
 Q 1
 ;
vOpen23() ; DISTINCT TABLE FROM SYSMAPLITDTA WHERE TABLE=:V4
 ;
 ;
 S vos26=2
 D vL23a1
 Q ""
 ;
vL23a0 S vos26=0 Q
vL23a1 S vos27=$$BYTECHAR^SQLUTL(254)
 S vos28=$G(V4) I vos28="" G vL23a0
 S vos29=""
vL23a4 S vos29=$O(^SYSMAP("LITDATA",vos29),1) I vos29="" G vL23a0
 I '($D(^SYSMAP("LITDATA",vos29,vos28))) G vL23a4
 Q
 ;
vFetch23() ;
 ;
 ;
 I vos26=1 D vL23a4
 I vos26=2 S vos26=1
 ;
 I vos26=0 S rslit="" Q 0
 ;
 S rslit=vos28
 S vos26=100
 ;
 Q 1
 ;
vOpen24() ; CODE FROM DBTBL7D WHERE TABLE = :V1 AND TRGID = :V2
 ;
 ;
 S vos1=2
 D vL24a1
 Q ""
 ;
vL24a0 S vos1=0 Q
vL24a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="" G vL24a0
 S vos4=$G(V2) I vos4="" G vL24a0
 S vos5=""
vL24a5 S vos5=$O(^DBTBL(vos5),1) I vos5="" G vL24a0
 S vos6=""
vL24a7 S vos6=$O(^DBTBL(vos5,7,vos3,vos4,vos6),1) I vos6="" G vL24a5
 Q
 ;
vFetch24() ;
 ;
 ;
 I vos1=1 D vL24a7
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rs="" Q 0
 ;
 S vos7=$G(^DBTBL(vos5,7,vos3,vos4,vos6))
 S rs=$P(vos7,$C(1),1)
 ;
 Q 1
 ;
vOpen25() ; KEYWORD FROM STBLSYSKEYWD WHERE KEYWORD=:V1
 ;
 ;
 S vos1=2
 D vL25a1
 Q ""
 ;
vL25a0 S vos1=0 Q
vL25a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="" G vL25a0
 I '($D(^STBL("SYSKEYWORDS",vos3))#2) G vL25a0
 Q
 ;
vFetch25() ;
 ;
 ;
 ;
 I vos1=0 S rskeywrd="" Q 0
 ;
 S vos1=100
 S rskeywrd=vos3
 S vos1=0
 ;
 Q 1
 ;
vOpen26() ; PSLEQUIV FROM STBLJRNFUNC WHERE FUNC=:V2 AND PSLEQUIV IS NOT NULL
 ;
 ;
 S vos4=2
 D vL26a1
 Q ""
 ;
vL26a0 S vos4=0 Q
vL26a1 S vos5=$$BYTECHAR^SQLUTL(254)
 S vos6=$G(V2) I vos6="" G vL26a0
 I '($D(^STBL("JRNFUNC",vos6))#2) G vL26a0
 S vos7=$G(^STBL("JRNFUNC",vos6))
 I '($P(vos7,"|",3)'="") G vL26a0
 Q
 ;
vFetch26() ;
 ;
 ;
 ;
 I vos4=0 S rsjrn="" Q 0
 ;
 S vos4=100
 S vos7=$G(^STBL("JRNFUNC",vos6))
 S rsjrn=$P(vos7,"|",3)
 S vos4=0
 ;
 Q 1
 ;
vOpen3() ; SRLCOL FROM DBUTARCHIVE WHERE ARCHTBL=:V1
 ;
 ;
 S vos1=2
 D vL3a1
 Q ""
 ;
vL3a0 S vos1=0 Q
vL3a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="" G vL3a0
 I '($D(^UTBL("DBARCHIVE",vos3))#2) G vL3a0
 Q
 ;
vFetch3() ;
 ;
 ;
 ;
 I vos1=0 S rsarch="" Q 0
 ;
 S vos1=100
 S vos4=$G(^UTBL("DBARCHIVE",vos3))
 S rsarch=$P(vos4,"|",2)
 S vos1=0
 ;
 Q 1
 ;
vOpen4() ; DI FROM DBTBL1D WHERE %LIBS='SYSDEV' AND FID=:V2 AND SRL=1
 ;
 ;
 S vos5=2
 D vL4a1
 Q ""
 ;
vL4a0 S vos5=0 Q
vL4a1 S vos6=$$BYTECHAR^SQLUTL(254)
 S vos7=$G(V2) I vos7="" G vL4a0
 S vos8=""
vL4a4 S vos8=$O(^DBTBL("SYSDEV",1,vos7,9,vos8),1) I vos8="" G vL4a0
 S vos9=$G(^DBTBL("SYSDEV",1,vos7,9,vos8))
 I '(+$P(vos9,"|",23)=1) G vL4a4
 Q
 ;
vFetch4() ;
 ;
 ;
 I vos5=1 D vL4a4
 I vos5=2 S vos5=1
 ;
 I vos5=0 S rs="" Q 0
 ;
 S vos9=$G(^DBTBL("SYSDEV",1,vos7,9,vos8))
 S rs=$S(vos8=vos6:"",1:vos8)
 ;
 Q 1
 ;
vOpen5() ; FID,FKEYS,DEL FROM DBTBL1F WHERE %LIBS='SYSDEV' AND TBLREF=:V1
 ;
 ;
 S vos1=2
 D vL5a1
 Q ""
 ;
vL5a0 S vos1=0 Q
vL5a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="",'$D(V1) G vL5a0
 S vos4=""
vL5a4 S vos4=$O(^DBINDX("SYSDEV","FKPTR",vos3,vos4),1) I vos4="" G vL5a0
 S vos5=""
vL5a6 S vos5=$O(^DBINDX("SYSDEV","FKPTR",vos3,vos4,vos5),1) I vos5="" G vL5a4
 Q
 ;
vFetch5() ;
 ;
 ;
 I vos1=1 D vL5a6
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rs="" Q 0
 ;
 S vos6=$G(^DBTBL("SYSDEV",19,vos4,vos5))
 S rs=$S(vos4=vos2:"",1:vos4)_$C(9)_$S(vos5=vos2:"",1:vos5)_$C(9)_$P(vos6,"|",3)
 ;
 Q 1
 ;
vOpen6() ; INSERTRTS,UPDATERTS,DELETERTS,SELECTRTS,INSRESTRICT,UPDRESTRICT,DELRESTRICT,SELRESTRICT FROM DBACCRTS WHERE TABLENAME=:V1 AND USERCLASS='PUBLIC'
 ;
 ;
 S vos1=2
 D vL6a1
 Q ""
 ;
vL6a0 S vos1=0 Q
vL6a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="" G vL6a0
 I '($D(^DBACCRTS(vos3,"PUBLIC"))) G vL6a0
 Q
 ;
vFetch6() ;
 ;
 ;
 ;
 I vos1=0 S rs="" Q 0
 ;
 S vos1=100
 S vos4=$G(^DBACCRTS(vos3,"PUBLIC",1))
 S vos5=$G(^DBACCRTS(vos3,"PUBLIC",2))
 S vos6=$G(^DBACCRTS(vos3,"PUBLIC",3))
 S vos7=$G(^DBACCRTS(vos3,"PUBLIC",4))
 S vos8=$G(^DBACCRTS(vos3,"PUBLIC"))
 S rs=$P(vos8,"|",1)_$C(9)_$P(vos8,"|",2)_$C(9)_$P(vos8,"|",3)_$C(9)_$P(vos8,"|",4)_$C(9)_$P(vos4,"|",1)_$C(9)_$P(vos5,"|",1)_$C(9)_$P(vos6,"|",1)_$C(9)_$P(vos7,"|",1)
 S vos1=0
 ;
 Q 1
 ;
vOpen7() ; DI,TYP,SFD,CMP FROM DBTBL1D WHERE %LIBS='SYSDEV' AND FID=:V1
 ;
 ;
 S vos1=2
 D vL7a1
 Q ""
 ;
vL7a0 S vos1=0 Q
vL7a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(V1) I vos3="" G vL7a0
 S vos4=""
vL7a4 S vos4=$O(^DBTBL("SYSDEV",1,vos3,9,vos4),1) I vos4="" G vL7a0
 Q
 ;
vFetch7() ;
 ;
 ;
 I vos1=1 D vL7a4
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rs="" Q 0
 ;
 S vos5=$G(^DBTBL("SYSDEV",1,vos3,9,vos4))
 S rs=$S(vos4=vos2:"",1:vos4)_$C(9)_$P(vos5,"|",9)_$C(9)_$P(vos5,"|",18)_$C(9)_$P(vos5,"|",16)
 ;
 Q 1
 ;
vOpen8() ; DISTINCT RTBL FROM DBMAP WHERE DB=:%DB AND TBL=:V1 ORDER BY RTBL ASC
 ;
 ;
 S vOid=$G(^DBTMP($J))-1,^($J)=vOid K ^DBTMP($J,vOid)
 S vos1=2
 D vL8a1
 Q ""
 ;
vL8a0 S vos1=0 Q
vL8a1 S vos2=$$BYTECHAR^SQLUTL(254)
 S vos3=$G(%DB) I vos3="" G vL8a0
 S vos4=$G(V1) I vos4="" G vL8a0
 S vos5=""
vL8a5 S vos5=$O(^DBMAP("COLUMNS",vos3,vos4,vos5),1) I vos5="" G vL8a11
 S vos6=$G(^DBMAP("COLUMNS",vos3,vos4,vos5))
 S vd=$P(vos6,$C(9),1)
 S vos7=$P(vos6,$C(9),1) S vos8=$P(vos6,$C(9),1) S:vos7="" vos7=vos2 S:vos8="" vos8=vos2
 S ^DBTMP($J,vOid,1,vos7,vos8)=vd
 G vL8a5
vL8a11 S vos2=""
vL8a12 S vos2=$O(^DBTMP($J,vOid,1,vos2),1) I vos2="" G vL8a0
 S vos3=""
vL8a14 S vos3=$O(^DBTMP($J,vOid,1,vos2,vos3),1) I vos3="" G vL8a12
 Q
 ;
vFetch8() ;
 ;
 ;
 I vos1=1 D vL8a14
 I vos1=2 S vos1=1
 ;
 I vos1=0 S rs="" K ^DBTMP($J,vOid) Q 0
 ;
 S rs=^DBTMP($J,vOid,1,vos2,vos3)
 ;
 Q 1
 ;
vOpen9() ; COL FROM DBMAP WHERE DB=:%DB AND TBL=:V2 AND RTBL=:V3
 ;
 ;
 S vos9=2
 D vL9a1
 Q ""
 ;
vL9a0 S vos9=0 Q
vL9a1 S vos10=$$BYTECHAR^SQLUTL(254)
 S vos11=$G(%DB) I vos11="" G vL9a0
 S vos12=$G(V2) I vos12="" G vL9a0
 S vos13=$G(V3) I vos13="",'$D(V3) G vL9a0
 S vos14=""
vL9a6 S vos14=$O(^DBMAP("COLUMNS",vos11,vos12,vos14),1) I vos14="" G vL9a0
 S vos15=$G(^DBMAP("COLUMNS",vos11,vos12,vos14))
 I '($P(vos15,$C(9),1)=vos13) G vL9a6
 Q
 ;
vFetch9() ;
 ;
 ;
 I vos9=1 D vL9a6
 I vos9=2 S vos9=1
 ;
 I vos9=0 S rs2="" Q 0
 ;
 S vos15=$G(^DBMAP("COLUMNS",vos11,vos12,vos14))
 S rs2=$S(vos14=vos10:"",1:vos14)
 ;
 Q 1
vcdmNew(this,vC,vInitObj) ; Constructor, called for Class.new()
 N vT S vT=$T
 S this=vC
 S $P(this,$C(9),6)=1
 S $P(this,$C(9),5)=1
 D initialize(.this,.vInitObj)
 I vT
 Q
