	#PACKAGE framework.psl
	#OPTION  ResultClass ON

private String UCGMC( noret String cmd,
		noret String m2src(),
		ret   Number lptr,
		noret String str,
		ret   Number ptr,
		noret String tok)	//
	/*
	ORIG: FSANCHEZ - 25 DEC 1998 
	DESC: Interprets Extended M compiler options 

	---- Revision History --------------------------------------------------
	2008-03-27, Frans S.C. Witte, CR: 33569
		* Corrected IF: argument must be tokenized for $$condBool^UCGM()
		* Corrected PSL: missing quotes around keyword false.

	12/21/06 - Frans S.C. Witte, L. Kwan - CRs: 27800
		* Added #CLASSDEF, #PACKAGE, #PROPERTYDEF, and #PSL
		* added $$allPSL()
		* Replaced commands(,) by pslPrsr(,)
		* Replaced 'public' by 'ret' or removed the modifier for arrays
		* Removed defWARN (now handled by UCOPTS.ini)
		* Removed #BREAK (not used, and not portable to Java)
		* Removed support for ASK in #XECUTE, and $ask()

	01/22/07 - RussellDS - CRs: 24902 / 24903 / 24974
		Replaced use of variable true with isTrue to avoid conflict
		with new PSL intrinsic variable
	
	10/31/06 - Frans S.C. Witte - CRs: 22719 / 20163
		* Corrected quit from XECUTE if bootstrap

	07/11/06 - Frans S.C. Witte - CRs: 22720 / 22274
		* Added support for #OPTION ResultClass
		* Corrected quit from $$IF() if error.

	06/07/06 - Frans S.c. Witte - CRs: 22060 / 22061
		* Added utility subroutine splitCode() to break a long code line
		  into pieces.

	04/25/06 - Frans S.C. Witte - CRs: 21394 / 21395
		* Added $$INFO(), $$OPTION(), $$DEFINE(), decode() and
		  decodeLine().
		  Added support for '*' in #INFO, #WARN, #OPTIMIZE and #OPTION.
		  Added warn/info group LENGTH.

	03/14/06 - Frans S.C. Witte - CRs: 20280 / 18164
		* Converted to PSL.

	11/29/05 - Frans S.C. Witte - CRs: 18163 / 18164
		* getLit and RgetLit commented out. Code is now handled by
		  litVal^UCCOLUMN.
		* Changed $$rdb^UCDBRT() to $$rtIsRdb^UCXDD() (3 occurrences)
		* Subroutine xecute: corrected code when in boot mode

	08/04/05 - Frans S.C. Witte -	CRs: 15592 / 15593
		* Added descriptions of WARN / OPTIMIZE / Options
		* #XECUTE ignored in BOOT mode
		* replaced 32767 by $$getPslValue^UCOPTS("maxLineLength")

	06/29/05 - Frans S.C. Witte - CR16346
		* Modified RgetLit to conform to standard ER handling

	05/05/05 - RussellDS - CR15379
		* Modify IF section to identify functions involved in #IF
		  directives, and update the sysmap() array
		* Remove checkCalls section

	04/07/05 - Frans S.C. Witte - CRs: 14919 / 14920
		$$rdb^UCDB() changed to $$rdb^UCDBRT() (3 occurrences)
		* Changed ERROR^UCGM(.message) to ERROR^UCGM(message).

	21/21/04 - Frans S.C. Witte - CRs: 13403 / 13404
		* Call to chkCalls^UCLABEL() with new signature enabled.
		* Added compiler warning when #BYPASS is detected. It uses the
		  warning option  BYPASS, that has been added to $$allWARN and
		  $$defWARN.
		* Removed code that was commented out by previous CR.

	11/28/04 - Frans S.C. Witte - CRs: 11445 / 11446
		* Call to chkCalls^UCLABEL() (in subroutine checkCalls()) adapted.
		* chkCalls^UCLABEL() is now also used to check labels local to the
		  current compilation unit. To be able to make changes to both a
		  DQ procedure and an M routine given the CR install programs, the
		  change to this routine must be implemented through a separate CR
		  that is deployed after the CR that changed UCLABEL.
		* Removed function $$related() and procedure checkparam(), because
		  this is now handled exclusively by UCLABEL.
		* Added READ to list of all warnings.
		* Value assigned to pslPrsr("WARN",cond) is now 1 (was ""). This
		  allows $DATA(pslPrsr("WARN",cond)) to be replaced by $GET().
		* Added functions $$allWARN(), $$defWARN() $$allOPTIMZE(),
		  $$defOPTIMIZE(), and $$allOptions().
		* All #CompCommands that insert comment now properly call
		  initLevel^UCGM().
		* Subroutine getTable commented out (not called).
		* Added deprecation warnings for Schema.createTable and
		  Schema.deleteTable.
		* When #BYPASS is detected, values assigned to all Primitives are
		  invalidated.

	05/12/04 - RussellDS - CR9676
		Move Profile04 version to Profile01 to support single code
		base for PSL.

	03/26/04 - RussellDS - CR9172
		     Integrated changes related to filers to PSL.

	01/14/04 - Spier- 7240
		removed quit from label in newTable, since next line
		quit from label it was not needed.

	11/14/03 - SPIER - 51640
	        Modified checkparam section, loop through comma seperated
		parameters did not account for params such as ttx(,). Converted
		to tabs through call to ATOM^%ZS

	11/13/03 - Added logic to turn off warnings with switch

	10/01/03 - fsanchez
	        Added Schema.getTable method

	09/04/03 - SPIER - 51640
	        Changes made to correct param checking. If parameter
		is not passed from within the element it is not 
		necessarily required.

	07/11/03 - SPIER - 51423
	        Changes to while section to correct errors.
	 	Change to if section to define condition
		that should be ignored for dead code issues

	04/24/03 - GIRIDHARANB - 45497
		Corrected an improper call to RgetLit section

	03/27/03 - GIRIDHARANB - 45497
		Fixes made to the RnewTable section to correct an improper
		call to MAP^DBMAP to check the created column names are not
		reserved words.

	03/13/03 - Chenardp/Giridharan - 45497
		Added support for Oracle/DB2 (RnewTable,RdelTable,RgetLit)

	02/14/03 - SPIER - 51423
	        Bug fixes

	10/01/02 - FSANCHEZ
	        Fixed #BYPASS stack error

	03/19/02 - SPIER - 49177
	        Modified to call routine TBXANALZ to save
		the data collected during the compile.

	10/06/00 - SPIER - 41971
		Modified UCGMC section to add indicator that 
		code being compiled is coming fom this routine.

	08/14/00 - SANCHEZ	40349
		Fixed infinite loop condition in checkCalls

	02/18/00 - SPIER - 35208
		Modified newTable to change the format type from
		Numeric to text for all columns.

	09/15/99 - Chiang - 35208
		Modified newTable section to limit global name to 8
		characters.

	06/11/99 - FRS - 32919
		Modified to support supertype table.

	01/05/99 - SPIER - 31307
		Modified 'newTable' section to prevent the removal of 
		DQ created tables of the same name. 

	12/16/98 - CHIANG - 31307
		Modified 'newTable' section to allow tables defined with
		only access keys.
	*/
	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	type public String fCompile()

	set cmd = cmd.extract( 2, cmd.length())

	if cmd="ACCEPT"             quit $$ACCEPT( m2src(), lptr, str, .ptr, tok)
	if cmd="BYPASS"             quit $$BYPASS( m2src(), .lptr, .ptr)
	if cmd="CLASSDEF"           quit $$ignore( str, .ptr, tok)
	if cmd="IF"                 quit $$IF( m2src(), .lptr, str, .ptr, tok)
	if cmd="ELSE",  fCompile>0  quit $$ELSE( m2src(), .lptr, .ptr)
	if cmd="END",   fCompile>0  quit $$END( .ptr)
	if cmd="ENDIF", fCompile>0  quit $$END( .ptr)
	if cmd="OPTIMIZE"           quit $$OPTIMIZE( str, .ptr, tok)
	if cmd="OPTION"             quit $$OPTION( str, .ptr, tok)
	if cmd="PACKAGE"            quit $$ignore( str, .ptr, tok)
	if cmd="PROPERTYDEF"        quit $$ignore( str, .ptr, tok)
	if cmd="WARN"               quit $$WARN( str, .ptr, tok)
	if cmd="INFO"               quit $$INFO( str, .ptr, tok)
	if cmd="WHILE"              quit $$WHILE( m2src(), .lptr, str, .ptr, tok)
	if cmd="XECUTE"             quit $$XECUTE( str, .ptr, tok)

	do PSL.error( "Unexpected compiler command: "_cmd)
	set ptr = 0
  	quit "; "_str

	// ---------------------------------------------------------------------
private String ignore( noret String str,
		ret   Number ptr,
		noret String tok)
	/* ---------------------------------------------------------------------
	return comment string for commands that are ignored here
	*/
	set ptr=0
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	quit "; "_$$UNTOK^%ZS(str,tok)

	/* ================================================================== */
	/* Compiler directives that occur in PSL source code                  */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
private String ACCEPT( noret String m2src(),
		noret Number lptr,
		noret String str,
		ret   Number ptr,
		noret String tok)	// Accept a warning and quiet the compiler
	/* ---------------------------------------------------------------------
	*/
	type public String pslPrsr(,,)

	type String atom = "", kwd,return
	type List   val
	type Number elm, llptr = m2src(lptr).order()

	for  set return = $$getExpr(str,.ptr,tok, "") quit:return.isNull()  set atom=atom_return quit:ptr=0

	for kwd="DATE","PGM" do {
		set val = atom.getSub( kwd, ";", "=", 1)

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if val.isNull() do warnGroup^UCGM( "SYNTAX", "Accept requires "_kwd_" field")
	}

	/* CR field is required for PSL v2.7 and up only.
	   To prevent warnings for "old" #ACCEPTS that carried into PSL v2.7 +,
	   try to extract the YEAR from the DATE keyword (delimiter + 4 digits
	   at the end, or 4 digits + delimiter at the beginning, programmers
	   that still use 2 digit years will get what they deserve).
	   If the year is before 2005, don't warn. */
	if pslPrsr("cs","PSL","Version") '< 2.7 do {
		set val = atom.getSub( "CR", ";", "=", 1)
		if val.isNull() do {
			type String dat = atom.getSub( "DATE", ";", "=", 1)
			if dat?.E1P4N set dat = dat.extract( dat.length()-3, dat.length())
			else   if dat?4N1P.E set dat = dat.extract(1, 4)
			if dat?4N, dat.toNumber()<2005 quit

			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			do warnGroup^UCGM( "SYNTAX", "Accept requires CR field")
		}
	}

	/* Deal with the GROUP tag. Currently every value is acceptable
	   */
	set ptr = 0
	set val = atom.getSub("GROUP", ";", "=", 1).upperCase()
	if val.isNull() set pslPrsr( "ACCEPT", llptr) = ""
	else  for elm=1:1:val.count() set pslPrsr( "ACCEPT", llptr, val.elementAt(elm)) = ""

	quit "; "_ str

	// ---------------------------------------------------------------------
private String BYPASS( noret String m2src(),
		ret   Number lptr,
		ret   Number ptr)	// Bypass the M++ compiler
	/* --------------------------------------------------------------------	
	All lines following this line, until the line that contains the
	"#ENDBYPASS" is directly inserted into the target code.
	A warning message will be supplied.
	*/
	type String  init
	type String  mcode
	type Boolean stop = 0

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do warnGroup^UCGM( "BYPASS", "Embedded M code bypassing compiler")

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set init = $$initLine^UCGM( PSL.level)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do ADD^UCGM( init_";*** Start of code by-passed by compiler")

	while 'stop  set lptr = m2src(lptr).order() quit:lptr=""  do {

		set mcode = m2src(lptr)
		if mcode.upperCase()["#ENDBYPASS" set stop=1 quit
		set mcode=init_ mcode.translate( 9.char()," ").trim(-1)

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		do ADD^UCGM( mcode)
	}

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do resetType^UCGM()	// Invalidate assignments to Primitives

	set ptr = 0
	quit ";*** End of code by-passed by compiler ***"


	// ---------------------------------------------------------------------
private String IF( noret String m2src(),
		ret   Number lptr,
		noret String str,
		ret   Number ptr,
		noret String tok)	// Process #IF
	/* ---------------------------------------------------------------------
	There are two forms of #IF:
	1) #IF condition
		This form indicates that the code block following the source
		line that contains the #IF and including all lines up to the
		matching #ELSE or #END must only be included if the condition is
		met. If the condition is not met, the lines will not be included
		in the generated M routine.
	2) #IF condition code
		This form indicates that the code following the condition shall
		only be included if the condition is met. By definition, the
		scope of the #IF is just the current source line, and #ELSE is
		inappropriate.

	NOTES:
	. Due to the very strict interpretation of code-following-the-condition,
		the current implementation treats the follwoing combination as a
		case of #IF conditition code:
			#IF condition // comment
	. The functions IF, ELSE, END, and WHILE use public variable fCompile()
		to keep track of the outcome of nested #IFs:
		- if a #IF block is detected, fCompile is incremented, and the
			truthvalue is stored in fCompile(fCompile)
		- a successive #ELSE checks fCompile(fCompile) to see if its
			code block needs to be included or skipped
		- the #END and #ENDIF directives KILL fCompile(fCompile), and
			decrement fCompile
	*/
	type public String fCompile()
	type public String struct(,)
	type public PSLParser pslPrsr

	type String  atom,cmdDel
	type Number  cmdNum
	type Boolean isTrue

	/* Do not untokenize str here, because atom will be passed to
	   $$condBool^UCGM(), and that function expects a tokenized string.
	   */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set atom=$$ATOM^%ZS(str,.ptr,";",,1)

	// Find any extrinsic functions ($$) used in #IF
	if atom["$$" do {
		type String fatom,func
		type Number fptr

		set fptr = 0
		for  do { quit:fptr=0
			/* Don't need to untokenize here either, because only
			   the method^module are used here. */
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			set fatom=$$ATOM^%ZS(atom,.fptr,"+-*/\#_'=><[]&!?",,1)
			quit:fatom.extract(1,2)'="$$"
			set func = fatom.piece( "(", 1)
			set func = func.extract( 3, func.length())
			do pslPrsr.addSysmap( "#IF", "FUNC", func, "")
		}
	}
	set cmdDel = $select(ptr:str.extract(ptr+1),1:""),cmdNum=0

	type Number ER = 0

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set atom=$$condBool^UCGM(atom) if ER quit ""

	do {
		catch ifEx {
			do PSL.error(" Runtime exception in #IF: "_ifEx.toString())
		}

		#ACCEPT DATE=20060314;PGM=FSCW;CR=20280;GROUP=XECUTE
		xecute ("S isTrue="_atom)

		if 'isTrue set ptr = 0	// Don't process the rest of the line

		if isTrue set struct( 7, PSL.subRou) = lptr
		if '(cmdDel=" ") do {			// #IF/#END[IF] block

			set fCompile = fCompile+1
			set fCompile(fCompile) = isTrue_ 9.char()_ lptr

			if 'isTrue do skip( m2src(), .lptr, "#IF")
		}
	}

	quit ""

	// ---------------------------------------------------------------------
private String INFO( noret String str,
		ret Number ptr,
		noret String tok)
	/* ---------------------------------------------------------------------
	#INFO groups switch

	INFO groups are the same as WARN groups, even though most groups will
	have no associated INFO messages.
	*/
	type public PSLParser pslPrsr

	type List    all  = $$allINFO
	type List    atom = $$getExpr( str, .ptr, tok, $$allWARN)
	type Boolean switch=$$getSwitch(str, .ptr, tok, 1)

	do setCmds( "INFO", atom, switch, all, pslPrsr)

	set ptr = 0
	quit ""

	// ---------------------------------------------------------------------
private String ELSE( noret String m2src(),
		ret Number lptr,	// Process #ELSE
		ret Number ptr)
	/* ---------------------------------------------------------------------
	*/
	type public String fCompile()

	if fCompile(fCompile).piece( 9.char()) do skip( m2src(), .lptr, "#ELSE")

	quit ""

	// ---------------------------------------------------------------------
private String END( ret Number ptr)	// Process #END or #ENDIF
	/* ---------------------------------------------------------------------
	*/
	type public String fCompile()

	kill fCompile(fCompile)

	set fCompile = fCompile-1
	set ptr = 0

	/* ======== code below questionable
	if PSL.subRou="" do {					// Ended with a quit

		for  set lptr=$O(m2src(lptr)) quit:lptr=""!($L($TR($E(m2src(lptr)),$C(9,32))))
		set lptr=$O(m2src(lptr),-1)
	}
	======== */

	quit ""

	// ---------------------------------------------------------------------
private String OPTIMIZE( noret String str,
		ret   Number ptr,
		noret String tok)
	/* ---------------------------------------------------------------------
	#OPTIMIZE options switch
	*/
	type public PSLParser pslPrsr

	type List    all  = $$allOPTIMIZE
	type List    atom = $$getExpr( str, .ptr, tok, all)
	type Boolean switch = $$getSwitch(str, .ptr, tok, 1)

	do setCmds( "OPTIMIZE", atom, switch, all, pslPrsr)

	set ptr = 0
	quit "; "_str

	// ---------------------------------------------------------------------
private String OPTION( noret String str,
		ret   Number ptr,
		noret String tok)
	/* ---------------------------------------------------------------------
	#OPTION options switch
	*/
	type public PSLParser pslPrsr

	type List all  = $$allOptions

	do {
		catch xClsdes {
			// ignore exception on clsdes (eg dummy or null moduleName)
			}
			type PSLClass clsdes = pslPrsr.getPSLClass( pslPrsr.moduleName)
			if clsdes.classType > -1 set all = all.piece(",ResultClass")_all.piece(",ResultClass",2)
	}

	type List    atom = $$getExpr( str, .ptr, tok, all)
	type Boolean switch = $$getSwitch(str, .ptr, tok, 1)

	do setCmds( "Options", atom, switch, all, pslPrsr)

	set ptr = 0
	quit "; "_str

	// ---------------------------------------------------------------------
private String WARN( noret String str,
		ret   Number ptr,
		noret String tok)
	/* ---------------------------------------------------------------------
	#WARN groups switch
	*/
	type public PSLParser pslPrsr

	type List    all  = $$allWARN
	type List    atom = $$getExpr( str, .ptr, tok, all)
	type Boolean switch=$$getSwitch(str, .ptr, tok, 1)

	do setCmds( "WARN", atom, switch, all, pslPrsr)

	set ptr = 0
	quit ""

	// ---------------------------------------------------------------------
private String WHILE( noret String m2src(),
		ret   Number lptr,
		noret String str,
		ret   Number ptr,
		noret String tok)	// Process #WHILE
	/* ---------------------------------------------------------------------
	*/
	type public String fCompile()

	type String expr
	type Number ER,i,lptrb,lptre

	// condition as PSL expression
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type PSLExpression atom=$$ATOM^%ZS(str,.ptr,";",tok)
	type String        cmdDel=$select(ptr:str.extract(ptr+1),1:""),
	type Number        cmdNum=0

	set (lptrb,lptre)=lptr

	/* If #WHILE-block, find the associated #END by calling skip(,,)
	   */
	if cmdDel="" set fCompile = fCompile+1 do skip( m2src(), .lptre, "#WHILE")

	type Boolean bQuit = 0

	for i=1:1:1000 do { if bQuit quit

		set ER=0
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set expr=$$condBool^UCGM(atom) if ER set bQuit=1 quit

		do {
			catch whileEx {
				do PSL.error( "Runtime exception in #WHILE: "_whileEx.toString())
				set bQuit=1
			}
			#ACCEPT DATE=20060314;PGM=FSCW;CR=20280;GROUP=XECUTE
			xecute "I "_expr
			else  set bQuit=1 quit

			set lptr=lptrb

			/* Single line #WHILE
			   */
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			if (lptr=lptre) do line^UCGM( m2src(lptr).extract( ptr+1, PSL.maxLineLength)) quit

			/* Multiple line #WHILE
			   */
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			for  set lptr = m2src(lptr).order() quit:(lptr'<lptre)  do line^UCGM( m2src( lptr)) if ER quit
		}
	}
	set lptr=lptre

	set ptr=0
	quit ""

	// ---------------------------------------------------------------------
private String XECUTE( noret String str,
		ret   Number ptr,
		noret String tok)	// xecute a string in the compiler
	/* ---------------------------------------------------------------------
	Ignored in BOOT mode (all levels)
	*/
	if PSL.getSetting("boot","restrictionlevel",0)>0 set ptr=0 quit ""

	#ACCEPT DATE=2006-03-14;PGM=FSCW;CR=20280;GROUP=ACCESS,XECUTE
	xecute $$UNTOK^%ZS(str.extract( ptr + 2, str.length()),tok)
	set ptr = 0

	quit ""

	/* ================================================================== */
	/* Compiler directives that occur in UCOPS files                      */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
private void DEFINE( PSLParser prsr
		, noret String str
		, ret   Number ptr
		, noret String tok
		) // #DEFINE [section.]name value
		
	/* ---------------------------------------------------------------------
	This directive is only allowed in UCOPTS files.

	The value can be a literal (Sting or Number only), or it can be a simple
	expression composed of literals, and the string operator (_), the
	arithmatic operators (+, -, *, /, \, and #) or logical operators (', &,
	and !) and parenthesis.
	*/
	type literal String BINOPS = "+-*/\#_'!&()"

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type PSLExpression name = $$ATOM^%ZS( str, .ptr, "", tok)
	type String sect = "DEFINE"

	if name["." set sect = name.piece( "."), name = name.extract( name.find("."), name.length())
	if '({List}"boot,DEBUG,DEFINE").contains( sect) do PSL.error( "Invalid section '"_ sect_ "'") set ptr = 0
	if 'name.isVariable() do PSL.error( "Variable name expected") set ptr = 0

	type PSLExpression expr = ""
	type String atom,atomsect
	while ptr>0 do {
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set atom = $$ATOM^%ZS( str, .ptr, BINOPS, tok)
		if BINOPS[atom set expr = expr_atom quit
		if atom.isLiteral() set expr = expr_atom quit
		set atomsect = sect
		if atom [ "." set atomsect = atom.piece( "."), atom = atom.extract( atom.find("."), atom.length())
		if atomsect '= sect do PSL.error( "Invalid section '"_ atomsect_ "'") set ptr=0 quit
		if 'prsr.hasSetting( sect, atom) do PSL.error("Invalid experession element: "_atom) set ptr=0 quit
		set expr = expr_ prsr.getSetting( sect, atom)
	}

	#ACCEPT Date=2006-04-25; PGM=FSCW; CR=20280; Group=XECUTE
	xecute "set expr="_expr
	do prsr.addSetting( sect, name, expr)

	quit

	// ---------------------------------------------------------------------	
private void PSL( PSLParser prsr	// parser that wants to receive the setting
		, noret String str
		, ret Number ptr
		, noret String tok
		) // #PSL settingName value
	/* ---------------------------------------------------------------------
	The #PSL compiler command supports the assignment of an arbitrary literal 
	value to a single compiler setting.

	The value found in the string will be validated here. Incorrect values
	will not be added to the PSLParser.
	All mismatches are reported as warnings, because UCGMCU will force
	default values for every settingName. As a result, incorrect #PSL
	compiler command lines will effectively be ignored.
	*/
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String name = $$ATOM^%ZS(str,.ptr,"",tok)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if name.isNull()!$$isComment(name) do warnGroup^UCGM("MISMATCH","missing settingName in #PSL") quit

	type String value = ""

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if ptr>0 set value = $$ATOM^%ZS(str,.ptr,"",tok)
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if value.isNull()!$$isComment(value) do warnGroup^UCGM("MISMATCH","missing value in #PSL") quit
	if value = "true" set value = 1
	else  if value = "false" set value = 0
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	else  if 'value.isLiteral() do warnGroup^UCGM("MISMATCH","Invalid #PSL String value '"_value_"'") quit
	if 'value.isNumber() set value = value.stripQuotes()

	// check settingName and value
	type List all = $$allPSL()
	type Number pos = all.position( name, , 1)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if pos = 0 do warnGroup^UCGM("MISMATCH","Invalid #PSL settingName '"_ name_ "'") quit
	if 'all.contains( name) {
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		do warnGroup^UCGM("MISMATCH","#PSL settingName ("_ name_") is case sensitive")
		set name = all.elementAt( pos)
	}
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if prsr.hasSetting( "PSL", name) do warnGroup^UCGM("MISMATCH","Ignored duplicate #PSL "_ name) quit

	if name = "BooleanMask" {
		/* #PSL BooleanMask String
		   The value follows the pattern trueWord,falseWord, and shall
		   not contain quotes. Or it shall be "".
		   See UCOPTS.ini for the meaning of an empty mask.
		   */
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if 'value.isNull(), value.length(",")'= 2 ! value.contains("'")! value.contains("""") do warnGroup^UCGM("MISMATCH","Invalid #PSL BooleanMask value '"_value_"'") quit

		do prsr.addSetting( "PSL", "BooleanMask", value)
	}
	else  if name = "CompileSummary" {
		/* #PSL CompileSummary Boolean
		   The value must be a PSL boolean (0, 1, false, true).
		   */
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if '({List}"0,1").contains( value) do warnGroup^UCGM("MISMATCH","Invalid #PSL CompileSummary value '"_ value_ "'") quit

		do prsr.addSetting( "PSL", "CompileSummary", value)
	}
	else  if name = "DateMask" {
		/* #PSL DateMask String
		   The value must be a valid date mask, or it must be "".
		   See UCOPTS.ini for the meaning of an empty mask.
		   */
		catch xmask { // if exception is thrown, the mask is invalid
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			do warnGroup^UCGM("MISMATCH","Invalid #PSL DateMask value '"_value_"'")
		}
		/* Try the mask on %CurrentDate. If it fails, report a warning.
		   The call to addSetting() will only execute if no exception
		   was thrown.
		   */
		type String ign
		if 'value.isNull() set ign = %CurrentDate.toString( value)

		do prsr.addSetting( "PSL", "DateMask", value) // seems OK !
	}
	else  if name = "TimeMask" {
		/* #PSL TimeMask String
		   The value must be a valid time mask, or it must be "".
		   See UCOPTS.ini for the meaning of an empty mask.
		   */
		catch xmask { // if exception is thrown, the mask is invalid
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			do warnGroup^UCGM("MISMATCH","Invalid #PSL TimeMask value '"_value_"'")
		}
		/* Try the mask on %CurrentTime. If it fails, report a warning.
		   The call to addSetting() will only execute if no exception
		   was thrown.
		   */
		type String ign
		if 'value.isNull() set ign = %CurrentTime.toString( value)

		do prsr.addSetting( "PSL", "TimeMask", value) // seems OK !
	}
	else  if name="Version" {
		/* #PSL Version Number
		   The value must be a Number between the minimum version and
		   the maximum (= current) version that can be handled by the
		   compiler ($$getPSLMinVersion^PSLC() and
		   $$getPSLVersion^PSLC())
		   */
		type Number minVersion = $$getPSLMinVersion^PSLC()
		type Number pslVersion = $$getPSLVersion^PSLC()	

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if '(value.isNumber()) do warnGroup^UCGM("MISMATCH","invalid #PSL Version value '"_ value_ "'") quit
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if value<minVersion do warnGroup^UCGM("MISMATCH","#PSL Version cannot be less than "_ minVersion) quit
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if value>pslVersion do warnGroup^UCGM("MISMATCH","#PSL Version cannot be greater than "_ pslVersion) quit

		do prsr.addSetting( "PSL", "Version", value)
	}

	quit

	/* ================================================================== */
	/* public and private functions and subroutines                       */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
public List allINFO() // return list of all possible INFO options
	/* ---------------------------------------------------------------------
	This function returns a List of all possible INFO options.

	The values that are site configurable are described in UCOPTS.ini. In
	addition the following values are intended for system use only:
	INTERNAL	report internal compiler warnings (such as unexpected
			calls or values).
	*/
	quit $$allWARN

	// ---------------------------------------------------------------------
public List allOPTIMIZE() // return list of all possible OPTIMIZE options
	/* ---------------------------------------------------------------------
	This function returns a sorted List of all possible optimization
	options. It can be used by supporting code for validation, or to turn
	optimize options ON or OFF before the PSL compiler is invoked.

	See UCOPTS.ini for a description of the individual values.
	*/
	quit "FUNCTIONS,OBJECTS"

	// ---------------------------------------------------------------------
public List allOptions() // return list of all possible Option options
	/* ---------------------------------------------------------------------
	This function returns a sorted List of all possible Option options.
	It can be used by supporting code for validation, or to turn Options
	options ON or OFF before the PSL compiler is invoked.
	There is no $$defOptions() function because all Option options are
	"OFF" by default.

	The values that are site configurable are described in UCOPTS.ini. In
	addition the following values are intended for system use only:
	nolink		suppress automatic ZLINK of compiled routine
	*/
	quit "$GetEFD,AutoPublicERRM,nolink,ResultClass"

	// ---------------------------------------------------------------------
public List allPSL() // return list of all possible PSL commands
	/* ---------------------------------------------------------------------
	This function returns a List of all possible PSL settingNames.

	The values that are site configurable are described in UCOPTS.ini. 
	*/
	quit "BooleanMask,CompileSummary,DateMask,TimeMask,Version"

	// ---------------------------------------------------------------------
public List allWARN() // return list of all possible WARN options
	/* ---------------------------------------------------------------------
	This function returns a sorted List of all possible warning options.
	It can be used by supporting code for validation, or to turn warning
	options ON or OFF before the PSL compiler is invoked.

	The values that are site configurable are described in UCOPTS.ini. In
	addition the following values are intended for system use only:
	INTERNAL	report internal compiler warnings (such as unexpected
			calls or values).
	*/
	type literal String WARN01 = "ACCESS,BYPASS,DATABASE,DEAD,DEPRECATED"
	type literal String WARN02 = WARN01_",DYNAMIC,FUNCTION,GLOBAL,LENGTH"
	type literal String WARN03 = WARN02_",MISMATCH,PRECEDENCE,PSLBOOT,READ"
	type literal String WARN04 = WARN03_",RECEXISTS,SCOPE,SYNTAX,SYSVAR"
	type literal String WARN   = WARN04_",XECUTE"
	quit WARN

	// ---------------------------------------------------------------------
private void decode( PSLParser pslPrsr, String line) // decompose a line
	/* ---------------------------------------------------------------------
	This subroutine decodes a line that contains a #INFO, #WARN, #OPTIMIZE,
	#OPTION or #DEFINE compiler command.

	NOTES:
	. The name of the PSLParser parameter must be equal to the name that is
		used in the type public PSLParser defintions of the compiler
		instracutions that are decoded.
	*/

	// declare and hide PUBLIC vars of all #command implementations
	type String fCompile(),RM,struct(,)
	type Number ER

	type Number ptr = 0
	type String tok

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set line = $$TOKEN^%ZS( line, .tok)

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String cmd = $$ATOM^%ZS( line, .ptr, ";").upperCase()

	if $$isComment( cmd) quit
	if ({List}"#INFO,#OPTIMIZE,#OPTION,#WARN").contains(cmd) set cmd = $$UCGMC( cmd, , 0, line, ptr, tok) quit

	if cmd="#DEFINE" do DEFINE( pslPrsr, line, ptr, tok) quit
	if cmd="#PSL" do PSL( pslPrsr, line, ptr, tok) quit

	quit

	// ---------------------------------------------------------------------
void decodeFile( String sDir, String sFil, PSLParser prsr) // decompose a file
	/* ---------------------------------------------------------------------
	This subroutine decodes a line that contains a #WARN, #OPTIMIZE or
	#OPTION compiler command.
	*/
	type IO rIO = Class.new( "IO")
	set rIO.directory = sDir
	set rIO.fileName  = sFil
	set rIO.openParams = "READ"

	type String subRou = rIO.device		// subRou for PSL.error()
	type Number lptr			// line pointer for PSL.error()
	do {
		catch xIO {
			if xIO.type'["OPEN" do rIO.close()
		}
		do rIO.open()
		for lptr=1:1 do decode( prsr, rIO.read().translate( 9.char(), " "))
	}	
	quit

	// ---------------------------------------------------------------------
public List defOPTIMIZE() // return list of default OPTIMIZE options
	/* ---------------------------------------------------------------------
	This function returns a sorted List of all optimization options that
	are "ON" by default.
	It is used by UCDTASYS.proc to set the defualt set of options if
	UCOPT did not provide an environment specific value.
	*/
	quit $$allOPTIMIZE()

	// ---------------------------------------------------------------------
String replaceAndNotOr( String src)	// replace keywords and/or/not
	/* ---------------------------------------------------------------------
	Support function, called by $$lineAndNotOr^UCGM() to replace the
	keywords and, or, and not by the associated boolean operator.
	*/
	type literal List KWDS = "and,not,or"
	type literal List BOPS = "&,',!"

	type public PSLParser pslPrsr

	quit:pslPrsr.getSetting("PSL","Version")<3 src

	type String cd, ct, kw, lc, rc
	type Number c1 = PSL.maxStringLength+2 ,c2 = PSL.maxStringLength+2, wc

	if src.contains("//") set c1 = src.find("//")
	if src.contains(";")  set c2 = src.find(";")
	if c1<c2 set cd = src.extract(1, c1-2)
	else  set cd = src.extract(1, c2 - 2)
	set ct = src.extract( cd.length() + 1, src.length())

	for wc = 1:1:KWDS.count() {
		set kw = KWDS.elementAt( wc) quit:cd'[kw
		for lc = " ",")" if cd.contains( lc_ kw) {
			for rc = " ", "(" if cd.contains( lc_ kw_ rc) set cd = cd.replace( lc_kw_rc, lc_ BOPS.elementAt(wc)_ rc)
		}
	}
	quit cd_ct

	// ---------------------------------------------------------------------
String SetLit( noret PSLExpression mcode,	// M code under construction
		noret PSLExpression atom,		// target variable
		noret PSLExpression expr) 		// value to assign
	/* ---------------------------------------------------------------------
	Set a value to it's literal
	*/
	do {
		catch xLit {
			set xLit.ident = "LITERAL"
			throw xLit
		}
		if 'expr.fitsLineLength( "S expr=".length()) set expr = $$bigExpr(expr)
		#ACCEPT DATE=20060314;PGM=FSCW;CR=20280;GROUP=XECUTE
		else  xecute ("S expr="_expr)
	}
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do setInst^UCGM( atom, "", expr.toByteString().toPSLExpression())

	/* Strip "S " from end of mcode
	   */
	quit mcode.extract( 1, mcode.length()-2)

	// ---------------------------------------------------------------------
void splitCode( noret String expr,	// long string
		noret Number extra,		// extra room (*2)
		noret String at,		// characters at which to split (*3)
		String split())		// chunks
	/* ---------------------------------------------------------------------
	Split a long string into chuncks that fit within the (byte)length limits
	imposed by the GT.M implementation.

	ARGUMENTS:
	(*2) extra = extra room needed to construct the code
		The difference between PSL.maxLineLength and the actual maximum
		supported by the platform will leave room for some additonal
		code. However, if the code to be added has "substantial" length,
		then the chunks shall be smaller to allow for the extra
		characters needed for the code. The value supplied here will be
		substracted from PSL.maxLineLength to obtain the maximum length
		of the chuncks in split().
	(*3) at = characters that are valid split characters
		If empty, expr will be split at "arbitrary" positions,
		that are determined completely by PSL.maxLineLength
		If not empty, the subroutine will scan backward from the position
		determined by PSL.maxLineLength to find one of the characters in
		at. However, at least MINCHUNKSIZE characters will placed in a
		chunk.
	*/
	type literal Number MINCHUNKSIZE = PSL.maxLineLength \ 8
	type Number y

	for  do { quit:expr.isNull()
		set y = expr.byteLimitSubstring( 1, PSL.maxLineLength - extra).length()

		if 'at.isNull(),y<expr.length() for y=y:-1:MINCHUNKSIZE quit:at[expr.extract(y)

		set split(split("").order(-1) + 1) = expr.extract( 1, y)
		set expr = expr.extract( y+1, expr.length())
	}
	quit

	/* ================================================================== */
	/* local support functions and subroutines                            */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
private String bigExpr(noret String expr)	// Execute an expression that's bigger than the M line length !!
	/* ---------------------------------------------------------------------
	*/
	type String tok,vox()
	type Number sub

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set expr = $$TOKEN^%ZS( expr, .tok)
	for  quit:'(expr[0.char())  do {
		set sub =  vox("").order(-1)+1

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set vox(sub) = $$UNTOK^%ZS( 0.char()_ expr.piece( 0.char(), 2)_ 0.char(), tok)
		set vox(sub) = vox(sub).stripQuotes()
		set expr=expr.piece(0.char(),1)_"vox("_sub_")"_expr.piece( 0.char(),3,9999)
	}

	#ACCEPT DATE=2006-03-14;PGM=FSCW;CR=20280;GROUP=XECUTE
	xecute ("S expr="_expr)

	quit expr

	// ---------------------------------------------------------------------
private String getExpr( noret String str,
		ret   Number ptr,
		noret String tok,
		noret String dft
		)	// Return expression value
	/* ---------------------------------------------------------------------
	*/
	if ptr = 0 quit dft		// Default expression

	type String atom

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set atom = $$ATOM^%ZS(str,.ptr,"",tok).upperCase()

	if $$isComment(atom) do {		// Hit a comment, use default

		if ptr=0 set ptr = str.length()
		set ptr = ptr - atom.length() - 1
		set atom = dft
	}
	quit atom

	// ---------------------------------------------------------------------
private String getSwitch( noret String str,
	ret   Number ptr,
	noret String tok,
	noret String dft)	// Return switch value
	/* ---------------------------------------------------------------------
	*/
	type Boolean atom = $$getExpr(str, .ptr, tok, dft)

	if atom=0!(atom=1)
	else  if atom="ON"  set atom=1
	else  if atom="OFF" set atom=0
	else  do PSL.error( "Unknown Compiler Switch: "_atom)

	quit atom

	// ---------------------------------------------------------------------
private Boolean isComment( noret String expr)	quit (expr=";")!(expr="//")!(expr="/*")

	// ---------------------------------------------------------------------
private void setCmds( noret String cls,	// level 1 subscript in cmds()
		noret List vals,	// List of assignment targets (*2)
		noret String switch,	// value to store
		noret List valid,	// List of valid values (*4)
		PSLParser cmds)		// output array (*5)
	/* ---------------------------------------------------------------------
	support function that sets pslPrsr(cls,val)=switch for each val in vals

	ARGUMENTS:
	(*2) vals = List of assignment targets
		Probably produced by $$getEpxr(), in which case the values are in
		uppercase
		If vals="*", then the function will replace is by valid. This
		effectively acts as an indicator for "all".
	(*4) valid = List of valid values
		The purpose of this List is two fold:
		- an entry will only be added to cmds(cls,) if the element from
			vals occurs in valid (ignoring case)
		- the entry will be added using the case in valid, not the case
			in vals.
	(*5) cmds(,) = output array
		cmds(cls,val) will be added for each val in vals, provided that
		it occurs in valid, and using the spelling of valid.
	*/
	type Number elm,pos
	type String val

	if vals = "*" set vals = valid

	for elm=1:1:vals.count() do {
		set val = vals.elementAt(elm)
		set pos = valid.position( val, , 1)
		if pos>0 do cmds.addSetting( cls, valid.elementAt(pos), switch)
	}
	quit

	// ---------------------------------------------------------------------
private void skip(	noret String m2src(),
		ret   Number lptr,
		noret String cmd)
	/* ---------------------------------------------------------------------
	Skip over code section, stop at #ELSE or #END[IF] on #IF level
	*/
	type public Number fCompile

	type String atom, rec, tok
	type Number ptr, stop = fCompile

	for  set lptr = m2src(lptr).order() quit:lptr=""  do { if (fCompile<stop)!(stop=0) quit

		set ptr=1

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set rec  = $$TOKEN^%ZS( m2src(lptr).translate( 9.char(), " "),.tok)

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set atom = $$ATOM^%ZS(rec,.ptr,";",.tok).upperCase()

		if atom="#END"   set atom=$$END(.ptr) quit	// #END
		if atom="#ENDIF" set atom=$$END(.ptr) quit	// #ENDIF
		if atom="#ELSE",fCompile=stop set stop=0 quit
		if atom="#IF" do {				// Nested #IF
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			set atom = $$ATOM^%ZS(rec,.ptr,";",tok)
			if ptr=0!(rec.extract(ptr+1)'=" ") set fCompile = fCompile + 1
		}
	}

	if lptr.isNull() set lptr = m2src("").order(-1) do PSL.error("Missing #END")
	quit
 #OPTION ResultClass ON
public String vSIG()	quit "61111^17292^Frans S.C. Witte^41613"	// Signature - LTD^TIME^USER^SIZE
