	/*
	ORIG:	Frans S.C. Witte, 2005-03-11
	DESC:	This unit contains subroutines and functions that deal with
		interaction to the DATA-QWIK Data Dictionary.
		It belongs to the Dictionary group of the compiler.

	---- Environment Sensitive Elements ------------------------------------
	DBTBL1D.TYP = 'L' and DBTBL1D.REQ = 1 and DBTBL1D.DEF is not null
		For consistent upgrade behavior across different Profile
		versions, the following addtional requirements must be met:
		- The source environment of UCXDD shall be of the latest Profile
			version.
		- All columns of dictionary tables that have dataType="L", and
			that are UPDATED during an upgrade shall be defined
			explicitly according to the latest rules (REQ=1, DEF IS
			NOT NULL).

	---- Comments ----------------------------------------------------------
	Even though it is likely that the DQ DD will reside in M for quite some
	time, access to the dictionary will be grouped into units that are
	clearly distinguishable by name.

	This procedure contains runtime functions. A number of these functions
	are encapsulated as methods or properties of schema related classes (such
	as PSL, PSLColumn, SchemaTable, and SchemaColumn). The subroutines that
	generate the code for these methods resides elsewhere (UCMETHOD for PSL
	and PSLColumn, UCDB and UCSCHEMA for SchemaTable and SchemaColumn).

	Function Name Conventions
	=========================
	This unit provides assess to the "PSL view" of the data at several
	levels:
	* The PSL class level
		The unit focusses on implementing the runtime behavior of the
		methods and properties of the PSL classes that encapsulate the
		Data Dictionary. The signature of the runtime function follows
		the signature of the class method, with the reference to the
		object as the first parameter. The code for the runtime call
		will be generated by a subroutine in UCMETHOD, that has the same
		name as the function in this unit:
		PSL syntax:		objInst.someMethod(p1,p2,p3)
		Signature in UCXDD:	somMet(objInst,p1,p2,p3)
		Code generated by:	somMet^UCMETHOD, using actual() 1,2,3
	* The non-PSL runtime level
		In some cases, the code to retrieve or assign column values is
		not known until runtime, e.g. when the SQL* modules translate a
		SQL statement into Record.property references. To complement the
		runtime PSLColumn class calls, runtime wrapper calls are
		provided. The signature of these convenience methods is derived
		from the signature of the class method. Instead of the PSLColumn
		instance, the tablename (tn) and columnname (cn) are provided.
		In addition these calls support use of a "SchemeTable cache
		array" (tdc()) and a "PSLColumn cache array" (cdc()). These
		functions will add the PSLColumn instance and the SchemaTable
		instance to the class if needed.
		Runtime class call:	somMet(objInst,p1,p2,p3)
		Runtime wrapper call:	rtSomMet(tbl,cln,p1,p2,p3,tdc(),cdc())
	* The code generating level
		This is the lowest level interface. It assumes knowledge of all
		parameters that are needed to generate a certain piece of code,
		but hides the details of combining these parameters.
		A good example is the funtion that generates the code for the
		maintenance of the -161/-162 info. It requires 9 parameters, but the
		caller does not need to know that the data ends up in the
		vobj(,-161-162,) subtree. The name of the code generating function
		follows the name of the runtime class call. Because there is no
		direct relationship between the parameters of the runtime class
		call, and the parameters needed to generate the code, the order
		of the parameters to the code generating function is not related
		to the parameter order in the runtime class call. 
		Runtime class call:	somMet(objInst,p1,p2,p3)
		Code generation call:	cdSomMet(pX,pY,pZ)
	* The value calculation level
		This too is a low level interface. Where cdSomMet(pX,pY,pZ)
		returns the code to construct the value, vlSomMet(pX,pY,pZ) will
		calculate that value at runtime. Because these functions use
		primitive values only, and refrain from property refernces or
		method calls, these function can be used by all classes without
		the danger of resursion.
		Runtime class call:	somMet(objInst,p1,p2,p3)
		Value calculation call:	vlSomMet(pX,pY,pZ)
	In general the runtime wrapper $$rtSomMet() calls $$somMet(),
	and $$somMet() calls $$cdSomMet(). This ensures that knowledge of the
	implementation details is centralized in one place, and changes to are
	likely to have limited impact on code "elsewhere".
	
	Local Variable Purpose Mapping
	==============================
	A number of calls will generate code that accesses one or mode nodes in
	the vobj() structure. The structure is well-defined, with each node
	serving a specific purpose. For example vobj(recordobject,-2) contains
	the record mode, vobj(recordobject,-152) contains the host variables
	for the WHERE clause to	update the row in an RDB, and vobj(recordobject,-3)
	contains the first primary key value. This mapping between node and
	purpose facilitates optimization mechanisms where the data of the node
	serving that purpose is stored in a separate lvn. To simplify the mapping
	of vobj nodes to lvns a single structure has been defined that describes
	the mapping of nodes in vobj to M lvns. This structure can be passed to
	all calls that support vobj() remapping. The general pattern of the
	structure is:
		lvpm(vobjSubscript2) = lvn to be used in generated code
	However, there are some important exceptions. The private function
	$$lpvm^UCXDD() provides (and documents) the mapping.

	---- Revision History --------------------------------------------------
	2009-02-05, Frans S.C. Witte, CRs 35741/37665
		* Corrected code generated for incremental loading of Blob/Memo

	2009-02-02, RussellDS, CRs 35741/37982
		* Modified getFlrLgc to iteratively deal with any children of
		  parent tables to ensure that all necessary qualifiers get set.
		* Added getChildren method.
	
	2008-12-18, Frans S.C. Witte, CRs 35741/36952
		* Corrected getSavCode() to return code that calls rdbSaveC for
		  parent tables.

	2008-10-22, Frans S.C. Witte, CRs 35741/35918
		* changed access of getExisCode() to public.
		* Changed parameter of rtIsRdb() from /NOREQ to /REQ.
		* Introduced PSLColumn.currentNode property, and modified a
		  number of methods to use this new property.
		* Corrected code generated by getExisCode() for MDB type 1

	2008-10-19, RussellDS, CR35741/35918
		Corrected comments related to node -152 and whether the delimiter
		is trailing or leading.  It's trailing.
	
	2008-09-25, RussellDS, CR35741/35828
		Modified getSavCode for memo/blob field in M to use proper
		extract and length commands, $E or $ZE, $L or $ZL based on
		character set.
	
	09/18/2008 - RussellDS - CR35741/35742
		* Fix problem in getExisCode with need for $D()#2 check for
		  recordtype = 1 tables
	
	01/21/2008 - RussellDS - CR30801
		* Removed reference to SchemaTable.filerPGM and DBTBL1.UDFILE
		* Add PSLTable.pslpackage
		* Modified new to remove the code generation and just return
		  call to RecordTABLE.vcdmNew method
		* Add getNewMethodCode to provide code in support of vcdmNew
		  method
		* Modified getRecQid1 to build appropriate code when called
		  from PSLRecordBuilder
		* Modification to support bootstrapping.
		* Moved getRecCode and getRecQid1 to UCDB
	
	09/21/2007 - Russell - CR29295
		* Modified sections getUpdCode, getUpdOvh, getRdbAsn, and
		  cdRdbAsn to incorporate new parameter and processing for
		  new in-line form of RDB insert/update code.
		* Modified getLodCode to build -161/-162 initialization on
		  incremental loads.
		* Modified getUpdOvh to split return into pre and post overhead
		* Changed comments referencing obsolete -150 info.
		* Modified getSavCode and getSavWr for change in structure
		  of WHERE clause and addition of -152.  The WHERE clause now
		  contains host variables.  -152 contains the values
		  list of those host variables, with a trailing delimiter.
		* Modified calls to obsolete wrapper code for %DBAPI calls and
		  replaced with direct calls.
		* Modified getWhrKey to make it private.  It is now used by
		  other elements to obtain the WHERE clause for the keys
		  instead of the prior assignment of the WHERE clause to
		  (now obsoleted) node -151.

	09/03/07 - Frans S.C. Witte - CR: 27800
		* Changed keyword 'public' to 'ret' in fp declaration.
		* Replaced commands(,) by PSL.xxxSetting()
		* Added #OPTION ResultClass ON
		* PSLTable cache and PSLColumn cache now come from PSLParser.

	08/29/07 - KWANL / Frans S.C. Witte - CR: 28995
		* DQ type "B" now maps to PSL Primitive type ByteString
		* Added PSLColumn cdc() to $$getPslTbl and $$caPslTbl()
		* Modified calculation of PSLColumn.isNullToZero
		* Added support for /UCLREGEN to $$getFlrLgc()
		* Parent tables will now always maintain -100 info
		* Adapted to new CATCH/THROW mechanism

	04/05/07 - Frans S.C. Witte - CR: 26334
		* $$getSavCode() and $$getSavWr() now call $$wrapFits^UCREC4OP()
		  to determine if the code needs multiple code lines.
		* Removed quit after throw to prevent warning

	03/23/07 - RussellDS - CR26386
		* Changes to support archiving -
		   - Added comment in lvpm for vobj(,-99)
		   - Added $$getQuery() and $$isParent()
	
	08/31/06 - RussellDs - CRs: 22719 / 20613
		* Modified getRdbAsn section to eliminate replacement of
		  PSLCoumn.getCurrentNode() with PSLColumn.node to allow
		  VOBJ^DBSDBASE and others access to "right" value
		* In getWhrKey, replaced use of $C(9) with table delimiter.
		* Added code for RDB save through direct SQL statements.
		* All calls to wrXYZ^UCDBRT now pass 0 (zero) instead of "" for
		  vIndex.
		* Added $$nodIsBM(), $$nodIsKey(), $$nodIsNeg() and $$nodIsTop()

	06/23/06 - Frans S.C. Witte - CRs: 21397 / 21937
		Modified $$getFlrLgc() to include CASCADE in the returned list
		in order to differentiate between referencing table and
		referenced table, and added another %LIBS='SYSDEV'.
		Corrected $$getSavCode for negative nodes.

	06/15/06 - Frans S.C. Witte - CRs: 21791 / 21792
		Added $$getSavCode()
		Modified $$getFlrLgc to use %LIBS='SYSDEV' when this works.

	05/24/06 - Frans S.C. Witte - CRs: 21394 / 21395
		Modified warning to conform to standard pattern (PSL-W-XXXX).
		Modified code that generates PSLTable.nodeQuotedList (to be used
		by copy^UCRECORD.

	05/10/06 - Frans S.C. Witte - CRs: 21101 / 18164
		isAutoLog property moved from SchemaTable to PSLTable
		Added $$getFlrLgc().

	05/08/06 - Frans S.C. Witte - CRs: 21158 / 18164
		#IF %VersionID>6.4 also added in tAssert
		Computed logical columns are no longer "required" (with default)

	03/27/06 - Frans S.C. Witte - CRs: 20280 / 18164
		Subroutine getSchCln: Added #IF %VersionID>6.4 for dataType="L".
		Added functions $$getSfdRT(), $$getUpdAudit() and $$getUpdOvh().
		Modified $$getLodCode to use bSel for blob/memo as well

	03/02/06 - Frans S.C. Witte - CRs: 19877 / 18164
		Corrected use of .uppercase() in parseCmp().

	12/23/05 - Frans S.C. Witte - CRs: 18163 / 18164
		PSLTable.database is now derived from DBTBL1.DBASE.
		Added $$getDbase() to provide a standardized default value for
		PSLTable.datase (cf $$getDelimiter())
		Renamed $$getDBI() to $$rtDbase().
		Removed $$vlIsRdb(). Modified $$rtDbase(), $$getPslTbl(),
		$$getSchTbl(), and $$rtIsRdb(), to use $$getDbase().
		Modified $$getDataNode() to use $$CREATESP^DBSDBASE().
		Added support for implied default / isRequired for type 'L' to
		$$getCmpTBl() and $$getSchCln().
		Modified $$getSchTbl(), $$tAssert(), and removed $$getCmpTbl()
		because SchemaTable is now a proper descendant of PSLTable.

	11/15/05 - Frans S.C. Witte - CRs 18727 / 18728
		Added support for numeric recInst to support vobj-by-voxn
		replacement.
		Added $$caPslCln(), $$caPslTbl(), $$getClass(), $$getDataNode(),
		$$getExisCode(), $$getPurNode(), getRecCode(), $$getRecQid1().
		Corrected $$rtLodCode(), $$rtUpdCode().

	10/25/05 - Frans S.C. Witte - CRs 17937 / 15593
		Modified $$isSfdMaster to use DBTBL1D.ISMASTER, and the logic
		around that column.

	10/07/05 - Frans S.C. Witte - CRs 15592, 17056 / 15593, 17057
		Added $$getDBI(), $$getPslTbl(), $$vlIsRdb(), $$mpPslTbl(),
		$$rtIsRdb(), $$tAssert(), $$getLodCode(), $$getNewCode(),
		$$getWhrKey(), $$lvpm().
		Corrected problem with -100 tree for keys
		Redefined return value for $$getOldNode().

	06/17/05 - Frans S.C. Witte - CR16346
		Corrected value of PSLColumn.position for literal keys.
		Corrected value of PSLColumn.getUpdateCode() for key column
		without audit.
		Modified value of PSLColumn.getOldNode() for vobj(oid).
		Added $$getCmp(), $$getUpdKey(), $$mpPslCln(), $$rtUpdKey(),
		and parseCmp().

	05/27/05 - Frans S.C. Witte - CRs: 15028 / 16039
		Added $$cdNodChg(), $$cdOldLvn(), $$cdRdbAsn(), $$getCurLvn(),
		$$getCurNode(), $$getDelimiter(), $$getOldLvn(), $$getOldNode(),
		$$getPslCln(), $$getRdbAsn(), $$getSchCln(), $$getSfd(),
		$$getSfdMaster(), $$nextSubfield(), $$rtCurLvn(), $$rtCurNode(),
		$$rdOldLvn(), $$rtOldNode(), $$stripQuotes().

	03/11/05 - Frans S.C. Witte - CRs: 14919 / 14920
		New unit. Contains $$getCmpTbl, $$getSchTbl() and $$isTable().
	*/
	/* As long as SQL modudes still need direct access to functions and
	   subroutines in this module, it will reside in pacakge framework
	   (instead of framework.psl)
	   */
	#PACKAGE framework
	#OPTION ResultClass ON

	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	// ---------------------------------------------------------------------
void addRdbPos( PSLColumn rdbPos(),	// RDB column descriptors (*1)
		PSLColumn clnDes)	// column descriptor
		
	/* ---------------------------------------------------------------------
	Support function that inserts either the supplied column descriptor (if
	it is not a masterfield) or the subfield column descriptors (if it is a
	masterfield) into the rdbCln(position) array.

	ARGUMENTS:
	. rdbCol( pos) = PSLColumn
		With pos = PSLColumn.position. This is used by $$getSavCode()
		to generate the INSERT and/or UPDATE statement that corresponds
		to Record.bypassSave().
	*/
	if $$nodIsKey( clnDes.node) set rdbPos( clnDes.currentNode) = clnDes quit
	if clnDes.masterfieldType < 2 set rdbPos( clnDes.position) = clnDes quit

	type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D", "%LIBS='SYSDEV',FID=:clnDes.table,DI=:clnDes.column", 1)
	type String N = dbtbl1d.nod
	type Number P = dbtbl1d.pos
	type ResultSet rs = Db.select("DI","DBTBL1D","%LIBS='SYSDEV' and FID=:clnDes.table and DI<>:clnDes.column and NOD=:N and POS=:P")
	while rs.next() {
		set clnDes = $$getPslCln( clnDes.table, rs.getCol(1))
		set rdbPos( clnDes.position) = clnDes
	}
	quit

	// ---------------------------------------------------------------------
PSLColumn caPslCln( PSLColumn cache(),
		String PROP,
		PSLTable tdc())
	/* ---------------------------------------------------------------------
	Runtime implementation of PSL.cachePSLColumn(cache(),qcn,tblCache()),
	that returns the PSLcolumn from the supplied PLSColumn cache array.
	If the descriptor does not yet exist in the array, it will be inserted.

	OUTPUT:
	. $$ = PSLColumn
	*/
	if 'cache( PROP).exists() set cache( PROP) = $$getPslCln( PROP.piece("."), PROP.piece(".",2), tdc())
	quit cache( PROP)

	// ---------------------------------------------------------------------
PSLTable caPslTbl( PSLTable cache(),
		String TBL,
		Number LVL,
		PSLColumn cdc())	// PSLColumn cache
	/* ---------------------------------------------------------------------
	Runtime support function that returns the PSLTable from the supplied
	PSLTable cache array. If the descriptor does not yet exist in the
	array, it will be inserted using the supplied information level.

	OUTPUT:
	. $$ = PSLTable
		If the entry has been inserted, it will only contain the basic
		data (level 0).
	*/
	if 'cache( TBL).exists() set cache( TBL) = $$getPslTbl( TBL, LVL.get(), cdc())
	else  if LVL.get()>0 set cache( TBL) = $$tAssert(cache( TBL), LVL, cdc())
	quit cache( TBL)


	// ---------------------------------------------------------------------
String cdNodChg( PSLIdentifier recInst,
		PSLExpression node)
	/* ---------------------------------------------------------------------
	Runtime function that returns the code for a reference to the glvn, that
	indicates if any value of a column stored in a node has changed.
	only the supplied variable names. This is the lowest level of code that
	can be constructed by this DQ Procedure.

	OUTPUT:
	. $$ = "vobj(recInst,-100,node)"

	NOTES:
	. See cdOldLvn.
	*/
	type literal String oLvn = "vobj"

	quit oLvn_ "("_ recInst_ ",-100,"_ node_ ")"

	// ---------------------------------------------------------------------
String cdOldLvn( PSLIdentifier recInst,
		PSLExpression node,
		PSLExpression column) 
	/* ---------------------------------------------------------------------
	Runtime function that returns the code for an "oldVal" reference, using
	only the supplied variable names. This is the lowest level of code that
	can be constructed by this DQ Procedure.

	OUTPUT:
	. $$ = "vobj(recInst,-100,node,column)"

	NOTES:
	. There are several routines that either construct their own version of
		this variable, or reference the -100 tree.
		A search on 2005-05-19 resulted in the following list:
		non compiler: DBSFILB.proc, DBSTRG.proc, SQLCMP.m, SQLFILER.m
		PSL compiler: UCCOLUMN.proc UCRECORD.m, UCUTIL.m, UCUTILN.proc
		It is recommended that the occurrences are investigated, and if
		the code appears to use knowledge of the implementation of the
		tree, it shall be changed to call a function in UCXDD instead 
	*/
	type literal String oLvn = "vobj"

	quit oLvn_ "("_ recInst_ ",-100,"_ node_ ","_ column_ ")"

	// ---------------------------------------------------------------------
String cdRdbAsn( PSLIdentifier recInst,	// record instance variable
		PSLExpression intCln,		// internal column name
		PSLExpression nod,		// node (*3)
		PSLExpression pos,		// position (*4)
		String dlmStr,			// delimiter in string form
		PSLExpression getval,		// value expression to assign to column (*6)
		PSLExpression mod,		// value modifier (*7)
		PSLExpression RdbCodeForm,	// Code form (*8)
		Boolean isFirst)		// First call (*9)
	/* ---------------------------------------------------------------------
	Runtime function that returns the assignment to the lvns that indicates
	that a column value was modified. This is the lowest level of code that
	can be constructed by this DQ Procedure.

	ARGUMENTS:
	(*3) node - Shall be as required by API:
		* "0*" for type 1 tables, type 11 top node, tables without key
		* n for wide table "descendent" nodes or Blob/Memo columns
	(*4) position - Shall be as required by API:
		- ignored for keys
		- position in vobj(rec) / vobj(rec,nod)
	(*6) getval - value expression; cannot use direct value being assigned
		to column since could be $$func with side effects
	(*7) modifier - Shall be as required by API:
		0 - do not modify the column value
		1 = take numeric interpretation except if value is empty string
		2 = unconditionally take numeric interpretation
	(*8) RdbcodeForm - Shall be as required by API:
		Determines form of returned code.  Node -161 has a
		different structure for update than for insert.  The code
		for either may be returned as in-line code, or as a function
		call (if in-line code results in too long a line, or for
		indirection).

		Values:  0 = update, in-line form
			 1 = update, function form
			 2 = update, no overlay in-line form
			 3 = update, no overlay function form
			 4 = insert, in-line form
			 5 = insert, function form
			 6 = insert, no overlay in-line form
			 7 = insert, no overlay function form

		The default construction for -161/-162 is the update form.  At
		the point of saving the record, if an insert is being done, the
		data will be transformed.  The reason for this is that we won't
		know until that point whether we are going to do an update or
		insert, so choose to optimize for update since we have to do
		other construction on save for insert in any case.  The options
		for insert are provided for the possibility of some code, e.g.,
		SQL, that will know it is doing an insert from the outset.
		
		Structure of -161/-162:
		
		-161, nod) = Number of pieces, rdbcol=:HV1, rdbcol=:HV2,...
		-162, nod) = rdbtable_ delim_ HV1value_ delim_ HV2value ...
		
	(*9) isFirst - indicates if the first call in a series, in which case
		we'll N vCc.  If subsequent calls, which will append the results,
		we can avoid re-Newing vCc.

	OUTPUT:
	. $$ - based on value of codeForm.
	
	      if RdbCodeForm = 0 (update, in-line form)
	
		N vCc S vCc=+vobj(recInst,-161,nod) S:vobj(recInst,-161,nod)[",intCln=" >>
		  $P(vobj(recInst,-162,nod),dlm,$P(vobj(recInst,-161,nod),",intCln=:HV",2)+1)=value,vCc=0 >>
		  S:vCc vobj(recInst,-161,nod)=vobj(recInst,-161,nod)_",intCln=:HV"_vCc, >>
		  vobj(recInst,-162,nod)=vobj(recInst,-162,nod)_dlm_value,$p(vobj(recInst,-161,nod),",",1)=vCc+1
		  
	      if RdbCodeForm = 1 (update, function form)
	       
	        N vX S vX=$$rdbColUpd^UCDBRT(0,recInst,intCln,nod,value)
	        
	      if RdbCodeForm = 2 (update, no overlay in-line form), used for .copy()
	        for example, when know that doing initial creation of record
	        from another, don't need to check for overlay
	        
	        N vCc S vCc=+vobj(recInst,-161,nod),vobj(recInst,-161,nod)=vobj(recInst,-161,nod)_",intCln=:HV"_vCc, >>
		  vobj(recInst,-162,nod)=vobj(recInst,-162,nod)_dlm_value,$p(vobj(recInst,-161,nod),",",1)=vCc+1

	      if RdbCodeForm = 3 (update, no overlay function form)
	       
	        N vX S vX=$$rdbColUpd^UCDBRT(1,recInst,intCln,nod,value)
	        
	      if RdbCodeForm = 4 (insert, in-line form)
	      
	        N vCc S vCc=+vobj(recInst,-161,nod) S:vobj(recInst,-161,nod)[",intCln=" >>
		  $P(vobj(recInst,-162,nod),dlm,$L($P(vobj(recInst,-161,nod),",intCln="),",")+1)=value,vCc=0 >>
		  S:vCc vobj(recInst,-161,nod)=vobj(recInst,-161,nod)_",intCln=",
		  vobj(recInst,-162,nod)=vobj(recInst,-162,nod)_dlm_value,$p(vobj(recInst,-161,nod),",",1)=vCc+1

	      if RdbCodeForm = 5 (insert, function form)
	      
	        n vX S vX=$$rdbColIns^UCDBRT(0,recInst,intCln,nod,value)
	        
	      if RdbCodeForm = 6 (insert, no overlay in-line form), when know that
	        doing initial creation of record from another, don't need to
	        check for overlay
	        
	        N vCc S vCc=+vobj(recInst,-161,nod),vobj(recInst,-161,nod)=vobj(recInst,-161,nod)_",intCln=",
		  vobj(recInst,-162,nod)=vobj(recInst,-162,nod)_dlm_value,$p(vobj(recInst,-161,nod),",",1)=vCc+1
		  
	      if RdbCodeForm = 7 (insert, no overlay function form)
	       
	        N vX S vX=$$rdbColIns^UCDBRT(1,recInst,intCln,nod,value)

	NOTES:
	. In order to support key updates in a simple way, a modification of a
		key column shall be noted in vobj(recInst,-161/-162,"0*"), as
		with any other column. For wide table key updates the 
		vobj(recInst,-161/-162,n) node shall be set for each node as well.
	*/
	type literal String oLvn = "vobj"

	type Boolean isUpd = (RdbCodeForm < 4)
	type Boolean isFunc = (RdbCodeForm # 2 = 1)
	type Boolean noOverlay = ({List}"2,3,6,7").contains(RdbCodeForm)
	
	type String cdRdbAsn
	
	// Modify value based on mod
	if (mod = 1) set getval = "$S("_ getval_ "="""":"""",1:+"_ getval_ ")"
	else  if (mod = 2) else  set getval = "+("_ getval_ ")"

	if 'isFunc do {
	
		type String ref161 = oLvn_ "("_ recInst_ ",-161,"_ nod_ ")"
		type String ref162 = oLvn_ "("_ recInst_ ",-162,"_ nod_ ")"
		
		if isFirst set cdRdbAsn = " N vCc"
		else  set cdRdbAsn = ""
		
		set cdRdbAsn = cdRdbAsn_ " S vCc=+"_ ref161
		
		if 'noOverlay do {
		
			set cdRdbAsn = cdRdbAsn_ " S:"_ ref161_ "["","_ intCln_ "="" $P("_ ref162_ ","_ dlmStr
			if isUpd set cdRdbAsn = cdRdbAsn_ ",$P("_ ref161_ ","","_ intCln_ "=:HV"",2)+1)"
			else  set cdRdbAsn = cdRdbAsn_ ",$L($P("_ ref161_ ","","_ intCln_ "=""),"","")+1)"
			set cdRdbAsn = cdRdbAsn_ "="_ getval_ ",vCc=0"
			set cdRdbAsn = cdRdbAsn_ " S:vCc "
		}
		else  set cdRdbAsn = cdRdbAsn_ ","
		
		set cdRdbAsn = cdRdbAsn_ ref161_ "="_ ref161_ "_"","_ intCln_ "="
		if isUpd set cdRdbAsn = cdRdbAsn_ ":HV""_vCc"
		else  set cdRdbAsn = cdRdbAsn_ """"
		set cdRdbAsn = cdRdbAsn_ ","_ ref162_ "="_ ref162_ "_"_ dlmStr_ "_"_ getval_ ",$P("_ ref161_ ","","",1)=vCc+1"
	}
	else  do {
		
		set cdRdbAsn = " N vX S vX=$$rdbColUpd^UCDBRT("_ noOverlay_ ","_ recInst_ ","_ intCln.addQuotes()_ ","_ nod_ ","_ dlmStr_ ","_ getval_ ")"
		
		if 'isUpd set cdRdbAsn = cdRdbAsn.replace("$$rdbColUpd", "$$rdbColIns")
	}
		
	quit cdRdbAsn
	
	// ---------------------------------------------------------------------
List checkAccessRights( PSLTable tblDes,	// table descriptor
			Boolean fromTable)	// force checking DBACCRTS
	/* ---------------------------------------------------------------------
	Implementation of PSLTable.checkAccessRights(oid), that returns
	the list of actions that require access rights checking for the
	table.
	
	If fromTable is true, will get access rights from table DBACCRTS,
	otherwise, will first attempt to get rights from RecordTABLE, and
	if that fails due to not being compiled, will look at DBACCRTS table.
	Generally, this value is set to true only when used by
	PSLRecordBuilder.
	
	Return value is a list which may include the following elements:
	
	  - insert, update, delete, or select - if included in the list,
	  	indicates that access rights checking is necessary for the
	  	operation, i.e., there is not a PUBLIC grant of the right
	  - Any with "Restrict" appended indicates at least one userclass,
	  	including PUBLIC, has a restrict clause associated with the
	  	particluar right.  Note that only one of the right or the
	  	right with "Restrict" appended will appear (i.e., both
	  	select and "selectRestrict cannot appear).
	*/
	
	type List checkList = ""
	
	if tblDes.isRdb quit ""		// Access rights does not apply
	
	// Does not apply during bootstrap
	if (PSL.getSetting("boot","restrictionlevel",0) > 1) quit ""
	
	do {
		
		type String table = tblDes.table
		
		catch error {
			
			type Number deleterts, insertrts, selectrts, updaterts
			type String right
			
			type ResultSet rs = Db.select("TABLENAME", "DBACCRTS", "TABLENAME='DBACCRTS'")
	
			if rs.isEmpty() quit		// Not using access rights
			
			/* If no public privilege for a specific access, then add
			   it to the list, unless there is a restrict clause, in
			   which case add *_RESRICT to the list. 
			   
			   Use Db.select instead of Db.getRecord to avoid issues
			   with generation during bootstrap. */
			   
			type ResultSet rs1 = Db.select("DELETERTS,INSERTRTS,SELECTRTS,UPDATERTS", "DBACCRTS", "TABLENAME=:tblDes.table AND USERCLASS='PUBLIC'")
			
			if rs1.next() do {
				
				set deleterts = rs1.getCol("DELETERTS")
				set insertrts = rs1.getCol("INSERTRTS")
				set selectrts = rs1.getCol("SELECTRTS")
				set updaterts = rs1.getCol("UPDATERTS")
			}
			else  set (deleterts, insertrts, selectrts, updaterts) = 0
	
			for right = "INSERT", "UPDATE", "DELETE", "SELECT" do {
		
				type String where = "TABLENAME='"_ tblDes.table_ "' AND "_ right.extract(1, 3)_ "RESTRICT IS NOT NULL"
		
				#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=DYNAMIC
				type ResultSet rs2 = Db.select("TABLENAME", "DBACCRTS", where)
	
				if 'rs2.isEmpty() set checkList = checkList.add(right.lowerCase()_ "Restrict")
				else  do {
			
					if (right = "INSERT"), (insertrts '> 0) set checkList = checkList.add("insert")
					else  if (right = "UPDATE"), (updaterts '> 0) set checkList = checkList.add("update")
					else  if (right = "DELETE"), (deleterts '> 0) set checkList = checkList.add("delete")
					else  if (right = "SELECT"), (selectrts '> 0) set checkList = checkList.add("select")
				}
			}
		}
		
		if fromTable throw Class.new("Error", "%PSL-E-force")		// Force error
		
		#ACCEPT DATE=05/15/2008; PGM=Dan Russell; CR=30801; Group=BYPASS
		#BYPASS
		X "S checkList=$$vcheckAccessRights^Record"_table
		#ENDBYPASS
	}
	
	quit checkList

	// ---------------------------------------------------------------------
private String cmpCurNode( String nod,		// DBTBL1D.node
			Number pos,		// position
			String typ,		// datatype
			PSLTable tblDes)	// table descriptor
	/* ---------------------------------------------------------------------
	Compute the value of PSLColumn.currentNode

	OUTPUTS:
	. $$ = node as follows:
		* If the column is a key column: - clnDes.position - 2
		* If the column is a Blob or Memo: node_",1"
		* Else if the column resides in the node of the bottom key: ""
		* If colDes.node contains a negative number: "v"_ ABS(node)
		* Otherwise node

	NOTES:
	. The values returned by this function must be coordinated with
		subroutines or functions that generate generic code such as code
		that handles runtime interpretation of values. Known cases
		include:
		. AUDIT^UCUTILN
		. code generated by the filers
	*/
	if nod?1.N1"*" quit -2 - pos

	if tblDes.recordType = 1 do {
		/* recordType 1 tables will always need numeric values for node
		   when the column is a Blob or Memo: 1 for MDB, clnDes.position
		   for RDB. */
		if "BM" '[ typ set nod = ""
	}
	else  do {
		if tblDes.recordType = 11 do {	// Compare node to bottom key
			type String keys = tblDes.primaryKeys
			if keys.piece(",",keys.length(",")) = nod set nod = ""
		}
		if nod < 0 set nod = "v"_ (-nod)
		//if 'nod.isLiteral(),'nod.isNull(),bQuoted set nod = """"_ nod_ """"
	}

	/* Add the additional subscript level for Blob/Memo */
	if "BM" [ typ set nod = nod_ ",1"
	quit nod
	
	// ---------------------------------------------------------------------
List getChildren( PSLTable tblDes)	// table descriptor
	/* ---------------------------------------------------------------------
	This function provides the run-time code for the PSLTable.isChildren()
	method.
	
	OUTPUT:
	. $$ = null if not parent
	     = comma separated list of children if table is parent
	*/
	
	type List children = Class.new("List")
	
	type ResultSet rs = Db.select("FID", "DBTBL1", "%LIBS='SYSDEV' AND PARFID=:tblDes.table")
	
	while rs.next() set children = children.add(rs.getCol("FID"))
	
	quit children

	// ---------------------------------------------------------------------
String getClass( PSLColumn clnDes)		// PSLColumn
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLColumn.getClass()
	*/
	type String typ = clnDes.dataType

	if "TUF"[typ quit "String"
	quit ",ByteString,Boolean,Date,Memo,Number,Number,Time".piece( ",", "BLDMN$C".find( typ))

	// ---------------------------------------------------------------------
private String getCmp( PSLColumn clnDes,	// PSLColumn
		String recInst,			// record instance variable
		PSLIdentifier lvpm())		// loc var pur map	/NOREQ/MECH=REFARR:R
	/* ---------------------------------------------------------------------
	Local runtime function that returns the rightexpr of a computed column
	(or "" if the column is not a computed column).
	Called by $$getCurExpr() for computed columns
	*/
	type String pt()

	/* If generating code for compiler pass 1 (recInst.isNumber()), allocate
	   a separate position for each computed column. (to come) */
	// if recInst.isNumber() ...

	do parseCmp( clnDes.computation, pt())

	type Number acc				// dummy to receive $$accByDec
	type Number cnt = pt("").order(-1)	// number of elements
	type PSLColumn ccd			// descriptor for indiv. elems.
	type Number elm				// element iterator
	type PSLExpression getval = ""		// return value
	type String qcn				// qualified columnname, and table

	for elm = 2:2:pt("").order(-1) do {
		/* The call to $$aclnByCln() without additional checks relies on
		   the structure of the tree() returned by parseCmp(): the even
		   numbers are always columnnames.
		   reduce 
		   */
		set qcn = pt(elm)
		if qcn["." do {
			/* Qualified column name.
			   Table name in computation shall match table name of
			   computed column. Throw exception if not. Strip table.
			   */
			if qcn.piece(".") '= clnDes.table throw class.new( "Error", "%PSL-E-COMPUTE,,invalid qualified name '"_ qcn_ "' in "_clnDes.table_"."_clnDes.column)
			set qcn = qcn.piece(".", 2)
		}
		set ccd = $$getPslCln( clnDes.table, qcn)
		if recInst.isNumber() do clnByCln^UCREC4OP( recInst, clnDes, ccd)
		set getval = getval_ pt(elm-1)_ $$getCurExpr( ccd, recInst, 0, lvpm())
	}

	quit getval_ pt(cnt)

	// ---------------------------------------------------------------------
String getCurExpr( PSLColumn clnDes,
		String recInst,		// record instance variable
		Boolean bLeft,		// leftexpr (1) of rightexpr (0)?
		PSLIdentifier lvpm())	// loc var pur map	/NOREQ/MECH=REFARR:R
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLColumn.getCurrentExpr(oid,left), that
	returns the expression to assign a value to the column (bLeft=1), or
	retrieve the column value (bLeft=0) for the supplied Column description.
	Calls $$getCurLvn() to obtain the variable, and adds the
	$PIECE() (or $$GETSUB() for subfields) if needed.

	OUTPUT:
	$$ leftexpr of rightexpr for this column depending on the value of bLeft
		If bLeft=1, then the expression is returned that must be used on
		the left-hand side of the assignment. For subfield columns this
		is the rightexpr of the masterfield. For RDB masterfields and
		for computed columns, an exception will be thrown. For all other
		columns it is the same as the rightexpr.
		If bLeft=0, then the expression to retrieve the column value is
		returned. For RDB masterfields this is the computation that
		constructs the masterfields out of the subfields.
	*/
	type literal String oLvn = "vobj"

	// RDB masterfield assignment and retrieval:
	if clnDes.masterfieldType=2,bLeft throw Class.new("Error", "%PSL-E-COMPUTE,,Masterfield has no leftexpr "_clnDes.table_"."_clnDes.column)
	if clnDes.masterfieldType=2 quit $$getMfRDB^UCCOLSF(clnDes, recInst, lvpm())

	// computed column: return computation
	if 'clnDes.computation.isNull(),bLeft throw Class.new("Error", "%PSL-E-COMPUTE,,Cannot modify computed data item "_clnDes.table_"."_clnDes.column)
	if 'clnDes.computation.isNull() quit $$getCmp( clnDes, recInst, lvpm())
	
	type PSLExpression getval = $$getCurLvn( clnDes, recInst, lvpm())

	// key columns and Blob/Memo are complete
	if clnDes.node?1.N1"*"  quit getval
	if "BM"[clnDes.dataType quit getval
	
	if clnDes.position >0 set getval = "$P("_ getval_ ",$C("_ clnDes.delimiter_ "),"_ clnDes.position_ ")"

	if clnDes.subfieldPosition.isNull()!bLeft quit getval

	// rightexpr for subfield (on MDB)
	quit $$getSfMDB^UCCOLSF(getval, clnDes.subfieldTag, clnDes.subfieldMajor, clnDes.subfieldMinor, clnDes.subfieldPosition)

	// ---------------------------------------------------------------------
String getCurLvn( PSLColumn clnDes,
		String recInst,		// record instance variable
		PSLIdentifier lvpm())	// loc var pur map	/NOREQ/MECH=REFARR:R
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLColumn.getCurrentLvn(oid), that returns the
	subscripted lvn that will hold the current value for the supplied
	Column description. Calls $$getCurNode() to obtain the node, and
	constructs the vobj() reference based on that value.

	*/
	type literal String oLvn = "vobj"

	type String nod = $$getCurNode( clnDes, 1)

	if recInst.isNumber() quit $$lvpm( recInst, $$getPurNode( clnDes), lvpm())

	if nod.isNull() quit oLvn_ "("_ recInst_ ")"

	quit oLvn_ "("_ recInst_ ","_ nod_ ")"

	// ---------------------------------------------------------------------
String getCurNode( PSLColumn clnDes,	// column descriptor
		Boolean bQuoted)	// do no add quotes
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLColumn.getCurrentNode(), that returns the
	node in vobj(oid,) that will contain the current value for the supplied
	PSLColumn.

	OUTPUTS:
	. $$ =  for PSLColumn.getCurrentNode(0) just PSLColumn.currentNode
		for PSLColumn.getCurrentNode(1) PSLColumn.currentNode will be
		quoted as follows:
		* If the column is a Blob or Memo, strip the ",1"
		* If the remaining value is not numeric (or "") add quotes
		* If the column is a Blob or Memo, append the ",1"

	NOTES:
	. The values returned by this function must be coordinated with
		subroutines or functions that generate generic code such as code
		that handles runtime interpretation of values. Known cases
		include:
		. column indirection generated by UCCOLUMN
		. AUDIT^UCUTILN
		. code generated by the filers
	*/
	if 'bQuoted quit clnDes.currentNode

	// quoted ==> need to manipulate
	type String nod = clnDes.currentNode

	/* Strip the additional subscript level for Blob/Memo */
	if "BM" [ clnDes.dataType set nod = nod.extract(1, nod.length() - 2)

	if 'nod.isLiteral(),'nod.isNull() set nod=nod.addQuotes()

	/* Add back the additional subscript level for Blob/Memo */
	if "BM" [ clnDes.dataType set nod = nod_ ",1"

	quit nod

	// ---------------------------------------------------------------------
String getDataNode( PSLTable tblDes,	// table descriptor
		String  recInst,	// record instance variable
		String  node,		// the node to load (*3)
		Boolean bNotFound,	// wrap RECNOFL (*4)
		PSLIdentifier lvpm(),	// purposemap	   /NOREQ/MECH=REFARR:R
		PSLColumn clnDes())	// PSLColumn cache /NOREQ/MECH=REFARR:RW
	/* ---------------------------------------------------------------------
	Support function, that returns the mimimun M code to load the specified
	node from the db (using minimal characteristics)

	ARGUMENTS:
	(*3) node = ordinary datanode to load
		No special purpose node, blob node, or memo node shall be
		supplied.
	(*4) bNotFound = code for Record-not-found case
		For incremental loads, the old-or-new-record state is already
		handled (by the initial load), and not-found conditions can be
		wrapped and ignored (bNotFound = 0).
		For RDB this implies that the returned value is a call to
			$$wrXXX^UCDBR()
		For MDB this implies that the returned value is a
			$GET()
		For initial loads, in the context of a Db.getRecord, a not-found
		condition must be handled by the caller (bNotFound = 1), and
		this function will return the complete M statement that assigns
		the retrieved value to the specified node. However the caller
		must add the the code to handle record-not-found.
	OUTPUT:
	. $$ = M expr to retrieve the node
		Either as a rightexpr (bNotFound=0),
		or as a complete M statement (bNotFound=1). In the latter case,
		the code for RDB node retrieval will contain the handling of a
		fatal (SQL) error from %DBAPI.

	NOTES:
	. The RDB code will contain references to the following variables:
		- vEr
		- vData
		- vRm
	*/
	type literal String oLvn = "vobj"

	type String dbref = ""		// database reference code (DB dep)

	if node = "0*" set node = ""

	if tblDes.isRdb do {		// RDB code

		//type String ER,RM	// ER and RM returned by $$RUNSP
		type String hostexpr	// for call to $$EXECSP^%DBAPI
		type String hostcrsp	// for call to $$RUNSP^DBSDBASE
		type String intt = $$nod2tbl^DBMAP( tblDes.database, tblDes.table, node)
		type String ord()	// columnnames by ordinal position
		type List   pkeys = tblDes.primaryKeys
		type String sel = "*"	// select list (assume SELECT *)
		type Number k = $SELECT(pkeys="":0,1:pkeys.count())

		/* Code will be different for table with or without blob/memo
		   If node IS NOT NULL, then the underlying wide table will not
		   have blobs/memos
		   */
		if node.isNull() do {
			set tblDes = $$tAssert( tblDes, 1, clnDes())
			if intt?1"W_"1.A1"_" set intt="ACN"	// temp fix

			/* special SELECT list only if blob or memo */
			if tblDes.hasBlob'!tblDes.hasMemo quit

			type String tbl = tblDes.table
			type Number pos
			type PSLColumn cd
			type ResultSet rs = Db.select( "DI", "DBTBL1D", "%LIBS='SYSDEV' AND FID=:tbl")
			while rs.next() do {
				set cd = $$caPslCln( clnDes(), tbl_ "."_ rs.getCol(1))
				set pos = cd.position
				if pos.isNull() quit		// computed, literal, masterfield, ...
				if cd.dataType = "B" quit
				if cd.dataType = "M" quit
				set ord( pos) = cd.internalColumn
			}
			set sel = ord(1)	// no table starts with B/M
			for pos = 2:1:ord("").order(-1) set sel = sel_ ","_ ord(pos).get( "NULL")
		}


		if sel '= "*" do {	// RDB with blob or memo
			type String where  = $$getWhrKey( tblDes, recInst, 2, lvpm(), .hostexpr)
			type String sqlstm = "SELECT "_ sel_ " FROM "_ intt_ where

			/* Will need to split sqlstm when the resulting M line
			   exceeeds the maximum line length (to be done). */

			set dbref = "(0,"""_sqlstm_""",$C("_ tblDes.columnDelimiter_ "),"_ hostexpr
			if bNotFound set dbref = " S vEr=$$SELECT^%DBAPI"_ dbref_ ",.vData,.vRm),"_ $$lvpm( recInst, node, lvpm())_ "=vData I vEr<0 S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)),$EC="",U1001,"""
			else  set dbref = "$$SELECTDATA^%DBAPI"_ dbref_ ")"
		}
		else  do {		// RDB without blob or memo

			/* Create stored procedure and generate call to it.
			   RUNSP^DBSDBASE will throw an exception when it fails.
			   */
			type String crsp()
			type String sqlstm = "SELECT * FROM "_intt
			type String where  = $$getWhrKey( tblDes, recInst, 1, lvpm(), .hostexpr, .hostcrsp)
			set crsp( "WHERE")    = where.piece(" WHERE ", 2, where.length())
			set crsp( "SQL")      = sqlstm_ where
			set crsp( "HOSTVARS") = hostcrsp

			do {
				catch crspEx {	// $$CREATESP failed, code as SELECT
					do PSL.warn("CREATESP failed due to "_crspEx.description)

					set where =  $$getWhrKey( tblDes, recInst, 2, lvpm(), .hostexpr)
					set sqlstm = sqlstm_ where
					if hostexpr.isNull() set hostexpr = """"""

					set dbref = "(0,"""_sqlstm_""",$C("_ tblDes.columnDelimiter_ "),"_ hostexpr

					if bNotFound set dbref = " S vEr=$$SELECT^%DBAPI"_ dbref_ ",.vData,.vRm),"_ $$lvpm( recInst, node, lvpm())_ "=vData I vEr<0 S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)),$EC="",U1001,"""
					else  set dbref = "$$SELECTDATA^%DBAPI"_ dbref_ ")"
				} /* end catch $$CREATESP() exception */

				type String spnam  = $$CREATESP^DBSDBASE( intt, "SelectAll", crsp(), 0)
				if hostexpr.isNull() set hostexpr = """"""

				set dbref = "(0,"""_ spnam_ ""","_ hostexpr_ ","_ k_ ",$C("_ tblDes.columnDelimiter_")"
	
				if bNotFound set dbref = " S vEr=$$EXECSP^%DBAPI"_ dbref_ ",.vData,.vRm),"_ $$lvpm( recInst, node, lvpm())_ "=vData I vEr<0 S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)),$EC="",U1001,"""
				else  set dbref = "$$EXECUTESP^%DBAPI"_ dbref_ ")"
			} // end code protected by catch
		} // end RDB without blob or memo
	}  // end RDB
	else  do {				// MDB code
		type String gref = $$getGbl( tblDes, recInst, lvpm())

		/* Different kind of nodes:
		   - empty: remove last subscript and append right par.
		   - node originally negative: reconstruct
		   - others: add node
		   */
		if node.isNull()  set dbref = gref.extract( 1, gref.length() - 1)_ ")"
		else  if node.extract(1,2)="""v" set dbref = gref_ "-"_ node.extract( 3,node.length() - 1)_ ")"
		else  set dbref = gref_ node_ ")"

		set dbref = "$G("_ dbref_ ")"
		if bNotFound set dbref = " S "_ $$lvpm( recInst, node, lvpm())_ "="_ dbref
	}

	quit dbref

	// ---------------------------------------------------------------------
private String getDbase( String db)	// database vendor or ""
	/* ---------------------------------------------------------------------
	Helper function that provides the value to store for PSLTtable.database.
	This function is called by $$getSchCln() and $$getSchTbl() to
	ensure that
	1) The database is always non-null
	2) they use the same default

	INPUTS:
	. %DB = underlying database
		If defined, this value will be supplied as the default value
		for db="".

	OUTPUTS:
	. %DB will certainly exist after a call to this function.
		- An existing value will not be overwritten
		- If undefined, it will be set to the value of the environment
			variable SCAU_DB
		- If that value is "", %DB will be set to "GTM"
	*/
	type literal String DQINT = "GTM"

	type public String %DB

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if %DB.get()="" set %DB = $$SCAU^%TRNLNM("DB") if %DB.isNull() set %DB = DQINT

	if db.isNull() quit %DB
	quit db

	// ---------------------------------------------------------------------
private Number getDelimiter( String delim)	// delimiter value or empty string
	/* ---------------------------------------------------------------------
	Helper function that provides a default column delimiter if "" is
	supplied. This function is called by $$getSchCln() and $$getSchTbl() to
	ensure that
	1) The delimiter is always non-null
	2) they use the same default
	*/
	if delim.isNull() quit 124
	quit delim.toNumber()

	// ---------------------------------------------------------------------
public String getExisCode( PSLTable tblDes,	// PSLTable, level 0
		String recInst,		// record instance variable (*2)
		String lvpm())		// keyvar map (*3)  /NOREQ/MECH=REFARR:R
	/* ---------------------------------------------------------------------
	Implementation of PSLTable.getExistsCode(oid,lvpm())
	This function returns the IF statement(s) that set $TEST to indicate
	record-not-found. It assumes:
	- for RDB tables, that the return value of the call to %DBAPI is in vEr,
		and that value follows the SQLCODE standard (100 = no data)
	- for MDB tables with recordType=1 or recordType=11, or
		existsNode IS NOT NULL, that the top/exists node has been
		retrieved, and a non-empty value is a sufficient condition for
		record found, and $DATA()#2 is only needed if that node stores
		an empty string. The #2 is appended in case overlapping table
		definitions lack foreign key integrity.
	- for other MDB tables that a $DATA() is the only and required action
	*/
	if tblDes.isRdb quit " I vEr=100"

	type String gblref = $$getGbl( tblDes, recInst, lvpm())
	type String nod = tblDes.existsNode


	if 'nod.isNull() set gblref = gblref_ nod_ ")"
	else  do {
		set gblref = gblref.extract( 1, gblref.length() - 1)
		if gblref [ "(" set gblref = gblref_ ")"
	}

	if 'nod.isNull()!(tblDes.recordType = 1) quit " I "_ $$lvpm(recInst, nod, lvpm())_ "="""",'($D("_ gblref_ ")#2)"
	if tblDes.recordType = 11 quit " I "_ $$lvpm(recInst, nod, lvpm())_ "="""",'$D("_ gblref_ ")"

	quit " I '$D("_ gblref_ ")"

	// ---------------------------------------------------------------------
List getFlrLgc( PSLTable tblDes,	// PSLTable, level 1
		String oper,		// operation to perform (*2)
		PSLExpression qualExp,	// applicable qualifiers (*3)
		Boolean isPslExp)	// qualExp PSLExpression or String? (*4)  
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLTable.getFilerLogic().

	ARGUMENTS:
	(*2) oper = operation
		shall be one of "INSERT", "UPDATE", "DELETE", "SAVE"
		Where "SAVE" means "INSERT" + "UPDATE".
		Values shall be in uppercase.
	(*3) qualExp = qualifier list
		The slash-separated List (isPslExp=0) or PSLExpression.
		If List it may specify any of the following values
		or there negations (/NOXXX):
		INDEX (MDB only),
		VALFK (MDB only),
		JOURNAL,
		LOG,
		TRIGAFT,
		TRIGBEF,
		VALDD  (INSERT/UPDATE only),
		VALREQ (INSERT/UPDATE only),
		VALRI  (INSERT/UPDATE only),
		VALST  (INSERT/UPDATE only)
		An absent parameter will be treated as a "yes"
		The list shall not contain conflicting parameters.
		A leading slash implies the presence of the empty qualifier, but
		this does not impact the result.
	(*4) isPslExp				/NOREQ/DEFAULT=0
		This parameter is optional, and has a default value of 0 (not a
		PSLExpression). The purpose of the parameter is to allow the
		possibility of passing two kinds of values into the method
		- If isPslExp=0, then qualExp contains a slash separated List
			of filer qualifiers.
		- If isPslExp=1, then qualExp is a PSLEXpression as will be
			produced by the compiler. It may contain literals,
			variables, and operators.
			If the value represents a literal, then call will be
			equivalent to
			    $$getFlrLgc( tblDes, oper, qualExp.stripQuotes(), 0)
			If the value does not represent a literal, then the call
			will be equivalent to
			    $$getFlrLgc( tblDes, oper, "", 0)

	OUTPUT:
	. $$ = Slash separated List of filer functions that will be needed for
		the requested operation on the table, given the supplied
		qualifiers.
		In addition to the qualifiers that are possible in the qual()
		array, the list will contain the CASCADE qualifier when the
		table is referenced by a foreign key.

	NOTES:
	. The code below explicitly uses
			'qual.contains("NOqualname","/")
		This ensures that an absent parameter is treated as yes.
	. fastDel qualifiers are: /NOJOURNAL/NOTRIGBEF/NOTRIGAFT
	. bypassSave qualifiers are: /NOJOURNAL/NOTRIGAFT/NOTRIGBEF/NOVALDD/NOVALREQ/NOVALRI/NOVALST
	. The /VALFK qualifier only deals with the referencing side of the
		constraint. The referenced side, that needs to take care of the
		cascade logic cannot be bypassed (ignoring the /NOCASDEL). The
		implication is that when the table is a referenced table, then
		some new qualifier must be added to the result to indicate that
		a call to the filer is needed. The CASCADE qualifier is used for
		this purpose.
	. The current version of the function ignores the CASDEL qualifier.
		Thus $$getFlrLgc(tbldes,"DELETE","/NOCASDEL") will still return
		CASCADE if the table is referenced.
	. It shall be noted that every use of this method only returns the list
		of functions that are needed given the CURRENT state of the DQ
		DD. Changes to the DQ DD such as adding an index, foreign key,
		trigger or journal invalidates values returned before. If these
		historic values have been used to generate code, the generated
		code may no longer be correct.
	*/
	type List logic, qual
	
	if isPslExp.get() do {
		if qualExp.isLiteral() set qual = qualExp.stripQuotes()
		else  set qual = ""
	}
	else  set qual = {List}qualExp


	if tblDes.isAutoLog, 'qual.contains("NOLOG","/") set logic = "LOG"
	else  set logic = ""

	if 'qual.contains("NOUCLREGEN","/") {
		catch vEx {
			// if call fails (e.g. V6.4) , there are no literals
		}
		type String call = "$$vhasLiterals^Record"_ tblDes.table
		if @call set logic = logic.add("UCLREGEN","/")
	}

	/* Qualifiers that are relevant for MDB only.
	   */
	if 'tblDes.isRdb do {
		set tblDes = tblDes.assertLevel(1)	// need PSLTable.indexList

		// If /NOINDEX not specified and index columns: add INDEX
		if 'qual.contains("NOINDEX","/"), 'tblDes.indexList.isNull() set logic = logic.add("INDEX","/")

		// If /NOVALFK not specified: add VALFK if the table is
		// a referencing table, and the operation is not DELETE
		if 'qual.contains("NOVALFK","/") do {
			//if oper'="DELETE", Db.isDefined( "DBTBL1F", "%LIBS='SYSDEV' and FID=:tblDes.table", 1) set logic = logic.add("VALFK","/") quit
			if oper'="DELETE", Db.isDefined( "DBTBL1F", "FID=:tblDes.table", 1) set logic = logic.add("VALFK","/") quit
		}
	}

	// Triggers
	if 'qual.contains("NOTRIGBEF","/")!'qual.contains("NOTRIGAFT","/") do {

		type Boolean trg(,)
		type ResultSet rs7 = Db.select("ACTBI,ACTAI,ACTBU,ACTAU,ACTBD,ACTAD","DBTBL7","%LIBS='SYSDEV' and TABLE=:tblDes.table")
		while rs7.next() do {
			if rs7.getCol("ACTBI") set trg( "TRIGBEF", "INSERT")=1, trg( "TRIGBEF", "SAVE")=1
			if rs7.getCol("ACTAI") set trg( "TRIGAFT", "INSERT")=1, trg( "TRIGAFT", "SAVE")=1
			if rs7.getCol("ACTBU") set trg( "TRIGBEF", "UPDATE")=1, trg( "TRIGBEF", "SAVE")=1
			if rs7.getCol("ACTAU") set trg( "TRIGAFT", "UPDATE")=1, trg( "TRIGAFT", "SAVE")=1
			if rs7.getCol("ACTBD") set trg( "TRIGBEF", "DELETE")=1
			if rs7.getCol("ACTAD") set trg( "TRIGAFT", "DELETE")=1
		}
		if 'qual.contains("NOTRIGBEF","/"), trg("TRIGBEF",oper).exists() set logic = logic.add("TRIGBEF","/")
		if 'qual.contains("NOTRIGAFT","/"), trg("TRIGAFT",oper).exists() set logic = logic.add("TRIGAFT","/")
	}

	// Journals
	if 'qual.contains("NOJOURNAL","/") do {
		/* Do NOT try to combine these 3 lines into a single line that
		   uses a HOSTVAR in the LIKE-predicate: it will generate a
		   compile time error because our SQL engine needs to insert the
		   HOSTVAR's value at compile time in order to be able to
		   generate the correct M code for LIKE */
		if (oper="SAVE")!(oper="INSERT"), Db.isDefined( "DBTBL9", "%LIBS='SYSDEV' and PRITABLE=:tblDes.table and MODE like '%I%'", 1) set logic = logic.add("JOURNAL","/") quit
		if (oper="SAVE")!(oper="UPDATE"), Db.isDefined( "DBTBL9", "%LIBS='SYSDEV' and PRITABLE=:tblDes.table and MODE like '%U%'", 1) set logic = logic.add("JOURNAL","/") quit
		if oper="DELETE", Db.isDefined( "DBTBL9", "%LIBS='SYSDEV' and PRITABLE=:tblDes.table and MODE like '%D%'", 1) set logic = logic.add("JOURNAL","/")
	}

	/* Current version: VALDD, VALREQ, VALRI, VALST will be returned when
	   not explicitly disabled by /NOVALxx, even if the qualifier is
	   irrelevant for this table.
	   */
	// VALDD, VALREQ, VALRI, and VALST: only look at explicit exclusion
	if oper '= "DELETE" do {
		type String q
		for q="VALDD","VALREQ","VALRI","VALST" if 'qual.contains( "NO"_ q, "/") set logic = logic.add( q, "/")
	}

	// CASCADE: If table is referenced, then UPDATE and DELETE may cascade
	/* On MDB, if the table is referenced, then UPDATE, SAVE and DELETE must
	   call the filer because the rules are enforced exclusively by the
	   filers.
	   On RDB, the above does apply unconditionally for UPDATE because
	   Oracle does not support ON UPDATE CASCADE, but for DELETE it is
	   possible to skip the filer calls if there are no delete actions on
	   any of the referencing tables (needs to be determined recursively).
	   According to our new rules, the settings of JOURNAL, LOG, TRIGAFT,
	   and TRIGBEF that are passed in, are passed down to the referencing
	   tables. */
	if oper'="INSERT" do {
		if oper="DELETE", tblDes.isRdb do {

			type Boolean   logCasc = 0
			type ResultSet rsCasc = Db.select( "FID", "DBTBL1F", "%LIBS='SYSDEV' and TBLREF=:tblDes.table")
			type PSLTable  tdCasc

			while rsCasc.next() & 'logCasc do {
				set tdCasc = PSL.getPSLTable( rsCasc.getCol(1), 1)
				if '$$getFlrLgc( tdCasc, "DELETE", qual.toString()).isNull() set logic = logic.add("CASCADE","/"),logCasc=1
			}	// end while rsCasc.next() & 'logCasc
		}	// end if RDB DELETE
		else  if Db.isDefined( "DBTBL1F", "TBLREF=:tblDes.table", 1) set logic = logic.add("CASCADE","/")
	}	// end if not INSERT (= DELETE, SAVE or UPDATE)

	/* ================ begin simple code ================
	if oper'="INSERT", Db.isDefined( "DBTBL1F", "TBLREF=:tblDes.table", 1) set logic = logic.add("CASCADE","/")
	================ end simple code ================ */

	// If there are children, consider their filer logic as well
	if tblDes.isParent() do {
		
		type List children = tblDes.getChildren()
		type List childLogic
		type Number i, j
		
		for i = 1:1:children.count() do {
			
			type PSLTable tblChild = PSL.getPSLTable(children.elementAt(i))
			
			set childLogic = tblChild.getFilerLogic(oper, qual, 0)
			for j = 1:1:childLogic.count("/") set logic = logic.add( childLogic.elementAt(j, "/"), "/", false)
		}
	}

	quit logic

	// ---------------------------------------------------------------------
String getGbl(	PSLTable tblDes,	// PSLTable, level 0
		String recInst,		// record instance variable (*2)
		PSLIdentifier lvpm())	// keyvar map (*3)  /NOREQ/MECH=REFARR:R
	/* ---------------------------------------------------------------------
	Construct a global reference, based on the information supplied

	ARGUMENTS:
	(*2) recInst = record instance variable
		If this variable is not empty, then all missing keys in lvpm()
		will default to vobj(recInst,-2-keynum)
		If the empty value is supplied, the first missing key in the
		lvpm() array will terminate the construction. This allows for
		the construction of partial global references (Db.isDefined).
	(*3) lvpm() = local var purpose mapping for primary key
		This function uses the primary key purpose entries (1*, ...). 

	OUTPUTS:
	. $$ = global reference with all supplied (or implied) keyvars inserted
		and remaining key levels dropped. The return value will end in
		a punctuation character: "(" for tables without keys, "," for
		all others.
	*/
	//type literal String oLvn = "vobj"

	type String gblref = tblDes.global
	type String gkey	// individual subscript
	type String gkeys	// list of subscripts
	type String tok		// literals
	type Number i		// iterator
	type Number keynum = 0	// current key number
	type String return 

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set gkeys = $$TOKEN^%ZS( gblref.piece("(",2,999), .tok)

	set gblref = gblref.piece("(")_ "("
	if lvpm(-99).exists() set gblref="^|"_$$lvpm( recInst, -99, lvpm())_"|"_gblref.extract(2,gblref.length())

	set return = gblref

	if gkeys = "" quit return

	for i=1:1:gkeys.length(",") do {
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set gkey=$$UNTOK^%ZS( gkeys.piece(",",i), .tok)
		if gkey.isLiteral() set return = return_ gkey_ "," quit

		set keynum=keynum+1
		if recInst.isNull(), 'lvpm(keynum_"*").exists() set i = gkeys.length() quit
		set return = return_ $$lvpm( recInst, keynum_"*", lvpm())_ ","
	}

	quit return

	// ---------------------------------------------------------------------
String getGvn(	PSLTable tblDes,	// PSLTable, level 0
		String recInst,		// record instance variable (*2)
		PSLIdentifier lvpm())	// keyvar map (*3)  /NOREQ/MECH=REFARR:R
	/* ---------------------------------------------------------------------
	Support funtion that calls $$getGbl() with the same parameters, and
	turns the result into a real M gvn by either removing the "(" at the
	end, or replacing the terminating "," by ")".
	*/
	type String gvn = $$getGbl( tblDes, recInst, lvpm())
	set gvn = gvn.extract( 1, gvn.length()-1)
	if gvn["(" quit gvn_ ")"
	quit gvn

	// ---------------------------------------------------------------------
String getLodCode( PSLTable tblDes,	// table descriptor
		String recInst,		// record instance variable	 /NONULL
		String  node,		// the node to load (*3)
		Number  mode,		// the record mode (*4)
		Boolean bExists,	// include local node exists? (*5)
		PSLIdentifier lvpm())	// purposemap (*6)  /NOREQ/MECH=REFARR:R
	/* ---------------------------------------------------------------------
	Runtime implementation of
	PSLTable.getLoadCode(oid,node,mode,bExist,lvpm()), that	returns
	the complete M code to incrementally load the specified node from the db
	(using the supplied characteristics).

	ARGUMENTS:
	(*2) recInst = record instance variable
		The supplied value will end up in a call to $$getGbl() for MDB
		tables. Because $$getGbl uses the value of recInst to decide how
		it interprets "absent" key variables, callers shall supply a
		non empty value to ensure that proper defaults for key columns
		are included, even if the recInst value itself will not occur in
		the generated code.
	(*3) node = node to be loaded
		For Blob or Memo columns, this shall be "*" folled by the DQ
		name of the column.
		For all other columns, the value shall be supplied as returned
		by PSLColumn.getCurrentNode(1), which ensures the proper quoting
	(*4) mode = record mode
		0 = record is known to be new
		1 = record is known to be existing
		-1 = use runtime value of mode variable, however all keys are
			non-empty
		-2 = use runtime value of mode variable, one or more keys may
			be empty
	(*5) bExists = include local node exists check
		If 1, then a $DATA() check will be performed before the node
		is retrieved from the database. This is usefull if the caller
		does not know the state of the node (e.g. for incremental loads)
		If 0, the node will be retrieved unconditionally
	(*6) lvpm()  = local variable purpose mapping
		This array contains substitutes for default values from the
		vobj() array. The following pupose values are used by this
		function:
		* node (or "0*" if node="")
			lvn to receive the node retrieved from the DB
		* "1*", "2*", ...
			by $$getGbl() to construct the global reference (MDB)
		* -2
			to obtain the mode variable if mode<0.
		* -161  existence of this nodes indicates to set up vobj
			for -161 and -162
		It is the callers responsibility to provide a consistent set of
		values.
	OUTPUT:
	. $$ = M statement(s) to load the node
		The code will start with the SPACE that preceeds the first
		command word.

	NOTES:
	. The structure "*"_columnname for blob/memo columns is unambiguous
		because a literal node starting with an asterics will be
		supplied as """*literal"""
	. This function cannot be used to return the code to load the initial
		node as part of Db.getRecord, because that code needs to be
		able to deal with "record not found". This information cannot
		be derived from the code returned by this function.
		Furthermore, that code may be too long to fit on a single line
		(RDB tables with blob/memo may require a "long" select clause).
	. The values mode=-1 and mode=-2 are identical for RDB loads, but needed
		for MDB code: Even though $$getDataNode() will add the $GET(),
		this will only be valid if all keys are non-empty. This will
		be the case if the Class.new() that instantiates the record will
		also specify all key columns. Unfortunately there is a lot of
		code around that does not specify the primary key on
		Class.new(). This will result in vobj(vOid,-3)="", which when
		used in $GET() will throw a GTM-E-NULLSUBSC exception. For this
		reason, bSel will need to be maintained for MDB incremental
		loads with mode=-2
		In fact similar behavior could be implemented for RDB loads,
		because %DBAPI functions will wrap the "not found" condition.
		However, it is expected that checking the -2 purpose node is
		less expensive than an RDB API call.
	. The code returned by this function needs to be synchronized with code
		in UCREC4OP that is responsible for providing the actual M lvns
		that will end up in the code, in particular the special purpose
		nodes -2 and -152 need attention.
	*/
	type literal String oLvn = "vobj"

	type PSLColumn cd		// column descriptor for blob/memo

	/* If memo/blob node, fill cd, and modify node
	   use pur for calls to $$lvpm() except if pur does not occur in lvpm()
	   and recInst is not a number
	   */
	type String pur = node
	if node.extract()="*" do {
		set cd = $$getPslCln(tblDes.table, node.extract(2, node.length()))
		//set node = $$getCurNode(cd, 0)
		set node = cd.currentNode
		if 'lvpm(pur).exists(), 'recInst.isNumber() set pur = node
	}

	type String code  = " S"	// return value
	type String dbref = ""		// database reference code (DB dep)
	type String init161 = ""	// node -161/-162 initialization code
	type String left  = $$lvpm( recInst, pur, lvpm())	// target lvn
	type String mdvar = $$lvpm( recInst, -2, lvpm())	// record mode
	type Boolean bSel = (mode=-2)!(mode<0 & tblDes.isRdb)	// Add $S() ?

	if bExists set code = code_ ":'$D("_ left_ ")"

	// -161/-162 are used for RDB only for update data (see cdRdbAsn^UCXDD)
	if lvpm(-161).exists() do {
		
		type String nod

		// Blob/memo node needs to be quotes for -161/-162 use
		if node.toNumber() '= node set nod = node.addQuotes()
		else  set nod = node

		//set init161 = oLvn_ "("_ recInst_ ",-161,"_ nod_ ")=1,"
		//set init161 = init161_ oLvn_ "("_ recInst_ ",-162,"_ nod_ ")="_ ($$nod2tbl^DBMAP( %DB, tblDes.table, node)).addQuotes()_ ","
		set init161 = $$lvpm( recInst, -161, lvpm())_ nod_ ")=1,"
    		set init161 = init161_ $$lvpm( recInst, -162, lvpm())_ nod_ ")="_($$nod2tbl^DBMAP( tblDes.database, tblDes.table, node)).addQuotes()_ ","
	}
	/* Code for mode=0 is independent of MDB/RDB */
	if mode = 0 quit code_ " "_ init161_ left_ "="""""

	set code = code_" "_ init161_ left_ "="

	/* Blob or Memo must be handled here, others can call $$getDataNode() */
	if node?.E1",1" do {
		if tblDes.isRdb do {	// RDB code	
			/* Construct a SELECT statement:
			   	SELECT bmcol FROM internaltable WHERE keys
			   The keys can be taken from getWhrKey using host
			   variables. Because there will be no stored procedure
			   to select the data, the -152 node can be concatentated
			   at runtime.
			   */
			type String sqlstm = "SELECT "_cd.internalColumn_" FROM "_ cd.internalTable
			type String nd152 = $$lvpm( recInst, -152, lvpm())	// Host variable values list
			type String where = $$getWhrKey(tblDes, recInst, 2)
			set dbref="$$SELECTDATA^%DBAPI(0,"""_ sqlstm_ where_""",$C("_ tblDes.columnDelimiter_"),"_nd152_ ")"
		}
		else  do {			// MDB code
			type String gref = $$getGbl( tblDes, recInst, lvpm())
			type String ref
			set code=code_""""""	// Initialize

			/* Load BLOB's into vobj(object,node,1) */
			if tblDes.recordType=1 set ref = gref_ "von)"
			else  set ref = gref_ node.piece(",",1)_ ",von)"

			/* Runtime mode detection, and runtime already-loaded
			   detection require conditional code.
			   The simplest way would be to include an IF statement
			   but since this has the side effect of setting $TEST,
			   such code cannot be inserted (eg not between an IF
			   and an ELSE on two consecutive lines).
			   A QUIT:dontLoad is added immediately after the FOR.
			   This results in slightly less efficient code when
			   more than one node needs to be retrieved.
			   The exact code for 'dontLoad' depends on bExists and
			   bSel. In case of bExists we use an additional scratch
			   variable, and we need to rewrite 'code' completely.
			   */
			if bExists {
				set code  = " N von,vol S von="""",vol=$D("_ left_ ") S:'vol "_ left_ "="""" F  Q:vol"
				if bSel set code = code_ "!'"_ mdvar, bSel = false
			}
			else {
				set code = code_ " N von S von="""" F"
				if bSel set code = code_ " Q:'"_ mdvar, bSel = false
			}
			set code = code_"  S von=$O("_ref_") quit:von=""""  S "_left_"="_left_"_"_ref
		}
	}
	else  set dbref = $$getDataNode( tblDes, recInst, node, 0, lvpm())

	if bSel set dbref = "$S("_ mdvar_ ":"_ dbref_ ",1:"""")"
	quit code_ dbref


	// ---------------------------------------------------------------------
List getLogging( PSLTable tblDes,	// table descriptor
		 Boolean fromTable)	// force checking DBACCRTS
	/* ---------------------------------------------------------------------
	Implementation of PSLTable.getLogging(oid), that returns
	whether or not audit logging is enable for any userclass for
	the table.
	
	If fromTable is true, will get access rights from table DBAUDITDEF,
	otherwise, will first attempt to get rights from RecordTABLE, and
	if that fails due to not being compiled, will look at DBAUDITDEF
	table.  Generally, this value is set to true only when used by
	PSLRecordBuilder.
	
	Return value is a list which may include the following elements:
	
	  - insert, update, delete, select - if included in the list,
	  	indicates that audit logging is necessary for the
	  	operation for some userclass
	*/
	
	type List logList = ""
	
	if tblDes.isRdb quit ""		// Logging does not apply to RDB
	
	// Does not apply during bootstrap
	if (PSL.getSetting("boot","restrictionlevel",0) > 1) quit ""
	
	do {
		
		type String table = tblDes.table
		
		catch error {
			
			type ResultSet rs = Db.select("INSERTLOG,UPDATELOG,DELETELOG,SELECTLOG", "DBAUDITDEF", "TABLENAME=:tblDes.table")
			
			while rs.next() do {
				
				if (rs.getCol("INSERTLOG") > 0) set logList = logList.add("insert", ",", false)
				if (rs.getCol("UPDATELOG") > 0) set logList = logList.add("update", ",", false)
				if (rs.getCol("DELETELOG") > 0) set logList = logList.add("delete", ",", false)
				if (rs.getCol("SELECTLOG") > 0) set logList = logList.add("select", ",", false)
			}
		}
		
		if fromTable throw Class.new("Error", "%PSL-E-force")	// Force error
		
		#ACCEPT DATE=05/15/2008; PGM=Dan Russell; CR=30801; Group=BYPASS
		#BYPASS
		X "S logList=$$vgetLogging^Record"_table
		#ENDBYPASS
	}
	
	quit logList


	// ---------------------------------------------------------------------
String getNewCode( PSLTable tblDes	// table descriptor
		, String recInst	// record instance variable (*2)
		, PSLExpression mode	// record mode expression (*3)
		, Boolean bNoNodes	// suppress creation of extra nodes (*4)
		)	// runtime code PSLTable.getNewCode()
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLTable.getNewCode(oid,mode), that returns
	the complete M code to instantiate a new Record object for this table.

	ARGUMENTS:
	(*2) recInst = record instance variable
		The supplied value will be the target of the assignment of the
		new object instance. Although this parameter is defined as a
		String, just as in all other functions, it does NOT support
		numeric values, because a Class.new for a Record instance will
		always create a vobj() entry.

	(*3) mode = record mode (0, 1, 2, 3)
		This value will be the rightexpr that will be assigned to
		vobj(recInst,-2)
		
	(*4) bNoNodes
		If true, suppress assignment that creates the default node
		and the mode node.
		In this case, the caller must set both nodes before the object
		is used in other PSL constructs, because all PSL generated code
		expects that these nodes will be present.

	OUTPUT:
	. $$ = M statement(s) to instantiate the record, and assign the
		-1 and -2 nodes. The default node (or top node) will be
		created as well. This ensures that a complete, valid RecordTBL
		object exists after executing the M code returned by this
		function.

	NOTES:
	. The limitation to non-numeric values may be removed later, if this
		subroutine will be used for code generation of voXN record
		access (i.e. when this subroutine becomes the (only) place that
		generates Class.new("RecordXYZ") code).
	*/
	type literal String oLvn = "vobj"
	
	type String code  = ""		// return value
	type String nod

	set code = $$cdNewObj^UCCLASS( recInst, """Record"_tblDes.table_"""")
	//set code = code_ ","_ oLvn_ "("_ recInst_ ",-2)="_mode

	if 'bNoNodes {
		set code = code_ ","_ oLvn_ "("_ recInst_ ",-2)="_mode
		if tblDes.recordType#2>0 set code = code_ ","_ oLvn_ "("_ recInst_ ")="""""
		else  do {
			type String defNod = tblDes.existsNode
			if defNod.isNull() quit
			if 'defNod.isNumber() set defNod = defNod.addQuotes()
			set code = code_  ","_ oLvn_ "("_ recInst_ ","_ defNod_ ")="""""
		}
	}
	
	/* Initialize -161/-162 for base node.  For wide tables, if new record,
	   initialize -161/-162 and the node value to null for split table nodes. */
	if tblDes.isRdb do {
		
		type String it 	= $$nod2tbl^DBMAP(tblDes.database, tblDes.table, "")
		type String nod = "0*".addQuotes()

		set code = code_ ","_ oLvn_ "("_ recInst_ ",-161,"_ nod_ ")=1,"_ oLvn_ "("_ recInst_ ",-162,"_ nod_ ")="""_ it_ """"
		
		// init other nodes for mode 0
		if (mode = 0) set code = code_ tblDes.getInitCode(recInst, false)
	}
	quit code
	
	
	// ---------------------------------------------------------------------
String getNewMethodCode( PSLTable tblDes,	// table descriptor
			String methodName)	// method name (*2)
	/* ---------------------------------------------------------------------
	Implementation of PSLTable.getNewMethodCode(oid,mode), that returns
	the complete M (or eventually Java) code to form the RecordTABLE.vcdmNew()
	method for this table.
	
	Return value is a string, with individual lines of code separated by
	tabs.  It is up to the caller to split this to build the method.
	
	This code does not set key values, it simply initializes the keys to null,
	providing a fully formed object.  It is the responsibility of the code
	generator for Record.new() to provide the initialization code, avoiding
	issues with data typing if we were to do it here.  See classNew^DBSDYNRA.

	ARGUMENTS:
	(*2) methodName = method name (e.g., vcdmNew), since this will construct the
			  entire method structure.
	*/
	
	type literal String RECINST = "vOid"
	type literal String TAB = 9.char()
	
	type List keys = {List}(tblDes.primaryKeys)
	type Number i
	type String recClass = "Record"_ tblDes.table
	type String code = "public static "_ recClass_ " "_ methodName_"()"
	
	set code = code_ TAB_ " type "_ recClass_ " "_ RECINST
	
	set code = code_ TAB_ " #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS"
	set code = code_ TAB_ " #BYPASS"
	
	// M implementation - that's all there is for now
	set code = code_ TAB_ tblDes.getNewCode(RECINST, 0)
	
	for i = 1:1:keys.count() do {
		
		type PSLColumn cd = PSL.getPSLColumn(tblDes.table, keys.elementAt(i))
		
		set code = code_ TAB_ cd.getUpdateCode(RECINST, """""", 0, 2)
	}

	if 'tblDes.isRdb, 'tblDes.getArchiveTable().isNull() set code = code_ TAB_ " S vobj(vOid,-99)="""""
	// END M implementation

	set code = code_ TAB_ " #ENDBYPASS"
	// Avoid warning on vOid being undefined
	set code = code_ TAB_ " #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=SCOPE"	
	set code = code_ TAB_ " quit vOid"
	
	quit code
	

	// ---------------------------------------------------------------------
String getInitCode( PSLTable tblDes,	// table descriptor
		String recInst,		// record instance variable (*2)
		Boolean bExists)	// include local node exists? (*3)
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLTable.getInitCode(oid,mode), that returns
	the complete M code to perform additional initialization when a Record
	is instantiated as a new record (mode = 0).

	Currently limited to RDB wide tables to initialize -161/-162 and the
	node itself for nodes other than the base node.

	ARGUMENTS:
	(*2) recInst = record instance variable
		The supplied value will be the target of the assignment of the
		initializations.
		
	(*3) bExists = include local node exists check - pass to getLoadCode

	OUTPUT:
	. $$ = M statement(s) to perform further initialization of the record,
		namely assignment of -161/-162 and initialization of the node
		for split tables associated with wide tables, excluding the
		base node.
	*/
	type literal String oLvn = "vobj"

	type String code = ""			// return value

	if tblDes.isRdb do {
		type Number n
		type String lvpm(), nod, nodes

		set tblDes = tblDes.assertLevel(1)
		set nodes = tblDes.nodeQuotedList
		quit:nodes.isNull()			// applies to wide tables only

		set lvpm(-161) = oLvn_ "("_ recInst_",-161,"
		set lvpm(-162) = oLvn_ "("_ recInst_",-162,"

		for n = 1:1 set nod = nodes.piece(",", n, n, """") quit:nod.isNull()  do {
			
			/* Ignore blob or memo - handled as update after insert and
			   do not imply wide table */
			quit:nod.beginsWith("*")

			set code = code_ tblDes.getLoadCode(recInst, nod, 0, bExists, lvpm())
		}
	}
	quit code

	// ---------------------------------------------------------------------
String getOldExpr( PSLColumn clnDes,
		PSLIdentifier recInst,	// record instance variable
		Boolean bLeft)		// leftexpr (1) of rightexpr (0)?
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLColumn.getOldExpr(oid,left), that
	returns the leftexpr (bLeft=1) or the rightexpr (bLeft=0) for the "old"
	column value. Because each column's oldVal is stored in a separate lvn,
	PSLColumn.getOldExpr(oid,1) returns the same value as
	PSLColumn.getOldLvn(oid).

	OUTPUT:
	$$ leftexpr or rightexpr for this column depending on the value of bLeft
		If bLeft=1, then the expression is returned that must be used on
		the left-hand side of the assignment. This is the same value as
		PSLColumn.getOldLvn(oid).
		If bLeft=0, then the expression to retrieve the column's "old"
		value is returned. For masterfields (both MDB and RDB) this is
		the computation that constructs the masterfields out of the "old"
		values of each subfield, which is returned as a long TAB-delimited
		string.

	NOTES:
	. Because access to "old" by definition implies vobj(,) usage, only
		non-numeric values of recInst are expected.
	*/
	type literal String oLvn = "vobj"

	if bLeft quit $$getOldLvn( clnDes, recInst)

	if clnDes.masterfieldType>0 quit $$getOfXDB^UCCOLSF( clnDes, recInst)

	type String vcur = $$getCurExpr( clnDes, recInst, 0)
	type String vold = $$getOldLvn( clnDes, recInst)

	/* use current data if -100 not defined */
	quit "$S($D("_ vold_ "):$P($E("_ vold_ ",5,9999),$C("_ clnDes.delimiter_ ")),1:"_ vcur_ ")"

	// ---------------------------------------------------------------------
String getOldLvn( PSLColumn clnDes,
		PSLIdentifier recInst) 
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLColumn.getOldLvn(PSLIdentifier), that
	returns the subscripted lvn that will hold the "oldVal" information for
	the column.

	OUTPUT:
	. $$ = "vobj(recInst,-100,xNode,xColumn)" with:
		xNode = clnDes.getOldNode()
		xColumn = clnDes.column

	NOTES:
	. Because access to "old" by definition implies vobj(,) usage, only
		non-numeric values of recInst are expected.
	*/
	quit $$cdOldLvn( recInst, clnDes.getOldNode(1), """"_ clnDes.column_ """")

	// ---------------------------------------------------------------------
String getOldNode( PSLColumn clnDes,
		Boolean bQuoted)	// do no add quotes
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLColumn.getOldNode(), that returns the node
	that will contain the "oldVal" information for the supplied table and
	column.
	
	OUTPUTS:
	. $$ = value of PSLColumn.node transformed into a literal (i.e. quotes
		added if needed). Note that this value will never be empty
		* for keys: "clnDes.position_"*"
		* for "top node": "0*"
		* for all others: PSLColumn.getCurrentNode()

	NOTES:
	. The values returned by this function must be coordinated with
		subroutines or functions that generate generic code such as code
		that handles runtime interpretation of values. Known cases
		include:
		. column indirection generated by UCCOLUMN
		. AUDIT^UCUTILN
	*/
	/* ---------------- old implementation
	type String nod = clnDes.node
	if nod '= +nod, nod.extract() '= """" quit nod.addQuotes()
	---------------- */

	type String nod = $$getCurNode(clnDes, bQuoted)
	if nod.isNull() set nod = "0*"					// top
	else  if nod.toNumber() < 0 set nod = clnDes.position_"*"	// key

	if nod.toNumber() '= nod, nod.extract() '= """",bQuoted quit nod.addQuotes()
	quit nod

	// ---------------------------------------------------------------------
public String getPrimaryKeyWhere( PSLTable tblDes	// PSLTable descriptor
		) // get WHERE-clause on primary key
	/* ---------------------------------------------------------------------
	Implementation of PSLTable.getPrimaryKeyWhere().

	Calls $$getWhrKey(tblDes, "vIgnore", 2)

	QUTPUT:
	. $$ = where-clause (key1=:V1 AND key2=:V2)
		The clause includes the prefix " WHERE " if there is a where
		clause, otherwise the return value is null.
	*/
	quit $$getWhrKey( tblDes, "vIgnore", 2)

	// ---------------------------------------------------------------------
PSLColumn getPslCln( String TBL, // table name
		String CLN,		// column name
		PSLTable tblDes())	// (*3)		/MECH=REFARR:RW/NOREQ
	/* ---------------------------------------------------------------------
	Runtime code for PSL.getPSLColumn(,). It returns a PSLColumn instance
	Note that the PSLColumn instance is internally represented as a 
	String. It is also manipulated as a String, because this function needs
	to assign values to "properties", that are read-only.

	ARGUMENTS:
	. tblDes() = table description cache array
		The function uses a PSLTable instance to derive some of the
		property values. This instance can be "cached", eg when the
		function is called by the PSL compiler, and references to the
		same table are likely to occur.
		The array will be used to check if a table description is
		already present. If so, that description will be used, else the
		description will be added to the array. If the parameter is not
		supplied, then the "cache" is effectively disabled, and the scope
		of the description will be limited to this function.

	NOTES:
	. It turned out that DBTBL1D.DEL could be different from DBTBL1.DEL even
		though there is no way a programmer can specify the delimiter at
		the column level: DQ itself used a trigger to force the equality
		but if these modifications were not exported to StarTeam, the
		distribution would contain invisible inconsistencies.
	*/
	type literal String SEP = "|"

	type RecordDBTBL1D dbtbl1d 
	type String rv = TBL_ SEP_ CLN

	do {
		catch xNF:type="%PSL-E-RECNOFL" {
			set xNF.description = "Undefined column"
			set xNF.context = TBL_ "."_ CLN
			throw xNF
		}
		set dbtbl1d = Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID=:TBL,DI=:CLN")
		type PSLTable td = $$caPslTbl( tblDes(), TBL, 0)


		set rv.piece(SEP, 5) = td.columnDelimiter	// delimiter
		set rv.piece(SEP, 6) = dbtbl1d.typ		// dataType
		set rv.piece(SEP, 7) = dbtbl1d.len		// length
		set rv.piece(SEP, 8) = dbtbl1d.dec		// precision

		/* NULL indicator. The DQ DD is a mess. The indicator happens to
		   be set for text based columns and for columns that have
		   referential type of constraints (lookup tables). So force it
		   to be false for all DQ types except "$" and "N". */
		type Number n2z = dbtbl1d.nullind
		if n2z, "$N"'[dbtbl1d.typ ! 'dbtbl1d.tbl.isNull() set n2z = 0
		set rv.piece(SEP, 9) = n2z			// isNullToZero

		/* computation: need to clean up value because Blob/Memo columns
		   often have a non-empty value here */
		if "BM"'[dbtbl1d.typ set rv.piece(SEP,14) = dbtbl1d.cmp

		//set ret.piece(SEP,15) = $$isSfdMaster(TBL,CLN, dbtbl1d.ismaster)
		set rv.piece(SEP,15) = ''dbtbl1d.ismaster	// force boolean

		/* Fill the properties that depend on the INTERNAL schema:
		   node, position, subfieldTag, subfieldMajor, subfieldMinor,
		   subfieldPosition, internalTable, internalColumn) */
		type String node = dbtbl1d.nod		// assume same for MDB and RDB

		if td.isRdb do {
			type String intTbl = TBL
			type String intCln = CLN
			type Number pos

			do MAP^DBMAP(td.database, .intTbl, .intCln, .pos)
			if intCln["(" set intCln = ""	// do not store computations
			if intCln.extract()="""" set intCln = intCln.stripQuotes()

			type List pks = td.primaryKeys
			if pks.isNull() set node=""	// node for CUVAR etc.		
			else  if node["*"		// RDB=MDB, no extra processing
			else  if td.recordType = 11 do {	// node for wide table
				type Number suffix = $$tbl2nod^DBMAP( intTbl)
				if suffix?1.N set node = suffix
				else  set node = pks.elementAt( pks.count())
			}
			else  set node = pks.elementAt( pks.count())

			// subfieldXxx will be implied empty if not assigned explicitly
			set rv.piece(SEP, 4) = pos		// position
			set rv.piece(SEP,16) = intTbl		// internalTable
			set rv.piece(SEP,17) = intCln		// internalColumn

			/* If Blob or Memo, set node = position */
			if "BM"[dbtbl1d.typ set node = pos

			/* If Masterfield, increment type */
			if rv.piece(SEP,15)=1 set rv.piece(SEP,15)=2
		}
		else  do {	// MDB table
			type Number pos
			set rv.piece(SEP,10) = dbtbl1d.sft	// subfieldTag
			set rv.piece(SEP,11) = dbtbl1d.sfd1	// subfieldMajor
			set rv.piece(SEP,12) = dbtbl1d.sfd2	// subfieldMinor
			/* force subfieldPosition non-zero if subfieldTag non-empty */
			set pos = dbtbl1d.sfp
			if 'dbtbl1d.sft.isNull(),pos'>0 set pos = 1
			set rv.piece(SEP,13) = pos		// subfieldPosition
			set rv.piece(SEP, 4) = dbtbl1d.pos	// position
			set rv.piece(SEP,16) = TBL		// internalTable
			set rv.piece(SEP,17) = CLN		// internalColumn
			/* If Blob or Memo, force node non-empty.
			   The comparison td.recordType=1 is safe here because it deals
			   exclusively with MDB tables. */
			if "BM"[dbtbl1d.typ,node.isNull()!(td.recordType=1) set node = 1
		}

		/* For primary key columns the values for node and position will
		   be the same for MDB and RDB:
		   	node = dbtbl1d.nod
			position = {List}primKey.position(CLN)
		*/
		//if td.primaryKeys.isNull() set rv.piece(SEP, 3) = ""	// node
		//else  set rv.piece(SEP, 3) = node
		set rv.piece(SEP, 3) = node
		if node["*",CLN'=+CLN,CLN.extract()'="""" do {
			type List keys = td.primaryKeys
			set rv.piece(SEP, 4) = keys.position(CLN)	// key position
		}
		// calculate PSLColumn.currentNode
		set rv.piece(SEP, 18) = $$cmpCurNode( rv.piece(SEP, 3), rv.piece(SEP, 4), rv.piece(SEP, 6), td)
	}	// end do { catch {}
	quit rv

	// ---------------------------------------------------------------------
PSLTable getPslTbl( String TBL,		// table name
		Number LVL,		// information level (*2)
		PSLColumn cdc())	// column descriptor cache
	/* ---------------------------------------------------------------------
	Runtime code for PSL.getPSLTable(,). It returns a PSLTable instance
	Note that the PSLTable instance is internally represented as a 
	String. It is also manipulated as a String, because this function needs
	to assign values to "properties", that are read-only.

	ARGUMENTS:
	(*2) LVL = information level
		The level of information that needs to be supplied during
		instantiation. This parameter shall have one of the values
		defined below. All other values are reserved for future use.
		0 = basic information level
			Will fill the PSLTable.database property plus all data
			directly obtained or derived from DBTBL1.
		1 = PSL code level
			Will fill all fields that are needed by the PSL compiler
			to generate code.
	(*3) cdc() = column descriptor cache
		If LVL > 0, the method will need to access all columns. This
		array can be used to provide and maintain a cache of PSLColumn
		entries for this table.
	
	THROWS:
	. %PSL-E-RECNOFL
		If table does not occur in DBTBL1
	*/
	type literal Number PSLTBLMX = 16
	type literal String SEP = "|"
	type literal String DQINT = "GTM"

	type String rv

	type ResultSet rs1 = Db.select("ACCKEYS,DBASE,DEL,EXIST,GLREF,LOG,PARFID,PSLPACKAGE,RECTYP", "DBTBL1","%LIBS = 'SYSDEV' AND FID = :TBL", "", "", "/PSLBOOT")
	
	if rs1.isEmpty() throw Class.new("Error", "%PSL-E-RECNOFL,Table not defined,"_ TBL)
	
	set rv = rs1.next()
	set rv = ""
	
	#IF 1
	/* Old code, still uses STBLMTBLS */
	type String dbi = $$rtDbase( TBL)
	#ELSE
	/* New code, uses DBTBL1.DBASE */
	type String  dbi = $$getDbase( rs1.getCol("DBASE"))
	#END
	type Boolean rdb = (dbi '= DQINT)

	/* Ensure that value contains the correct number of SEPs regardless of
	   the information level */
	set rv.piece( SEP, PSLTBLMX) = ""

	/* fill the properties that are independent of LVL and DBI */
	set rv.piece(SEP, 1) = TBL					// table
	set rv.piece(SEP, 3) = $$sub2cln(rs1.getCol("ACCKEYS"))		// primaryKeys
	set rv.piece(SEP, 6) = rs1.getCol("PSLPACKAGE")			// package
	set rv.piece(SEP, 7) = rs1.getCol("PARFID")			// parentTable
	set rv.piece(SEP, 8) = dbi					// datebase
	set rv.piece(SEP,10) = $$getDelimiter( rs1.getCol("DEL"))	// columnDelimiter
	set rv.piece(SEP,16) = rs1.getCol("LOG")			// isAutoLog

	/* Fill the properties that depend on the INTERNAL schema:
		database, global, internalNames, recordType (and the computed
		property isRdb)
	*/
	if rdb do {	// for RDB tables
		/* database = name of underlying database system
		   global = NULL (not filled)
		   internalNames = RDB name or names (wide table)
		   recordtype = 11 for wide-table, 1 for others
		   */
		type String intNms = TBL
		do MAP^DBMAP(dbi, .intNms)
		set rv.piece(SEP,9) = intNms			// internalNames
		if intNms["," set rv.piece(SEP,4) = 11
		else  set rv.piece(SEP,4) = 1			// recordType
	}
	else  do {	// for MDB tables
		/* database = value of literal DQINT ("GTM")
		   global = DBTBL1D.GLREF (but strip "*" key of CUVAR et.all)
		   internalNames = table
		   recordType = DBTBL1.RECTYP
		   existsNode = DBTBD1.EXIST
		   */
		if (rs1.getCol("ACCKEYS") = """*""") set rv.piece(SEP,2) = rs1.getCol("GLREF").piece("(")
		else  set rv.piece(SEP,2) = rs1.getCol("GLREF")
		set rv.piece(SEP, 4) = rs1.getCol("RECTYP")		// recordType
		set rv.piece(SEP, 9) = TBL				// internalNames
		set rv.piece(SEP,12) = rs1.getCol("EXIST")		// existsNode
	}

	/* Fill the properties for levels greater than zero */
	if LVL>0 quit $$tAssert(rv, LVL, cdc())

	quit rv

	// ---------------------------------------------------------------------
String getPurNode( PSLColumn clnDes)	// column descriptor
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLColumn.getPurposeNode(), that returns the
	purpose identifier for the node to be used in local variable purpose
	mappings.

	OUTPUTS:
	. $$ = purpose id as follows:
		* if clnDes.datatype = "B", then "*"_clnDes.column
		* if clnDes.datatype = "M", then "*"_clnDes.column
		* if clnDes.getCurrentNode(1).isNull(), then "0*"
		* else clnDes.getCurrentNode(1)
	*/
	if "BM"[clnDes.dataType quit "*"_ clnDes.column

	type String nod = $$getCurNode( clnDes, 1)

	if nod.isNull() quit "0*"
	quit nod

	// ---------------------------------------------------------------------
String getQuery( PSLTable tblDes)	// table descriptor
	/* ---------------------------------------------------------------------
	This function provides the run-time code for the PSLTable.getQuery()
	method.
	
	OUTPUT:
	. $$ = contents of DBTBL1.QID1
	*/
	
	type RecordDBTBL1 dbtbl1 = Db.getRecord("DBTBL1", "%LIBS='SYSDEV',FID=:tblDes.table")
	
	quit dbtbl1.qid1

	// ---------------------------------------------------------------------
String getRdbAsn( PSLColumn clnDes,
		String recInst,		// record instance variable
		PSLExpression getval,	// value expression to assign to column (*3)
		Number RdbCodeForm)	// form of code for RDB (*4)
	/* ---------------------------------------------------------------------
	Support function that returns the M SET-argument(s) that will be used to
	notify the RDB API that a column value has changed.
	
	ARGUMENTS:
	(*3) getval = value expression; cannot use direct value being assigned
		to column since could be $$func with side effects
	(*4) RdbCodeForm = form of code to return for RDB.  see cdRdbAsn()

	OUTPUT:
	. $$ = code returned by cdRdbAsn() with all literal values taken from
		the PSLColumn descriptor.

	NOTES:
	. Because record modify access by definition implies vobj(,) usage, only
		non-numeric values of recInst are expected.
		And if at some point in time voXN record access for recordType 1
		RDB tables is going to be supported, then presumably the call to
		this function will be suppressed.
	. See cdRdbAsn() for constraints on node
	. For wide tables, this function uses the fact that they are recordType
		11, and that clnDes.internalTable for key columns is ACN.
	*/
	type PSLExpression ic = clnDes.internalColumn

	type PSLExpression nod = clnDes.getOldNode(1)
	
	type PSLExpression pos = clnDes.position
	if pos.isNull() set pos = """"""
	
	type PSLExpression mod = $$toValMod( clnDes.dataType, clnDes.isNullToZero)
	type String dlmStr
	
	if (clnDes.delimiter < 32) set dlmStr = "$C("_ clnDes.delimiter_ ")"
	else  set dlmStr = """"_ clnDes.delimiter.char()_ """"

	// If non-key column the single statement can be returned
	if clnDes.node'?1.N1"*" quit $$cdRdbAsn(recInst, ic, nod, pos, dlmStr, getval, mod, RdbCodeForm, true)

	// For key columns return one assignment per node/wide table
	type PSLTable td = $$getPslTbl( clnDes.table, 0)
	set pos = clnDes.currentNode
	type String rdbAsn = $$cdRdbAsn(recInst, ic, """0*""", pos, dlmStr, getval, mod, RdbCodeForm, true)
	if td.recordType>1 do {
		type Number n
		type String it
		for n = 1:1:td.internalNames.count() do {
			set it = td.internalNames.elementAt( n)
			set nod = $$tbl2nod^DBMAP( it)
			if 'nod.isNull() set rdbAsn = rdbAsn_ $$cdRdbAsn(recInst, ic, nod, pos, dlmStr, getval, mod, RdbCodeForm, false)
		}
	}
	quit rdbAsn

	// ---------------------------------------------------------------------
String getRdbExpr( PSLColumn clnDes,
		String recInst)		// record instance variable
	/* ---------------------------------------------------------------------
	Support function that returns the M expression that will be used to
	force the automatic datatype conversions for a column value before it
	will be passed to the RDB API.

	OUTPUT:
	. $$ = clnDes.getCurrentExpr(recInst,0), modified according to the
		following rules:
		- If clnDes.type = 'L', then "''"_curExp
		- else if clnDes.type in ('C', 'D', 'N', '$') and
			clnDes.isNullToZero, then "+"_curExp
		- else  if clnDes.type in ('C', 'D', 'N', '$') then
			if key column then "+"_curExp
			else  "$S("_curExp_"="""":"""",1:+"_curExp)
		- else  curExpr

	NOTES:
	. the implied datatype conversion for 'U' is discarded
	. CR28995 modified the value assigned to clnDes.isNullToZero such that
		'C' and 'D' will always have clnDes.isNullToZero = false.
		So 'C' and 'D' could be removed from the list. Leaving them in
		does not harm and restricts the knowledge about the value of
		clsDes.isNullToZero to $$getPslCln().
	*/
	type PSLExpression curExp = clnDes.getCurrentExpr( recInst, 0)
	if clnDes.dataType = "L" quit "''"_ curExp
	if clnDes.isNullToZero quit "+"_ curExp
	if "CDN$" [ clnDes.dataType quit $select(clnDes.currentNode<0:"+"_curExp,1:"$S("_curExp_"="""":"""",1:+"_curExp_")")
	quit curExp


	// ---------------------------------------------------------------------
String getRecPur( PSLTable tblDes)	// table desctiptor descriptor
	/* ---------------------------------------------------------------------
	Runtime support function, that returns the purpose identifier for the
	node that will receive the data retrieved by the code in getRecCode().

	OUTPUTS:
	. $$ = purpose id as follows:
		* if tblDes.recordType = 1, then "0*"
		* else if tblDes.recordType = 11, then "0*"
		* else tblDes.existsNode (which may be empty!)

	NOTES:
	. An empty return value indicates that no code will be loaded by
		getRecCode
	. Returning tblDes.existsNode as "purpose ID" will only work for
		non-negative numeric values. Other values need to be quoted, and
		negative numeric values need to be transformed to "v"_(-node)
		like in getCurNode().
	*/
	if tblDes.recordType # 2 = 1 quit "0*"

	quit tblDes.existsNode

	// ---------------------------------------------------------------------
String getSavCode( PSLTable tblDes,	// table descriptor
		String recInst,		// record instance variable (*2)
		String  node,		// the node to load (*3)
		Number  mode,		// the record mode (*4)
		PSLIdentifier lvpm(),	// purposemap (*5)
		PSLColumn rdbCln())	// RDB column descriptors (*6)
	/* ---------------------------------------------------------------------
	Runtime implementation of
	PSLTable.getSaveCode(oid,node,mode,lvpm()), that returns the complete M
	code to save the specified node to the db (using the supplied
	characteristics).

	ARGUMENTS:
	(*2) recInst = record instance variable				/NONULL
		The supplied value will end up in a call to $$getGbl() for MDB
		tables. Because $$getGbl uses the value of recInst to decide how
		it interprets "absent" key variables, callers shall supply a
		non empty value to ensure that proper defaults for key columns
		are included, even if the recInst value itself will not occur in
		the generated code.
	(*3) node = node to be loaded
		For Blob or Memo columns, this shall be "*" folled by the DQ
		name of the column.
		For all other columns, the value shall be supplied as returned
		by PSLColumn.getCurrentNode(1), which ensures the proper quoting
	(*4) mode = record mode
		0 = record is known to be new
		1 = record is known to be existing
		-1 = use runtime value of mode variable
	(*5) lvpm()  = local variable purpose mapping			/NOREQ
		This array contains substitutes for default values from the
		vobj() array. The following pupose values are used by this
		function:
		* node (or "0*" if node="")
			lvn to receive the node retrieved from the DB
		* "1*", "2*", ...
			by $$getGbl() to construct the global reference (MDB)
		* -2
			to obtain the mode variable if mode=-1.
		It is the callers responsibility to provide a consistent set of
		values.
	(*6) rdbCln() = RDB column descriptors
		For INSERT or UPDATE to RDB, this array contains the column
		descriptors of the columns that are involved in the operation:
			rdbCln(position) = PSLColumn for column at this position
		The list shall include all columns that are possibly modified.
		Key columns that are explicitly assigned shall use the negative
		positions that correspond to PSLColumn.getCurrentNode().
		It is the callers responsibility to ensure that all columns
		reside on the same node, and that at least one non-key column
		(i.e a non-negative position) exists in rdbCln().
		It is recommended to use addRdbPos^UCDXX() to add a PSLColumn
		for use by this subroutine.
		For INSERT, keycolumns that are not included in the list will be
		assumed present by the subroutine (in order to satisfy the
		primary key constraint).
		For UPDATE however, the WHERE-clause that specifies the "current
		key" will be added to the sql statement using host variables
		and the host variables (contained in -152 purpose node) will be
		added to the host variables list, and code to update a key column
		will only be included if the keycolumn is explicitly listed in
		rdbCln().
		This behavior guarantees that the correct code will be generated
		for all modes (including mode=-1).
		This array is ignored for MDB save code.
	OUTPUT:
	. $$ = M statement(s) to save the node
		The code will start with the SPACE that preceeds the first
		command word.

	NOTES:
	. The structure "*"_columnname for blob/memo columns is unambiguous
		because a literal node starting with an asterics will be
		supplied as """*literal"""
	. In the current implementation, there is no difference between INSERT
		and UPDATE against an MDB. In both cases the result will be the
		assignment of the node to the global, even if (the equivalent
		of) vobj(recInst,node)="".
	. For blob or memo memo columns, the code will always perform an UPDATE
		because saving the blob/memo follows the saving of the other
		data.
	. The code returned by this function needs to be synchronized with code
		in UCREC4OP that is responsible for providing the actual M lvns
		that will end up in the code, in particular the special purpose
		nodes -2 and -152 need attention.
	. The code returned for "standard" MDB nodes is just a single assignment
		to the global node. Code generated by saveNoFl^UCRECORD would
		add the following behavior:
		- Always use a scratch lvn (vD).
		- SET vD=right or SET vD=$$RTBAR^%ZFUNC(right)
		- SET the global only if vD'=""
		- ZWITHDRAW the node if vD=""
	. The code returned for "standard" RDB nodes will contain one or two
		complete SQL statements. Because each SQL statement names all
		columns that participate in the update, this code can easily
		exceeed PSL.maxLineLength. Furthermore, when this function
		calculates the limits, it does not consider additional code that
		may need to be added to the same line, such as updating the -2
		and -152 nodes after the Record.save operation.
	*/
	type literal String oLvn = "vobj"

	type PSLColumn cd		// column descriptor

	/* If memo/blob node, fill cd, and modify node.
	   Use pur for calls to $$lvpm() except if pur does not occur in lvpm()
	   and recInst is not a number
	   */
	type String pur = node
	if node.extract()="*" do {
		set cd = $$getPslCln(tblDes.table, node.extract(2, node.length()))
		//set node = $$getCurNode(cd, 0)
		set node = cd.currentNode
		if 'lvpm(pur).exists(), 'recInst.isNumber() set pur = node
	}

	type String code  = ""					// return value
	type String right = $$lvpm( recInst, pur, lvpm())	// source lvn
	type String mdvar = $$lvpm( recInst, -2, lvpm())	// record mode
	type String gref  = $$getGbl( tblDes, recInst, lvpm())

	/* Blob or Memo must be handled here, others can call $$getDataNode() */
	if node?.E1",1" do {
		// ================ RDB blob / memo ================
		if tblDes.isRdb do {	
			/* Construct a call to LOBUPDATE^%DBAPI() when LOB is
			   used or to EXECUTESQL^%DBAPI(,UPDATE) when column maps to
			   VARCHAR.
			   The keys can be taken from getWhrKey using host
			   variables, with the -152 node providing their values.
			   The criteria to use an ordinary SQL UPDATE are: MEMO
			   with maximum length less than 4001
			   */
			type literal Number MINLOBSIZE = 4001

			type String nd152 = $$lvpm( recInst, -152, lvpm())	// Host variable values list
			type String where = $$getWhrKey( tblDes, recInst, 2)
			
			if cd.dataType = "M", cd.length < MINLOBSIZE do {
				type String sqlstm = "UPDATE "_ cd.internalTable _ " SET "_ cd.internalColumn _"="
				set code=" N vRet S vRet=$$EXECUTESQL^%DBAPI("""","""_sqlstm_"""_$$QADD^%ZS("_right_",""'"")_"_where_",$C("_ tblDes.columnDelimiter_"),"_nd152_")"
			}
			// Remove " WHERE" for call to LOBUPDATE
			else  set code=" N vRet S vRet=$$LOBUPDATE^%DBAPI(0,"""_ cd.internalTable _""","""_cd.internalColumn _ """,$E("_ where.extract(7,where.length())_ ",8,"_ PSL.maxStringLength _ "),"_ right_",$C("_ tblDes.columnDelimiter _"),"_nd152_")"
		}
		// ================ MDB blob / memo ================
		else  do {
			type String eCmd, lCmd, ref
			type Number step = PSL.maxDataLength
			type Number extr = step - 1
			
			/* Use appropriate extract command based on character set,
			   otherwise may get errors in UTF8 environment. */
			   
			if $$rtChset^UCBYTSTR = "M" set eCmd = "$E", lCmd = "$L"
			else  set eCmd = "$ZE", lCmd = "$ZL"
	
			/* Save BM's from vobj(object,node,1)
			   There is a fundamental difference between the code
			   for a recordType=1 and a recordType>1 save sequence.
			   For recordType=1, the deletion of the "old" BM must
			   be handled by a KILL of the "top" node before it is
			   stored. This kills the top node AND the BM nodes.
			   For recordType>1, the BM node itself can be killed as
			   part of the code generated for the BM save.
			   */
			if tblDes.recordType=1 set ref = gref_ "vS1)"
			else  set ref = gref_ node.piece(",")_ ",vS1)", code= " K "_gref_ node.piece(",")_")"
			set code = code_ " N vS1,vS2 S vS1=0 F vS2=1:"_step_":"_lCmd_"("_right_") S vS1=vS1+1,"_ref_"="_eCmd_"("_right_",vS2,vS2+"_extr_")"
		}
	}
	else  do {
		// ================ RDB standard node ================
		if tblDes.isRdb do {
			/* Use rdbCln() to construct the INSERT and UPDATE
			   statements. Construct codCol/codVal for INSERT and
			   codUpd for UPDATE in parallel, because they all rely
			   on the columns in rdbCln().
			*/
			type String codCol = ""		// column list for INSERT
			type String codHvI = ""		// hostval INSERT list
			type String codHvU = ""		// hostval UPDATE list
			type String codUpd = ""		// column=value list for UPDATE
			type String codVal = ""		// value list for INSERT

			type Number pos = rdbCln("").order()	// position iterator
			type Number hvn = 1			// hostval number
			type String hve				// hostvar expression
			type String sqlstm

			// no rdbCLn(). Behavior to be specified
			if pos.isNull() do { quit
				if node.isNull() do {
					
					type String saveLabel, where

					if tblDes.isOneNode(), 'tblDes.isParent() set saveLabel = "rdbSaveS"
					else  set saveLabel = "rdbSaveC"
					
					set where = $$getWhrKey( tblDes, recInst, 2)
					
					set code = " D "_ saveLabel_ "^UCDBRT("_recInst_",$C("_ tblDes.columnDelimiter_ "),"_ where.addQuotes()_ ")"
				}
			}

			set codCol = rdbCln(pos).internalColumn
			set codVal = ":HV1"
			set codUpd = rdbCln(pos).internalColumn _ "=:HV1"
			set codHvU = $$getRdbExpr( rdbCln(pos), recInst) _ "_$C("_tblDes.columnDelimiter_ ")"
			set sqlstm = rdbCln(pos).internalTable	// same for all columns

			/* Iterate over all supplied positions
			   */
			for hvn=2:1 set pos = rdbCln(pos).order()  quit:pos.isNull()  do {
				set codCol = codCol_ ", "_ rdbCln(pos).internalColumn
				set codVal = codVal_ ", :HV"_ hvn
				set codUpd = codUpd_ ", "_ rdbCln(pos).internalColumn _ "=:HV"_ hvn
				set codHvU = codHvU_ 9.char()_ $$getRdbExpr( rdbCln(pos), recInst) _ "_$C("_tblDes.columnDelimiter_ ")"
			}

			/* if not known to be UPDATE, add missing keys to INSERT
			   list */
			if (mode <> 1) do {
				set codHvI = codHvU
				for pos = 1:1:tblDes.primaryKeys.count() do {
					if rdbCln(-pos-2).exists() quit

					set cd = $$getPslCln( tblDes.table, tblDes.primaryKeys.elementAt(pos))
					set codCol = codCol_ ", "_ cd.internalColumn
					set codVal = codVal_ ", :HV"_ hvn
					set codHvI = codHvI_ 9.char()_ $$getRdbExpr( cd, recInst)_ "_$C("_ tblDes.columnDelimiter_ ")"
					set hvn = hvn + 1
				}
			}
			if (mode <> 0) do {
				type String whrKey = $$getWhrKey(tblDes, "", 2)
				
				// Table may have no keys
				if 'whrKey.isNull() set codHvU = codHvU_ 9.char()_ $$lvpm(recInst, -152, lvpm())
				set codUpd = codUpd_ whrKey
			}

			set codCol = "INSERT INTO "_ sqlstm_ " ("_ codCol_ ") VALUES ("_ codVal_ ")"
			set codUpd = "UPDATE "_ sqlstm_ " SET "_codUpd

			/* Now we have 4 Strings (codCol, codHvI, codUpd and 
			   codHvU). Depending on the size of each of them, and
			   the mode value, this may fit on a single line, or
			   will require multiple lines. */

			if mode=0 set code = $$getSavWr( "", codCol, tblDes.columnDelimiter, codHvI)
			else  if mode=1 set code = $$getSavWr( "", codUpd, tblDes.columnDelimiter, codHvU)
			else  do {
				set code = $$getSavWr( ":'("_ mdvar_ ")", codCol, tblDes.columnDelimiter, codHvI)
				set sqlstm = $$getSavWr( ":"_ mdvar, codUpd, tblDes.columnDelimiter, codHvU)
				if $$wrapFits^UCREC4OP(code_sqlstm,10) set code= code_ sqlstm
				else  set code = code_ 9.char()_ sqlstm
			}

			/* If more than 1 TAB, vS1 and vS2 need to be NEWed.
			   This is based on the following observations:
			   - if $$getSavWr() returns code that does not fit on
				a single line, it adds at least 2 TAB characters
				(i.e constructs at least 3 "lines"): one for the
				construction of vS1, on for the construction of
				vS2, and one for the call to EXECUTESQL^%DBAPI.
			   - if mode=-1, and each call to EXECUTESQL^%DBAPI fits on
				a single line, but the two statements do not fit
				on a single line, then code contains a single
				TAB character.
			   */
			if code.length( 9.char())>2 set code = " N vS1,vS2"_ 9.char()_ code
			
			/* Use in getSavWr - since getSavWr may be called twice
			   only want to new vRet once. */
			set code = " N vRet"_ code
		}
		// ================ MDB standard node ================
		else  do {
			if node.isNull() set gref = gref.extract( 1, gref.length() - 1)
			if node.extract(1,2)="""v" set node = "-"_ node.extract( 3,node.length() - 1)
			if tblDes.recordType = 1 do {
				type PSLTable td = tblDes.assertLevel(1)
				if td.hasBlob!td.hasMemo set code = " K:$D("_ oLvn_ "("_ recInst_ ",1,1)) "_ gref_ ")"
			}
			set code = code_ " S "_gref_ node_ ")="_ right
		}
	}	/* end standard node */
	quit code

	// ---------------------------------------------------------------------
String getSavWr( String postCond,	// postconditional (incl ":")
		String sql,		// SQL statement (unquoted)
		Number delim,		// ASCII code of delimiter
		String hvList)		// hostvalue construction list
	/* ---------------------------------------------------------------------
	Support function for $$getSavCode() to contruct the call to the 
	function $$EXECUTESQL^%DBAPI().

	ARGUMENTS:
	. The postCond argument will be inserted into the code as supplied.
		This implies that the caller must prepend
		the colon that separates the postcondition from the commandword.
		The sql argument will be modified by
		this function. If the complete M code fits on a single line, it
		will be literalized (sql.addQuotes()), else one or more M SET
		commands will be used to assign the sql text to a variable in
		chunks that fit the line length.

	OUTPUTS:
	. $$ = code to execute
		If the code fits on a single line, then a single DO statement
		will be returned. The code does not use any additional M lvns.
		If the code does not fit on a single line, then a series of
		lines, separated by TAB will be returned. In that case two
		M lvns will be used in the generated code, that will not have
		been NEWed: vS1, vS1

	NOTES:
	. The reason to use the M lvns but not NEW them is that for mode=-1, it
		is very likely that neither the INSERT nor the UPDATE will fit
		on a single line. In that case, the M lvns need to be NEWed only
		once. The caller can very easily detect the need to NEW the M
		lvns: If, and only if, the code contains a TAB, then the M lvns
		need to be NEWed.
	*/
	if $$wrapFits^UCREC4OP( postCond_ sql_ delim_ hvList, 40) quit " S"_postCond_" vRet=$$EXECUTESQL^%DBAPI(0,"_ sql.addQuotes()_ ",$C("_ delim_ "),"_ hvList.translate( 9.char(), "_")_")"

	type String code,aHvl(),aSql()
	type Number ln

	// split SQL statement and insert lines into code
	do splitCode^UCGMC( sql, 20, "", aSql())
	set code = " S"_postCond_" vS1="_ aSql(1).addQuotes()
	for ln=2:1:aSql("").order(-1) set code = code_ 9.char()_ " S"_postCond_" vS1=vS1_"_ aSql( ln).addQuotes()

	// split hostval list creation and append lines to code (assume 40 wraps)
	do splitCode^UCGMC( hvList, 400, 9.char(), aHvl())
	set code = code_ 9.char()_ " S"_postCond_" vS2="_ aHvl(1).translate( 9.char(), "_")

	/* Note that for all but the last node in aHvl() the last character is
	   an underscore, that must be removed when appending the next statement
	   */
	for ln=2:1:aHvl("").order(-1) set code = code.extract(1, code.length()-1)_ 9.char()_ " S"_postCond_" vS2=vS2_"_ aHvl( ln).translate( 9.char(), "_")

	quit code_ 9.char()_ " S"_postCond_" vRet=$$EXECUTESQL^%DBAPI(0,vS1,$C("_ delim_"),vS2)"


	// ---------------------------------------------------------------------
SchemaColumn getSchCln( String TBL,		// table name
		String CLN)		// column name
	/* ---------------------------------------------------------------------
	Runtime code for Db.getSchemaColumn(,). It returns a new SchemaColumn
	instance. Because SchemaColumn extends PslColumn, it first calls
	$$getPslCln(,) to fill the properies inherited from that class.
	Note that the SchemaColumn instance is internally represented as a 
	String. It is also manipulated as a String, because this function needs
	to assign values to "properties", that are read-only.

	NOTES:
	. The literal Number PSLL shall be kept in sync with the number of
		(stored) properties in the PslColumn class
	*/
	type literal String SEP = "|"
	type literal Number PSLL = 18

	type public PSLParser pslPrsr

	type String rv = $$fromPSLColumn( $$getPslCln( TBL, CLN))
	type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID=:TBL,DI=:CLN")

	set rv.piece(SEP, PSLL +  1) = dbtbl1d.dft		// default
	set rv.piece(SEP, PSLL +  2) = dbtbl1d.dom		// userType
	set rv.piece(SEP, PSLL +  3) = dbtbl1d.tbl		// lookupTable
	set rv.piece(SEP, PSLL +  4) = dbtbl1d.ptn		// pattern
	set rv.piece(SEP, PSLL +  5) = dbtbl1d.xpo		// postProcExpr
	set rv.piece(SEP, PSLL +  6) = dbtbl1d.xpr		// preProcExpr
	set rv.piece(SEP, PSLL +  7) = dbtbl1d.des		// description
	set rv.piece(SEP, PSLL +  8) = dbtbl1d.itp		// internalType
	set rv.piece(SEP, PSLL +  9) = dbtbl1d.min		// minimum
	set rv.piece(SEP, PSLL + 10) = dbtbl1d.max		// maximum
	set rv.piece(SEP, PSLL + 11) = dbtbl1d.req		// isRequired
	set rv.piece(SEP, PSLL + 12) = dbtbl1d.siz		// displaySize
	set rv.piece(SEP, PSLL + 13) = dbtbl1d.rhd		// reportHeader
	set rv.piece(SEP, PSLL + 14) = dbtbl1d.srl		// isSerial
	set rv.piece(SEP, PSLL + 15) = dbtbl1d.cnv		// conversionFlag
	set rv.piece(SEP, PSLL + 16) = dbtbl1d.ltd		// dateUpdated
	set rv.piece(SEP, PSLL + 17) = dbtbl1d.user		// userUpdated
	set rv.piece(SEP, PSLL + 18) = dbtbl1d.mdd		// masterDataDictionary
	set rv.piece(SEP, PSLL + 19) = dbtbl1d.val4ext		// isValidForExtraction
	set rv.piece(SEP, PSLL + 20) = dbtbl1d.deprep		// preProcDataEntry
	set rv.piece(SEP, PSLL + 21) = dbtbl1d.depostp		// postProcDataEntry

	/* Specials for datatype 'L': force isRequired=1 and
	   default = 0 if non supplied. Applies only to ccl 2.7 and up
	   */
	if pslPrsr.getSetting("PSL","Version",$$getPSLVersion^PSLC)>2.6, ({PSLColumn}rv).dataType = "L",({PSLColumn}rv).computation.isNull() do {
		set rv.piece( SEP, PSLL + 11) = 1
		if rv.piece( SEP, PSLL + 1).isNull() set rv.piece( SEP, PSLL +  1) = 0
	}
	quit rv

	// ---------------------------------------------------------------------
SchemaTable getSchTbl( String TBL)	// name of table
	/* ---------------------------------------------------------------------
	Runtime version of Db.getSchemaTable() method.
	Function that returns a SchemaTable instance.
	Note that the SchemaTable instance is internally represented as a 
	String. It is also manipulated as a String, because this function needs
	to assign values to "properties", that are read-only.
	
	THROWS:
	. %PSL-E-RECNOFL
		If table does not occur in DBTBL1D
	*/
	type literal Number PSLTBLMX = 16
	type literal String SEP = "|"
	type literal String DQINT = "GTM"

	/* Call constructor of ancestor class
	   */
	type PSLTable dtd = $$getPslTbl( TBL, 0)
	type String   rv = $$fromPSLTable( dtd)

	type RecordDBTBL1 rec = Db.getRecord("DBTBL1","%LIBS = 'SYSDEV',FID = :TBL")

	set rv.piece(SEP, PSLTBLMX  +  1) = rec.fsn		// fileShortName
	set rv.piece(SEP, PSLTBLMX  +  2) = rec.udpre		// verifyPGM
	set rv.piece(SEP, PSLTBLMX  +  3) = rec.publish	// publishPGM
	set rv.piece(SEP, PSLTBLMX  +  4) = rec.syssn		// systemName
	set rv.piece(SEP, PSLTBLMX  +  5) = rec.netloc		// networkLocation
	set rv.piece(SEP, PSLTBLMX  +  6) = rec.ptrtld		// dateCreated
	set rv.piece(SEP, PSLTBLMX  +  7) = rec.ptrtim		// timeCreated
	set rv.piece(SEP, PSLTBLMX  +  8) = rec.ptruser	// userCreated
	set rv.piece(SEP, PSLTBLMX  +  9) = rec.ptrtldu	// dateUpdated
	set rv.piece(SEP, PSLTBLMX  + 10) = rec.ptrtimu	// timeUpdated
	set rv.piece(SEP, PSLTBLMX  + 11) = rec.ptruseru	// userUpdated
	set rv.piece(SEP, PSLTBLMX  + 15) = rec.des		// description

	quit $$tAssert( rv, 2)

	// ---------------------------------------------------------------------
String getSfd( String TBL,	// table name
		String CLN,	// column name
		String SFD())	// The subfield definitions (*)	/MECH=REFARR:W
	/* ---------------------------------------------------------------------
	This subroutine returns an array of Row objects that each represent a
	subfield definition. The returned RowDes value describes the columns
	in Rows().
	ARGUMENTS:
	. SFD() = subfield definitions as stored in DQ DD:
		String SFT, Number SFD1, Number SFD2, Number SFP
		Fields are separated by a "~"

	OUTPUTS:
	. $$	= "~String DI,String SFT,Number SFD1, Number SFD2,Number SFP"
		This value can be used by the caller to construct a Row object
		that describes the data returned in SFD().
		The first character specifies the separator.
		The remaining characters define the columns,
		This allows the caller to reference the data by exactly the same
		names as used in the DD.

	NOTES:
	. Unfortunately, PSL does not (yet) support passing an array of rows
		between routines. For this reason SFD() is typed as String.
		If the caller wants to treat the result as Row SFD(), then the
		caller must assign SFD(nr) to a Row variable, and use explicit
		casting: set sfdRow = {Row}SFD(nr)
	. The subfield information is extracted directly from DBTBL1D.
		Neither this subroutine, nor any other code that wants to access
		subfield "properties" can use SchemaColumn instances, because
		that class strips subfield information from columns of RDB
		tables. This is due to the fact that the subfields are stored as
		individual, unreleated columns. The associated masterfield in an
		RDB table is no more than an updatable computed column.
	*/
	type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D", "%LIBS='SYSDEV',FID=:TBL,DI=:CLN", 1)
	if dbtbl1d.getMode() = 0 quit ""

	type String N = dbtbl1d.nod
	type Number P = dbtbl1d.pos
	type ResultSet rs = Db.select("DI,SFT,SFD1,SFD2,SFP","DBTBL1D","%LIBS='SYSDEV' and FID=:TBL and DI<>:CLN and NOD=:N and POS=:P","SFT,POS")
	type Number cnt = 0
	while rs.next() set cnt = cnt + 1, SFD(cnt) = rs.getRow().toString("~")
	quit "~String DI,String SFT,Number SFD1, Number SFD2,Number SFP"

	// ---------------------------------------------------------------------
String getSfdMaster( String TBL,	// table name
		String CLN)		// column name
	/* ---------------------------------------------------------------------
	This funtion returns the masterfield of the supplied subfield.
	
	OUTPUTS:
	. $$ = "" if (TBL,CLN) does not occur in DQ DD
	     = "" if (TBL,CLN) represents an ordinary column
	     = masterfield if (TBL,CLN) represents a subfield
	*/
	type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID=:TBL,DI=:CLN", 1)
	if dbtbl1d.sfd.isNull() quit ""		// not a subfield 

	type String N = dbtbl1d.nod
	type Number P = dbtbl1d.pos

	/* The masterfield is the field at this position of this node that has
	   neither a subfieldTag nor a subfieldPosition. Note that this query is
	   formulated in terms of individual columns, not in terms of the
	   masterfield expression. */
	type ResultSet rs = Db.select("DI","DBTBL1D","%LIBS='SYSDEV' and FID=:TBL and nod=:N and POS=:P and SFT is null and SFP is null")
	if rs.next() quit rs.getCol(1)
	quit ""

	// ---------------------------------------------------------------------
Row getSfdRT() // Row Template for getSfd
	/* ---------------------------------------------------------------------
	Returns the Row Template definition of the array elements passed out of
	$$getSfd(). Code that calls $$getSfd^UCXDD() may either use the
	"runtime" value returned by $$getSfd(), or they can use this template in
	the Row constructor to use a "compiletime" value.
	The latter is far more efficient, because the compiler can translate
	property names to positions at complile time.
	To use this template, instantiate your Row object as:
		Class Row myrow = Class.new( "Row", "#$$getSfdRT^UCXDD()")
	*/
	quit "String DI,String SFT,Number SFD1,Number SFD2,Number SFP"_ 9.char()_ 126

	// ---------------------------------------------------------------------
String getUpdAudit( PSLColumn clnDes,
		PSLIdentifier recInst,
		PSLExpression getval,
		Boolean       fromSQL)	// PSL audit (0) or SQL audit (1)
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLColumn.getUpdateAudit()

	Returns the code that creates the "oldval" node:
		vobj(recInst,node,colname) = T_PPP_getval_dlm_origin_dlm_sfd
	with:
	T = clndes.dataType
	PPP = clndes.position as 3 digits with leading zeros
	getval = the old value as specified by the getval parameter
	dlm = the table's columndelimiter
	origin = "" or 1:
		For PSL audit, the second piece will always be empty.
		For SQL audit, the second piece will always be 1.
	sfd = subfield descriptor, as found in DBTBL1D, except if dlm="~", in
		which case the subfield data is delimited by ";" 

	Furthermore, piece 11 will contain the "fmtable" value

	NOTES:
	. This code needs to be synchronized with the code in copytf^UCRECORD()
		because that subroutine generates code for the deprecated
		Record.fromArray() method, which includes code that copies data
		from UX(table,column) to vobj(recInst,-100,node,column).
	*/
	type String oldlvn = $$getOldLvn(clnDes, recInst)
	type String xtra = ""
	type String z = " S:'$D("_oldlvn_") "_oldlvn_"="""_clnDes.dataType_ ({String}(1000 + clnDes.position)).extract(2,4)_"""_"

	if clnDes.node?1.N1"*" set z = z_ "$G("_ getval_ ")"
	else  do {
		type String fmtable
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set fmtable = $$FMTABLE^DBSMACRO( clnDes.table_ "."_ clnDes.column)
		set z = z_ getval
		if 'clnDes.subfieldPosition.isNull() do {
			type String d2 = $SELECT(clnDes.delimiter=126:";",1:"~")
			set xtra.piece( clnDes.delimiter.char(), 3) = clnDes.subfieldTag_ d2_ clnDes.subfieldMajor_ d2_ clnDes.subfieldMinor_ d2_ clnDes.subfieldPosition
		}
		if 'fmtable.isNull() set xtra.piece( clnDes.delimiter.char(), 11) = fmtable
	}

	if fromSQL set xtra.piece( clnDes.delimiter.char(), 2) = 1
	if 'xtra.isNull() set z = z_ "_"_ xtra.toByteString().toPSLExpression()
	quit z

	// ---------------------------------------------------------------------
String getUpdCode( PSLColumn clnDes,
		String recInst,		// record instance variable
		PSLExpression value,	// value to assign to column
		Number mode,		// audit and RDB tracking (*3)
		Number RdbCodeForm,	// form of code for RDB (*4)
		PSLIdentifier lvpm())	// loc var pur map	/NOREQ/MECH=REFARR:R
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLColumn.getUpdateCode(oid,val,mode,rcf), that
	returns the complete M code to update the specified column with the
	supplied expression. The generated code can be one of the following
	variations, depending on the value of the mode parameter in combination
	with the value of the RdbCodeForm parameter.  With CR29295 the use of
	purpose node -150 to track info for RDB updates and inserts has been
	replaced by nodes -161 and -162, with slightly different code for updates
	(the default) than inserts.  Because this new code is lengthy, it is only
	referenced below (see cdRdbAsn for the details on the RDB tracking code):
	mode = 0 and RDB:
		S vobj(recInst,node)=value S [-161/-162 update or insert code]
	mode = 1 and RDB:
		S:'$D(oldvar) oldvar=data1 S vobj(recInst,node)=value S [-161/-162 update or insert code]
	mode = 2 and RDB:
		S:'$D(oldvar) oldvar=data2 S vobj(recInst,node)=value S [-161/-162 update or insert code]
	mode = 3 or ( mode = 0 and MDB)
		S vobj(recInst,node)=value
	mode = 4 or ( mode = 1 and MDB)
		S:'$D(oldvar) oldvar=data1 S vobj(recInst,node)=value
	mode = 5 or ( mode = 2 and MDB)
		S:'$D(oldvar) oldvar=data2 S vobj(recInst,node)=value
	If the column is a masterfield, and either audit tracking on or an RDB
	table, then the code will contain the appropriate variants above for
	each subfield, separated by TAB characters

	Independent of the value of mode, the following assingment will be added
	at the end if the table's recordType'=1 (or if mode=1 or mode=3):
		,vobj(recInst,-100,node)=""

	ARGUMENTS:
	(*2) recInst = record instance variable, or declaration position
		If a numeric value is passed, $$dec2ovs^UCREC4OP() will be
		called to obtain the name variable to use. This will only result
		in correct M code if the variable denoted by the position is
		unsubscripted.
	(*3) mode = audit and RDB tracking indicator.  See $$getUpdOvh()
	(*4) RdbCodeForm = form of code to return for RDB
		If table is RDB table, code can be returned for	either update
		or insert and in either in-line or function form.  (Parameter
		is ignored for MDB.] See cdRdbAsn()

	OUTPUT:
	. $$ = M statement(s) to update column value
		The code will start with the SPACE that preceeds the first
		command word. Code for masterfield updates may contain TABs to
		allow the caller to break it down into several lines of code.
	*/
	type literal Number RDBSUPPRESS = 3

	type Boolean bAudit = (mode # RDBSUPPRESS)>0
	type PSLTable td = $$getPslTbl( clnDes.table, 0)

	/* If assignment to Masterfield, transform to assignments to individual
	   subfields. This applies unconditionally to RDB and to MDB if
	   AuditFlag=1 in order to maintain the -100 tree at the subfield level.
	   The return value will be a very long series of TAB-delimited
	   SET-statements. It is up to the caller to break this down into code
	   pieces that can be handled at runtime. */
	if clnDes.masterfieldType>0,td.isRdb!bAudit quit $$setMfXDB^UCCOLSF( clnDes, recInst, value, mode, RdbCodeForm, lvpm())

	/* Since this code will not execute for masterfields, the assignment will
	   indeed result in a SET command, and the assignment of the -161/-162 nodes
	   can be appended to the code already present in return. */
	type PSLExpression getval
	type PSLExpression setval = $$getCurExpr( clnDes, recInst, 1, lvpm())

	if clnDes.subfieldPosition.isNull() do {
		set getval = setval
		set setval = setval_ "="_ value
	}
	else  do {
		set getval = $$getCurExpr( clnDes, recInst, 0)
		set setval = $$setSfMDB^UCCOLSF( setval, value, clnDes.subfieldTag, clnDes.subfieldMajor, clnDes.subfieldMinor, clnDes.subfieldPosition)
	}

	type String code = $$getUpdOvh( clnDes, td, recInst, mode, RdbCodeForm)
	// Split pre and post overhead code
	set code = code.piece(9.char(), 1)_ " S "_ setval_ code.piece(9.char(), 2)

	quit code

	// ---------------------------------------------------------------------
String getUpdKey( PSLTable tblDes,
		String recInst,		// record instance variable
		String lvpm())		// purpose mappings (*3)
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLTable.getUpdateKey(oid,lvpm()), that
	returns the complete M code to construct the WHERE clause host variables
	list for node -152.  The WHERE clause itself is built by getWhrKey and
	can be generated into code since it uses host variables.

	The host variable order is the key order, to match the host variable
	assignments to the WHERE clause constructed by getWhrKey.

	The list is preceded by a delimiter.

	ARGUMENTS:
	(*3) lvpm() = purpose mappings
		This method assumes it will be called in a context that may use
		key variable overrides (such as to generate code for $$vDbN()),
		so it uses lvpm( key_"*") to resolve key variables.

	OUTPUT:
	. $$ = M statement to store WHERE clause that addresses current row in
		vobj(recInst,-152). Or "" when table has no primary key
	*/
	type literal String oLvn = "vobj"

	type String cd152 = ""
	type List keys = tblDes.primaryKeys
	type Number pos

	if keys.isNull() quit ""

	for pos = 1:1:keys.count() do {
		type PSLColumn cd = $$getPslCln( tblDes.table, keys.elementAt(pos))
		type String typ = cd.dataType
		//type String kve = cd.getCurrentLvn( recInst)
		type String kve = $$lvpm( recInst, pos_"*", lvpm())

		/* B, and M do not occur in key
		   F, U, and T map to character type
		   $, C, D, L, and N map to numeric type */
		//if "FUT"[typ set kve = "$S("_ kve_ "'[""'"":""'""_"_ kve_ "_""'"",1:$$QADD^%ZS("_ kve_ ",""'""))"
		//else  set kve = "(+"_ kve_ ")"
		if "$CDLN"[typ set kve = "(+"_ kve_ ")"
		set cd152 = cd152_ "_"_ kve_ "_$C("_tblDes.columnDelimiter_ ")"
	}

	// Strip leading concatenate character
	quit " S "_ $$lvpm( recInst,-152, lvpm())_ "="_ cd152.extract(2, cd152.length())

	// ---------------------------------------------------------------------
String getUpdOvh( PSLColumn clnDes,
		PSLTable td,		// PSLTable descriptor
		String recInst,		// record instance variable (*2)
		Number mode,		// audit and RDB tracking (*3)
		Number RdbCodeForm)	// form of code for RDB (*4)
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLColumn.getUpdateOverhead(td,oid,md,RDBfrm),
	that returns the complete M code that deals with the "overhead" of a column
	update:
	- the code that maintains the -100 tree (MDB and RDB) [pre overhead]
	- the code that maintains the -161/-162 trees (RDB only) [post overhead]
	
	Pre overhead code is to be executed prior to the assignment of the value
	to the object (the S vobj(recInst,node)=value code below).  Post overhead
	code is to be executed after the assignment of the value.  This function
	is responsible only for generating the pre and post overhead code, which
	is returned separated by a tab.  It is the responsibility of the caller
	to insert the update code between the pre and post overhead.

	The final generated code can be one of the following variations, depending
	on the value of the mode parameter.  With CR29295 the use of purpose
	node -150 to track info for RDB updates and inserts has been
	replaced by nodes -161 and -162, with slightly different code for
	updates (the default) than inserts.  Because this new code is lengthy,
	it is only referenced below.
	
	mode = 0 and RDB:
		S vobj(recInst,node)=value S [-161/-162 update or insert code]
	mode = 1 and RDB:
		S:'$D(oldvar) oldvar=data1 S vobj(recInst,node)=value S [-161/-162 update or insert code]
	mode = 2 and RDB:
		S:'$D(oldvar) oldvar=data2 S vobj(recInst,node)=value S [-161/-162 update or insert code]
	mode = 3 or ( mode = 0 and MDB)
		S vobj(recInst,node)=value
	mode = 4 or ( mode = 1 and MDB)
		S:'$D(oldvar) oldvar=data1 S vobj(recInst,node)=value
	mode = 5 or ( mode = 2 and MDB)
		S:'$D(oldvar) oldvar=data2 S vobj(recInst,node)=value

	If the column is a masterfield, and either audit tracking on or an RDB
	table, it will return an error as masterfields under those conditions
	cannot be used directly by this function.  However, update code for them
	can be generated by getUpdCode, which will return the appropriate variants
	above for each subfield, separated by TAB characters.

	Independent of the value of mode, the following assignment will be added
	at the end if the table's recordType'=1 (or if mode=1 or mode=3):
		,vobj(recInst,-100,node)=""

	ARGUMENTS:
	(*2) recInst = record instance variable, or declaration position
		If a numeric value is passed, $$dec2ovs^UCREC4OP() will be
		called to obtain the name variable to use. This will only result
		in correct M code if the variable denoted by the position is
		unsubscripted.
	(*3) mode = audit and RDB tracking mode. Shall be one of:
		0 - RDB (-161/-162) tracking on,  oldval audit off
		1 - RDB (-161/-162) tracking on,  oldval audit PSL
		2 - RDB (-161/-162) tracking on,  oldval audit SQL
		3 - RDB (-161/-162) tracking off, oldval audit off
		4 - RDB (-161/-162) tracking off, oldval audit PSL
		5 - RDB (-161/-162) tracking off, oldval audit SQL
		The purpose of the difference between PSL audit and SQL audit is
		explained in the PSL Help. If SQL audit is specified, then the
		returned code will set the second piece in the -100 node to 1.
	(*4) RdbCodeForm = form of code to return for RDB
		If table is RDB table, code can be returned for	either update
		or insert and in either in-line or function form.  (Parameter
		is ignored for MDB) See cdRdbAsn() values and detail.
	OUTPUT:
	. $$ = M statement(s) that deal with the overhead (-100, -161/-162)

	NOTES:
	. the RDB tracking part of mode can be thought of as a "suppression"
		flag: 0 corresponds to don't suppress, 1 corresponds to suppress
	. if mode#3>0 and recInst.isNumber(), the generated code is known to be
		incorrect. This will be dealt with later.
	*/
	type literal Number RDBSUPPRESS = 3

	type Boolean bAudit = (mode # RDBSUPPRESS) > 0
	type PSLExpression getval = $$getCurExpr( clnDes, recInst, 0)

	/* If assignment to Masterfield, transform to assignments to individual
	   subfields. This applies unconditionally to RDB and to MDB if
	   AuditFlag=1 in order to maintain the -100 tree at the subfield level.
	   The return value will be a very long series of TAB-delimited
	   SET-statements. It is up to the caller to break this down into code
	   pieces that can be handled at runtime. */
	if clnDes.masterfieldType>0,td.isRdb!bAudit throw Class.new("Error","%PSL-E-NOTSUPPORTED,method not supported for masterfield")

	type String codePost,codePre
	if recInst.isNumber() set recInst = $$dec2ovs^UCREC4OP(recInst)
	if td.isRdb, mode < RDBSUPPRESS set codePost = $$getRdbAsn(clnDes, recInst, getval, RdbCodeForm)
	else  set codePost = ""

	// Code to save column.oldval if audit is on
	if bAudit set codePre = $$getUpdAudit( clnDes, recInst, getval, (mode # RDBSUPPRESS) = 2) // prepend!
	else  set codePre=""

	/* According to the code in UCCOLUMN.m (before it was translated to PSL),
	   -100 nodes would never be generated for key column changes unless
	   auditing is on. This behavior is copied here.
	   The "node changed" indicator is vobj(recInst,-100,oldNode). It will
	   be set under the following conditions:
	   - if td.recordType > 1: all except key columns
	   - if bAudit: always
	   - if td.isParent(): always
	   */
	// add code to notify node changed if needed or requested
	if ((td.recordType > 1) & (clnDes.currentNode'<0)) ! bAudit ! td.isParent() do {
		if codePre.isNull() set codePre = " S "
		else  set codePre=codePre_ ","
		set codePre = codePre_ $$cdNodChg(recInst, $$getOldNode(clnDes,1)) _ "="""""
	}

	quit codePre_ 9.char()_ codePost

	// ---------------------------------------------------------------------
private String getWhrKey( PSLTable tblDes,	// PSLTable descriptor
		PSLIdentifier recInst,	// record instance var (*2)
		Number md,		// hostval mode (*3)
		String lvpm(),		// key value mapping (*4)
		ret String hostval,	// host value expression (*5)
		ret String hostrsp,	// for $$RUNSP^%DBAPI (*6)
		PSLColumn coldes())	// Column descriptor cache
	/* ---------------------------------------------------------------------
	Build the WHERE clause on the primary key, and the code string to pass
	the values of the host variables

	To return only the WHERE clause on the primary keys, with host variable
	syntax, only the first three parameters are necessary.

	ARGUMENTS:
	(*2) recInst = record instance variable
		This value is passed to $$lvpm()
	(*3) md = hostval mode
		- 1 = For call to $$EXECSP^%DBAPI()
			In this case, the generated code uses $C(1) as separator
			and no quote-processing will be added
			The "hostvars" in the where-clause will not be prepended
			with a colon
		- 2 = For call to $$SELECT^%DBAPI()
			In this case the generated code will use
			tblDes.delimiter, and SQL quote enclosure will be
			included in the generated code
			The "hostvars" in the where-clause will be prepended with
			a colon
	(*4) lvpm() = local variable purpose mapping
		This function uses "1*", ...
	(*5) hostval = host value expression
		M code to construct the parameter that passes the host values.
		The input value is unconditionally reset.
	(*6) hostrsp = list for $$RUNSP^DBSDBASE()
		List of values to pass to $$RUNSP^DBSDBASE(). The exact purpose
		and contents of this variable are unclear, but the call to
		$$RUNSP^%DBAPI seems to work best if this list contains the same
		names as used in the returned WHERE clause.
	
	QUTPUT:
	. $$ = where-clause (key1=:V1 AND key2=:V2)
		The clause includes the prefix " WHERE " if there is a where
		clause, otherwise the return value is null.
	. hostval = host value expression
		If keyvals="", then hostval=""
	. hostrsp = list for $$RUNSP^DBSDBASE
		
	. coldes() = PSLColumn descriptions of keycolumns
		The array is indexed by key ordinal position
	*/
	type PSLColumn cd			// individual column descriptor
	type String cln				// individual (key)column name
	type Number k				// interator
	type List   primkey = tblDes.primaryKeys
	type String tbl = tblDes.table		// external table name
	type String val				// individual key value expr
	type String where = " WHERE "		// where clause (to be returned)

	// variables used to differentiate code depending on md
	type String colon,sep

	set (hostval, hostrsp) = ""

	// If primary key IS NULL quit ""
	if primkey.isNull() quit ""

	// Set colon, qtpre, qtpost, and sep based on md
	if md=1 set sep = "_$C(1)", colon = ""
	else  set sep = "_$C("_tblDes.columnDelimiter_")", colon = ":"

	/* Construct where and hostval in single loop
	   Note that table will have the "correct" internal tablename, provided
	   that all keys map to the same table. */
	for k=1:1:primkey.count() do {
		set val = "V"_ k
		set cln = primkey.elementAt( k)
		set cd = $$caPslCln( coldes(), tbl_ "."_ cln)
		if k>1 set where = where_ " AND ", hostval = hostval_ "_", hostrsp = hostrsp_ ","
		set where = where_ cd.internalColumn_ "="_ colon_ val
		set hostrsp = hostrsp_ val
		set hostval = hostval_ $$lvpm(recInst, k_"*", lvpm())_ sep
	}
	quit where

	// ---------------------------------------------------------------------
Boolean isColumn( String TBL,	// table name
		String CLN)	// column name
	/* ---------------------------------------------------------------------
	This function returns 1 when the supplied combination exists in DBTBL1D,
	otherwise it returns 0.
	
	OUTPUTS:
	. $$ = 0 if (TBL,CLN) does not exist in DD
	     = 1 if (TBL,CLN) does exist in DD
	*/
	quit Db.isDefined("DBTBL1D","%LIBS='SYSDEV',FID=:TBL,DI=:CLN")

	// ---------------------------------------------------------------------
Boolean isSfdMaster( String TBL,	// table name
		String CLN,		// column name
		Boolean dicval)		// dictionary value (*3)	/NOREQ
	/* ---------------------------------------------------------------------
	This subroutine returns 1 when the supplied combination is a
	masterfield, otherwise it returns 0.

	ARGUMENTS:
	(*3) dicval = value of DBTBL1D.ISMASTER
		If the caller had access to the DBTBL1D record, then is can
		supply the value of DBTBL1D.ISMASTER.
		If a non-empty value is supplied, it will be used
		unconditionally, else the DBTBL1D row will be retrieved to
		obtain the value.
		This is a reasonable compromise between unconditional use
		(interpretation) of the version dependent DBTBL1D.ISMASTER value
		by the caller, and unnecessary lookups of a known value.
	
	OUTPUTS:
	. $$ = "" if (TBL,CLN) does not occur in DQ DD
	     = 0 if (TBL,CLN) represents a subfield, or an ordinary column
	     = 1 if (TBL,CLN) represents a masterfield
	*/
	// if value supplied, and not empty, return it
	if 'dicval.get().isNull() quit dicval

	// need to retrieve row
	if 'Db.isDefined("DBTBL1D","%LIBS='SYSDEV',FID=:TBL,DI=:CLN") quit ""
	type RecordDBTBL1D dbtbl1d = Db.getRecord("DBTBL1D","%LIBS='SYSDEV',FID=:TBL,DI=:CLN")

	// if value specified in dictionary, return it
	if 'dbtbl1d.ismaster.isNull() quit dbtbl1d.ismaster

	// need to derive ...
	//if pslPrsr.getSetting("PSL","Version",$$getPSLVersion^PSLC)>2.6 quit 0		// V2.7 and up: NULL = 0
	if 'dbtbl1d.sfd.isNull() quit 0		// subfield, so not a masterfield
	type String nod = dbtbl1d.nod
	type Number pos = dbtbl1d.pos

	/* The following assumes that a key column can never be a masterfield.
	   If this assumption is invalid, then the statement shall be replaced
	   by:
		if nod?1.N1"*" set pos=$CHAR(254)
	*/
	if nod?1.N1"*" quit 0			// key, so not a masterfield
	if nod.isNull() quit 0			// no node (Memo or Blob)
	if pos.isNull() quit 0			// no position (???)

	type Number count = -1

	if PSL.getSetting("boot","restrictionlevel",0)>0 do {
		set count = 0
		/* The ResultSet below iterates over ALL columns of the supplied
		   table, and the while-loop checks the addtional conditions
		   (NOD=:nod AND POS=:pos). DO NOT ADD these additional
		   conditions to the WHERE clause. If you do, the SQL engine
		   will generate code that uses the NODEPOS index, which is
		   known to be inconsistent during bootstrap. */
		type ResultSet rs = Db.select("NOD,POS","DBTBL1D","%LIBS='SYSDEV' AND FID=:TBL")
		while rs.next() if rs.getCol("NOD")=nod, rs.getCol("POS")=pos set count = count + 1
	}
	if count > -1 quit (count>1)

	type String col1,col2
	set col1=$$nextSubfield(TBL,nod,pos,""))
	set col2=$$nextSubfield(TBL,nod,pos,CLN))

	/* If there is more than one column for this position, then CLN must be
	   the masterfield (because it is not a subfield). If this is the only
	   column for this position, it is an ordinary column.
	*/
	if col1'=CLN quit 1		// Masterfield if CLN is not the first
	if col2'="" quit 1		// Masterfield if CLN is not the last

	quit 0				// CLN is fist and last, a.k.a. the only

	// ---------------------------------------------------------------------
Boolean isOneNode( PSLTable tblDes)	// table descriptor
	/* ---------------------------------------------------------------------
	This funtion returns 1 if the internal implementation of the supplied
	PSLTable uses a single node. This will be the case if all of the
	following conditions are met:
	- tblDes.recordType = 1
	- the table does not contain Blob columns
	- the table does not contain Memo columns
	otherwise it returns 0.
	
	OUTPUTS:
	. $$ = 1 if table uses single node
	     = 0 if uses multiple nodes
	*/
	type PSLTable td = $$tAssert( tblDes, 1)

	if td.recordType=1,'td.hasMemo,'td.hasBlob quit 1
	quit 0

	// ---------------------------------------------------------------------
Boolean isParent( PSLTable tblDes)	// table descriptor
	/* ---------------------------------------------------------------------
	This function provides the run-time code for the PSLTable.isParent()
	method.
	
	OUTPUT:
	. $$ = 0 if not a parent
	     = 1 if a parent, i.e.
	*/
	
	type ResultSet rs = Db.select("FID", "DBTBL1", "%LIBS='SYSDEV' AND PARFID=:tblDes.table")
	
	quit 'rs.isEmpty()
	

	// ---------------------------------------------------------------------
Boolean isTable( String TBL)	// table name
	/* ---------------------------------------------------------------------
	This funtion returns 1 when the supplied name exists in DBTBL1,
	otherwise it returns 0.
	
	OUTPUTS:
	. $$ = 0 if TBL does not exist in DD
	     = 1 if TBL does exist in DD
	*/
	quit Db.isDefined("DBTBL1","%LIBS='SYSDEV',FID=:TBL")

	// ---------------------------------------------------------------------
String lvpm( String recInst,	// instance variable (*1)
	String pur,		// purpose (*2)
	PSLIdentifier lvpm())	// mapping (*3)		    /NOREQ/MECH=REFARR:R
	/* ---------------------------------------------------------------------
	This function implements the mapping of vobj nodes with a specific
	purpose to an M lvn that will be used in the generated code.
	This function encapsulates all knowledge about nodes with a specific
	purpose and the associated default lvn or its override.

	Note that the LVPM() purpose value for primary key columns has two
	mappings:
	-  "key ordinal position" followed by "*"
		This follows the "vobj oriented" nature of the PSLTable and
		PSLColumn classes (as opposed to the MDB oriented history of the
		DQ DD). Due to this orientation the value will differ from
		keycolumn.node and keycoloumn.getOldNode() if the MDB layout of
		the table includes literal subscripts.
	- -keynumber - 2
		This is the direct mapping into "vobj subscripts".
	See the mapping algorithm below for the relationship between these two.

	Mapping algorithm:
	- if pur.isNull(), use pur="0*"
	- if lvpm(pur).exists(), then its value will be returned
		i.e. explicit assignments always prevail
	- else, if recInst.isNumber() return $$lvpm^UCREC4OP()
		i.e. encoded record declarations come next
	- else, if pur = "0*" return "vobj(recInst)"
	- else, if pur matches 1.N1"*", then $$lvpm( pur.toNumber() - 2)
		i.e. key_"*" will have higher precedence than -key-2, but the
		latter is an acceptable fall-back.
	- else "vobj(recInst,"_pur_")"

	ARGUMENTS:
	(*1) recInst = record instance variable
		Will be used if and only if lvns(pur) does not exist
		If a numeric value is supplied, then $$lvpm^UCREC4OP(recInst,pur)
		will be returned, else an "ordinary" vobj() refererence will be
		returned.
	(*2) pur = "purpose" of variable
		Corresponds to the subscript in lvpm() that provides the lvn
		for this purpose. The following special purpose nodes are
		recognized:
		""			same as "0*"
		"0*"	vobj()		top node, used for recordTypes 1 and 11
		"1*"	vobj(,-3)	first key
		"2*"	vobj(,-4)	second key
		-152	vobj(,-152)	WHERE clause host variable list (with
					  trailing delimiter)
		-99	vobj(,-99)	archive directory from which record loaded
		-2	vobj(-2)	Record mode indicator
		-3	vobj(,-3)	first key
		-4	vobj(,,-4)	second key
		node	vobj(,node)	"ordinary" data node
	(*3) lvpm() = local variable purpose mapping.
		lvpm(purpose) = lvn to use
		See the description of the mapping algorithm about the use of
		this variable.

	OUTPUTS:
	. $$ = lvn to substitute in the code

	NOTES:
	. This function shall be the called by all subroutines and functions
		that support purpose variable remapping.
	. The caller is supposed to know whether the call makes sense. For
		example the "purpose" of -100 is to maintain old column values,
		but this is implemented as a tree, not as a single node.
		Nevertheless, a call to $$lvpm^UCXDD("ri",-100,lvpm()) will
		return "vobj(ri,-100)".
	. Callers shall exercise care when dealing with key columns. Taking the
		first key as an example, the function supports both "1*" and -3
		as valid purpose values, with "1*" cascading into -3, but not
		the other way round:
		- $$lvpm( "ri", "1*", lvpm() will return the value of lvpm("1*)
			if it exists, else it will return $$lvpm("ri", -3).
		- $$lvpm( "ri", -3, lvpm()) will return the value of lvpm(-3)
			if it exists, else it will return "vobj(ri,-3)", even if
			lvpm("1*") exists.
	*/
	type literal String oLvn = "vobj"

	if pur="" set pur = "0*"

	if lvpm(pur).exists() quit lvpm(pur)

	if recInst.isNumber() quit $$lvpm^UCREC4OP(recInst,pur,1)

	if pur = "0*" quit oLvn_"("_ recInst_")"
	if pur?1.N1"*" quit $$lvpm( recInst, -2 - pur.toNumber())

	/* All others: node = purpose */
	quit oLvn_"("_ recInst_ ","_ pur_ ")"

	// ---------------------------------------------------------------------
String mpPslCln( PSLColumn colDes,	// PSLColumn descriptor
		String property)	// PSLColumn property (*2)
	/* ---------------------------------------------------------------------
	This is a helper function for M routines to access PSLColumn properties
	by name.
	When PSL source code can use colDes.property, M routines will pass
	colDes and property to this function, to obtain the value:
		PSL: set val=colDes.property
		M:   set val=$$mpPslCln(colDes,"property")

	ARGUMENTS:
	(*2) property = name of PSLColumn property.
		The value is case sensitive, and shall exactly mathc the spelling
		of the property in OBJECTPROP.

	OUTPUTS:
	. $$ The equivalent of colDes.property
	*/
	if property="column"           quit colDes.column
	if property="computation"      quit colDes.computation
	if property="dataType"         quit colDes.dataType
	if property="delimiter"        quit colDes.delimiter
	if property="internalColumn"   quit colDes.internalColumn
	if property="internalTable"    quit colDes.internalTable
	if property="isNullToZero"     quit colDes.isNullToZero
	if property="length"           quit colDes.length
	if property="masterfieldType"  quit colDes.masterfieldType
	if property="node"             quit colDes.node
	if property="position"         quit colDes.position
	if property="precision"        quit colDes.precision
	if property="subfieldMajor"    quit colDes.subfieldMajor
	if property="subfieldMinor"    quit colDes.subfieldMinor
	if property="subfieldPosition" quit colDes.subfieldPosition
	if property="subfieldTag"      quit colDes.subfieldTag
	if property="table"            quit colDes.table
	
	throw class.new("Error","%PSL-E-INVALIDPROP,"_property)
	quit ""		// dead code

	// ---------------------------------------------------------------------
String mpPslTbl( PSLTable tabDes,	// PSLTable descriptor
		String property)	// PSLTable property (*2)
	/* ---------------------------------------------------------------------
	This is a helper function for M routines to access PSLTable properties
	by name.
	When PSL source code can use tabDes.property, M routines will pass
	tabDes and property to this function, to obtain the value:
		PSL: set val=tabDes.property
		M:   set val=$$mpPslTbl^UCXDD1(tabDes,"property")

	ARGUMENTS:
	(*2) property = name of PSLTable property.
		The value is case sensitive, and shall exactly mathc the spelling
		of the property in OBJECTPROP.

	OUTPUTS:
	. $$ The equivalent of tabDes.property
	*/
	if property="columnDelimiter"	quit tabDes.columnDelimiter
	if property="database"		quit tabDes.database
	if property="dataTypes"		quit tabDes.dataTypes
	if property="existsNode"	quit tabDes.existsNode
	if property="global"		quit tabDes.global
	if property="hasBlob"		quit tabDes.hasBlob
	if property="hasComputed"	quit tabDes.hasComputed
	if property="hasMasterfield"	quit tabDes.hasMasterfield
	if property="hasMemo"		quit tabDes.hasMemo
	if property="indexList"		quit tabDes.indexList
	if property="internalNames"	quit tabDes.internalNames
	if property="isRdb"		quit tabDes.isRdb
	if property="masterfieldList"	quit tabDes.masterfieldList
	if property="primaryKeys"	quit tabDes.primaryKeys
	if property="parentTable"	quit tabDes.parentTable
	if property="recordType"	quit tabDes.recordType
	if property="table"		quit tabDes.table

	throw class.new("Error","%PSL-E-INVALIDPROP,"_property)
	quit ""		// dead code

	// ---------------------------------------------------------------------
String rtCurExpr( String TBL,	// table name
		String CLN,		// column name
		String recInst,		// record instance variable
		Boolean bLeft,		// leftexpr (1) or rieghtexpr (0) ?
		PSLTable tblDes(),	// cache	/MECH=REFARR:RW/NOREQ
		PSLColumn clnDes())	// cache	/MECH=REFARR:RW/NOREQ
	/* ---------------------------------------------------------------------
	Runtime function that returns subscripted lvn that will hold the current
	value for the supplied table and column. Calls $$getCurExpr() .
	*/
	type String prop = TBL_ "."_ CLN
	if 'clnDes(prop).exists() set clnDes(prop) = $$getPslCln(TBL, CLN, tblDes())
	if 'tblDes(TBL).exists()  set tblDes(TBL)  = $$getPslTbl(TBL,0)

	quit $$getCurExpr(clnDes(prop), recInst, bLeft)

	// ---------------------------------------------------------------------
String rtCurLvn( String TBL,	// table name
		String CLN,		// column name
		String recInst,		// record instance variable
		PSLTable tblDes(),	// cache	/MECH=REFARR:RW/NOREQ
		PSLColumn clnDes())	// cache	/MECH=REFARR:RW/NOREQ
	/* ---------------------------------------------------------------------
	Runtime function that returns subscripted lvn that will hold the current
	value for the supplied table and column. Calls $$getCurLvn().
	*/
	type String prop = TBL_ "."_ CLN
	if 'clnDes(prop).exists() set clnDes(prop) = $$getPslCln(TBL, CLN, tblDes())
	if 'tblDes(TBL).exists()  set tblDes(TBL)  = $$getPslTbl(TBL,0)

	quit $$getCurLvn(clnDes(prop), recInst)

	// ---------------------------------------------------------------------
String rtCurNode( String TBL,	// table name
		String CLN,		// column name
		Boolean bQuoted,	// value (0) or code (1)
		PSLTable tblDes(),	// cache	/MECH=REFARR:RW/NOREQ
		PSLColumn clnDes())	// cache	/MECH=REFARR:RW/NOREQ
	/* ---------------------------------------------------------------------
	Runtime function that returns node in vobj(oid,) that will contain the
	current value for the supplied table and column.
	*/
	type String prop = TBL_ "."_ CLN
	if 'clnDes(prop).exists() set clnDes(prop) = $$getPslCln(TBL, CLN, tblDes())
	if 'tblDes(TBL).exists()  set tblDes(TBL)  = $$getPslTbl(TBL,0)

	quit $$getCurNode(clnDes(prop), bQuoted)

	// ---------------------------------------------------------------------
String rtDbase( String table)	// list of tables
	/* ---------------------------------------------------------------------
	Get the DataBase Internal store.
	This function returns the name of the database used to store the data of
	the supplied table.
	If no table is supplied, it returns the value of %DB.

	ARGUMENTS:
	. table = list of tables			/NOREQ/MECH=VAL
		If supplied, and not empty, the first table will determine the
		result. This assumes that joins between RDB and M will not occur.
		If empty it will return the value of %DB
		if not defined in DBTBL1, then it will return the value of %DB

	OUTPUTS:
	. $$ = database internal store
		If table is not supplied, or empty the function will return %DB
		Else, if the first table in the list occurs in STBLMTBLS, then
		it will return the constant "GTM",
		else it will return %DB
	. %DB will have been initialized as follows if not defined or empty:
		- if the value of the SCAU variable DB is not empty, then that
			value
		- else "GTM"

	NOTES:
	. This function accesses STBLMTBLS, and its contents is assumed to be
		trustworthy.

	. The assumption that mixed RDB - M joins will not occur is reasonable,
		because only the Data Dictionary and the OBJECT structures are
		stored in M.
	*/
	type literal String DQINT = "GTM"

	type public String %DB
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if %DB.get()="" set %DB = $$SCAU^%TRNLNM("DB") if %DB.isNull() set %DB = DQINT

	if table.get().isNull() quit %DB

	#IF 1
	/* Old code: use STBLMTBLS */
	if Db.isDefined("STBLMTBLS", "MTBLS=:table.piece("","")") quit DQINT
	quit %DB

	#ELSE
	/* NewCode:
	   Use Db.getRecord(,,1) to ignore invalid table name. This will result
	   in dbtbl1.dbase is null, which will return the default database
	   internal store.
	   */
	type String T1 = table.piece(",")
	type RecordDBTBL1 dbtbl1 = Db.getRecord( "DBTBL1", "%LIBS='SYSDEV', FID=:T1",1)
	
	quit $$getDbase( dbtbl1.dbase)
	#END

	// ---------------------------------------------------------------------
public Boolean rtIsRdb( String table)	// list of tables
	/* ---------------------------------------------------------------------
	Runtime function that returns if table is stored in relational database.
	This function returns 1 if the supplied table is stored on a relational
	database, and 0 if stored in M.

	ARGUMENTS:
	. table = list of tables			/REQ/MECH=VAL
		The first table will determine the result. This assumes that
		joins between RDB and M will not occur.

	NOTES:
	. The variations $$rtIsRdb() and $$rtIsRdb("") are no longer supported.
		Use isRdb^vRuntime() for these calls.
	*/
	type literal String DQINT = "GTM"
	quit $$rtDbase(table) '= DQINT

	// ---------------------------------------------------------------------
String rtLodCode( String table,	// table name
		String recInst,		// record instance variable
		String  node,		// the node to load
		Number  mode,		// the record mode
		Boolean bExists,	// include local node exists?
		PSLIdentifier lvpm())	// purpose mapping
	/* ---------------------------------------------------------------------
	Runtime function that wraps PSLTable.getLoadCode() for specifed
	table and node.
	*/
	type PSLTable td = $$getPslTbl(table,0)

	quit $$getLodCode(td, recInst, node, mode, bExists, lvpm())

	// ---------------------------------------------------------------------
String rtOldLvn( String TBL,	// table name
		String CLN,		// column name
		String recInst,		// record instance variable
		PSLTable tblDes(),	// cache	/MECH=REFARR:RW/NOREQ
		PSLColumn clnDes())	// cache	/MECH=REFARR:RW/NOREQ
	/* ---------------------------------------------------------------------
	Runtime function that returns subscripted lvn that will hold the "oldVal"
	information for the supplied table and column.
	*/
	type String prop = TBL_ "."_ CLN
	if 'clnDes(prop).exists() set clnDes(prop) = $$getPslCln(TBL, CLN, tblDes())
	if 'tblDes(TBL).exists()  set tblDes(TBL)  = $$getPslTbl(TBL,0)

	quit $$getOldLvn(clnDes(prop), recInst)

	// ---------------------------------------------------------------------
String rtOldNode( String TBL,	// table name
		String CLN,		// column name
		Boolean bQuoted,	// value (0) or code (1)
		PSLTable tblDes(),	// cache	/MECH=REFARR:RW/NOREQ
		PSLColumn clnDes())	// cache	/MECH=REFARR:RW/NOREQ
	/* ---------------------------------------------------------------------
	Runtime function that returns the node that will contain the "oldVal"
	information for the supplied table and column.
	*/
	type String prop = TBL_ "."_ CLN
	if 'clnDes(prop).exists() set clnDes(prop) = $$getPslCln(TBL, CLN, tblDes())
	if 'tblDes(TBL).exists()  set tblDes(TBL)  = $$getPslTbl(TBL,0)

	quit $$getOldNode( clnDes(prop), bQuoted)

	// ---------------------------------------------------------------------
String rtUpdCode( String TBL,	// table name
		String CLN,		// column name
		String recInst,		// record instance variable
		PSLExpression value,	// value to assign to column
		Boolean bAudit,		// include change audit code ?
		Number RdbCodeForm,	// form of code for RDB
		PSLTable tblDes(),	// cache	/MECH=REFARR:RW/NOREQ
		PSLColumn clnDes())	// cache	/MECH=REFARR:RW/NOREQ
	/* ---------------------------------------------------------------------
	Runtime function that wraps PSLCoumn.getUpdateCode() for specifed
	table and column.
	*/
	type String prop = TBL_ "."_ CLN
	if 'clnDes(prop).exists() set clnDes(prop) = $$getPslCln(TBL, CLN, tblDes())
	if 'tblDes(TBL).exists()  set tblDes(TBL)  = $$getPslTbl(TBL,0)

	quit $$getUpdCode(clnDes(prop), recInst, value, bAudit, RdbCodeForm)

	// ---------------------------------------------------------------------
String rtUpdKey( String TBL,	// table name
		String recInst,		// record instance variable
		PSLTable tblDes())	// cache	/MECH=REFARR:RW/NOREQ
	/* ---------------------------------------------------------------------
	Runtime function that wraps PSLTable.getUpdateKey().
	*/
	if 'tblDes(TBL).exists()  set tblDes(TBL)  = $$getPslTbl(TBL,0)

	quit $$getUpdKey(tblDes(TBL), recInst)

	// ---------------------------------------------------------------------
private String nextSubfield( String tbl,	// name of table
		String nod,		// node
		Number pos,		// position within node
		String cln)		// column name
	/* ---------------------------------------------------------------------
	Helper function that returns next node from ^DBINDX("SYSDEV","STR").
	This subroutine directly accesses the global, using #BYPASS, because the
	author does not know how to express this in PSL.
	*/
	#ACCEPT CR=15028;DATE=2005-03-14;PGM=FSCW
	quit $ORDER(^DBINDX("SYSDEV","STR",tbl,nod,pos,cln))

	// ---------------------------------------------------------------------
	/* Support function that returns 1 if and only if the node is used to
	   store a blob or memo.
	   */
Boolean nodIsBM( String nod) quit (nod.extract() = "*") ! (nod?.E1",1")

	// ---------------------------------------------------------------------
	/* Support function that returns 1 if and only if the node is used to
	   store a keycolumn
	   */
Boolean nodIsKey( String nod) quit (nod < 0) ! ((nod?1.N1"*") & (nod'="0*"))

	// ---------------------------------------------------------------------
	/* Support function that returns 1 if and only if the node is the vobj()
	   eqivalent of a negative node.
	   */
Boolean nodIsNeg( String nod) quit nod? 1"""v"1.N1""""

	// ---------------------------------------------------------------------
	/* Support function that returns 1 if and only if the node is used to
	   store the "top" data of tyupe 1 or type 11 tables
	   */
Boolean nodIsTop( String nod) quit nod = "0*" ! nod.isNull()

	// ---------------------------------------------------------------------
void parseCmp( PSLExpression expr,	// computation (*1)
		String tree())			// parse result (*2)	/REFARR:W
	/* ---------------------------------------------------------------------
	Decode supplied computational expression into tree().
	This subroutine uses a very simple algorithm to decompose the computation
	and produces a simple, linear parse tree(). The parser recognizes all PSL
	(M) binary and unary operators and the patternmatch operator. Any other
	token shall be either a PSL literal (numeric or string), a PSL function
	(intrinsic or extrinsic), a system keyword from STBLSYSKWD, or a column
	name.

	The retured parsetree has a simple structure as well. It is based on the
	obeservation that the computation can be decomposed as
		nonColTokens columnName nonColTokens columnName nonColTokens ...
	I.e. an odd number of elements in which the even elements are columnnames
	Depending on the computation the first and/or last nonColTokens can be
	empty. Note that PSL/M expressions will never have two ajacent columns,
	so nonColTokens "in the middle" will never be empty.

	ARGUMENTS:
	(*1) expr - computation
		Shall conform to the simple rules specified above
	(*2) tree() - parse result
		Subscripts use sequential numbers, starting at 1. The odd numbers
		contain non column tokens, concatenated as they occur in the
		supplied expression. The even numbers contain the column names,
		as they occur in the expression (either qualified or unqualified)
		tree(1) = nonColTokens
		tree(2) = columnname
		tree(3) = nonColTokens
		tree(4) = columnname
		tree(5) = nonColTokens
        */
        type literal String dels="[]+-*/\#_'=><\*(),!&:?"

	type String atom		// parser atom
        type String getval = ""		// return value
        type String lit			// tokenized literals
        type Number nr = 0		// token number
        type Number ptr = 0		// char ptr
        type String skwd		// system keyword value

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set expr = $$TOKEN^%ZS( expr, .lit)

	for  do { quit:ptr=0

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set atom=$$ATOM^%ZS(expr,.ptr,dels,,1)

		/* Deal with deprecated [FID]DI syntax.
		   Translate to FID.DI (and treat it as a qualified column
		   reference). */
		if atom = "[", expr.extract( ptr+1)?1A, expr.find( "]", ptr) do {

			// Fill atom with table name
			set atom = expr.extract( ptr+1, expr.find( "]",ptr)-2)

			/* Check if atom is a valid identifier.
			   If not, treat '[' as separate symbol.
			   If it is indeed an identifier, advance pointer and
			   transform to FID.DI */
			if atom.translate( "_", "0")'?1A.AN set atom = "[" quit
			set ptr  = ptr + atom.length() + 1

			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			set atom = atom_ "."_ $$ATOM^%ZS(expr,.ptr,dels,,1)
		}

		if atom="?" do { quit
			/* The pattern following "?" requires separate treatment
			   because it contains tokens that may interfere with the
			   normal decomposition (such as literals). */
			type Number origptr = ptr
			type String z
			for ptr=ptr+1:1 quit:ptr>expr.length()  set z=expr.extract(ptr) quit:'(z?1N!(z=".")!(z?1A)!(z.ascii()=0))
			set ptr = ptr-1
			set getval = getval_ expr.extract(origptr, ptr)
		}
		if dels[atom set getval = getval_ atom quit
		/* If it starts with "%", this may be a keyword or a column
		   name. Note that the call to $$getSysKwd^UCDTAUTL is expensive
		   because that unit needs to support bootstrap access to the
		   STBLSYSKEYWD table which implies "ResultSet only" access.
		   */
		if atom.extract()="%" set skwd = $$getSysKwd^UCDTAUTL(atom) if 'skwd.isNull() set getval = getval_ skwd quit

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if atom.ascii()=0 set getval = getval_ $$UNTOK^%ZS(atom,lit) quit
		if atom.extract()="$" set getval = getval_ atom quit
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte	
		if $$isNum^UCGM(atom) set getval = getval_ atom quit

		/* Should be column reference at this point.
		   Will presumably throw exception down the line if not.
		   */
		set nr = nr + 1, tree(nr) = getval
		set nr = nr + 1, tree(nr) = atom.upperCase()
		set getval = ""
	}
	set nr = nr + 1, tree(nr) = getval
        quit

	// ---------------------------------------------------------------------
String stripQuotes( String ident,	// identifier
		String literals)	// M and/or SQL literals	/NOREQ
	/* ---------------------------------------------------------------------
	This funtion strips the opening and closing quotes from a Profile SQL
	identifier. This is a simplified version of String.stripQuotes(), based
	on the following properties of a Profile identifier:
	* The name of the identifier will never contain the (M) double quote
		character.
	* The name of the identifier will never contain the (SQL) single quote
		character.
	If the identiefier starts with $CHAR(1), then the 'literals' parameter
	shall be supplied, and it will used ro be "untokenize" the ident first.
	
	OUTPUTS:
	$$
	*/
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if ident.extract()=1.char() set ident=$$UNTOK^%ZS(ident, literals)
	if ident.extract()="""" quit ident.piece("""",2)
	quit ident

	// ---------------------------------------------------------------------
String sub2cln( String sublist)	// subscript list
	/* ---------------------------------------------------------------------
	Convert a subscript list with literals to a column list without literals
	*/

	type String cln, ER	// ER created by TOKEN^%ZS() !!
	type String clnlist = ""
	type Number sub
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte	
	set sublist = $$TOKEN^%ZS(sublist)
	for sub=1:1:sublist.length(",") do {
		set cln = sublist.piece(",",sub)
		if cln=+cln quit		// skip numlit
		if cln[(0.char()) quit	// skip strlit
		if clnlist.isNull() set clnlist = cln quit
		set clnlist = clnlist_ ","_ cln
	}
	quit clnlist

	// ---------------------------------------------------------------------
PSLTable tAssert( PSLTable tabDes,	// PSLTable  (*1)
		Number LVL,		// information level (*2)
		PSLColumn clnDes())	// PSLColumn() cache
	/* ---------------------------------------------------------------------
	Runtime implementation of PSLTable.assertLevel().

	If the supplied tabDes already contains the information for the
	requested level, then tabDes is returned. Otherwise all missing
	information up to the requested level will be added to tabDes, and the
	modified PSLTable instance will be returned.

	This function will need to iterate over several DQ DD tables to compute
	the requested information.

	If the PSLTable instance is new, or its current information level is
	less than the requested level, then the clnDes() array will contain the
	PSLColumn entries for all columns of the table on exit

	ARGUMENTS:
	(*1) the PSLTable instance as returned by $$getPslTbl()
		PSLTable.hasComputed.isNull() will be considered the trigger to
		accumulate the level 1 information.
		SchemaTable.count.isNull() will be considered the trigger to
		accumulate the level 2 information.
	(*2) LVL = information level
		LVL = 1 corresponds to a "full" PSLTable instance
		LVL = 2 corresponds to a "full" SchemaTable instance

	OUTPUTS:
	. $$ = A PSLTable instance that contains at least the information at the
		requested level
	. clnDes(table.column) = PSLColumn
		If (and only if) the current information level is less than the
		requested information level, clnDes() will contain PSLColumn
		instances for each column of the table.

	NOTES:
	. Although this function does not explicitly maintain a maximum value,
		getPslTbl^UCMETHOD and tAssert^UCMETHOD must be updated to
		insert the new "maximum" as the default value whenever a new
		level is added here.
	. PSLTable.assertLevel(2) will calculate the fields for a SchemaTable
		instance, even if the object is a PSLTable instance.
		However, none of the fields will be stored. To distinguish a
		PSLTable instance from a SchemaTable instance, the function
		uses tablDes.length(SEP)
	*/
	type literal String SEP = "|"
	type literal Number PSLTBLMX = 16	// "size" of PSLTable
	type literal Number LVL1IND  = 11	// PSLTable.hasComputed
	type literal Number LVL2IND  = 29	// SchemaTable.count 

	type public PSLParser pslPrsr
	if LVL=0 quit tabDes
	if LVL>1,({SchemaTable}tabDes).count>0 quit tabDes
	if LVL>0,'tabDes.hasComputed.isNull() quit tabDes

	type String  cln			// column name
	type Boolean cmp   = 0			// hasComputed?
	type Number  count = 0			// column count
	type String  def			// default value
	type List    dfl   = ""			// defaultList
	type List    ixl   = ""			// indexList
	type Number  key			// ORDERBY iterator
	type List    mfl   = ""			// masterfieldList
	type String  nod			// node
	type String  nodes()			// array of nodes
	type String  ndl   = ""			// nodeList
	type Boolean req			// isRequired?
	type List    rql   = ""			// requiredList
	type String  ordby			// DBTBL8.ORDERBY
	type String  types = ""			// dataTypes
	type String  table = tabDes.table

	type ResultSet rs1d = Db.select("DI,TYP,CMP,ISMASTER,REQ,DFT","DBTBL1D","%LIBS='SYSDEV' and FID=:table")
	type PSLTable tdc()		// local "cache" for calls ...
	set tdc( table) = tabDes	// ... to $$getPslCln()
	while rs1d.next() do {
		type Row rec = rs1d.getRow()

		// Don't include literal keys
		if rec.di.isNumber() quit
		if rec.di.extract()="""" quit

		set count = count + 1
		set cln = rec.di

		if '(types[rec.typ) set types = types_rec.typ

		//if $$isSfdMaster(table, cln, rec.ismaster) set mfl = mfl.add( cln)
		if rec.ismaster set mfl = mfl.add( cln)

		if cmp = 0,'rec.cmp.isNull(),rec.typ'="M" set cmp = 1

		type String ref = table_"."_cln
		set clnDes(ref) = $$getPslCln( table, cln,tdc())
		set nod = clnDes(ref).getPurposeNode()

		/* If not key or top, save in nodes() */
		if nod.toNumber()'<0,nod'?1.N1"*" set nodes(nod)=""

		/* Build defaultList and requiredList, taking
		   special treatment of Logicals into account. */
		set req = ''rec.req
		set def = rec.dft

		if pslPrsr.getSetting("PSL","Version",$$getPSLVersion^PSLC)>2.6, rec.typ = "L",rec.cmp.isNull() set req = 1 if def.isNull() set def = 0
		if req set rql = rql.add( cln)
		if 'def.isNull() set dfl = dfl.add( cln)
	}

	/* Construct nodeList as a list of purpose nodes. Non-numeric
	   nodes will have been quoted properly. Special purpose nodes
	   for Blob or Memo columns will be unquoted.
	   The assumption is that no node contains SEP. As long as SEP
	   is equal to the separator in DBTBL1D, this is a valid
	   assumption. */
	set nod = -1
	for  set nod=nodes(nod).order() quit:nod=""  set ndl = ndl_","_ nod

	/* Construct indexList. Add columnname at most once.
	   */
	type ResultSet rs8 = Db.select("ORDERBY","DBTBL8","%LIBS='SYSDEV' and FID=:table")
	while rs8.next() do {
		
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set ordby = $$TOKEN^%ZS(rs8.getCol("ORDERBY"))
		for key=1:1:ordby.length(",") do {
			set cln = ordby.piece(",",key)
			if cln=+cln quit		// skip numlit
			if cln[(0.char()) quit	// skip strlit
			if ixl.contains(cln) quit	// duplicate
			set ixl = ixl.add(cln)
		}
	}

	type String intDes = tabDes	// TEMP !!!!
	set intDes.piece( SEP, 5) = types
	set intDes.piece( SEP, 11) = cmp
	set intDes.piece( SEP, 13) = ixl
	set intDes.piece( SEP, 14) = mfl
	set intDes.piece( SEP, 15) = ndl.extract(2, ndl.length())

	if LVL>1, intDes.length( SEP)>PSLTBLMX do {
		set intDes.piece( SEP, 28) = count
		set intDes.piece( SEP, 29) = dfl
		set intDes.piece( SEP, 30) = rql
	}

	quit intDes

	// ---------------------------------------------------------------------
private Number toValMod( String typ,	// DQ datatype
		Boolean nul)		// isNullToZero
	/* ---------------------------------------------------------------------
	Support function that returns value modifier indicator to be stored in
	the construction of the -161/-162 nodes for an RDB column assignment.
	
	QUTPUT:
	. $$ = modifier value (see getRdbAsn)
		- 0 if the datatype is character based (BFMTU)
		- 2 if 'L' or null-to-zero
		- 1 otherwise ($CDN)
	*/
	quit $select("BFMTU"[typ:0,typ="L"!nul:2,1:1)

	// TEMPORARY CLASS MISMATCH HIDERS
private String fromPSLColumn( PSLColumn cd) quit cd
private String fromPSLTable( PSLTable td) quit td
 #OPTION ResultClass ON
public String vSIG()	quit "61397^34727^Frans S.C. Witte^167273"	// Signature - LTD^TIME^USER^SIZE
