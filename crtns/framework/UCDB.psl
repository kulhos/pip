	/*
	ORIG: FSANCHEZ - 01/15/98
	DESC: Library of Db methods

	KEYWORDS:

	========================================================================
	Because a separate project to migrate the PSL compiler itself from a set
	of "M routines" to "PSL	procedurer", is not expected to start in the near
	future, but the growing complixity of the MDB/RDB support can be much
	better handled by "PSL" than by "M", this PSL compiler element will be
	migrated on a per-subroutine basis. The code that has not yet been
	migrated is embedded in #BYPASS - #ENDBYPASS blocks. The only purpose
	and justification for these unusally large chunks of #BYPASSed code is
	this slow migration.
	========================================================================

	---- Comments ----------------------------------------------------------
	This unit implements the methods and properties of class Db and class
	Cache.

	Subroutines generated by this unit will use the class-specific
	prefixes "vCa" (Cache) and "vDb" (Db).

	In addition the following non-standard prefixes are used:
	vExNNaYY	labes jumped to in code generated for "advance to next
			row" of Db.isDefined()
	vFetchNN	Fetch result code for Db.select() and Db.selectDbset()
	vLNNaYY		labels jumped to in code generated for "advance to next
			result" of Db.select() and Db.selectDbSet()
	vOpenNN		Open cursor code for Db.select() and Db.selectDbset()

	---- Revision History --------------------------------------------------
	2009-04-21, Frans S.C. Witte, CRs 35741/39733
		* Modified addMSaveByspass to deal with qual.isNull()
		* Added support for DEBUG,IOCOUNT in Db.select()

	2008-12-16, Frans S.C. Witte, CRs 35741/36952/36954
		* Modified isDefined for MDB to account for code that calls
		  $$BYTECHAR^SQLUTL() at the beginning of all SQL code.

	2008-10-16, Frans S.C. Witte, CRs 35741/35918/35922
		* Modified code generated for dynamic select to support tracking
		  of open cursors.
		* Corrected issue for Db.getOneRow(,,,delim). All callers of
		  $$RsMsXV^UCDBRT() now supply the 'delimiter' parameter and
		  use PSLTable.columnDelimiter in the calls to %DBAPI
		* Modified delRdb() to work with TCOMMIT after RDB commit

	2008-10-04, Frans S.C. Witte, CR 35741/35828/36013
		* Db.select() on type LITERAL ResultSet now handled by UCRESULT.

	06/13/2008 - RussellDS - CR 30801
		* Modified delete section to remove filerPGM reference and
		  related logic
		* Modified delByFiler, getRecSr, keyVal sections to change
		  filerPGM reference to RecordTABLE
		* Modified insert and update sections to unconditionally add
		  audit, instead of basing on if filer
		* Modified delRdb to remove consideration for logging, since
		  if logging is enabled for a table, it will be handled by
		  a call to the filer in the delete section.  Moved delRcode
		  into delRdb since no longer multiple calls.
		* Modified getRecSr, and added getRecSrCode, to use
		  RecordTABLE methods to get records
		* Modified getRecord section to turn on auditFlag when
		  updateRestrict access rights apply to a table
		* Modified select to patch M code for access rights
		* Modified keyVal to use SELECT (like rdb) if there are select
		  rights on the table
		* Modified fastDel to correctly check for literal keys that
		  are missing
		* Modified getRecord to deal wtih call for DbSet when audit
		  logging is in use
		* Added akey2asgn to build key assignment code for use by
		  classNew^DBSDYNRA
		* Moved getRecCode and getRecQid1 from UCXDD
		  
	2008-04-02 - Frans S.C. Witte - CR 33569
		* Code generated for vFetchN() will now set row to "" when after
		  the last row.

	09/24/2007 - RussellDS - CR29295
		* Modified getRecSr section to eliminate node -150 and add
		  handling for nodes -161/-162 for RDB for constructioon of
		  insert/update code.  Eliminated call to UCCLASS and now
		  use method getNewCode for initial instantiation code.
		* Modified getRecSr section to include new node -152 as
		  replacement for -151.
	
	08/15/07 - Frans S.C. Witte - CR: 27800
		* Replaced commands(,) by pslPrsr(,)
		* Replaced 'public' by 'ret' in fp declarations
		* Replaced sysmap assignment with call to PSLParser.addSysmap()
		* Converted get1row, insert, and update to PSL
		* Changed PSLubrou.toString() to PSLSubrou.getName()
		* moved commands("DEBUG") to
		  PSLParser.getSetting("DEBUG","FILEQUAL")
		* Added getSchCln, getSchTbl, isSchCln, isSchTbl from UCSCHEMA
		* corrected LitInst.
		* Moved procPars to UCRUNTIM.PROC, and modified calls to UCRUNTIM
		  to use method call syntax.

	08/20/07 - KWANL / Frans S.C. Witte - CR 28995
		* Adapted to new CATCH/THROW mechanism

	05/16/07 - Frans S.C. Witte - CR: 27486
		* RECNOFL exceptions now put table name in Error.context
		* Removed dead (M) code from previous version of keyVal().
		* Converted getRecPr to PSL.
		* Added support for Cache.getRecord(,,classNew) and
		  Cache.isDefined(,)
		* Added support for PSLParser.getSetting("DEBUG","DBIOCOUNT") in
		  getRecSr()
		* Corrected sql2akey() to deal with SQL strlits in whereclause

	04/17/07 - Frans S.C. Witte - CR: 26334
		* Corrected code that uses addm2^UCGM
		* Removed quit after throw to prevent warning

	03/23/07 - RussellDS - CR26386
		* Changes to support archiving
		   - Modified getRecSr to add consideration for purpose node -99,
		     archive directory.
		   - Modified cacheSr to consider archive on incremental loading.
	
	07/02/05 - Frans S.C. Witte - CRs: 25185 / 25186 / 25187
		* Corrected code generated for Db.isDefined when count>1
		* Added code to find more in-line optimizations for Db.isDefined
		  in MDB.
		* Added lvn 'mode' to list of lvns NEWed in vOpen0 for MDB (this
		  lvn is referenced by FLT^SQLCACHE).

	07/27/06 - Frans S.C. Witte - CRs: 22719 / 20613
		* Corrected problem in select when data item protection was used
		  and in call to selSrOpen^UCDBR() for dynamic select with data
		  item protection.
		* Added third parameter in code generated for filer calls, and
		  modified fileQual to call initPar^UCUTILN().
		* delRdb now uses $C(9) in call to $$EXECUTE^%DBAPI()
		* All %PSL-E-SQLFAIL exceptions now include the error message
		  returned by the API, with newline translated into space, and
		  comma into tilde.
		* Rewrote keyVal(), removed RKeyVal() and all code no longer
		  called.
		* Converted procPar() to PSL
		* getRecSr() now uses PSLTable.getUpdateKey() to construct the
		  -152 node.
		* calls to %DBAPI now pass 0 (zero) instead of "" for vIndex.
		* Corrected problem in CacheSr() for tables without primary key.

	07/21/06 - Frans S.C. Witte - CRs: 22273 / 22274
		* Modified isDefined and select to support Unicode change to
		  SQLM for >= and <=.

	06/01/06 - Frans S.C. Witte - CRs: 21397 / 21937
		* Corrected $$hasQual()
		* Rewrote $$filequal() and renamed to $$fileQual().
		* Added support for dynamic qualifier in Db.delete(),
		  Db.insert() and Db.update().
		* Replaced '255' by PSL.maxLitLength (and converted M to PSL).
		* Rewrote select and isDefined to PSL, using new PSLSubrou
		  capabilities. Removed subVar and tagcheck because this code
		  now resides in addExe^UCPSLSR().

	05/24/06 - Frans S.C. Witte - CRs: 21394 / 21395
		* Warnings now reported through warnGroup^UCGM()
		* Added extra check to $$sql2akey()

	05/09/06 - Frans S.C. Witte - CRs: 21101 / 18164
		* Implemented support for /LOG (and /NOLOG) for both MDB and RDB
		* modified Db.fastDelete so it no longer includes the qualifiers
		  /NOINDEX/NOVALFK, and corrected code to deal with non-literal
		  access key specification.
		* SELECT * is now replaced by SELECT $$COLLIST^DBSDD before
		  passing the query to either MDB or RDB. This ensures that the
		  select-list and struct() will all have the same idea about the
		  columns and their order.

	03/21/06 - Frans S.C. Witte - CRs: 20280 / 18164
		* Added access for all private subroutines and functions.
		* Added GROUP to all ACCEPT compiler commands.
		* Corrected MDB delete (table has no primary key, where-clause
		  references undefined row).
		* Implemented $$sql2akey().
		* Corrected RKeyVal() for Db.currVal()
		* Corrected CacheSr()

	11/09/05 - Frans S.C. Witte - CRs: 18163 / 18164
		* The source code is "converted" to PSL. Most subroutines and
		  functions are still #BYPASSed M code.
		* removed history older than 2004-01-01
		* Replaced setScop^UCGM + setType^UCGM by setScope^UCGM
		* Added support for /PSLBOOT qualifier in dynamic select
		* Modified Db.isDefined (for RDB).
		* Rewrote getRecord and LitInst to use functions in UCXDD, which
		  makes them DBI in all aspects.
		* Rewrote Cache to have vobj and voxn code in same place

	08/31/05 - Frans S.C. Witte - CRs: 15592, 17056 / 15593, 17057
		* Replaced literal 1900 by $$getPslVal^UCOPT("maxLineLength")
		  (4 occurrences).
		* Documented subroutine tagcheck, and cleaned variable usage.
		* Subroutine select: support for /PSLBOOT
		* replaced call to TYP^DBSDD with TYP^SQLDD
		* Replaced SchemaTable by PSLTable (comment only)

	06/14/05 - Frans S.C. Witte / RussellDS - CR16346
		* Modified subroutine VIEW() to support parent/child on RDB
		* Modified function $$getGbl()
		* Commented out subroutine getRow (method Db.getRow not defined,
		  and not called from within UC* or ^OBJECT.
		* Commented out function $$query() (only called by getRow)
		* Commented out subroutine BLDRETURN (only called by $$query())
		* Commented out function $$pos() (only called by getList code
		  that has been commented out)
		* Commneted out ET (not called / no trap set)
		* Added $$RgetDef() and $$RgetKey()
		* Commented out subroutine RisDefined (merged with isDefined)
		* Commented out subroutine RgetRecord (merged with getRecord)
		* Commented out BMsel and hasBMtyp (only called by RgetRecord)
		* Eliminate RfastDel section
		* Modify fastDel to call delete for RDB and pass parameters
		  to delete for both RDB and MDB
		* Modify Rdelete to implement TRUNCATE command and direct
		  delete calls, versus filer, when appropriate
		* Modify handling of vEr after calls to %DBAPI to conform to
		  values returned
		* Rework Rdelete section to eliminate unnecessary code
		* Eliminate WHR section - no longer used
		* Subroutine Cache: correct assignment to patch(-6,,,) for type
		  1 tables.
		* Subroutine LitInst moved code that checks M_global
		* Subroutine filequal now calls setPar^UCUTILN(,) to insert
		  defaults or debug related parameters (to handle conflicts)
		* subroutine RkeyVal now generates code that adds SQL quotes for
		  non-numeric literals.

	06/14/05 - GIRIDHARANB / RussellDS - CR16287
		* Modified section RgetRecord to use sql select statements to 
		  load the large object columns.Added sections hasBMTYp,BMsel to 
		  support the above changes.
		* Replaced references to parameter() with sysmap()(2 occurences)
		* Patched section RisDefined to check for CLS for an isDefined
		  on DEP/LN

	03/15/05 - CHENARDP/RussellDS/F.S.C. Witte - CRs 15379, 14919 / 14920
		* Modified isDefined and RisDefined sections to update
		  parameters(#IF" based on isDirctv flag
		* Modified select section to eliminate conditional check on
		  paramters before updating SYSMAP data since it is now always
		  collected.
		* Patch - Modified WHR section to strip outer layer of
		  parens from the value.
		* Modified $$hv() section to handle a list of vsql()
		  entries.
		* Modified selectDyn to call $$RsRdb^UCDBRT(), $$RsDyRT^UCDBRT()
		  and the structures provides by that function in the generated
		  code. Also added code to throw an exception when the cursor
		  open returns a non-zero ER (same behavior as MDB).
		* Removed assignment to struct("open",,,) (not used).
		* Introduced node vobj(rs,-4) to contain the equivalent of
		  vsql("D") at runtime.
		* Subroutines RSelect, OPENLBL, FETCHLBL, map, typmap, and
		  RselDyRT removed (that functionality is now handled by
		  UCDBR.proc and UCDBRT.proc).
		* Changed ERROR^UCGM(.RM) to ERROR^UCGM($G(RM)) (4 occurrences)
		* Subroutine procPar: removed redundant $G() (2 occurrences)
		* Corrected subroutines gblRef and LitInst to handle the literal
		  keys, and to retrieve the (Record) instance at compile time.
		  NOTE that LitInst will not work for Rdb!
		* Db.getList now always produces an error (not documented, no
		  longer supported).
		* ER/RM replaced by vEr/vRm (all RDB code).
		* Subroutine Rdelete: added code line to NEW vEr,vRm
		* splitExpr() now uses a 1900 byte chunk size.
		* subroutines select and selectDyn: added ";=noOpti" marker for
		  lines that shall not be removed by UCPATCH.

	02/16/05 - Frans S.C. Witte - CRs 14185 / 14186
		* Subroutine select: modified code generated for vOpen and vFetch
		  to fetch row only when it is requested (fetch before
		  construct), except for fetch of first row to be able to satisfy
		  ResultSet.isEmpty().
		* Subroutine mapPSLvar: added SQL binary operators (+ - * / > <)
		  as token delimiters when looking for hostvar.
		* Added accessibility of private/public subroutines

	02/15/05 - GIRIDHARANB - CR14419
		* Modified sections Rselect and RselDyRt to include support for
		  the DQMODE parameter (par("DQMODE")=1).
		* Modified section map to correct parsing errors when the columns
		  selected contained a DISTINCT clause.

	02/11/05 - GIRIDHARANB - CR14407
		* Modifed section Rselect to correct errors with column order in 
		  Input select list.
		* Modified section Rdelete to pass the correct where clause to
		  the key select logic.

	01/19/05 - GIRIDHARANB - CR 13233
		* Miscellaneous fixes to section map() to correct reserved check
		  in the 'order by' clause.
		* Modified RisDefined section to correct the sql string 
		  for the isDefined method.
		* Newed Variable 'array' in section Rdelete.
		* Modifed section typmap() to check for "." in column name.
		* Modified section Rkeyval to do a DBMAP check for inc=1.

	01/05/05 - Frans S.C. Witte - CRs 12313 / 12314
		* Subroutines BLDRETURN, map(), rdb(), Rfrmcls(), typmap(),
		  WHR(): Added SPACE before ";" to conform to M standard.
		* Inserted QUIT before first subroutine of this routine.
		* Replaced ^SQLQ(,,,,.0,,.vdd,.vdd) by ^SQLQ(,,,,0,,.fsn,.vdd)
		  (ie ".0" by "0", and first occurrence of "vdd" by "fsn")
		  (4 occurrences).
		* Subroutine selectDyn: fixed code generated for return value of
		  vOpen0() for RDB (object instead of vobj(object)), and value
		  assigned to vobj(object,0) after opening the cursor
		  (vsql instead of 1). Fixed code generated to set
		  vobj(object,-2) ($$vFetch0 instead of $$vOpen0).

	12/16/04 - Frans S.C. Witte - CRs 11445 / 11446
		* Changed $D(pslPrsr("WARN",)) to $G(pslPrsr("WARN",)
		  (2 occurrences).
		* Subroutine selectDyn(): the lvns used by dynamic select are now
		  checked against and added to type().
		* Function $$ISSFD(): will now quit on ER from ^SQLxxx.

	11/16/04 - Frans S.C. Witte - CRs 11441, 12564 / 11442, 12565
		* Fixed problem in subroutine getList (when pos=0).
		* Fixed problem in subroutine WHR() ('> shall translate to less
		  or equal)
		* Subroutine Get1Row (code for Db.getOneRow) moved from UCDBTX
		  to this routine (and renamed get1Row). Added deprecation
		  warning for this method.
		* Subroutine getSchTab (code for Db.getSchemaTable) copied from
		  subroutine getTable in UCSCHEMA.proc.
		* Added deprecation warnings for Db.insert, Db.nextKey,
		  Db.prevKey, and Db.prevVal.
		* subroutine getLock commented out. (method Db.getLock not defined)
		* Subroutines insert and update: remove new of variable X from
		  the generated code.
		* subroutine Cache: REPLACED if ftype#2 BY if ftype#2 do
		* Subroutine filequal(): filer qualifiers in pslPrsr("SQLPARS")
		  are used again when present. Since no part of the compiler will
		  set this node, the net effect will be a no-op in these versions.
		  The presence of this statement ensures compatibility with
		  p01rel03_01 (where the compiler does set this node).
		* Subroutine isDefined: Moved code that decomposes accesskey to
		  separate function (akey2sql()). Requirement that all keys are
		  supplied is now restricted to two-argument form.
		* Subroutine akey2sql(): modified $TR(val,"""","'") to
		  $$QADD^%ZS($$QSUB^%ZS(val,""""),"'") (in case constant includes
		  one of the quote characters).
		* Subroutine mapPSLvar(): removed "fif" parameter from call to
		  $$valExpr^UCGM().
		* Multiple subroutines: code that generates runtime exception now
		  conforms to new Error.type layout: %PSL-E-error.

	11/11/04 - RussellDS - CR13190 (P04) / CR13911 (P01)
		     Corrected additional issue related to return on dynamic
		     select from vOpen0 for RDB.

		     Fix problem in fastDel related to literal keys.

	09/20/04 - RussellDS - CR12259 (P04) / CR12526 (P01)
		     Corrected problem in selectDyn to change to return
		     result of first fetch from vOpen0.

		     Corrected error in update section - removed reference
		     to $g(par), replaced with actual(4).

		     Removed unnecessary $D(actual()) and $G(actual()) tests
		     in update section.

	09/06/04 - GIRDHARANB - CR8533
		     Cleaned out dead code warnings in section Rdelete.

	09/01/04 - RussellDS - CR11515
		     Added code to handle dynamic selects from RDBs.

	06/15/04 - Giridharanb - CR9217
		     Misc Bug fixes in sections RfastDel,Rkeyval. Also added 
		     section typmap to support optimization of the select method.

	03/29/04 - RussellDS - CR9172
		     Integrate changes as part of move of filers to PSL.

		     Added code to isDefined section to handle CUVAR and similar
		     globals, which use "*" as a key.

		     Change vExist generated label name to vExst to shorten to
		     avoid conflict problems.

		     Remove use of SQLPARS - obsoleted with changes for filers.

		     Added code to handle automatically treating ER and RM as
		     public scope for versions prior to Profile04.

	02/02/04 - FSANCHEZ/KELLYP - 7813
		     Fixed loading error in Db.getRecord if nested property
		     syntax is used (e.g.,  Db.getRecord("DEP",1).bal).

	01/08/04 - GIRIDHARANB - 7811
		     Minor fixes and code optimizations to RfastDel,Rdelete
		     WHR,RgetRecord section
	*/
	#PACKAGE framework.psl

	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.  The M routine from the     *
	// * crtns directory should be used for this purpose.                *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit
	
	// --------------------------------------------------------------------
addAuditLogCode(String operation,	// UPDATE or DELETE
		PSLBuffer buf,		// PSL buffer
		PSLTable td,		// PSLTable
		String statement,	// SQL statement
		String where)		// WHERE clause
	/* --------------------------------------------------------------------
	Add code to do audit logging and to return DBAUDITLOG.SEQ number for
	use in potential later detail logging by individual records.
	
	This method is used by delByFiler and update to add the code needed
	to check for audit logging, call the audit log if appropriate, and
	return the value for the audit log sequence, which indicates if the
	individual statement has already been logged, or not, and allows
	separate records to be logged under that sequence, if a multi-row
	operation.
	
	If the WHERE clause contains host variables, we need to turn them into
	a using statement at runtime.
	*/
			
	type String code
	type String hostVars = ""
		
	do buf.add(" type Number vauditLogSeq = 0")
		
	// Build host variable clause
	if where.isLike("%:%") do {
			
		// ^SQLQ variables
		type String exe(), vsql(), vsub()
			
		#ACCEPT DATE=06/18/2008; PGM=Dan Russell; CR=30801; Group=ACCESS	
		do ^SQLQ(where, td.table)
			
		set hostVars = vsql("hostVars").get()
			
		if 'hostVars.isNull() do {
			
			do buf.add(" type String using")
			do buf.add(" #ACCEPT Date=06/05/2008; Pgm=RussellDS; CR=30801; Group=BYPASS")
			do buf.add(" #BYPASS")
			do buf.add(" X "_ ("S using="_ hostVars).addQuotes())
			do buf.add(" #ENDBYPASS")
		}
	}
		
	do buf.add(" type static Record"_ td.table)
		
	set code = " if Record"_ td.table_ ".logUserclass("""_ operation_ """) set vauditLogSeq = $$auditLog^SQLAUDIT("""_ operation_ """, """_ td.table_ ""","""_ statement_""","
	if hostVars.isNull() set code = code_ """"")"
	else  set code = code_ "using)"
		
	do buf.add(code)

	quit "vauditLogSeq"
	

	// ---------------------------------------------------------------------
akey2apl( PSLTable td,		// table descriptor
		PSLIdentifier var,	// object variable (*2)
		String akeys,		// access key expression (*3)
		Number sparse,		// sparse indicator (*4)
		String lvpm())		// purpose mapping (*5)	  /MECH=REFARR:W
	/* ---------------------------------------------------------------------
	Transform access key expression into actual parameter list and local
	variable purpose mapping.

	ARGUMENTS:
	(*2) var = object variable
		When a variable name is supplied (unsubscripted!), then each
		key value expression that reduces to a single variable name
		(again unsubscripted) will be recorded in
			patch(-3,PSL.subRou,var,,)=hostvarname
		It denotes a potential variable name to reference the key.
	(*3) akeys = access key expression
		the function supports both the deprecated positional list and
		the NAME=value syntax. Furthermore it supports a SQL conforming
		specification of the primary key (i.e keyword AND instead of
		comma to separate key column comparison predicates)
	(*4) sparse = indicates how missing keys (sparse expression) are treated
		 0 - report an error
		 1 - accept and insert "" in the returned list
		-1 - accept and ignore in the returned list
	(*5) lvpm() = local variable purpose mapping
		This (optional) output array will contain the key purpose
		mapping using the -keynum-2 convention.

	OUTPUTS:
	. $$ = positional list of primary key values
		This value can be used as the actual list to a subroutine that
		has a formallist speficying the primary key, such as the vDbN()
		method generated for Db.getRecord().
	. lvpm(keynum_"*") = key expression
		For each key supplied in akeys

	NOTES:
	. Variable PSL.tok must be used (instead of declaring a local) because:
		- $$valExpr^UCGM() uses 'tok' as a public variable (!!)
		- (double) quoted strings inside the access key must be added
		  to the existing list of tokens, because they will be
		  untokenized outside this subroutine.
	*/
	type public PSLTable pslTbl()
	type public String patch(,,,,)
	type public String tok

	type List fkeys = td.primaryKeys

	if fkeys.isNull() quit ""

	type String expr	// akeys expression element
	type Number i		// iterator
	type Number ptr = 0	// char pointer in akeys
	type String keyNam	// name of key
	type Number keyNum = 0	// key ordinal position
	type String xref()	// key column cross references

	if akeys.extract()="""" set akeys = akeys.stripQuotes()
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	else  do:'akeys.isNull() warnGroup^UCGM("MISMATCH","Literal parameter expected")
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set akeys = $$TOKEN^%ZS(akeys,.tok)	// APPEND to existing !!

	for i=1:1:fkeys.count() set xref(fkeys.elementAt( i)) = i
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	for  set expr = $$nextExpr^UCGM( akeys, .ptr, tok, 1) do { if ptr=0 quit

		if expr="",sparse quit			// missing key
		if expr="," quit
		if expr.upperCase()="AND" quit		// delimiter
		if expr["=" do {			// key=value

			set keyNam = expr.piece("=",1).upperCase()
			set expr   = expr.extract( keyNam.length() + 2, expr.length())
			set keyNum = xref( keyNam).get()
			if keyNum.isNull() throw Class.new( "Error", "%PSL-E-INVALIDREF, Invalid key column: "_keyNam)
		}
		else  do {

			set keyNum = keyNum + 1
			set keyNam = fkeys.elementAt( keyNum)
			if keyNam.isNull() throw Class.new( "Error", "%PSL-E-INVALIDREF, Too many access keys")
		}

		/* now keyNam contains the name, keyNum the ordinal position,
		   and expr the value.
		   */
		if lvpm(-keyNum-2).exists() do PSL.error("Duplicate access key: "_keyNam)

		kill xref(keyNam)	// drop name that has been used

		/* First case supports SQL 'literal' syntax
		   */
		if expr.extract()="'",expr.extract( expr.length())="'",expr.length("'")=3 set expr = expr.translate("'", """")
		
		/* TAB xxx TAB (patched reference) */
		else  if $$hasPatch^UCPATCH(expr)

		/* wrapped column reference */
		else  if $$hasWrap^UCREC4OP(expr)

		/* [FRS] This is not a strict sytax, currently ':' host
		   variable prefix is not required.  Everything is treated
		   as a host expression.
		   FSCW CR18163: NOTE valExpr uses 'tok' as public variable !!!
		   */
		else  do {
			type Number ER = 0
			if expr.extract()=":" set expr = expr.extract( 2,expr.length())
			if expr[(PSL.oLvn_"(") quit
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			set expr = $$valExpr^UCGM( expr) if ER throw Class.new( "Error", "%PSL-E-INVALIDREF, Invalid key value expression for "_keyNam)
		}

		set lvpm(-keyNum-2) = expr
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if $$isVar^UCGM(expr),$$isVar^UCGM(var) do {
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			type Number newPtr = $$getNew^UCGM(var)
			set patch( -3, PSL.subRou, var, newPtr, -2 - keyNum) = expr
		}
	}

	/* Construct the return value: an ordered list of xref(keyNum) values,
	   using the value of sparse to decide what to do with missing values
	   */
	type String return = ""
	type String zerror = ""

	for i=1:1:fkeys.count() do {
		if lvpm(-i-2).exists() set return = return_ lvpm(-i-2)_ "," quit
		if sparse = 0 set zerror = zerror_ fkeys.elementAt(i)_ "," quit
		if sparse > 0 set return = return_""""""
		set return = return_ ","
	}

	if 'zerror.isNull() do PSL.error("Missing actual keys: "_ zerror.extract( 1, zerror.length() - 1))

	/* Remove ALL trailing commas from return value
	   */
	// quit $$UNTOK^%ZS( return.extract( 1, return.length() - 1), tok)
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	quit $$UNTOK^%ZS( return.trim( 1, ","), tok)
	
	
	// ---------------------------------------------------------------------
akey2asgn( PSLTable td,		// table descriptor
		PSLIdentifier var,	// object variable
		String akeys,		// access key expression
		Boolean ignNull,	// ignore missing values (*4)
		String lvpm())		// purpose mapping	  /MECH=REFARR:W
	/* ---------------------------------------------------------------------
	Transform access key expression into assignment string and local
	variable purpose mapping.

	ARGUMENTS:
		All arguments are identical to akey2apl, except ingNull.
		
		(*4) ignNull =  ignore null values
			if set, do not include setting of keys to null

	OUTPUTS:
	. $$ = assignment of primary key values, e.g.,
		vobj(var,-3)="ABC",vobj(var,-4)=X
		This value can be used for the key assignment, for example,
		for Class.new("RecordTABLE") code generation.
	. lvpm(keynum_"*") = key expression
		For each key supplied in akeys
	*/
	
	type public PSLColumn pslCln()
	type public PSLTable pslTbl()
	
	type List fkeys = td.primaryKeys

	if fkeys.isNull() quit ""
	
	type Boolean bHasRoot
	type List keyvals
	type Number accPos, i
	type String assignCode, val
		
	set keyvals = $$akey2apl(td, var, akeys, 1, lvpm())
	
	set assignCode = ""
	for i = 1:1:fkeys.count() do {
		
		quit:(ignNull and 'lvpm(-i - 2).exists())
		
		if 'ignNull, 'lvpm(-i - 2).exists() set val = """"""
		else  set val = lvpm(-i - 2)
		
		type PSLColumn cd = PSL.cachePSLColumn(pslCln(), td.table_"."_fkeys.elementAt(i), pslTbl())
		
		set accPos = $$clnByOvs^UCREC4OP( PSL.subRou, var, cd, false, true, .bHasRoot)
		
		type Number decPos = $$getDec^UCREC4OP( PSL.subRou, var, accPos)

		type String return = $$clnAsn1^UCREC4OP( decPos, accPos, val)
		
		set assignCode = assignCode_ return
	}
	
	quit assignCode
	

	// ---------------------------------------------------------------------
Cache	// method Cache.getRecord ; Returns Record<Class> object
	/* ---------------------------------------------------------------------
	This subroutine generates a vCaX() subroutine that returns the
	top/default node of the requested Record from the Cache (as supplied in
	objectName), and loads it into the Cache (using Db.getRecord()) when the
	Cache does not yet contain that node.

	If the table's recordType is greater than 9, then it will also generate
	a subrutine vCaNL() to incrementally load a node through the Cache.

	2007-05-16: Added support for 3rd parameter in Cache.getRecord(), with
	the same meaning as the 3rd parameter of Db.getRecord(). This impacts
	generated code as follows:
	- The vDbN() call will now always be a Db.getRecord(,,1)
	- The node returned by vDbN() will be stored as before
	- The record mode returned by vDbN() will be stored in
		cache(table,k,e,y,-2)
	- For a Cache.getRecord(,,0) the exception will be thrown inside the
		generated vCaN() function instead of by the vDbN() function.
		This will be based exclusively on the value of the record mode
		found in the cache.
	- Because the execption must also be thrown for records that are already
		in the cache, the code that throws the exception will occur
		in a block that is independent of the call to vDbN().

	INPUTS:
	. PSL.actual(1) = table name (literal String)
	. PSL.actual(2) = access key expression (literal String)

	. PSLpslTbl()
		The table descriptor cache
	. PSL.var
		The target variable to receive the cached RecordTABLE instance
		Note also that this implies that "nested calls" must allocate
		and supply a scratch variable to use as assignment target.

	OUTPUTS:
	. PSL.actual(3) = record mode
		Assigned before calling getRecord
	. PSL.class = RecordTABLE
		where TABLE = PSL.actual(1).stripquotes()
	. PSL.return
		Extref to be called for this method

	NOTES:
	. The cache structure stores data nodes, mirroring the vobj(,) structure
		The code generated here uses the return value from $$vDbN() as
		the subscript in vobj() to access the initial node, and copy it
		in the cache.
	*/
	type static PSLClass
	type public PSLTable  pslTbl()

	type String table = PSL.actual(1)
	if table.extract() = """" set table = table.stripQuotes()

	/* Make sure the Db.getRecord() that must be called if the record is not
	   found in the Cache is defined.
	   After the call, PSL.return will contain the call to $$vDbN() that
	   shall be used inside vCaN(). 
	   To keep the count of references to vDbN() correct, increment it here
	   (as used by vCaN()).
	   Note that Cache.getRecord(,,0) and Cache.getRecord(,,1) will need
	   separate subroutines, so this distinction must be reflected in the
	   comment.
	   */
	set PSL.class = PSLClass.RECORDCLASS_ table
	//set PSL.actual(3) = 0
	type Number clsNew = PSL.actual(3).toNumber()
	set PSL.actual(3) = 1
	do getRecord

	type PSLTable td    = PSL.cachePSLTable( pslTbl(), table)
	type String   akeys = $$akey2apl( td, PSL.var, PSL.actual(2), 0)
	type String   cmmnt = "vobj()=({Cache}"_ PSL.objectName_ ".getRecord("_ table_ ","_ clsNew_ ")"
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String   label = $$findSubr^UCGM( "vCa", cmmnt)

	/* Increment reference count for lblGetRec */
	type String lbGetRec = PSL.return.piece( "(")
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do incrLabel^UCGM( lbGetRec)

	/* Mark the record-mode purpose variable as being used.
	   THIS IS TEMPORARY CODE, BECAUSE IT UNCONDITIONALLY CREATES THE ENTRY
	   WHEREAS THE ENTRY MAY ONLY BE NEEDED INSIDE vCaN() TO SET THE -2 NODE
	   OF THE CACHE. HOWEVER, TO DO THE LATTER, vCaN() MUST BE GENERATED AS
	   PSL CODE, NOT AS M CODE
	   */
	type Number dummy = $$purByOvs^UCREC4OP( PSL.subRou, PSL.var, -2)

	if 'PSL.subrouExists( label) do CacheSr( td, 1, label, cmmnt, PSL.objectName, clsNew, lbGetRec)
	set PSL.return = "$$"_ label_ "("_ akeys_ ")"

	if PSL.var.optimize()

	quit

	// ---------------------------------------------------------------------
CacheDef	// method Cache.isDefined
	/* ---------------------------------------------------------------------
	This subroutine generates the code for Cache.isDefined() as a simple
	PSL wrapper:
	
	vCaExN() //
		type public Cache cacheNm
		type RecordTABLE vRec = cacheRef.getRecord(table,accKeys,1)
		quit vRec.getMode()=1
	
	INPUTS:
	. PSL.actual(1) = table name (literal String)
	. PSL.actual(2) = access key expression (literal String)

	NOTES:
	. This code shall be adapted to generate a separate subroutine in the
		target language.
	*/
	type String tbl = PSL.actual(1)
	if tbl.extract() = """" set tbl = tbl.stripQuotes()

	type String cmt = "{Cache}"_ PSL.objectName_ ".isDefined("_ PSL.actual(1)_ ","_ PSL.actual(2)_ ")"

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String lbl = $$findSubr^UCGM( "vCaEx", cmt)

	set PSL.return = "$$"_ lbl_ "()"

	if 'PSL.subrouExists( lbl) {
		type PSLBuffer buf = PSL.openBuffer( "()", cmt)
		type String ucn = PSL.objectName.piece( "(")
		do buf.add(" type public Cache "_ ucn_ "()")
		do buf.add(" type Record"_ tbl_ " vRec = "_ PSL.objectName_ ".getRecord("_ PSL.actual(1)_ ","_ PSL.actual(2)_ ",1)")
		do buf.add(" quit vRec.getMode() = 1")

		do buf.insert( lbl, "Boolean")
	}

	quit

	// ---------------------------------------------------------------------
CacheSr( PSLTable td,		// table descriptor
		Boolean useVobj,
		String label,
		String comment,
		PSLIdentifier cacheNm,	// instantiator (cache instance)
		Number clsNew,		// value of ClassNew parameter (0, 1)
		String lbGetRec)	// label to use for getRecord
	/* ---------------------------------------------------------------------
	This subroutine generates 2 labels in a single subroutine:
	- vCaN() to load and cache the initial node
	- vCaNL() to load and cache the incrementally loaded nodes.

	The code generated by this subroutine has only minimal differences due
	to vobj() versus voxn. To load the initial node from the database, the
	supplied $$vDbN() will be called (if needed). This leads to the
	following  matrix for vCaN():
	cached?	vobj model			voxn model
	NO	1) purge cache			1) purge cache
		2) call $$vDbN()		2) call $$vDbN()
		3) copy init node from vobj()	3) copy init node from vOid
		   into cache			   into cache
		4) return result from $$vDbN()	4) return result from $$vDbN()
	YES	1) instantiate new Record
		   object,
		2) copy init node from cache	1) return init node from cache
		3) copy/set special purpose
		   nodes
		4) return vOid

	Because Cache access is supposed to deal with read-only cases, and
	because caching of blob/memo columns is not supported at all, the
	incremental load code for both MDB and RDB can use the actual key values
	from vobj(,-key-2)

	Some special care should be exercised with respect to incremental loads
	when Cache objects are involved. Because the Cache structure mirrors the
	vobj() structure, the existance of a Cache entry for a node must be
	deterministic:
	For recordType 11 tables, additional nodes in the Cache structure shall
	only exist if the top node exists.
	For recordType 1 tables and recordType 10 tables, the Cache is always
	consistent. For recordType 10 the consistency is a side-effect of the
	initial record loading of the associated $$vDb() function:
	- If there is an existsNode, $$vDb() will return the existsNode, and
		that node will always end up in the Cache (in the existsNode).
	- If there is no existsNode, $$vDb() will return "", and all nodes are
		loaded through incremental loading. The "" returned by $$vDb()
		will be stored in the top node, and be returned consistently for
		every Cache.getRecord() that uses this Cache.

	Furthermore, incremental loads through Cache use a separate subroutine,
	whereas for other incremental loads the retrieval code is generated
	"in line". When incremental loads are needed for an object, that object
	may have multiple, different instantiation expressions. In particular
	combinations of Cache.getRecord and calls that pass the object as an
	actual parameter are reasonable combinations.
	To allow the compiler to generate code that uses the Cache structure as
	much as possible while still maintaining the consistency of the Cache,
	the code generated for incremetal loads through Cache uses the following
	algorithm:
	- If the requested node is present in the Cache, it is returned
		immediately.
	- Else the node is loaded into a local variable.
	- If this is a recordType 10 table, the node is added to the Cache
		unconditionally, else it is a recordType 11 table, and the node
		will only be added to the Cache if "top" node exists in the
		Cache
	- In either case, the value of the local variable is returned.

	The subroutine generated for incremental node loading through Cache
	objects is limited to cases where the vobj node is equal to the MDB
	node. Incremental loading of nodes that do not preserve this mapping
	will always bypass the Cache object. This involves:
	- Blob and Memo columns in MDB and RDB
	- MDB negative nodes (where the MDB ^G(,,-N) maps to vobj(,"vN"))
	- RDB wide table nodes (because the table name would not be known until
		runtime)

	NOTES:
	. Cache entries for recordType 10 of optimized objects may need
		additional attention.
	*/
	type public PSLColumn pslCln()

	type String  code			// code construction
	type String  fpl = ""			// formal parameter list
	type String  fplAudit = ""		// formal parameters, including fromDBSet
	type Number  ftype = td.recordType	// record type
	type Boolean isArchived = false
	type Number  k				// key iterator
	type String  lvn			// cacheNm(v1,v2,v3)
	type String  lvn1			// cacheNm(v1,v2,v3,
	type String  lvnInit			// cache node for initial load
	type String  lvpm()			// map passed to getRecCode()
	type String  nodExis = td.existsNode	// exists node
	type String  nodInit = $$getRecPur^UCXDD( td)	// initial node
	type List    pkl = td.primaryKeys	// primary key columns
	type String  ucn = cacheNm.piece( "(")	// unsubscripted cache name
	type String  vobjHead			// "vobj(vOid"
	type String  vobjInit			// vDbN var that holds init node
	
	if 'td.getArchiveTable().isNull() set isArchived = true

	for k=1:1:pkl.count() do {
		if k>1 set fpl = fpl_ ","
		set fpl = fpl_ "v"_ k
		set lvpm( k_"*") = "v"_ k
	}
	
	// Add fromDBSet parameter
	if 'td.isRdb do {
		
		if fpl.isNull() set fplAudit = "0"
		else  set fplAudit = ",0"
	}
	
	if useVobj set vobjHead = PSL.oLvn_ "(vOid"

	if cacheNm.endsWith( ")") set lvn = cacheNm.extract( 1, cacheNm.length() - 1)_ ","
	else  set lvn = cacheNm_ "("

	set lvn = lvn_ fpl_ ")"
	if lvn.endsWith( "()") set lvn = lvn.extract( 1, lvn.length() - 2)
	if lvn.endsWith( ",)") set lvn = lvn.extract( 1, lvn.length() - 2)_")"

	set lvn1 = lvn

	if lvn1.extract(lvn1.length()) = ")" set lvn1 = lvn1.extract(1, lvn1.length()-1)_","
	else  set lvn1=lvn1_"("
	
	if (nodInit = "0*") ! nodInit.isNull() do {
		/* unsubscripted node is used.
		   target = cache lvn + formals
		   origin = vobj(recInst) (or vOid if optimized) */
		set lvnInit  = lvn
		set vobjInit = $SELECT(useVobj:vobjHead_")",1:lbGetRec)
	}
	else  if 'nodInit.isNull() do {
		/* exists node is used.
		   target = cache lvn + formals + existsNode
		   origin = vobj(recInst,nodExis) (or vOid if optimized) */
		set lvnInit  = lvn1_ nodExis_ ")"
		set vobjInit = $SELECT(useVobj:vobjHead_","_nodExis_")",1:"vOid")
	}

	set code = fpl
	if clsNew=1,'useVobj set code = ({List}code).add("v2out")
	type PSLSubrou sr = PSL.addSubrou( label, "("_ code_ ")", comment, 0)

	if useVobj do sr.addCode(" N vOid")

	// Add the code to load the record from the db if not in cache
	do sr.addCode(" I '$D("_ lvn_ ") D")
	if 'useVobj {
		set code = ""
		set:clsNew=0 code = "v2out"
		set:isArchived code = ({List}code).add("vArch")
		do:'code.isNull() sr.addCode(" .  N "_ code)
	}
	//do sr.addCode(" .  I $G("_ cacheNm_ ")>"_ PSL.maxCacheSize_ " S "_ ucn_ "="_ ucn_ "-"_ cacheNm_ " KILL "_ cacheNm)
	//do sr.addCode(" .  S "_ cacheNm_ "=$G("_ cacheNm_ ")+1,"_ ucn_ "=$G("_ ucn_ ")+1")
	do sr.addCode(" .  I $G("_ cacheNm_ ")>"_ PSL.maxCacheSize_ " KILL "_ cacheNm)
	do sr.addCode(" .  S "_ cacheNm_ "=$G("_ cacheNm_ ")+1")
	if useVobj do {
		do sr.addCode(" .  S vOid="_ lbGetRec_ "("_ fpl_ fplAudit_ ")")
		if isArchived do sr.addCode(" .  S "_ lvn1_"-99)="_ vobjHead_ ",-99)")
		do sr.addCode(" .  S "_ lvn1_"-2)="_ vobjHead_ ",-2)")
		if 'nodInit.isNull() do sr.addCode(" .  S "_ lvnInit_ "="_ vobjInit)
	}
	else  do {
		type String fplmod = fpl_ fplAudit
		if fplmod.isNull() set fplmod = ".v2out"
		else  set fplmod = fplmod_ ",.v2out"
		set code = " .  S "_lvnInit_ "="_ lbGetRec_ "("_ fplmod
		if isArchived set code = code_ ",.vArch),"_ lvn1_ "-99)=vArch,"_ lvn1_ "-2)=v2out"
		else  set code = code_ "),"_ lvn1_ "-2)=v2out"
		do sr.addCode(code)
	}

	do sr.addCode(" ;")

	// Add the code that creates the object to be returned
	if useVobj do {
		/* vobj mode: instantiate new record,
		   set mode to whatever was returned by Db.getRecord,
		   set keys. Do not set -152 (not yet supported). */
		do sr.addCode(" E  D")
		do sr.addCode(" . "_ $$cdNewObj^UCCLASS( "vOid", """Record"_ td.table_ """"))
		do sr.addCode(" .  S "_ vobjHead_ ",-2)="_ lvn1_ "-2)")
		if 'pkl.isNull() for k=1:1:pkl.count() do sr.addCode(" .  S "_ vobjHead_ ","_ (-2-k)_ ")=v"_ k)

		if 'nodInit.isNull() do sr.addCode(" .  S "_ vobjInit_ "="_ lvnInit)
	}

	do sr.addCode(" ;")

	// If not Cache.getRecord(,,1), add code that throws %PSL-E-RECNOFL
	// Else add the code that sets v2out when entry found in cache
	if clsNew = 0 {
		do sr.addCode(" I "_ lvn1_"-2)=0 S $ZE=""0,""_$ZPOS_"",%PSL-E-RECNOFL,,"_ td.table_ """,$EC="",U1001,""")
	}
	else  if 'useVobj do sr.addCode(" E  S v2out="_ lvn1_"-2)")

	do sr.addCode(" Q "_$SELECT(useVobj:"vOid",nodInit.isNull():"""""",1:lvnInit))

	/* For MDB tables with recordType > 1, add code to load nodes
	   incrementally. This code will not apply to RDB tables (hard to stay
	   independent of implementation of wide tables), and it does not work
	   for incremental loads of MDB and RDB blob/memo columns.
	   Note that the code below does not call $$getLodCode^UCXDD() */
	if ftype>1 do {
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if td.isRdb do warnGroup^UCGM("INTERNAL","Incremental loads will bypass Cache for : "_cacheNm_".getRecord("_td.table_")") quit

		if isArchived set lvpm(-99) = lvn1_"-99)"

		type String gbl = $$getDataNode^UCXDD( td, "vOid", "vn", 0, lvpm(), pslCln())

		if 'fpl.isNull() set fpl = fpl_ ","

	 	do sr.addCode( label_ "L("_fpl_"vn) ; Incremental Load "_ td.table_ " Cache into "_cacheNm)

	 	if ftype = 10 do {
	 		do sr.addCode( " I '$D("_ lvn1_ "vn)) S "_ lvn1_ "vn)="_ gbl)
	 		do sr.addCode( " Q "_ lvn1_ "vn)")
	 	}
	 	else  do {	// recordType = 11
		 	do sr.addCode( " I $D("_ lvn1_ "vn)) Q "_ lvn1_ "vn)") 
		 	do sr.addCode( " N vData S vData="_ gbl)
		 	do sr.addCode( " I $D("_ lvn_ ") S "_ lvn1_ "vn)=vData")
			do sr.addCode( " Q vData")
	 	}
	}
	quit

	// --------------------------------------------------------------------
delete	// Db.delete(table_name,where_clause,filer_qualifier)
	/* --------------------------------------------------------------------
	For MDB tables and RDB tables, if we need to call the filer, generate
	a subroutine that uses Db.selecteDbSet() and iterates over the matching
	rows to call the filer with %O=3 for each row.

	Otherwise, the MDB case and the RDB case differ.

	INPUTS:
	. actual(1) = tablename (literal)
	. actual(2) = where clause (literal)
	. actual(3) = filer qualifiers (literal)

	NOTES:
	. Even though the MDB code and the RDB code may differ, they behave
		"functionally equivalent".
	. All generated code treats the Db.delete() as a single database
		operation. Runtime.start() and Runtime.commit() will be added
		to make it "atomic". However, no catch-blocks are added, so the
		code relies on the throw/catch logic to do the implied
		Runtime.rollback() in case of a runtime exception.
	. FUTURE - make delete act as fastDelete for MDB if it meets all the
		qualifications for fastDelete.
	*/
	type public PSLTable pslTbl()

	type String table = PSL.actual(1).stripQuotes().upperCase()
	type String where = PSL.actual(2).stripQuotes()
	type String qual  = $$fileQual( "Db.delete", PSL.actual(3))

	type PSLTable td = PSL.cachePSLTable( pslTbl(), table)

	/* Call mapPSLvar to handle case of :record.column as host variable
	   to map to variable prior to call to delete sub-routine */
	if where[":" set where=$$mapPSLvar(where)

	/* See if the where-clause references a single row by primary key */
	type String akey = $$sql2akey( td, where)

	/* If RDB wide table with WHERE-clause, call DelByFiler(), because the
	   WHERE-clause may span multiple tables.
	   NOTE that the call to delByFiler() is based on the assumption that
	   all tables will always have a filer.
	   */
	if td.isRdb,td.recordType>1,'where.isNull() do delByFiler( td, where, akey, qual) quit
	
	/* If there are access rights restrictions on delete or audit logging on
	   delete, need to use the filer. */
	type List rights = td.checkAccessRights(false)
	
	if (rights.contains("delete") or rights.contains("deleteRestrict")) do delByFiler( td, where, akey, qual) quit
	if ({List}(td.getLogging(false))).contains("delete") do delByFiler( td, where, akey, qual) quit

	/* Check not needed.
	   Check filer logic that is reported as being required, but that is not
	   supported by inline PSL code. If the filer qualifier is not literal,
	   then $$getFlrLgc(,,"") will not be called. As a result, $$getFlrLgc()
	   will return the maximum list, which will ensure that a call to the
	   filer will be generated for this occurrence to deal with the dynamic
	   parameters. The only case that a dynamic value will not lead to code
	   that calls the filer is the case where the filer can always be
	   bypassed (no journals, no triggers). */
	type List flrLgc = $$getFlrLgc^UCXDD(td, "DELETE", qual, 1)
	if 'flrLgc.isEmpty() do delByFiler( td, where, akey, qual) quit

	if td.isRdb do delRdb( td, where) quit

	/* MDB delete one or more rows when there is no need to call the
	   filer.
	   If delete-by-accesskey, then replace DO:postCond by KILL:postCond
	   else generate subroutine.
	   To ensure that the DELETE is treated as an atomic operation, the
	   multi-row loop is enclosed by Runtime.start() and Runtime.commit()
	   */
	type PSLIdentifier lvpm()

	if 'akey.isNull()!td.primaryKeys.isNull() do {
		type String dummy = $$akey2apl(td, "", akey, 0, lvpm())
		type Number k

		/* Copy from lvpm( -k-2) to lvpm( k_"*") */
		for k=1:1:td.primaryKeys.count() set lvpm( k_"*") = lvpm( -k-2)

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set PSL.mcode  = $$backup^UCGM( PSL.mcode)
		set PSL.return = $$delMcode( td, lvpm(), PSL.postCond)
	}
	else  do {
		type String comment = "DELETE FROM "_td.table
		if 'where.isNull() set comment = comment_ " WHERE "_ where

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		type String label = $$findSubr^UCGM( "vDbDe", "")	// generate new label

		set PSL.return = label_ "()"

		if PSL.subrouExists( label) quit

		/* Need to generate the subroutine */
		type PSLBuffer buf = PSL.openBuffer( "()", comment)
		type Number k
		type List   pkeys = td.primaryKeys
		type String line = " type Primitive "
		type String getKeys = "set "
		type String setKeys = "set "
		for k=1:1:pkeys.count() do {
			set lvpm( k_"*") = "v"_k
			if k>1 set line = line_ ",", getKeys = getKeys_ ",", setKeys = setKeys_","
			set line = line _"v"_k
			set getKeys = getKeys_ "v"_ k_ "=vRs.getCol("_k_")"
			set setKeys = setKeys_ "vRec."_ pkeys.elementAt(k)_ "=v"_ k
		}
		do buf.add( line)
		do buf.add( " do Runtime.start(""CS"")")

		do buf.add( " type ResultSet vRs=Db.select("""_ pkeys_ ""","""_td.table_""","""_where_""")")
		do buf.add( " while vRs.next() do {")
		do buf.add( "   "_ getKeys)

		do buf.add( "   #ACCEPT CR=18163;DATE=2006-01-09;PGM=FSCW;GROUP=BYPASS")
		do buf.add( "   #BYPASS")
		do buf.add( $$delMcode( td, lvpm(), ""))
		do buf.add( "   #ENDBYPASS")
		do buf.add( " }")
		do buf.add( " do Runtime.commit()")
		do buf.add( " quit")

		do buf.insert( label, "void")
	}
	quit

	// --------------------------------------------------------------------
private delByFiler( PSLTable td,	// table descriptor
		String where,		// WHERE-clause
		String acckey,		// access key (or "" if not applicable)
		PSLExpression qual)	// filer qualifiers ("normalized")
	/* --------------------------------------------------------------------
	MDB and RDB DELETE code when the filer needs to be called is identical

	The generated subroutine will ensure that the entire DELETE is treated
	as a single transaction by including Runtime.start() before the delete,
	and Runtime.commit() after the delete. This is independent of the number
	of rows to delete, because even a single row delete may cascade into
	other deletes or db modifications, that all shall be treated as an
	atomic operation.
	*/
	type String sqlstat = "DELETE FROM "_td.table
	if 'where.isNull() set sqlstat = sqlstat_ " WHERE "_ where
	
	type String auditParam = "0"

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String label = $$findSubr^UCGM( "vDbDe", "")	// generate new label

	set PSL.return = label_ "()"

	if PSL.subrouExists( label) quit

	type PSLBuffer buf = PSL.openBuffer( "()", sqlstat)
	
	/* Add check for audit logging - do not make table specific to avoid
	   mass recompiles. */
	if $$usingAuditLog^SQLAUDIT set auditParam = $$addAuditLogCode("DELETE", buf, td, sqlstat, where)

	do buf.add(" do Runtime.start(""CS"")")
	if acckey.isNull() do {
		do buf.add(" type DbSet vDs=Db.selectDbSet("""_ td.table_ ""","_ where.addQuotes() _")")
		do buf.add(" while vDs.next() do {")
		do buf.add("   type Record"_ td.table_ " vRec = vDs.getRecord("""_td.table_""")")
		do buf.add("   do vRec.setMode(3)")
		if 'td.isRdb do {
		
			do addMSaveBypass(buf, td.table, "vRec", qual, auditParam)
		}
		else  do buf.add("   do vRec.save("_ qual_ ")")
		do buf.add(" }")
	}
	else  do {
		/* Single Row.
		   Call filer only if the row exists. Note that this code
		   executes under TP and cannot QUIT if "not found". It has to
		   go through the commit even if there is nothing to commit
		   */
		   
		type String code
		
		do buf.add(" type Record"_ td.table_ " vRec = Db.getRecord("""_td.table_""","_acckey_",1)")
		
		set code = " if vRec.getMode()=1 do vRec.setMode(3)"
		
		if 'td.isRdb do {
		
			do buf.add(code_ " do {")
			do addMSaveBypass(buf, td.table, "vRec", qual, auditParam)
			do buf.add("  }")
		}
			
		else  do buf.add(code_ ",vRec.save("_ qual_ ")")
	}
	do buf.add(" do Runtime.commit()")
	do buf.add(" quit")
	do buf.insert( label, "void")

	quit
	
	// --------------------------------------------------------------------
private addMSaveBypass(PSLBuffer buf,		// Buffer
		String tableName,		// Table name
		String objRef,			// Object reference
		PSLExpression qual,		// Save qualifiers
		String auditParam)		// Audit parameter value
	/* --------------------------------------------------------------------
	Support function that inserts BYPASS code for call to record save on
	MDB.  This is necessary because MDB version has another parameter
	related to audit logging that is not exposed as a save method
	parameter.
	
	Used by delByFiler and update
	*/
	set:qual.isNull() qual=""""""

	do buf.add("   #ACCEPT Date=07/09/2008; Pgm=RussellDS; CR=30801; Group=BYPASS")
	do buf.add("   #BYPASS")
	do buf.add("   D vSave^Record"_ tableName_ "("_ objRef_ ","_ qual_","_ auditParam_ ")")
	do buf.add("   #ENDBYPASS")
	
	quit

	// --------------------------------------------------------------------
private delMcode( PSLTable td,		// table descriptor
		String lvpm(),		// keys
		String mpc)		// M_postcond (incl ":", or "")
	/* --------------------------------------------------------------------
	Support function that returns the KILL or ZWITHDRAW statement for a
	singe row MDB delete.
	ZWITHDRAW will be used when the row is guaranteed to reside in a single
	global node (recordType = 1 and no blobs or memos)
	Otherwise KILL will be used.
	*/
	type String code = $$getGvn^UCXDD( td, "", lvpm())

	if td.isOneNode() quit " ZWI"_mpc_" "_code

	quit " K"_mpc_" "_ code


	// ---------------------------------------------------------------------
private delRdb( PSLTable td,		// table descriptor
		String where)		// where clause (*2)
	/* ---------------------------------------------------------------------
	SQL DELETE statement for RDB table, when we have parameters that would
	make no reason to call the filer.
	
	If in addition we don't have a WHERE clause, then we can use
	TRUNCATE or a direct delete call to the RDB, since we're deleting the
	entire table. The use of TRUNCATE is further limited by constraints on
	the table (e.g. foreign key). Until all these conditions are known,
	and used by the compiler, the doTrunct-flag is only used to indicate
	the absence of a WHERE clause, but the generated code will never use
	the TRUNCATE statement.

	If we do have a WHERE clause then use a direct delete call to the RDB.
	(Will not do this for wide tables since WHERE clause may involve more
	than just keys, and they do have a filer anyway).

	Note that because TRUNCATE does it's own commit automatically, we don't
	want to use it if already under TP at runtime.

	ARGUMENTS:
	(*2) where = WHERE-clause
		This function relies on the fact that the caller has already
		transformed the clause into a SQL compliant expression (e.g.
		by calling $$mapPSLvar())

	NOTES:
	. Because there will be no call to a filer, there is no need to deal
		with filerqualifiers.
	. This subroutine unconditionally codes a DELETE table WHERE where
		Since this cannot be applied to wide table deletes, the caller
		must handle that case.
		Because DELETE table or TRUNCATE table can be applied to wide
		tables, this is the only case that is acceptable.
	*/
	type String sqlcmt = "DELETE FROM "_td.table		// SQL delete for comment uses DQ name

	if 'where.isNull() set sqlcmt=sqlcmt_" WHERE "_where

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String label = $$findSubr^UCGM( "vDbDe", "")	// generate new label

	set PSL.return = label_ "()"

	if PSL.subrouExists( label) quit

	/* Need to generate the subroutine */
	type PSLBuffer buf = PSL.openBuffer( "()", sqlcmt)

	// NOTE: doTrunct is only used to indicate "no WHERE clause" (see intro)
	type static UCRUNTIM
	type Boolean doTrunct = ( where.isNull())

	/* Both code variations need to include calls to simulate
	   Runtime.start() and Runtime.commit() if needed.

	   NOTE: IF we ever decide to use TRUNCATE, then this "leading"
	   code needs to move into delRcode(), because the TSTART must
	   be postponed until the runtime code decided between TRUNCATE
	   and DELETE.
	   */
	do buf.add( "#ACCEPT CR=35741;DATE=2008-09-29;PGM=FSCW;GROUP=BYPASS")
	do buf.add( "#BYPASS")
	do buf.add( "N vEr,vRm")
	do buf.add( "N vTp S vTp=($TL=0) TS:vTp (vobj):transactionid=""CS"" D:vTp "_ UCRUNTIM.callStart())

	if doTrunct do {			// Use truncate, if possible
		type Number i
		type List tables = td.internalNames

		// do buf.add( "I 0,$TLEVEL=0 D  Q  ; TRUNCATE requires $TLEVEL=0")
		// do buf.add( ". ; Note - this code will not yet execute")
		// for i=1:1:tables.count() do buf.add( "."_$select(i>1:" I vEr'<0",1:"")_" S vEr=$$EXECUTE^%DBAPI(0,""TRUNCATE TABLE "_tables.elementAt(i)_""","""","""",.vRm)")
		// do buf.add( ". I vEr<0 S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLDELFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)),$EC="",U1001,""")
		// do buf.add( ". ; Note - no commit here, since if $Tlevel=0, we do truncate")

		for i=1:1:tables.count() do buf.add( $select(i>1:"I vEr'<0",1:"")_" S vEr=$$EXECUTE^%DBAPI(0,""DELETE FROM "_tables.elementAt(i)_""","""","""",.vRm)")

		do buf.add( "I vEr<0 S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLDELFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)),$EC="",U1001,""")
	}
	else  do {
		type String hvMap()
		type String vListCd
		type String sql = "DELETE FROM "_ td.internalNames
		type Integer delim = td.columnDelimiter

		if 'where.isNull() do {
			set where    = $$where^UCDBR( td.table, where, hvMap(,))
			set vListCd = $$RsMsXV^UCDBRT( hvMap(,), .where, 0, delim)
			set sql = sql_ " WHERE "_where
		}
		else  set vListCd = """"""

		do buf.add(" S vEr=$$EXECUTE^%DBAPI(0,"""_ sql_ """,$C("_ delim_ "),"_ vListCd_ ",.vRm)")
  		do buf.add(" I vEr<0 S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLDELFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)),$EC="",U1001,""")
	}

	// common exit
	do buf.add( "D:vTp "_ UCRUNTIM.callCommitCS())
	do buf.add( "#ENDBYPASS")
	do buf.add( "quit")

	do buf.insert( label, "void")
	quit

	// ---------------------------------------------------------------------
fastDel	// void; method Db.fastDelete
	/* ---------------------------------------------------------------------
	Db.fastDelete() is considered a special case of db.delete(), just like
	Record.bypassSave() is considered a special case of Record.save().
	The applicable filerqualifiers are:
		/NOJOURNAL/NOTRIGBEF/NOTRIGAFT

	As off CR18163 Db.fastDelete() for an MDB table and for a RDB table
	behave identical. In particular, referential integrity will be observed,
	and index tables will be maintained.

	NOTES:
	. Before CR18163, Db.fastDelete() of an MDB table would result in an
		M kill command regardless of the presence of indexes or foreign
		keys. This could result in an inconsistent database if
		surrounding code did not explicitly re-establish the referential
		integrity (by cascading the delete) and delete all indexes.
		Because that kind of behavior cannot be ported to SQL compliant
		RDB environments, the MDB version of fastDelete shall obey the
		same rules that apply to the RDB version.
	*/
	type public PSLTable  pslTbl()

	type Boolean checkDelete = false
	type Boolean useDelete = false
	type List allkeys, delkeys
	type String akeys, gbl, tok
	type Number i
	type String map()
	type PSLTable td = PSL.cachePSLTable( pslTbl(), PSL.actual(1).stripQuotes())

	set akeys = $$akey2apl( td, "", PSL.actual(2), -1, map())

	/* Copy map( -2-key) to map( key_"*" for call to $$getGvn^UCXDD.
	   Remove trailing keys that are missing. Note that missing intermediate
	   keys will end up in map() as "", so will show up as missing subscript
	   in the global. */
	for i = 1:1:td.primaryKeys.count() set map( i_"*") = map( -2-i).get()
	for i = td.primaryKeys.count():-1:1 quit:'map( i_"*").isNull()  kill map(i_"*")
	set gbl = $$getGvn^UCXDD( td, "", map())

	if gbl["()" set gbl = gbl.piece( "()")

	/* If there were literal keys (that are now missing), or,
	   if there is access rights checking necessary, or,
	   if table is RDB, or,
	   if access rights rules indicate, do regular delete */
	#ACCEPT DATE=06/18/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
	set delkeys = $$TOKEN^%ZS(gbl.piece("(", 2, 999), .tok)
	#ACCEPT DATE=06/18/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
	set allkeys = $$TOKEN^%ZS(td.global.piece("(", 2, 999), .tok)
	for i = delkeys.count()+1:1:allkeys.count() if allkeys.elementAt(i).isLiteral() or allkeys.elementAt(i).beginsWith(0.char()) set useDelete = true quit
	
	// If DBTBL1.QID1 is not null, need to use regular delete
	if '$$RsMsQID1^UCDBRT(td.table).isNull() set useDelete = true
	
	if 'useDelete, ((gbl["(,") or (gbl[",,")) set useDelete = true
	
	if 'useDelete do {
	
		/* Rules related to access rights (if we're already using
		   regular delete, we don't need to worry about this here):
		   
		    - If there is a WHERE clause, SELECT rights come
		      into play, so must use regular delete if either
		      SELECT or DELETE rights.
	
		    - If no WHERE clause (deleting entire table) OK if no
		      delete or deleteRestrict rights ; add check if
		      delete rights; do regular delete (row by row) if
		      deleteRestrict.  Delete of entire table does not
		      require SELECT rights
		      
		   If audit logging is set for delete, need to use delete,
		   not fast delete.
		*/
	
		type List rights = td.checkAccessRights(false)
		
		// No WHERE clause
		if PSL.actual(2).isNull() do {
			
			if rights.contains("delete") set checkDelete = true
			else  if rights.contains("deleteRestrict") set useDelete = true
		}
	
		// WHERE clause, and DELETE or SELECT rights
		else  if (rights.contains("delete") or rights.contains("deleteRestrict") or rights.contains("select") or rights.contains("selectRestrict")) set useDelete = true
		
		// Check audit logging
		if ({List}(td.getLogging(false))).contains("delete") set useDelete = true
	}
	
	if (useDelete or td.isRdb) do {
		set PSL.actual(2) = $$akey2sql( PSL.actual(2).stripQuotes(), td.primaryKeys)
		set PSL.actual(3) = """/NOJOURNAL/NOTRIGAFT/NOTRIGBEF"""
		do delete
	}
	else  do {
	
		/* Strip missing subscripts at the end */
		if gbl [ ",)" set gbl = gbl.piece( ",)")_ ")"
	
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set PSL.mcode = $$backup^UCGM( PSL.mcode)
		if checkDelete set PSL.return = " S:'$$deleteOK^Record"_ td.table_ "("""",%UCLS) $ZE=""0,""_$ZPOS_"",%PSL-E-ACCESS,""_$TR($$^MSG(6754,"""_ td.table_ """),$C(10,44),$C(32,126)),$EC="",U1001,"" "
		else  set PSL.return = " "
		set PSL.return = PSL.return_ "K"_ PSL.postCond_ " "_ gbl
	}
	quit

	// ---------------------------------------------------------------------
fileQual( String method,		// calling method (*1)
		PSLExpression qualarg)	// applicable qualifiers (*2)
	/* ---------------------------------------------------------------------
	Filer qualifier passing logic.
	Determine the filer qualifiers to use when calling a filer routine

	ARGUMENTS:
	(*1) method = calling method
		This value is not interpreted here, but the value will be
		compared to pslPrsr.getSetting("DEBUG","FILEQUAL") to determine
		if it needs to force /VALDD/VALRI for this call.
	(*2) qualarg = qualifier argument as modified by pass 1 of the PSL
		compiler. So a literal value will have quotes, but the value
		may contain a simple expression such as a variable name or even
		a complete expression with binary operators or function calls.

	INPUTS:
	. pslPrsr.getSetting("DEBUG","FILEQUAL")
		This entry will either contain "*" or it will contain the name
		of a single method. If it contains "*", then the qualifiers
		/VALDD/VALRI will be APPENDED to qualarg for all methods. If it
		has a different value, then these qualifiers will only be
		appended if the value passed as the method parameter matches the
		value of this setting.

	OUTPUT:
	. $$ = qualifier string as it shall be inserted in the code that calls
		the filer.
		- If qualarg.isLiteral(), then $$setPar^UCUTLN("",modQualarg)
			will have been called to deal with duplicates and
			conflicts.
		- Else if pslPrsr() settings force compile time modifications,
			then the return value will be a call to
			$$setPar^UCUTILN() that includes qualarg and the forced
			settings.
		In either case, the returned value will have been "normalized"
		by the time the value ends up in the filer.

	NOTES:
	. Looking at pslPrsr("SQLPARS") for specific standard values was a left-
		over from p01_rel03_01. method^UCGM would fill this node from
		OBJECTMET.QUALIFIERS, but this column has meanwhile been
		obsoleted. As the current version of the compiler is no longer
		backward compatible with p01 versions of the compiler, there is
		no reason to keep looking at this value.
	. The batch compiler DBSBCH has provisions that will result in the
		setting of pslPrsr.cs("DEBUG","FILEQUAL").
	. The value of the method parameter is hard-coded in the callers:
		delete^UCDB passes "Db.delete"
		insert^UCDB and update^UCDB pass "Db.update"
		save^UCRECORD passes "Record.save"
	. The history of OBJECTMET.QUALIFIERS has not been documented, so it is
		unknown what the original intend was, as is the reason to
		obsolete. Presumably OBJECTMET was not the best place to put
		default qualifiers, given that only very few methods use them.
		On the other hand, the idea of environment specific default
		qualifiers makes sense. If this is to be (re)introduced, it will
		most likely be through the UCOPTS.ini file.	
	*/
	type public PSLParser pslPrsr

	type String par = qualarg

	// standardize if literal
	if par.isLiteral() set par = $$setPar^UCUTILN( "", par.stripQuotes().upperCase()).addQuotes()

	/* ================ commented out - begin ================
	   FSCW, CR27800: The current version of UCDB is no longer backward
	   compatible with p01_rel03_0 (or any p01 version of UCGM), so it does
	   not make sense to keep this code, even more so because it does not
	   fit into the current PSLParser.xxxSetting() methodology.

	// PREPEND command("SQLPARS") defaults (backward comp. w. p01_rel03_01)
	if 'pslPrsr("SQLPARS").get().isNull() set par = "$$setPar^UCUTILN("""_ pslPrsr("SQLPARS")_ """,par)"
	================ commented out - end ================ */

	// APPEND debug settings if applicable
	type String  debug = pslPrsr.getSetting("DEBUG","FILEQUAL","")

	if debug = "*" ! (debug = method) set par = "$$setPar^UCUTILN("_ par_ ",""/VALDD/VALRI"")"

	set par = "$$initPar^UCUTILN("_ par_ ")"
	#ACCEPT CR=22719; DATE=2006-06-23; PGM=FSCW; GROUP=XECUTE
	if qualarg.isLiteral()!qualarg.isNull() xecute "set par=$$QADD^%ZS("_ par_ ")"

	quit par

	// ---------------------------------------------------------------------
get1Row // void; method Db.getOneRow
        /* ---------------------------------------------------------------------
	Syntax: Db.getOneRow(select_list,Table_name,Access_keys,delimiter)

	. select_list	A list of column names
	. table_name	DQ table name (support single table only)
	. access_keys	Primary access keys
	. delimiter	Field delimiter (not required, default to Tab)

	Example:
		S data=Db.getOneRow("TJD","CUVAR")
		S data=Db.getOneRow("CID,BAL,LNM,BOO,IRN","DEP","XCID")
		S data=Db.getOneRow("ACN,TAXID,AGE","CIF","XACN")
		S data=Db.getOneRow("TAMT","HIST","xcid,tseq",124)

	NOTES:
	. For RDB it is probably more efficient to translate this into a SQL
		SELECT that retrieves the row, especially if the number of
		requested columns is small compared to the total number of
		columns of the underlying RDB table.
	*/
	type public PSLTable pslTbl()

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
        do WARNDEP^UCGM(2.6, 0, "Db.getOneRow")

	type String list  = PSL.actual(1).stripQuotes()	// column list
	type String table = PSL.actual(2).stripQuotes() // table name
	type String keys  = PSL.actual(3).stripQuotes()	// access keys
	type String delim = $select(PSL.actual(4).get().translate( " ", ""):PSL.actual(4),1:9)	// Delimiter
	type PSLTable td = PSL.cachePSLTable( pslTbl(), table, 0)
	type PSLBuffer buf
	type String cmt = "Db.GetOneRow( "_ PSL.actual(1)_ ", "_ PSL.actual(2)_ ", "_ PSL.actual(3)_ ", "_ delim_ ")"

	/* Strip keyword distinct if present */
	if list.piece( " ") = "DISTINCT" set list = list.piece( "DISTINCT ",2)
	set list = list.upperCase()

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String label = $$findSubr^UCGM("vDbRow","")	// Get next label

	if td.isRdb {
		type Number k
		type List pkl = td.primaryKeys
		type String fpl = "(", whr = ""

		for k = 1:1:pkl.count() {
			if k>1 set fpl = fpl_",", whr = whr_ " AND "
			set fpl = fpl_ " String v"_ k
			set whr = whr_ pkl.elementAt(k)_ "=:V"_ k
		}

		// create SQL SELECT statement by calling UCDBRT
		type String map(,), sql = $$RsDyRT^UCDBRT( list, table, whr, "", "", "", map(,))
		type String hvl = $$RsMsXV^UCDBRT( map(,),.sql, 0, delim).translate("V","v")
		type String code = "type String vData,vRm"
		type String split()

		set buf = PSL.openBuffer( fpl_ ")", cmt)
		if ({PSLExpression}sql).fitsLineLength( 80) {
			set sql = sql.addQuotes()
		}
		else  {
			set code = code_",vSql"
			do splitCode^UCGMC( sql, 40, "", split())
			set sql = "vSql"
		}

		do buf.add( code)	// add declaration
		set k = split("").order(-1)
		if k>1 {
			do buf.add( " set vSql = "_split(1).addQuotes())
			for k = 2:1:k do buf.add( " set vSql = vSql_ "_split(1).addQuotes())
		}
		do buf.add( "type Number vEr = $$SELECT^%DBAPI(0,"_ sql_ ","_ delim_ ".char(),"_ hvl_ ",.vData,.vRM)")
		do buf.add( "quit vData")
		set PSL.return = "$$"_ label_ "("_ $$akey2apl( td, "", keys, 0)_ ")"
	}
	else  do {
		set buf = PSL.openBuffer( "()", cmt)

		do buf.add( "type Record"_table _" vRec = Db.getRecord("""_table_""","""_keys_""",1)")

		/* Create PSL code that concatenates 8 columns per line
		   If the total number of columns is less than 9, this will be
		   quit-argument as well. Otherwise, for the 9th column insert
		   code that declares + assigns the value to vRow. For each
		   following boundary generate set vRow=vRow_ code.
		   At the end of the loop expr will contain the complete value
		   to be returned.
		   NB: All code is generated WITHOUT additional whitespace to
		   ensure that the value of expr does not start with a blank,
		   which would turn the QUIT into an argumentless QUIT ...
		   */
		type Number I
		type String expr = "", prop
		for I=1:1:list.length(",") {
			if I>1 {
				if I#8=1 {
					if I=9 {
						do buf.add( "type String vRow="_ expr)
					}
					else    do buf.add( "set vRow="_ expr)
					set expr = "vRow"
				}
				set expr = expr_ "_"_ delim_ ".char()_"
			}
			set prop = list.piece( ",", I)
			if prop = "" quit
			//if prop'["." set prop = "vRec."_ prop.lowerCase()
			set expr = expr_ "vRec."_ prop.lowerCase()
		}

		do buf.add("quit "_ expr)
		set PSL.return = "$$"_ label_ "()"
	}
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do autoERRM^UCGM()
	do buf.insert( label, "String")
	quit

	// ---------------------------------------------------------------------
getRecCN( String df)	// value of ClassNew parameter
	/* ---------------------------------------------------------------------
	Helper function to provide a consistent value for the ClassNew parameter
	on Db.getRecord(,,df).
	- quotes are stripped
	- an empty value is translated into zero
	- a non-empty value is translated into one
	*/
	set df = df.stripQuotes()
	quit ''df

	// ---------------------------------------------------------------------
getRecord	// method Db.getRecord; returns RecordTABLE
	/* ---------------------------------------------------------------------
	INPUTS:
	. PSL.actual(1) = table name (literal String)
	. PSL.actual(2) = access key expression (literal String)
	. PSL.actual(3) = record not found mode
	
	. public Number ptr
		If the value of this variable is greater than zero, parsing of
		the expression is not yet complete, and we are dealing with a
		"nested property reference": Db.getRecord(t,k,m).column
	*/

	type public Number    ptr	// BAD USAGE !!

	if ptr do getRecPr quit	// 7813 - Handle nested property syntax
	
	do getRec(false)
	
	quit
	
	// ---------------------------------------------------------------------
getRec(Boolean bFromDbSet)	// Building DbSet.getRecord indicator
	/* ---------------------------------------------------------------------
	Db.getReoord and DbSet.getRecord builder; returns RecordTABLE
	
	Used by getRecord^UCDB and getRecord^UCDBSET
	
	INPUTS:
	. PSL.actual(1) = table name (literal String)
	. PSL.actual(2) = access key expression (literal String)
	. PSL.actual(3) = record not found mode
	
	. PSLpslTbl()
		The table descriptor cache
	. PSL.var
		The target variable to receive the new RecordTABLE instance
		Note that objectName="Db", and cannot be used.
		Note also that this implies that "nested calls" must allocate
		and supply a scratch variable to use as assignment target.
	*/
	type static PSLClass
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()	
	
	type PSLTable td = PSL.cachePSLTable( pslTbl(), PSL.actual(1).stripQuotes())
	type Boolean  deflt = $$getRecCN( PSL.actual(3))

	set PSL.return = $$akey2apl( td, PSL.var, PSL.actual(2), 0)
	
	if 'td.isRdb do {
		
		// Null if CUVAR-like with no keys
		if 'PSL.return.isNull() set PSL.return = PSL.return_ ","_ bFromDbSet
		else  set PSL.return = bFromDbSet
	}

	/* FSCW CR18163: Original code used deflt=-1 to kill vobj() on RECNOFL,
	   and quit "" without throwing an exception. Any occurrence of this
	   undocumented behavior is now an error (using the original actual(3)
	   because deflt is now 0 or 1): */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if '((+PSL.actual(3)=0) or (+PSL.actual(3)=1)) do ERROR^UCGM("Db.getRecord( "_ PSL.actual(1)_ ", "_ PSL.actual(2)_ ", "_ PSL.actual(3)_ ")")

	set PSL.class = PSLClass.RECORDCLASS_ td.table
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String scope = $$getScope^UCGM( PSL.var, PSL.varLevel)

	if scope="LITERAL" do LitInst( PSL.var, td.table, PSL.return, deflt, PSL.level) quit

	/* ================================
	   The code in this block is questionable for more than one reason:
	   1) UCGM will modify the scope of a FORMAL parameter to "vosc"
		This will occur BEFORE this subroutine is called, so the
		condition will never occur.
	   2) If this code were to be inserted, it may end up at an
		incorrect M line level: The line is inserted AFTER the
		line that contains the instantiation, but the line
		following the instantiation will have a different line
		level if a DO { occurs to the left of the instantiation.
		Furthermore, the instantiation itself may be in
		conditional code, so there is no guarantee that the
		execution of the inserted line will be appropriate
	   Given the above, the code block is commented out.
	if scope="FORMAL",td.recordType>1 do {			// Runtime test
		type String code = "$G("_ var_ ")"
		if PSL.mcode[("'"_code) quit
  		set code="I "_code_" S $ZE=""0,""_$ZPOS_"",%PSL-E-RECEXISTS"",$EC="",U1001,"""
		do ADD^UCGM($$initLine^UCGM(.level)_code,msrc+.001)
		if $G(pslPrsr("WARN","RECEXISTS")) do WARN^UCGM("Possible runtime error RECEXISTS")
	}
	================================ */
	
	/* Turn on audit flag if table has updateRestrict access rights.
	   Because updateRestrict rights checking checks the old value,
	   it must be tracked.  */
	#ACCEPT CR=30801;Date=04-06-2008;PGM=RussellDS;Group=DEPRECATED; use of type()
	type public String type(,)
	
	if td.checkAccessRights(false).contains("updateRestrict") set type(PSL.level, PSL.var).piece( 9.char(), 12) = 1
	
	// Get appropriate method in RecordTABLE
	type String comment = PSL.oLvn_ "()=Db.getRecord("_ td.table_ ",,"_ deflt_ ")"
	set PSL.return = $$getRecSr( td, false, deflt)_ "("_ PSL.return_ ")"
	
	quit
	

	// ---------------------------------------------------------------------
private getRecPr	// Db.getRecord has properties
	/* ---------------------------------------------------------------------
	This subroutine deals with contraucts such as:

	type Number mm = Db.getRecord("CIF", "ACN=":ACN").dob.monthOfYear() + 1

	Because $$nextExpr() will not treat the dot as a separator, the entire
	code between the first equal-sign and the plus-operator will be treated
	as a single expratom (inside $$valExpr()). This is then decomposed by
	$$valObj(), which will first see the method, and call $$method() to
	obtain the translation (of the entire code sequence). It in turn will
	call getRecord^UCDB, which calls getRecPr.

	At the time of the call, the entire expratom is available in the lvn
	PSL.atom.

	NOTES:
	. This is VERY tricky code !!!!
		It uses the lvn atom, which is assigned by $$valExpr^UCGM before
		it calls $$valObj(), which calls $$valObj^UCGM(), which calls
		$$method^UCGM(), which calls getRecord^UCDB which calls this
		subroutine ...
		If any of these levels NEWs atom, this subroutine will generate
		incorrect code.
	. lvn ptr must be set to zero at the end of the subroutine, because it
		is needed to construct the quit-argument.
	. This subroutine will use the key variables as public variables,
		without declaring them public. This relies on the suppression of
		warnings by PSLBuffer.insert().
	*/
	type static PSLClass
	type public String atom
	type public Number ptr

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte	
	if PSL.fset do ERROR^UCGM("Expression is not updateable") quit

	type String table = PSL.actual(1).stripQuotes()

	/* Append code to PSL source and create a unique label */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String var=$$nxtSym^UCGM
	type String label="vDbGr"_ var.piece("vo",2)	// Create unique label

	/* Always need to generate the subroutine */
	type PSLBuffer buf = PSL.openBuffer( "()", "nested Db.getRecord() using "_ var)
	do buf.add(" type "_ PSLClass.RECORDCLASS_ table_ " "_ var_ "=Db.getRecord("_ PSL.actual(1)_ ","_ PSL.actual(2)_ ","_ PSL.actual(3)_ ")")
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do buf.add(" quit "_ var_ $$UNTOK^%ZS(atom.extract( ptr + 1, atom.length()), PSL.tok))

	do buf.insert( label, "String")

	set PSL.return = label_ "()"
	set PSL.class  = "String"
	set ptr = 0	// PUBLIC Number ptr

	quit
	
	
	// ---------------------------------------------------------------------
getRecSr( PSLTable td,	// table descriptor
		Boolean useOpt,		// use optimization call
		Boolean clsNew)		// value of ClassNew parameter (0, 1)
	/* ---------------------------------------------------------------------
	Return appropriate Db.getRecord call, based on parameters.  Options are:
	
	  RecordTABLE.vRCgetRecord0    - if clsNew = false and useOpt = false
	  RecordTABLE.vRCgetRecord1    - if clsNew = true and useOpt = false
	  RecordTABLE.vRCgetRecord0Opt - if clsNew = false and useOpt = true
	  RecordTABLE.vRCgetRecord1Opt - if clsNew = true and useOpt = true
	*/
	
	// M-code generation only at this point.  Will need reconsideration for Java
	
	type String label = "vRCgetRecord"_ clsNew
	
	if useOpt set label = label_ "Opt"
	
	quit "$$"_ label_ "^Record"_ td.table
	

	// ---------------------------------------------------------------------
getRecSrCode( PSLTable td,		// table descriptor
		String recInst)		// record variable
	/* ---------------------------------------------------------------------
	Function that returns the complete M (or eventually Java) code to form 
	the RecordTABLE.vRCgetRecord methods (see getRecSr) for this table.
	The four methods generated implement the various Db.getRecord method
	options based on the combination of ClassNew and optimization.
	
	Generated code will consider whether there are SELECT access rights
	involved in this table and generate the appropriate checking and
	error handling (throw error).  Because the various access rights
	check methods are instance methods, and because the code being
	generated here is creating the record, the calls to the access
	rights checking are done under the #BYPASS, since there is not
	yet knowledge at a PSL level of the new record (i.e., "this"
	cannot be used).
	
	Generated code will also consider whether there is SELECT audit
	logging and generate the appropriate checking and audit log call.
	
	This function is called by PSLRecordBuilder when construction
	RecordTABLE code.
	
	Return value is a string, with individual lines of code separated by
	tabs.  It is up to the caller to split this to build the method.  All four
	methods will be included in the string.
	
	The generated methods will have the following signatures (assuming a
	table with 2 key columns), based on the getRecord classNew parameter:
	
		- vRCgetRecord0(v1,v2)
		- vRCgetRecord1(v1,v2)
	
	  For optimized methods vRCgetRecord0Opt and vRCgetRecord1Opt, the
	  signature will vary based on whether or not a table is archivable,
	  and whether or not the table is an RDB table, as follows:
	  
	  	- vRCgetRecordnOpt(v1,v2,v2out)
	  	- vRCgetRecordnOpt(v1,v2,v2out,v99out)
	  	- vRCgetRecordnOpt(v1,v2,v2out,v152out,use152)
	  	- vRCgetRecordnOpt(v1,v2,v2out,v99out,v152out,vuse152)
	
	  For each of the above signatures, if MDB, the parameter vfromDBset,
	  for use by audit logging, will follow the keys.
	
	Usage of the optimized forms will need to consider all the possible
	purpose nodes for the table, even if not using all of them.  The
	Boolean vuse152 will indicate if the caller cares about -152 in order
	to avoid setting it in vRCgetRecordnOpt if not necessary.

	Because the signatures will be different, the caller must be aware of
	the signature that is associated with the call to the supplied label.

	ARGUMENTS:
	(*2) recInst = record variable or declaration position
		If a record variable is supplied, the generated code will use
		vobj(recInst), and all assignments to negative nodes (key, -1,
		-2, -150, -152) will be included.
		If a declaration position is supplied, the generated code will
		assume the voxn mode. In this case, the code returned by
		getRecCode() will always be included. Assignements to
		variables that represent key columns will never be made because
		the subroutine may be called from different places that use
		different key pupose variables. Assignments to the special
		purpose node -2 will always be included; assignment to the
		special purpose node -99 will only be included for archivable
		tables; and to special purpose node -152 only if an RDB table.
		.
		The values will be passes out of the subroutine using additional
		formal parameters.
	*/
	
	/* At the present this is M-code generation only and will need reconsideration
	   for Java.  The optimization aspects will not be Java issues and therefore
	   those methods will not exist. */
	
	type literal String TAB = 9.char()
	
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()
	
	type PSLColumn cd
	type PSLExpression init161 = ""
	type PSLExpression set161 = ""

	type Boolean auditSelect = false
	type Boolean useAudit = $$usingAuditLog^SQLAUDIT
	type String  archref
	type String  archTbl = td.getArchiveTable()
	type String  code
	type List    accessChecks = td.checkAccessRights(false)
	type List    fkeys = td.primaryKeys
	type List    fpl = ""			// formal parameter list (no optimize)
	type List    fplOpt = ""		// formal parameter list (optimize)
	type List    archParams = ""		// parameters for archive
	type Number  i, j			// iterators
	type Number  maxOpt
	type String  auditCode = " if "
	type String  loadOpt(), loadNoOpt()	// load code by getRecCode()
	type String  loadNod = ""		// node corresponding to the lvn
	type String  lvpmNoOpt(), lvpmOpt()
	type String  methCode()			// method code for each of the methods
	type String  optRef = td.table.lowerCase()
	type String  recClass = "Record"_ td.table
	type String  retVal()
	type Number  selectChk = 0		// 1 = select, 2 = selectRestrict
	type String  selErrCode
	
	if accessChecks.contains("select") set selectChk = 1
	else  if accessChecks.contains("selectRestrict") set selectChk = 2
	
	if useAudit set auditSelect = ({List}(td.getLogging(false)).contains("select"))
	
	if auditSelect do {
		
		type Boolean isPositiveList
		type List userclasses
		
		if $$shouldLog^SQLAUDIT(td.table, "SELECT", "log", .userclasses, .isPositiveList) do {
			
			type String uclsCheck
			
			if (userclasses.count() = 0) set uclsCheck = ""		// No check necessary, do them all
			else  if (userclasses.count() = 1) set uclsCheck = "(%UserClass = "_userclasses.addQuotes()_ ")"
			else  set uclsCheck = "({List}"_ userclasses.addQuotes()_ ").contains(%UserClass)"
	
			/* Positive list will always have elements.  Negative list may
	 		   be empty, in which case there is not checking as it means
	 		   that PUBLIC is being logged and there are no exceptions. */
			
			if 'isPositiveList, 'uclsCheck.isNull() set uclsCheck = "'"_ uclsCheck
			
			if 'uclsCheck.isNull() set auditCode = auditCode_ uclsCheck_ ", "
			
			set auditCode = auditCode _ "'vfromDbSet set vauditLogSeq = $$auditLog^SQLAUDIT(""SELECT"", """_ td.table_ """, ""SELECT * FROM "_ td.table
		}
	}

	if 'fkeys.isNull() do {
	
		if auditSelect set auditCode = auditCode_ " WHERE "
	
		for i=1:1:fkeys.count() do {
			set lvpmNoOpt( i_ "*") = "v"_ i
			set lvpmOpt(i_ "*") = "v"_ i
			set fpl = fpl.add( "String v"_ i)
			set fplOpt = fplOpt.add( "String v"_ i)
			set archParams = archParams.add("v"_ i)
			set lvpmNoOpt( -2-i) = PSL.oLvn_ "("_ recInst_ ","_ (-2-i)_ ")"
			
			if auditSelect do {
				
				type String column = fkeys.elementAt(i)
				
				type PSLColumn cd = PSL.getPSLColumn(td.table, column)
				
				if (i > 1) set auditCode = auditCode_ "_"" AND "
				set auditCode = auditCode_ column_ "="
				if '({List}("T,U,F")).contains(cd.dataType) set auditCode = auditCode_ """_ v"_ i
				else  set auditCode = auditCode_ "'""_ v"_ i_ "_""'"""
			}
		}
		
		if auditSelect set auditCode = auditCode_", """")"
	}
	
	// In case using audit logging, add fromDbSet parameter to formal list
	if 'td.isRdb set fpl = fpl.add( "Boolean vfromDbSet"), fplOpt = fplOpt.add( "Boolean vfromDbSet")

	/* lvpm(-1) is needed for parent/child recordMode updates */
	set lvpmNoOpt(-1) = PSL.oLvn_ "("_ recInst_ ",-1)"
	set lvpmNoOpt(-2) = PSL.oLvn_ "("_ recInst_ ",-2)"

	set lvpmOpt(-2) = "v2out", fplOpt = fplOpt.add( "Number "_ lvpmOpt(-2))
	
	if 'archTbl.isNull()  do {
	
		set lvpmNoOpt(-99) = PSL.oLvn_ "("_ recInst_ ",-99)"
		set lvpmOpt(-99) = "v99out", fplOpt = fplOpt.add( "String "_ lvpmOpt(-99))
	}
	if td.isRdb do {
		
		set lvpmNoOpt(-152) = PSL.oLvn_ "("_ recInst_ ",-152)"
		set lvpmOpt(-152) = "v152out", fplOpt = fplOpt.add( "String "_ lvpmOpt(-152)), fplOpt = fplOpt.add("Boolean vuse152")
	}
	
	/* Build the code for each of the methods in methCode(0-3).  At
	   the end, concatenate to create single return value.
	   
	   Non-optimized methods will return a RecordTABLE class.
	   Optimized methods will return a String.
	
	   methCode indexes - 	0 = clsNew = false, optimize = false
				1 = clsNew = true, optimize = false
				2 = clsNew = false, optimize = true
				3 = clsNew = true, optimize = true */
	set code = "public static "
	for i = 0, 1 set methCode(i) = code_ recClass_ " vRCgetRecord"_ i_ "("_ fpl_ ")"
	for i = 2, 3 set methCode(i) = code_ "String vRCgetRecord"_ (i - 2)_ "Opt"_ "("_ fplOpt_ ")"
	
	/* code to NEW local vars, and to create new object:
	   For non-optimized modes, use RecInst, else get the node that will
	   receive the initial retrieval. Use this node locally as well, but
	   NEW it (because that variable will also receive the return from the
	   function call).  We must use the same variable(s) as mapped by
	   $$lvpm^UCREC4OP(), because the code generated by getRecCode()
	   may use these nodes to deal with DBTBL1.QID1 !!
	   */
	   
	for i = 0, 1 set retVal(i) = recInst, methCode(i) = methCode(i)_ TAB_ " type "_ recClass_ " "_ retVal(i)
	if auditSelect for i = 0:1:3 set methCode(i) = methCode(i)_ TAB_ " type Number vauditLogSeq"
	set loadNod = $$getRecPur^UCXDD( td)
	for i = 2, 3 do {
		
		if loadNod.isNull() set retVal(i) = """"""
		else  do {
			
			set (lvpmOpt(loadNod), retVal(i)) = optRef
			set methCode(i) = methCode(i)_ TAB_ " type String "_ retVal(i)
		}
	}
	
	// Provide variable for %UserClass for use under bypass
	if (selectChk > 0) do {
		
		// No access rights for table ~p1
		set selErrCode = "S $ZE=""0,""_$ZPOS_"",%PSL-E-ACCESS,""_$$^MSG(6754,"""_ td.table_ """),$EC="",U1001,"""
		
		for i = 0:1:3 set methCode(i) = methCode(i)_ TAB_ " type String vUcls = %UserClass.get()"
	}

	// M implementation - that's all there is for now
	for i = 0:1:3 do {
		
		set methCode(i) = methCode(i)_ TAB_ " #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS"
		set methCode(i) = methCode(i)_ TAB_ " #BYPASS"
		
		if td.isRdb set methCode(i) = methCode(i)_ TAB_ " N vData,vEr,vRm"
	}
	
	/* If basic SELECT access, classNew = 0, test immediately, since user
	   has no access to the table.  Use object ID of 0 since the vselectOK
	   method does not reference the record object when there is no restrict
	   clause, i.e., not selectRestrict.
	   
	   If classNew = 1, need to wait until see if new record or not. */
	if (selectChk = 1) for i = 0, 2 set methCode(i) = methCode(i)_ TAB_ " I '$$vselectOK(0,vUcls) "_ selErrCode
	
	for i = 0, 1 set methCode(i) = methCode(i)_ TAB_ td.getNewCode( recInst, 1, true)
	
	/* If database IO counts are requested, insert code here, so we count
	   unsuccessful calls as well */
	if PSL.hasSetting("DEBUG", "DBIOCOUNT") for i = 0:1:3 set methCode(i) = methCode(i)_ TAB_ " D "_ PSL.getSetting("DEBUG", "DBIOCOUNT")_ "("""_ td.table_ """,""READ"")"

	// Initialize archive directory purpose node, get archive key
	if 'archTbl.isNull() do {
	
		for i = 0, 1 set methCode(i) = methCode(i)_ TAB_ " S "_ lvpmNoOpt(-99)_ "="""""
		for i = 2, 3 set methCode(i) = methCode(i)_ TAB_ " S "_ lvpmOpt(-99)_ "="""""
	}

	// add initial load code - strip any archive reference
	do getRecCode( td, recInst, lvpmNoOpt(), loadNoOpt(), pslCln())
	/* pass numeric for recInst to force use of lvpm() map */
	do getRecCode( td, 1, lvpmOpt(), loadOpt(), pslCln())
	set maxOpt = loadNoOpt("").order(-1)
	if (loadOpt("").order(-1) > maxOpt) set maxOpt = loadOpt("").order(-1)
	for j = 1:1:maxOpt do {
		
		type String archref
		
		if lvpmNoOpt(-99).exists() set archref = lvpmNoOpt(-99)
		else  set archref = ""
		
		if loadNoOpt(j).exists() for i = 0, 1 set methCode(i) = methCode(i)_ TAB_ loadNoOpt(j).replace("|"_ archref_ "|", "")
		
		if 'archref.isNull() set archref = lvpmOpt(-99)
		
		if loadOpt(j).exists() for i = 2, 3 set methCode(i) = methCode(i)_ TAB_ loadOpt(j).replace("|"_ archref_ "|", "")
	}
	
	set methCode(0) = methCode(0)_ TAB_ " S "_ lvpmNoOpt(-2)_ "=1"
	set methCode(1) = methCode(1)_ TAB_ " S "_ lvpmNoOpt(-2)_ "='$T"
	set methCode(2) = methCode(2)_ TAB_ " S "_ lvpmOpt(-2)_ "=1"
	set methCode(3) = methCode(3)_ TAB_ " S "_ lvpmOpt(-2)_ "='$T"
	
	// Append RECNOFL exception, and record mode assignment
	if archTbl.isNull() do {
		
		set code = "S $ZE=""0,""_$ZPOS_"",%PSL-E-RECNOFL,,"_ td.table_ """,$EC="",U1001,"""
		set methCode(0) = methCode(0)_ TAB_ " I $T K "_ PSL.oLvn_ "("_ recInst_ ") "_ code
		set methCode(2) = methCode(2)_ TAB_ " I $T "_ code
	}
	else  do {
		
		type Number archKey = td.getArchiveKey(true)
		type PSLTable tdarch = PSL.getPSLTable(archTbl)
		
		for i = 0:1:3 do {

			type Boolean isClsNew = ((i # 2) = 1)
			type Boolean isOpt = (i > 1)
			
			set methCode(i) = methCode(i)_ TAB_ " I $T D  ; Try archive"
			set methCode(i) = methCode(i)_ TAB_ " . N vArch"
		
			set code = " . S vArch=$$getArchiveFile^Record"_ td.table_ "("""_ td.table_ """,1,"
			set code = code_ archParams.toString().piece( ",", 1, archKey)_ "-1E-10)"
			
			set methCode(i) = methCode(i)_ TAB_ code
			set code = " . I vArch="""""
			
			// If not in archive, OK to create new
			if isClsNew set code = code_ " Q"
			set methCode(i) = methCode(i)_ TAB_ code
		
			// Try to load from archive
			for j = 1:1:loadNoOpt("").order(-1) do {
				
				if isClsNew set code = " ."
				else  set code = " . E "
			
				// Load code will have ^|vobj(vOid,-99| - replace
				if 'isOpt set code = code_ loadNoOpt(j).replace(lvpmNoOpt(-99), "vArch")
				else  set code = code_ loadOpt(j).replace(lvpmOpt(-99), "vArch")
				set methCode(i) = methCode(i)_ TAB_ code
			}
		
			if isClsNew set code = " . ;"
			else  set code = " . I $T K vobj(vOid) S $ZE=""0,""_$ZPOS_"",%PSL-E-RECNOFL,,"_ td.table_ """,$EC="",U1001,"""
			set methCode(i) = methCode(i)_ TAB_ code
		
			// Update archive directory purpose node even if clsNew=1 and
			// no record since this record would have been in archive range
			if 'isOpt set methCode(i) = methCode(i)_ TAB_ " . S "_ lvpmNoOpt(-99)_ "=vArch"
			else  set methCode(i) = methCode(i)_ TAB_ " . S "_ lvpmOpt(-99)_ "=vArch"

			// Done earlier and won't change if clsNew = 0
			if (i = 3) set methCode(i) = methCode(i)_ TAB_ " . S "_ lvpmOpt(-2)_ "='$T"
		}
	}

	/* code to assign keys, and -161/-162 for Rdb
	   For clsNew, need to initialize -161/-162 and node for wide tables,
	   and need to set up key values into -161/-162 in all cases since may
	   end up as insert.  If not clsNew, just set up -152.  Only need
	   post-overhead for setting -161/-162 since key values set in all cases.
	*/
	for j=1:1:fkeys.count() do {
			
		for i = 0:1:3 do {
				
			if (i < 2) set methCode(i) = methCode(i)_ TAB_ " S "_ lvpmNoOpt( -2-j)_ "=v"_ j
			//else  set methCode(i) = methCode(i)_ TAB_ lvpmOpt( -2-j)_ "=v"_ j
			
			quit:'td.isRdb
			quit:(i <> 1)
				
			/* -161/-162 maintained only if using vobj() and
			   if clsNew */
			set cd = PSL.cachePSLColumn( pslCln(), td.table_ "."_ fkeys.elementAt(j), pslTbl())
			type String updOvh = $$getUpdOvh^UCXDD( cd, td, retVal(i), td.isAutoLog, 2)
			set set161 = set161_ updOvh.piece(9.char(), 2)
			set init161 = td.getInitCode( retVal(i), false)
		}
	}

	/* Note that vEr at this point can only be 0 (success) or 100
	   (no record found), and that a non-empty value of set161 implies a
	   non-empty value of set152. However, whether optimizing or not,
	   -152 will be non-empty if incremental loading or bypassSave
	   apply to this declaration. */
	if 'set161.isNull() do {
	
		// Use function form if code is too long
		if 'set161.fitsLineLength(20) do {
			
			set set161 = ""
			for j=1:1:fkeys.count() do {
				
				set cd = PSL.cachePSLColumn( pslCln(), td.table_ "."_ fkeys.elementAt(j), pslTbl())
				type String updOvh = $$getUpdOvh^UCXDD( cd, td, retVal(1), td.isAutoLog, 3)
				set set161 = set161_ updOvh.piece(9.char(), 2)
			}
		}
	
		if 'init161.isNull() do {
			
			set methCode(1) = methCode(1)_ TAB_ " I vEr=100 do"
			set methCode(1) = methCode(1)_ TAB_ "  . "_ init161
			set methCode(1) = methCode(1)_ TAB_ "  . "_ set161
		}
		else  set methCode(1) = methCode(1)_ TAB_ " I vEr=100 "_set161
		
		if 'fkeys.isNull() set methCode(1) = methCode(1)_ TAB_ " E "_ td.getUpdateKey( recInst, lvpmNoOpt())
	}
	
	if td.isRdb do {

		for i = 0, 1 if '((i = 1) and 'set161.isNull()) set methCode(i) = methCode(i)_ TAB_ td.getUpdateKey( recInst, lvpmNoOpt())
		set methCode(2) = methCode(2)_ TAB_ " I $G(vuse152)"_ td.getUpdateKey( retVal(2), lvpmOpt())
		set methCode(3) = methCode(3)_ TAB_ " E  I $G(vuse152)"_ td.getUpdateKey( retVal(3), lvpmOpt())
	}
			
	for i = 0:1:3 do {
		
		/* Delay check for classNew = true with select access restriction.
		   If selectRestrict, need to delay check as well. */
		
		if (selectChk > 0) do {
			
			type Number recInst
			
			set code = ""
			
			if (selectChk = 1) do {		// select
				
				set recInst = 0		// Don't need instance for select
				
				if (i = 1) set code = " I "_ lvpmNoOpt(-2)_ "=1,"
				else  if (i = 3) set code = " I "_ lvpmOpt(-2)_ "=1,"
			}
			else  do {			// selectRestrict
				
				set recInst = retVal(i)
				
				if ((i = 0) or (i = 2)) set code = " I "
				else  if (i = 1) set code = " I "_ lvpmNoOpt(-2)_ "=1,"
				else  set code = " I "_ lvpmOpt(-2)_ "=1,"
			}
		
			if 'code.isNull() do {
			
				if (i < 2) set code = code_ "'$$vselectOK("_ recInst_ ",vUcls"
				else  set code = code_ "'$$vselectOptmOK(vUcls,"_ recInst
								
				if (i > 1) for j = 1:1:fkeys.count() set code = code_ ",v"_ j
				
				set code = code_ ") "_ selErrCode
				
				set methCode(i) = methCode(i)_ TAB_ code
			}
		}
		
		set methCode(i) = methCode(i)_ TAB_ " #ENDBYPASS"
		if auditSelect set methCode(i) = methCode(i)_ TAB_ auditCode
		// Avoid warning on vOid being undefined
		if (i < 2) set methCode(i) = methCode(i)_ TAB_ " #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=SCOPE"
		set methCode(i) = methCode(i)_ TAB_ " quit "_ retVal(i)
	}
	
	set code = ""
	for i = 0:1:3 set code = code_ ""_ TAB_ methCode(i)_ TAB

	quit code.extract(1, code.length() - 1)
	

	// ---------------------------------------------------------------------
getRecCode( PSLTable tblDes,	// table descriptor
		String recInst,		// record instance variable
		PSLIdentifier lvpm(),	// loc var pur map	/NOREQ/MECH=REFARR:R
		String mcd(),		// generated M code	/MECH=REFARR:W
		PSLColumn clnDes())	// PSLColumn cache	/NOREQ/MECH=REFARR:RW
	/* ---------------------------------------------------------------------
	ARGUMENTS:
	(*4) lvpm() = local variable purpose mapping
		If the generated code needs to use local variables e.g. vN for
		key columns, then lvpm() shall contain these mappings.
		In particular, this entry will pass $$lvpm(N*) in vsub(keyN) to
		the SQL engine when dealing with DBTBL1.QID1
		If lvpm(-1) exists, it is copied into the array that will be
		passed to getRecQid1(), to generate code that overwrites the -1
		node with the runtime record class of the child.
	(*5) mcd() = generated M code
		This array will contain the minimum number of lines that are
		needed to
		- validate the table's view condition
		- load the top node or the default node (if one exists)
		- set $TEST to reflect "record not found"
	NOTES:
	. If the table has a query (DBTBL1.QID1 IS NOT NULL), that contains
		columns that are neither key columns nor columns that are stored
		on the top / exists node, then it is the callers responsibility
		to maintain the node variables, except if the standard vobj(,)
		node mapping is used.
	. Aside from the special entry lvpm(-1), the lvpm() array will be used
		to obtain the variables that contain the primary key values, and
		the variables that will receive the nodes of the initial load.
		A word of caution is needed with respect to the latter: The code
		that evaluates DBTBL1.QID1 is generated by $$getRecQid1(), that
		will use the vsub(qcn) mechanism of the SQL engine to specify
		"column retrieval expression". getRecQid1() will obtain this
		expression by calling $$getCurExpr(). Because $$getCurExpr()
		uses the lvpm() array for this purpose, callers shall supply
		consistent lvpm() values for all nodes that may occur in QID1.
	*/
	type List   fkeys = tblDes.primaryKeys
	type Number i
	type String nodes()		// nodes that need to be pre-loaded
	type String qid1code()		// code that deals with QID1
	type String tbl = tblDes.table	// DQ table name
	type String vsub()		// variable substitutes for SQL engine

	for i=1:1:fkeys.count() set vsub( tbl_"."_ fkeys.elementAt(i)) = $$lvpm^UCXDD( recInst, i_"*", lvpm())

	/* Add additional constraints for VIEWs and Parent/Child relationships
	   to mcode(). Copy lvpm(-1) to nodes(-1) before calling getRecQid1(),
	   and remove nodes(-1) after the call to prevent it from being
	   "loaded".  */
	if lvpm(-1).exists() set nodes(-1) = lvpm(-1)
	type Boolean isPc = false
	if PSL.getSetting("boot","restrictionlevel",0)<2 set isPc = $$getRecQid1( tblDes, recInst, lvpm(), , vsub(), nodes(), qid1code())
	kill nodes(-1)

	/* First insert load code for nodes that are needed for QID1.
	   These nodes will be loaded as incremental loads of existing records
	   without local var exists checks. For this reason, loading of the
	   existsNode is skipped here. */
	type Number base = 0
	type String xnd = $$getRecPur^UCXDD( tblDes)
	type String nod = ""
	for  set nod = nodes( nod).order() quit:nod=""  do {
		if nod'=xnd set base = base + 1, mcd( base) = $$getLodCode^UCXDD(tblDes, recInst, nod, 1, 0, lvpm())
	}

	/* Next insert load code for top node or existsNode.
	   Generate code that will allow "record not found" checking.
	   Note that MDB retrievals are always expected to be wrapped. */
	if 'xnd.isNull() do {
		type String code = $$getDataNode^UCXDD( tblDes, recInst, xnd, 1, lvpm())
		for i=1:1:code.length(9.char()) set mcd(base + i) = code.piece(9.char(), i)
	}

	/* Insert code generated that checks QID1 condition(s) */
	set base = mcd("").order(-1)
	for i=1:1:qid1code.get() set mcd(base + i) = qid1code(i)

	/* Finally insert the "record not found" check.
	   This check is not needed for child tables, because the check is
	   implied by QID1 (and inserted via qid1code().
	   However if qid1code() did contain code other than parent/child code,
	   then the "record not found" is an ADDITIONAL condition, that needs to
	   be checked only if QID1 is met.
	   */
	type String code
	if qid1code.data()>9,'isPc set code = " E "
	else  set code = ""
	if tblDes.parentTable.isNull() set base = mcd("").order(-1) + 1, mcd( base) = code_ tblDes.getExistsCode( recInst, lvpm())

	quit
	

	// ---------------------------------------------------------------------
getRecQid1( PSLTable tblDes,	// (PSL) table descriptor
		String recInst,		// record instance variable or number
		PSLIdentifier lvpm(),	// loc var pur map	/NOREQ/MECH=REFARR:R
		String ptable,		// parent table		/NOREQ
		String vsub(),		// qcn substitutes	/MECH=REAFARR:RW
		String nodes(),		// pre-load nodes	/MECH=REAFARR:RW
		String mcode())		// generated code	/MECH=REAFARR:RW
	/* ---------------------------------------------------------------------
	Build QID1 view logic for this table and descendant tables based on
	DBTBL1D.QID1. This column serves two purposes:
	1) For child tables, it defines the relationship with the parent table.
		QID1 of the child table defines the condition that rows in the
		parent table must satisfy to qualify as this class of child
		record object.
	2) For tables that share a common M global structure, QID1 defines the
		condition that qualifies a node in the global as a distinct row
		of that table. Because separate DQ tables never merge into a
		single RDB table, this case does not apply to RDB tables.

	ARGUMENTS:
	(*3) lvpm() = record instance or variable number array
		See Notes in getRecCode re need for lvpm related to QID1
	(*4) ptable = name of parent table
		If defined, then the call to this procedure is intended to
		create the code that determins the record class to be assigned
		based on QID1 of this child table.
		Otherwise the call is supposed to produce the discriminating
		condition for MDB shared globals.
	(*5) vsub() = qualified column name subtitutions
		All columnn references resuting from evaluating QID1 will end up
		in vsub(), to ensure that these values map to node-and-positions
		that are independent of the storage model, and are elegible for
		purpose variable substitution.
	(*6) nodes() = nodes used by columns in QID1, that need to be pre-loaded
		nodes(-1) = currentLvn
			If this node exists, and ptable exists, then the
			runtime recordclass of the child table will be assigned
			to the lvn specified in node(-1).
		nodes(node) = ""			/MECH=REFARR:W
			Will have been added for all nodes that must be loaded
			in order to be able to verify the VIEW condition.
			It is the callers responsibility to load these nodes.
	(*7) mcode() = generated M code			/MECH=REFARR:RW
		generated code is added to this array.
		* mcode = max line number in use
		* mcode(line) = M code
		All added code will be conditional code.
		If the function returns 0 (not parent/child code), then the
		returned code will SET $TEST to indicate that QID1 is not met
		(c.f. "not found").
		If the function returns 1 (parent/chid code), then the value
		of $TEST after executing the last line in mcode() is
		unspecified.

	INPUTS:
	. vsub() = qualified column name substitution array
		vsub(qcn) = rightexpr

	OUTPUTS:
	. $$ = isParent
		1 - if the code added to mcode() deals with the parent/child
			relationship (i.e. there were recursive calls to
			$$getRecQid1)
		0 - otherwise
			Including: no code added
	. vsub(qcn) = currentExpr(0)
		The substitution array will have been created for all columns
		that occur in DBTBL1.QID1 of either the table itself or its
		descendant tables.

	NOTES:
	. This routine calls itself recursively for each child table of the
		supplied parent table.
	. The use of node(-1) is a sub-optimal mechanism to distinguish between
		vobj(,) code and voXN (NO-OBJECT) code, but it prevents the use
		of an additional parameter exclusively for that purpose.
		Furthermore the mechanism is more or less consistent with the
		lvmp() conventions.
	*/
	type String tbl = tblDes.table	// DQ table name
	type String whr()		// result from VIEW^SQLM

	/* the following variables are unused, but required or created by the
	   calls to the SQL engine. */
	type String join,cmp(),fsn(),rng(),tok,vdd
	type String ER=0,RM=""		// good old error mechanism

	/* get mcode() for child tables, provided we are interested in record
	   class overrides (nodes(-1).exists()).
	   Note that isParent must be set independent of nodes(-1).exists():
	   Even if the caller is not interested in the record class override
	   code from the recursive calls, the function return must be correct
	   (i.e TRUE if parent) !
	   */
	type ResultSet rs = Db.select( "FID", "DBTBL1", "%LIBS='SYSDEV' AND PARFID=:tbl")
	type Boolean isParent = 'rs.isEmpty()
	if nodes(-1).exists() do {
		while rs.next() do {
			type String ctable = rs.getCol(1)
			type PSLTable ctd = $$getPslTbl^UCXDD( ctable, 0)
	
			type Boolean dummy = $$getRecQid1( ctd, recInst, lvpm(), tbl, vsub(), nodes(), mcode())
		}
	}

	/* If this is an RDB table, that is not a child table, we are done here
	   */
	if tblDes.isRdb,tblDes.parentTable.isNull() quit isParent

	type Number vxp = -1		// unused, but required by VIEW^SQLM
	do fsn^SQLDD( .fsn(), tbl)	// unused, but required by VIEW^SQLM
	do VIEW^SQLM( tbl, .whr(), .fsn()) if ER.toNumber()'=0 do PSL.error( RM.get()) quit isParent

	/* If there was no QID1, then whr() will not exist, and we are done */
	if whr.data()<9 quit isParent

	/* At this point whr() contains the additional conditions to be applied
	   The relevant parts of whr(n) are:
		* first TAB delimited piece: leftPartOfCompare
		* second TAB delimited piece: rightPartOfCompare
	   Each part may contain one or more column-references, enclosed in
	   $C(1). The even pieces contain qualified column names, the odd pieces
	   contain binary operators etc.
	   Although the call to QUERY^SQLA() will generate the correct MDB code
	   for non-numeric recInst values, vsub() will be pre-loaded with the
	   value of $$getCurExpr(,recInst) to ensure proper use of purpose
	   variable placeholders under all circumstances.
	   Note that $$getCurExpr() does not accept an lvpm() array. So
	   subtitution must be achieved by supplying a numeric recInst, and rely
	   on $$lvpm^UCREC4OP() to suppy the variable representing the node.
	   As a side-effect of specifying all vsub() entries, QUERY^SQLA() will
	   not generate the fsn(table,node) entries for any node that occurs in
	   vsub(), so these are initiated here as well.

	   Further investigation may be needed to ensure that this always works,
	   even for exotic cases such as computeds and masterfields. */
	type String c			// qualified column name
	type PSLColumn cd		// column descriptor
	type Number i,j,n		// iterators
	type String nod			// current node of qcn in whr()
	type String z			// scratch, data

	set n=""
	for  set n = whr(n).order() quit:n=""  for i=1,2 do {
		set z = whr(n).piece( 9.char(), i)
		for j = 2:2:z.length( 1.char()) do {
			set c = z.piece( 1.char(), j)
			if vsub( c).exists() quit
			set cd = $$getPslCln^UCXDD( c.piece("."), c.piece(".",2))

			/* Build vsub() entry for this qcn. Relies on numeric
			   RecInst for non-standard node variables.
			   */
			set vsub( c) = $$getCurExpr^UCXDD( cd, recInst, 0, lvpm())

			/* build nodes( nod) for this qcn:
			   - forget top node
			   - forget key columns (shall be present in vsub())
			   - calculate only once
			   */
			set nod = $$getCurNode^UCXDD(cd, 0)
			if nod'="",nod'<0,'nodes( nod).exists() set nodes( nod) = ""
		}
	}

	/* Translate whr() to M code. QUERY^SQLA() is called for that purpose.
	   The mcode() returned by QUERY^SQLA() will contain code that accesses
	   the nodes in nodes(nod).
	   */
	type Number ptr = mcode.get()		// skip current data in mcode()

	do QUERY^SQLA("".justify(whr("").order(-1),-1,1),.whr,.mcode,.vsub,tbl,,0,0)
	
	/* QID1 for child tables must be a simple query based on one or more
	   columns in the parent table that result in only a single mcode
	   entry. */
	if ptable.exists(), (mcode > (ptr + 1)) do PSL.error( "Child table query (DBTBL1.QID1) invalid") quit isParent

	/* modify the mcode() added by the call to
	   - remove the " S vsql=-1" that signals "end-of-search"
	   - prepend a space (to conform to M_line syntax)
	   - set vobj(vOid,-1) of descendant class
	   */
	for i=ptr+1:1:mcode.get() do {
		if mcode( i)[" S vsql=-1" set mcode( i) = mcode( i).piece(" S vsql=-1")
		set mcode( i) = " "_mcode( i)
		if i>(ptr + 1),mcode( i).extract( 1,4)'=" E  " set mcode( i)=" E "_ mcode( i)
		if 'ptable.exists() quit

		/* The remaining lines are only needed for child tables, to
		   override the parent record class by the record class of child
		   (as determined by QID1).
		   The unconditional use of nodes(-1) is acceptable because this
		   (nested) call getRecQid1() will only be made if node(-1)
		   exists().

		   After removing the " S vsql=-1", each line in mcode() has the
		   form
			IF '(condition)
		   Remove the "not", and add the assignment of the class.
		   */
		set mcode( i) = mcode( i).piece( "'")_ mcode( i).piece( "'",2,999)_ " S "_ nodes(-1)_ "=""Record"_ tbl_ """"
	}

	quit isParent


	// ---------------------------------------------------------------------
getSchCln	//void; method Db.getSchemaColumn(String,String)
	/* ---------------------------------------------------------------------
	INPUTS:
	. PSL.actual(1) = name of table (dynamic value allowed)
	. PSL.actual(2) = name of column (dynamic value allowed)

	OUTPUTS:
	. return = code to retrieve value at runtime (getSchCln^UCXDD)
	*/
	set PSL.return="$$getSchCln^UCXDD("_PSL.actual(1)_","_PSL.actual(2)_")"
	quit

	// ---------------------------------------------------------------------
getSchTbl	//void; method Db.getSchemaTable(String)
	/* ---------------------------------------------------------------------
	INPUTS:
	. PSL.actual(1) = name of table (dynamic value allowed)

	OUTPUTS:
	. return = code to retrieve value at runtime (getSchTbl^UCXDD)
	*/
	set PSL.return="$$getSchTbl^UCXDD("_PSL.actual(1)_")"
	quit


	// ---------------------------------------------------------------------
hasQual( ret PSLExpression expr,	// expression to be checked (*1)
		noret String val)		// qualifiers that shall occur (*2)
	/* ---------------------------------------------------------------------
	Does expr contain all qualifiers in val?

	This function checks if expr contains the supplied value according to
	the following rules:
	- If expr = "" it returns 0 (zero)
	- Else, if expr is not a literal, it returns 0 (zero)
	- Else it returns {List}(expr.StripQuotes()).contains(val,"/") for
		ALL qualifiers in val.

	If expr is passed by reference, and the value is a literal, its value
	will be standardized for qualifier use ("/" in the first position)

	ARGUMENTS:
	(*1) expr = qualifier exrpession to be checked.
		This is a PSLExpression: A literal value shall be properly
		quoted.
		This function assumes that qualifiers contain boolean qualifiers
		only, that values are specified as either /QUAL or /NOQUAL, and
		that conflicts have been resolved by the caller (eg both /QUAL
		and /NOQUAL).
		A supplied literal value need not start with a slash.
	(*2) val = qualifiers that shall occur
		This is a String parameter, that specifies the qualifier values
		to look for. Each slash-separated value is treated as a literal
		that shall occur in expr.
		The supplied value shall not be quoted, and shall start with a
		"/".

	OUTPUTS:
	. $$ = 1 if and only if expr contains ALL qualifiers listed in val.
	*/
	if expr.isNull() quit 0
	if 'expr.isLiteral() quit 0
	set expr = expr.stripQuotes()
	if expr = "" quit 0
	if expr.extract() '= "/" set expr = "/"_ expr

	type String qual = expr_"/"	// standardized with trailing "/"
	set expr = expr.addQuotes()	// standardized quoted literal

	if val_"/" = qual quit 1

	type Boolean ret = 1
	type Number  i

	for i=2:1:val.length("/") if qual'[("/"_ val.piece( "/", i)_ "/") set ret=0 quit

	quit ret

	// ---------------------------------------------------------------------
insert	//
	/* ---------------------------------------------------------------------
	This subroutine implements the deprecated method
	Db.insert( tableName, columnNames, columnValues, filerQualifiers)

	 INPUTS:
	. actual(1) = table name (literal)
	. actual(2) = column name list (literal)
	. actual(3) = column value list (literal)
	. actual(4) = filer qualifiers (dynamic allowed)

	NOTES:
	. This subroutine used to call $$fileQual("Db.update",) and inserted the
		result in the generated call to Record.save().
		Because save^UCRECORD will also call $$fileQual(), two different
		set of values were added. This resulted in potential problems,
		as UCUTILN will not deal with duplicate qualifiers (e.g. insert
		/VALFK if the list already contains /VALFK). To prevent these
		problems $$filequal() will not be called here any more.
		This implies that the following qualifiers will no longer be
		processed:
		1) pslPrsr("SQLPARS") for Db.insert() (see $$fileQual)
		2) parameters added due to prsr("DEBUG","FILEQUAL")="Db.update"
	. The code that deals with the columnValues is weak.
	*/
	type public PSLTable pslTbl()

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do WARNDEP^UCGM(2.6, 0, "Db.insert() - use Db.getRecord(,,1) or Class.new() and Record.save()")
	
	type String table   = PSL.actual(1).stripQuotes()	// Table name
	type String columns = PSL.actual(2).stripQuotes()	// Column names
	type String values  = PSL.actual(3).stripQuotes()	// Column values
	type String qual    = PSL.actual(4)			// filer qualifiers
	type PSLTable td    = PSL.cachePSLTable( pslTbl(), table, 0)

	if values[":" set values = $$mapPSLvar(values)

	type PSLBuffer buf = PSL.openBuffer("()","INSERT INTO "_table_" "_columns_" VALUES "_values)

	// Instantiate a new record
	do buf.add( "type Record"_ table_" vIns = Class.new(""Record"_ table_ """)")

	// turn change auditing on
	do buf.add("do vIns.setAuditFlag(1)")

	// set all columns into the new record as defined by columns and values
	// parameters of the method
	type String nextval = "", currval = "", prop, value
	type Number I

	for I=1:1:columns.length( ",") {
		set prop = columns.piece( ",", I)
		if prop [ "." set prop = prop.piece( ".", 2)

		set value = values.piece( ",", I)
		if value.upperCase() [ "NEXTVAL" set nextval = prop quit
		if value.upperCase() [ "CURRVAL" set currval = prop quit
		if td.primaryKeys.contains(prop) set nextval(prop) = value
		if value.extract() = ":" set value = value.extract( 2, value.length())
		if value.extract() = "'" set value = """"_ value.extract( 2, value.length()-1)_ """"
		else  if value?.P set value=""""_value_""""
		do buf.add("set vIns."_ prop.lowerCase()_" = "_ value)
	}

	if nextval'=""!(currval'="") {
		type String where = "", i = ""
		for  set i=nextval(i).order() quit:i=""  set where = where_ ","_ i_ "="_ nextval(i)
		if nextval'="" do buf.add( "set vIns."_ nextval.lowerCase()_ " = Db.nextVal( """_ table_ """, """_ where.extract( 2, 100)_ """)") quit
		do buf.add( "set vIns."_ currval.lowerCase()_ " = Db.currVal( """_table_""", """_ where.extract( 2, 100)_ """)")
	}

	/* save the data using the filer in order to use all triggers and journals.
	   */
	do buf.add("do vIns.save("_ qual _")")
	do buf.add("quit")

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do autoERRM^UCGM()

	/* get next label and insert into code
	   */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set PSL.return = $$findSubr^UCGM( "DbIns", "")		// Get next tag name
	do buf.insert( PSL.return, "void")
	set PSL.return = PSL.return_ "()"
	quit

	// ---------------------------------------------------------------------
isDefined	// void; method Db.isDefined
	/* ---------------------------------------------------------------------
	*/
	type public Boolean   isDirctv
	type public PSLTable  pslTbl()
	type public PSLParser pslPrsr

	type String expr
	type String from  = PSL.actual(1)
	type String where = PSL.actual(2)
	type Number count = PSL.actual(3).stripQuotes()

	// Determine if dynamic
	for expr=from,where,count if 'expr.isNull(),'expr.isLiteral() quit
	if  do isDefDyn(from,where,count) quit

	set from = from.stripQuotes()
	set where = where.stripQuotes()
	if 'count.isNull(),'({String}count).isNumber() do PSL.error("matchCount must be Number") quit

	type String   table = from.piece(",")
	type PSLTable td    = PSL.cachePSLTable( pslTbl(), table, 1)
	type List     fkeys = td.primaryKeys

	if isDirctv.get() do pslPrsr.addSysmap( "#IF", "Db.isDefined", table, fkeys.elementAt( fkeys.count()))

	// CUVAR etc. on MBD
	if fkeys.isNull(),'td.isRdb set PSL.return = "$D("_ td.global.piece("(")_ ")" quit

	if where'[" " set where = $$akey2sql( where, fkeys)	// Support legacy key syntax

	type String atom, saveatom, tkeys = ","_ fkeys_ ","
	type Number found, ptr = 0
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	for  set atom = $$ATOM^%ZS( where, .ptr, "=") do { quit:ptr=0
		if atom'="=" set saveatom = atom.stripQuotes()_ "," quit
		set found = tkeys.find( saveatom)

		/* isDefined may be used without some keys, if a column does not
		   match then that is the case so we can not warn about it. */
		if found=0 set tkeys = "" quit	
		set tkeys.extract( found-saveatom.length(),found-2) = ""
	}

	// In two-argument form (count not supplied), all keys must be supplied
	if count.isNull(),tkeys.translate(",")'="" do PSL.error("Incorrect number of keys; missing "_tkeys.translate(","," ")) quit
	if where[":" set where = $$mapPSLvar(where)

	/* For the remainder of the code an absent/empty count is equivalent to
	   count = 1 */
	if count.isNull() set count = 1

	/* From here the RDB code and the MDB code are different. The major
	   reason for the distinction is that FSCW is not sure why the statement
	   for the MDB version ends up as:
		SELECT DISTINCT key1 FROM table WHERE whereclause
	   The reason for this may be that the code returned in vsql can easily
	   be used to derive the correct MDB behavior.
	   For RDB tables, the SQL statement will be:
		SELECT COUNT(*) FROM table WHERE whereclause
	   The returned "row" will be compared to 'matchcount' (default: 1) to
	   construct the return value of the Db.isDefined() function call.
	   */
	if td.isRdb set PSL.return = $$isDefined^UCDBR( td, where, count) quit

	// MDB code
	type public String ER,RM

	/* If count=1, it might be sufficient to know if there is a match, and
	   the exact SELECT-clause does not really matter. However, if count>1,
	   then we need to count every possible matching row, and the
	   SELECT-clause must include the complete primary key.

	   The original M version of UCDB used the above difference. Furthermore
	   it inferred that any "jump forward" was a sufficient indication to
	   decide that no matching rows were to be found, and a "QUIT 0" was
	   appropriate. After a Unicode related change to the SQL engine, a
	   "jump forward" is no longer an indication of "no match".
	   In order to ensure behavior that stays close to the behavior of
	   Db.select(), all cases now use the complete primary key in the
	   SELECT-clause.
	================ old code begin ================
	if count = 1 set expr = "DISTINCT "_ fkeys.elementAt(1)_ " FROM "_ from
	else  set expr = "DISTINCT "_ fkeys_ " FROM "_ from
	================ old code end ================ */

	set expr = "DISTINCT "_ fkeys_ " FROM "_ from

	if 'where.isNull() set expr = expr_ " WHERE "_ where

	type String    code, exe(), vsql()
	type List      decl   = ""	// vsqlN vars that need to be declared
	type String    dline  = ""	// line that contains M $DATA()
	type PSLSubrou label  = PSL.addSubrou( "DbEx", "()", "min("_ count_ "): "_ expr, 1)

	/* Set prefix that will be used for labels that are jumped to (cf fetch
	   code). These labels will use at least 2 additional characters (aN,
	   where N is the subscript in the exe() array).
	   Iteration labels for Db.isDefined() start with vEx
	    */
	do label.setTagPrefix( "vEx"_ label.getName().piece("DbEx",2))

	/* Reserve a line that can be used for the declarations, and remember
	   its location. */
	do label.addCode(" ; No vsql* lvns needed")
	type Number declLine = label.getLine()

	if count>1 set dline = 0 do label.addCode(" N vCnt S vCnt=0")

	#ACCEPT DATE=06/18/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
	do SELECT^SQL(expr,"/NOCACHE",,,,,,-1) if ER quit

	type Number codPtr = vsql("P").get()
	type Number i

	if codPtr do {
		do label.addTag( 0, "Q 0")

		/* If count>1, then the "repeated fetch" will "jump" to the line
		   indicated by vsql(0). Make sure that line will receive a
		   label. This is needed because the jump to that line will
		   not be added by addExe() but by addLine(). Note that if
		   count=1, there will be no repeated calls and there is no need
		   to force the label. */
		if count>1,vsql(0).get() do label.addTag( vsql(0))
	}

	for i=1:1:codPtr do {
		set code = exe(i)

		/* Lines below must be synced with code generated by SQL engine.
		   Current version assumes the following:
		   S vsql()=$$BYTECHAR^SQLUTL(254)
		   S vsql()=$G(hostvarN) ...
		   I '($D(...)) ...
		   ...
		   */ 
		if code["'?.N",code["$$FDAT^%ZM" do label.addExe( ";") quit
		// SQL code addition of audit logging
		if code?1"N vauditseq".E do label.addExe( code) quit
		if code?.E1"$G("1U.E do { quit		// Sub host var
			type String lvn = code.piece("$G(",2).piece(" ")
			type Number n   = code.piece("vsql(",2).piece(")")
			do label.addExe( ";") 
			do label.addLvn( n, lvn.extract( 1, lvn.length()-1))
		}
		if dline="",(code["I '($D(^")!(code["I '$D(^") set dline = label.getLine()+1
		else  if code["BYTECHAR^SQLUTL",(+dline=0) set dline=""
		else  set dline=0

		if code["S vd" set i = codPtr quit	// FSCW: questionable ??

		do label.addExe( code)
	}

	// derive List of lvns to NEW
	type PSLExpression ex
	for i=1:1:label.getLvnMax() do {
		set ex = label.getLvn( i)
		if ex?1"vsql"1.N set decl=decl.add(ex)
	}

	// Cannot optimize archive enabled table
	if 'td.getArchiveTable().isNull() set dline = 0

	/* Only relevant line is the line that contains the IF '$DATA(). Return
	   as inline code.
	   FSCW 2008-12-18: decl contains at least the NEW vsqlN for $$BYTECHAR
	   */
	//if dline>0,decl.isNull() do { quit
	if dline>0,decl.count()<2 do { quit
		set PSL.return = label.getCode(dline)
		set PSL.return = PSL.return.piece("I '",2).piece(" Q 0")
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		do decrLabel^UCGM( label.getName())
	}

	/* count specified, but no labels (= no iteration) ==> at most one row
	   */
	type Number tag = label.getTagMax()
	if count>1,tag=0 do { quit
		set PSL.return = "0"
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		do INFO^UCGM("DEAD","Db.isDefined() always 0; MatchCount '"_count_"' exceeds possible matches ")
	}

	if 'decl.isNull() do label.insCode(declLine, " N "_decl)

	/* code line constructed here will be passed to PSLSourou.addExe(), that
	   expects code that does not start wit a space or tab. */
	set code="Q 1"
	if count>1 set code = "S vCnt=vCnt+1 I vCnt="_ count_ " "_ code

	/* Add code using PSLSubrou.addExe() to deal with jump around deepest
	   $ORDER(). See select for explanation etc.
	   */
	do label.addExe( code)

	if count>1 do label.addCode(" G "_ label.getTag( $SELECT(vsql(0).get():vsql(0),1:codPtr)))

	set PSL.return="$$"_ label.getName()_ "()"

	quit

	// ---------------------------------------------------------------------
private isDefDyn( String from,
		String where,
		Number count)
	/* ---------------------------------------------------------------------
	method Db.isDefined - Dynamic from or where

	Build this capability out later as needed
	*/
	do PSL.error("Dynamic Db.isDefined() is not supported") 
	quit

	// ---------------------------------------------------------------------
isSchCln	//void; method Db.isSchemaColumn(String,String)
	/* ---------------------------------------------------------------------
	INPUTS:
	. PSL.actual(1) = name of table (dynamic value allowed)
	. PSL.actual(2) = name of column (dynamic value allowed)

	OUTPUTS:
	. return = code to retrieve value at runtime (isColumn^UCXDD)
	*/
	set PSL.return="$$isColumn^UCXDD("_PSL.actual(1)_","_PSL.actual(2)_")"
	quit

	// ---------------------------------------------------------------------
isSchTbl	//void; method Db.isSchemaTable(String)
	/* ---------------------------------------------------------------------
	INPUTS:
	. PSL.actual(1) = name of table (dynamic value allowed)

	OUTPUTS:
	. return = code to retrieve value at runtime (isTable^UCXDD)
	*/
	set PSL.return="$$isTable^UCXDD("_PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
keyVal(inc)	// void; Method Db.nextVal, currVal, nextKey, prevKey, and prevVal
	/* ---------------------------------------------------------------------
	One subroutine for five methods. The inc parameter determines the
	method that is requested.
	Generate code for the methods Db.currVal(), Db.nextVal(), Db.nextKey(),
	and Db.prevKey()

	For table tbl with primary key key1,keyLast,keyTarget, the method call
	Db.method( "tbl","key1=:val1,keyLast=:valLast") is equivalent to the
	following SQL statement and M expression:

	ARGUMENTS:
	. inc = method to be generated:
		 0 = Db.currVal
		 	SELECT MAX(keyTarget) FROM table WHERE key1=:val1 AND keyLast=:valLast
		 	$ORDER(^TABLE(val1,valLast,""),-1)
		 1 = Db.nextVal
		 	SELECT MAX(keyTarget)+1 FROM table WHERE key1=:val1 AND keyLast=:valLast
		 	$ORDER(^TABLE(val1,valLast,""),-1)+1
		 2 = Db.nextKey (deprecated)
		 	SELECT MIN(keyLast) FROM table WHERE key1=:val1 AND keyLast>:valLast
		 	$ORDER(^TABLE(val1,valLast))
		 3 = Db.prevKey (deprecated) and Db.prevVal (deprecated)
		 	SELECT MAX(keyLast) FROM table WHERE key1=:val1 AND keyLast<:valLast
		 	$ORDER(^TABLE(val1,valLast),-1)

	INPUTS:
	. actual(1) = table
	. actual(2) = (partial) access key

	NOTES:
	. There are a couple of special cases in the RDB code:
		- for Db.currVal() and Db.nextVal(), the WHERE clause will be
			empty if the first key column is used for the increment.
			In this case, the call to $$where^UCDBR must be
			suppressed.
		- for Db.nextVal, if there are no matching rows (i.e. this will
			be the first values), then the ResultSet will be empty.
			So SELECT MAX(col)+1 will not return a value. This is
			handled by using the same SELECT clause for Db.currVal
			and Db.nextVal (MAX(col)), and adding one in the quit-
			argument that terminates the function.
	. Db.prevVal() and Db.prevKey() are now equivalent.
		The value inc=-1 that used to be associated with Db.prevVal()
		shall no longer be used. To be sure the correct code is
		generated, this subroutine changes inc=-1 into inc=3
	. For MDB, there is the special case of Db.currVal on a table with
		DBTBL1.QID1 IS NOT NULL. In that case, the last (constant) value
		of the $ORDER() may be other than "" (eg if QID1 has a KEY<max
		condition).
	. For MDB, if the table is archived, it is possible that all records will
	  be in archive files, so need to locate 
	*/
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if (inc=0)'!(inc=1) do WARNDEP^UCGM(2.7, 0, "Db."_ ("prevVal;nextKey;prevKey").piece(";",inc.translate("-")))

	if inc = -1 set inc = 3	// Force equivalence of Db.prevVal() and Db.prevKey()

	type String table = PSL.actual(1).stripQuotes()
	type PSLTable td  = PSL.cachePSLTable( pslTbl(), table, 1)
	type List rights = td.checkAccessRights(false)
	type PSLExpression map()
	type String akeys = $$akey2apl( td, "", PSL.actual(2), -1, map())

	type List fkeys = td.primaryKeys
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if fkeys.isNull() do ERROR^UCGM("Invalid method for table: "_table) quit

	type Number acnt = -map("").order()-2		// ord of last keyvalue
	type Boolean useRdb = false			// use RDB method for prevKey
	type Number k					// key iterator

	/* If Db.currVal() supplies all keys, then the "result" is the value
	   supplied for the last key (Goofy but OK according to Frank)
	   */
	if acnt<1 set acnt=0 if inc=2!(inc=3) throw Class.new("Error", "%PSL-E-INVALIDREF: missing accessKey for Db."_ PSL.method)
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if acnt=fkeys.count(), inc=0 set PSL.return = map( -acnt-2) do warnGroup^UCGM( "DEAD", "Db.currVal() with all keys - will assign "_ PSL.return) quit
	if acnt=fkeys.count(), inc=1 do {
		/* if Db.nextVal() supplies all keys, drop last key from map()
		   and from akeys */
	  	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		do warnGroup^UCGM( "DEAD", "Db.nextVal() with all keys - dropped "_ td.primaryKeys.elementAt( acnt)_ "="_ map( -acnt-2))
		kill map( -acnt-2) set acnt = acnt - 1
		if acnt = 0 set akeys ="" quit
		set akeys = map(-3)
		for k=2:1:acnt set akeys = akeys_","_map( -k-2)
	}

	/* For prevKey, if table is archived and we are at the archive key
	   level or below, then need to use SELECT, like RDB does, in order
	   to consider archive code.
	*/
	if (inc = 3),'td.getArchiveTable().isNull() do {

		type PSLTable tdarch = PSL.getPSLTable(td.getArchiveTable())

		type Number archkey = tdarch.getArchiveKey()

		// Not getting to archive key level
		if (acnt '< archkey) set useRdb = true
	}
	
	/* If there are SELECT access rights restrictions on the table
	   need to use SELECT, like RDB does */
	if (rights.contains("select") or rights.contains("selectRestrict")) set useRdb = true

	if td.isRdb ! useRdb do { quit
		/* RDB code for Db.currVal, Db.nextVal, Db.nextKey, Db.prevKey

		   MDB code for Db.prevKey if archived table, since need to
		   consider archive files for this one on backward collation.

		   The call will translate into a function call. The function
		   will have one formal parameter for each key that occurs in
		   accKey.
		   The formal parameters will be named V1, V2, etc. (note the
		   uppercase spelling), so the names can be used as SQL hostvar
		   without re-assignment.

		   For RDB, each method generates a call to $$SELECT^%DBAPI() with
		   the SQL SELECT statement listed for the method in the ARGUMENTS
		   section.

		   The construction of the WHERE clauses relies on the fact that
		   $$RsMsXV^UCDBRT() will ensure proper hostvar values (eg +Num)

		   For MDB, the call is to SELECT^SQL.
		   */
		type String sel		// select clause (with INTERNAL names)
		type String whr		// where clause (with DQ names)
		type PSLColumn cd	// column descriptor

		if inc = 0 ! (inc = 1) do {	// Db.currVal and Db.nextVal
			set cd = PSL.cachePSLColumn( pslCln(), table_"."_fkeys.elementAt( acnt+1), pslTbl())
			set sel = "MAX("_ cd.internalColumn_ ")"
			if inc = 1, "TUFL"[cd.dataType do PSL.error("Db.nextVal() invalid for data type "_cd.dataType)
			set whr = ""
		}
		if inc = 2 do {			// Db.nextKey
			set cd = PSL.cachePSLColumn( pslCln(), table_"."_fkeys.elementAt( acnt), pslTbl())
			set sel = "MIN("_ cd.internalColumn_ ")"
			set whr = cd.column _ ">:V"_acnt
			set acnt = acnt - 1
		}
		if inc = 3 do {			// Db.prevKey and Db.prevVal
			set cd = PSL.cachePSLColumn( pslCln(), table_"."_fkeys.elementAt( acnt), pslTbl())
			set sel = "MAX("_ cd.internalColumn_ ")"
			set whr = cd.column _ "<:V"_acnt
			set acnt = acnt - 1
		}

		/* Construct the (remaining) primary key, and transform the
		   where clause into an RDB where clause
		   */
		type String fpl = ""		// formal parameter list for sr
		type String hvmap(,)		// hostvar mapping

		for k = 1:1:acnt do {
			if 'whr.isNull() set whr = whr_ " AND "
			set whr = whr_ fkeys.elementAt( k)_ "=:V"_ k
			set fpl = fpl_",V"_k
		}
		if 'whr.isNull() do {
			if td.isRdb set whr = " WHERE "_ $$where^UCDBR( td.table, whr, hvmap(,))
			else  set whr = " WHERE "_whr
		}

		/* Use a unique comment string to locate the subroutine:
		   table + method + number of keys */
		type String cmt = td.table _ "."_ PSL.method_"#"_ acnt
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		type String label = $$findSubr^UCGM( "vDb", cmt)

		set PSL.return = "$$"_ label_ "("_ akeys_ ")"
		if PSL.subrouExists( label) quit

		if inc=2!(inc=3) set fpl = fpl_",V"_(acnt+1)

		type PSLSubrou sr = PSL.addSubrou( label, "("_ fpl.extract(2, fpl.length())_ ")", cmt, 0)

		if td.isRdb do {
			type Integer delim = td.columnDelimiter
			type String vListCd = $$RsMsXV^UCDBRT(hvmap(,),.whr, 0, delim))
			do sr.addCode( " N vData,vEr,vRm")
			do sr.addCode( " S vEr=$$SELECT^%DBAPI(0,""SELECT "_sel_" FROM "_ td.internalNames.elementAt(1)_whr_""",$C("_ delim_ "),"_vListCd_",.vData,.vRm)")
			do sr.addCode( " I vEr<0 S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)),$EC="",U1001,""")
		}
		else  do {
			do sr.addCode( " N ER,RM,vData")
			do sr.addCode( " D SELECT^SQL("""_sel_" FROM "_ td.internalNames.elementAt(1)_whr_""",,,.vData)")
			do sr.addCode( " I $G(ER) S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(RM),$C(10,44),$C(32,126)),$EC="",U1001,""")
		}
		if inc=1 do {
			do sr.addCode( " Q vData+1")
			}
		else  do sr.addCode( " Q vData")
	}	// end if RDB

	// MDB code
	type String ordExt		// $ORDER() extension
	if inc=1 do {		
		set ordExt = "),-1)+1"	// nextVal uses backward $order() + 1
		type PSLColumn cd = PSL.cachePSLColumn( pslCln(), table_"."_fkeys.elementAt( acnt+1), pslTbl())
		if "TUFL"[cd.dataType do PSL.error("Db.nextVal() invalid for data type "_cd.dataType)
	}
	else  if inc=2 set ordExt="))"	// nextKey uses forward $order()
	else  set ordExt = "),-1)"	// all others use backward $order()

	// $$getGbl^UCXDD() requires map(keynum_"*")
	for k=1:1:acnt set map(k_"*") = map( -k-2).get() if 'map( -k-2).exists() throw Class.new("Error","%PSL-E-INVALIDREF: missing accessKey for Db."_ PSL.method)

	// Db.currVal on table with view restriction is handled separately
	if inc=0,'$$RsMsQID1^UCDBRT( td.table).isNull() set PSL.return = $$keyValCurr(td, acnt, map()) quit

	// Add extra key for currVal and nextVal
	if inc=0!(inc=1) set map( acnt+1_"*") = """"""

	if 'td.getArchiveTable().isNull() do {
	
		type PSLTable tdarch = PSL.getPSLTable(td.getArchiveTable())

		type Number archkey = tdarch.getArchiveKey()
		
		// Not getting to archive key level
		if acnt < (archkey - 1) quit
		
		// If archkey does not exist or is null, we will use primary
		// archive directory, and don't need map(-99)
		quit:'map( archkey_ "*").exists()
		quit:map( archkey_ "*") = """"""
		
		set map(-99) = "$$getArchiveFile^Record"_ tdarch.table_ "("
		set map(-99) = map(-99)_ """"_ td.table_ """,0,"
			
		for k = 1:1:archkey set map(-99) = map(-99)_map( k_ "*")_ ","
		set map(-99) = map(-99).extract(1, map(-99).length() - 1)_")"
	}

	set PSL.return = $$getGbl^UCXDD( td, "", map())
	set PSL.return = "$O(" _ PSL.return.extract( 1, PSL.return.length()-1)_ ordExt
	quit

	// ---------------------------------------------------------------------
private keyValCurr( PSLTable td,
		Number acnt,		// number of access keys supplied
		PSLExpression map())	// key value exppresions
	/* ---------------------------------------------------------------------
	Support function for Db.currVal when table has VIEW restriction.
	This function mimics the "old" UCDB code that calls SELECT^SQL and
	interprets the result.
	*/
	type String exe(),ER,fsn,RM,vsql(),vsub()	// used by SQL engine

	type Number k
	type String whr = $SELECT(acnt>0:td.primaryKeys.elementAt(1)_"=:V1",1:"")
	for k=2:1:acnt set whr = whr_ " AND "_ td.primaryKeys.elementAt(k)_ "=:V"_k

	type String sql = "DISTINCT "_td.primaryKeys.elementAt(acnt+1)_ " FROM "_td.table
	if 'whr.isNull() set sql = sql_ " WHERE "_whr
	set sql = sql_ " ORDER BY "_ td.primaryKeys.elementAt(acnt+1)_ " DESC"
	#ACCEPT DATE=06/18/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
	do SELECT^SQL(sql,,,,,,,-2) if ER.get() do PSL.error( RM.get()) quit ""

	/* Interpret the exe() array (ugh!)
	   - assignments of the form
			S vsql(n)=$G(Vk)
		map key number k to vsql(n)
	   - replace archive file variable with archive file reference
	   - the line that contains the $O() is the line that we want
	   - if that line still contains vsql(n) occurrences, then we cannot
		use the code (and give up)
	   */
	type Number i,ii,keyNum
	type String code,vsqlN,keyVar

	for i=1:1:exe do {
		set code=exe(i)
		if code'["S vsql(" quit

		set vsqlN  = code.piece( "="), vsqlN = "vsql("_ vsqlN.piece( "S vsql(",2)
		set keyVar = code.piece( "=",2).piece( " ")
		if keyVar = vsqlN quit
		if keyVar.beginsWith( "$G(V") do {
			set keyNum = keyVar.piece("V",2).toNumber()
			if keyNum<1!(keyNum>acnt) quit
			set keyVar = map( keyNum_ "*")
		}

		for ii=i+1:1:exe do {
			if keyVar["$$ARCHFILE", exe(ii)[vsqlN set exe(ii) = exe(ii).replace(vsqlN, keyVar)
			if exe(ii)[vsqlN  set exe(ii) = $$VarSub^UCPATCH( exe(ii), vsqlN, keyVar)
		}
	}
	set code = exe( vsql("P"))

	if code'["=$O("  do PSL.error( "Compiler cannot interpret SQL") quit ""
	if code ["vsql(" do PSL.error( "Compiler cannot interpret SQL") quit ""

	type String tok
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set code = $$TOKEN^%ZS( code, .tok)
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	quit "$O("_ $$UNTOK^%ZS( code.piece("$O(",2).piece( ") "), .tok)_ ")"

	// ---------------------------------------------------------------------
LitInst( PSLIdentifier var,	// target variable
		String table,		// source table
		String akeys,		// access keys, literal values only
		String deflt,		// instantiate NEW flag
		String level)		// current DO level
	/* ---------------------------------------------------------------------
	OUTPUTS:
	. PSL.class  = class name of instance.
	. PSL.return = objectID of Record instance.
	. type(level,var)
		If level<0, then the instExpr piece of this node will have been
		filled with the object ID of instantiated Record.
	. vobj(return) or vobj(return,node)
		The initial load node will have been created. In addition, the
		special purpose nodes -1, and -2 will have been created.
	NOTES:
	. Also called by main^UCGM() to instantiate var CUVAR as a LITERAL
		RecordCUVAR instance
	. A type LITERAL ResultSet uses type(level,objectName,0) to store the
		row. This shall be modified when a multipass compiler is used.
	*/
	type static PSLClass
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	type String keys, load(), tok, v
	type Number i
	type PSLTable td = PSL.cachePSLTable( pslTbl(), table)

	set PSL.class = PSLClass.RECORDCLASS_ table
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set akeys = $$TOKEN^%ZS( akeys, .tok)

	/* Use Dynamic Record Access interface to instantiate a new record.
	   Do NOT try Class.new("Record", table), because PSL's object scoping
	   will add a KILL of the Record instance prior to return from the
	   subroutine */
	#ACCEPT CR=27800; DATE=2007-07-19; PGM=FSCW; GROUP=DEPRECATED
	type Number oid = $$new^DBSDYNRA( table).getPointer()

	if '(akeys="") for i=1:1:akeys.length(",") do {
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set v = $$UNTOK^%ZS( akeys.piece( ",", i), .tok)
		if 'v.isLiteral() do PSL.error( "Literal parameter required: "_ v) quit
		set vobj( oid, -2-i) = v.stripQuotes()
	}

	do get^DBSDYNRA( oid, deflt)

	if level<0 do {					; Pre-code

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		do setScope^UCGM( var, "", "", "LITERAL", PSL.class)

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		do typeFldSet^UCGM( var, 4, -1)		// Runtime code line
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		do typeFldSet^UCGM( var, 5, oid)	// "expression"
	}
	set PSL.return = oid
	quit

	// ---------------------------------------------------------------------
private rdb( String table)  // **** DEPRECATED ****
	/* ---------------------------------------------------------------------
	If you "own" a code element that calls this function, please rewrite
	them as follows:
		$$rdb^UCDB(): replace by $$isRdb^vRuntime()
		$$rdb^UCDB(table): replace by $$rtIsRdb^UCXDD(table).
	*/
	if 'table.exists() quit $$isRdb^vRuntime()
        quit $$rtIsRdb^UCXDD( table)

	// ---------------------------------------------------------------------
select	// method Db.select; returns ResultSet
	/* ---------------------------------------------------------------------

	OUTPUTS:
	. struct("s",subRou,declaredAt,rsobj) = ResultSet data, tab separated
		1) line where rsobj is instantiated
		2) sequence number
		3) ftemp flag (is ^DBTMP($J) used?)
		4) select list
		5) sequence number (if p2="", and set to 1 by Record.compare code)
		6) type/decimals list per column (for class Row)
		7) $$getScope^UCGM(rsobj)
		8) "" if selecting from M tables, 1 if selecting from RDB tables
	*/
	type String expr,RM,tok
	type Number ER=0
	type String select  = PSL.actual(1)
	type String from    = PSL.actual(2)
	type String where   = PSL.actual(3)
	type String orderby = PSL.actual(4)
	type String groupby = PSL.actual(5)
	type String parlist = PSL.actual(6)

	/* FSCW, CR15592: special code when PSLBOOT qualifier is included.
	   */
	if $$hasQual( .parlist, "/PSLBOOT") do selBoot^UCDBR( select, from, where, orderby, groupby, parlist) quit

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number varPtr = $$getNew^UCGM( PSL.var, PSL.varLevel)

	/* Determine if data select is dynamic select, exclude variables setup
	   within the procedure. */
	for expr=select,from,where,orderby,groupby,parlist if 'expr.isNull(),'expr.isLiteral() quit
	if  do selectDyn( select, from, where, orderby, groupby, parlist) quit

	set select = select.stripQuotes()
	set from   = from.stripQuotes()
	if 'where.isNull()   set where   = where.stripQuotes()
	if 'orderby.isNull() set orderby = orderby.stripQuotes()
	if 'groupby.isNull() set groupby = groupby.stripQuotes()
	if 'parlist.isNull() set parlist = parlist.stripQuotes() if parlist.extract()'="/" set parlist="/"_parlist

	if select.isNull()!from.isNull() do PSL.error("Expression expected") quit
	if where[":" set where=$$mapPSLvar(where) if ER quit

	/*  Replace SELECT * by SELECT $$COLLIST^DBSDD before passing the query
	    to either MDB or RDB. This ensures that the select-list and struct()
	    will all have the same idea about the columns and their order.
	    The replacement will be skipped if FROM contains an explict JOIN or
	    table alias. */
	if select="*", from.translate("()","  ")'[" JOIN ",from'[" AS " set select=$$RsSelAll^UCDBRT(from)

	set expr = select_ " FROM "_ from
	if 'where.isNull()   set expr = expr_ " WHERE "_ where
	if 'orderby.isNull() set expr = expr_ " ORDER BY "_ orderby
	if 'groupby.isNull() set expr = expr_ " GROUP BY "_ groupby

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set expr = $$SQL^%ZS( expr, .tok)
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type String untokExp = $$UNTOK^%ZS( expr, .tok)
	if ER do PSL.error( "Invalid SQL Syntax ("_ untokExp_ "), "_ RM.get()) quit

	/* update sysmap data.
	   Note that this is not the best way to do it. There are serious
	   limitations:
	   - only the first table in the FROM-clause is considered.
	   - a FROM-clause with comma-separated names (and /DQMODE) will be
	   	treated as a single table name
	   - all SELECT-clause elements are tied to the same table
	   - all SELECT-clause elements are treated as if they are columns (not
	   	expressions)
	   */
	do {
		type String select,from,ref
		type Number i
		set select = expr.piece(" FROM ",1)
		set from   = expr.piece(" FROM ",2).piece(" ",1)
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set from   = $$UNTOK^%ZS(from,.tok)
		if from["""" set from = from.stripQuotes()

		for i=1:1:select.length(",") do {
			set ref = select.piece(",",i)
			if ref[" " set ref = ref.piece(" ",1)
			
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			set ref = $$UNTOK^%ZS(ref,.tok)
			if ref["""" set ref = ref.stripQuotes()
			if ref["."
			else  set ref=from_"."_ref
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			do addXref^UCGM("P0",ref,"")
		}
	}
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if $$getScope^UCGM( PSL.var) = "LITERAL" do LitOpen^UCRESULT( PSL.var, select, from, where, orderby, groupby, parlist) quit

	/* The FROM-clause may contain keywords like JOIN, AS etc.
	   Call $$RsRdb^UCDBRT() because it takes that into account to determine
	   if this is an RDB select. */
	if $$RsRdb^UCDBRT(from) do select^UCDBR( select, from, where, orderby, groupby, parlist) quit

	// MDB only --------------------------------
	/* variables used / returned by SELECT^SQL() */
	type String exe(), vsql(), vsub()

	/* Split the SQL statement in case it is very long.
	   Use the first (and usually only part) as the comment when creating
	   the new vOpen() subroutine.
	   Add the remaining lines immediately after the subroutine declaration.
	   */
	type Number i
	type String split()

	if untokExp["""" set untokExp = untokExp.stripQuotes()
	do splitCode^UCGMC( untokExp, 0, " ,", split())
	type PSLSubrou openLbl = PSL.addSubrou( "Open","()", split(1), 1)
	for i=2:1:split("").order(-1) do openLbl.addCode( " ; "_ split(i))

	set PSL.return = "$$"_ openLbl.getName()_ "()"

	type Number seq      = PSL.return.extract( 8, PSL.return.length()).translate("()")
	type String fetchLbl = "vFetch"_ seq

	// iteration labels for Db.select() start with vL
	do openLbl.setTagPrefix( "vL"_ seq)

	set select = $$RsSelList^UCDBRT( select)		// remainder can use standard version

	/* FSCW CR14185: add trap, that only applies to call to SELECT^SQL() */
	do {
		catch vSQLex {
			set ER = 1, RM = vSQLex.toString()
		}
		#ACCEPT DATE=06/18/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
		do SELECT^SQL( expr, "/NOCACHE"_ parlist, , , , , .tok, -1) 
	}
	if ER do PSL.error( "Invalid SQL Expression ("_ untokExp_ "), "_ RM.get()) quit

	type Number  ftemp   = vsql("T").get()
	type Number  keyPtr  = vsql("K").get()
	type Number  codPtr  = vsql("P").get()

	/* Protection resides in vsql("prot",), so the vsql array is not a
	   proper PSL array. Use ACCEPT DEPRECATED to deal with the .data()
	   method. */
	#ACCEPT CR=22719;DATE=2006-07-27;PGM=Frans S.C. Witte;GROUP=DEPRECATED
	type Boolean protect = vsql("prot").data()>0	// Protection enabled

	/* GROUP BY will always cause a sort, it also indicates that codePtr
	   is not correct.

	   FSCW CR14185:
	   In case of GROUP BY, the last line contains the assignment to vd. So
	   codPtr shall point to the last-but-one-th line in this case.
	   Protection handling is added AFTER that.
	   NOTE: The above is based on observation of exe(), not on evidence
	   found in design docs. If problems are reported, the validity of the
	   above assumptions shall be verified. */
	if vsql("GB").exists() set ftemp = 1, codPtr = exe("").order(-1) - 1 - protect

	// determine if aggregate functions are used	;6/12/03
        type literal List AGGFUNC = "MIN,MAX,COUNT,AVG,SUM"
        type literal String TAB = 9.char()

        type public String struct(,,,)

	type Boolean isAgFunc = 0

        for i=1:1:select.length(",") if select.piece(",",i)["(", AGGFUNC.contains( select.piece( ",",i).piece( "(")) set isAgFunc = 1

	/* Save info for fetch optimization and column name support
	   If this identifier is already instantiated, check the statement
	   and null out if they are different. */
	type String z = ( PSL.msrc+1)_ TAB_ seq_ TAB_ ftemp_ TAB_ select

	/* [FRS] Added to support the Row class
	   02/09/04 - Piece #7 added to fix fetch label problem */
	set z.piece( TAB, 6) = vsql("D").get()
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set z.piece( TAB, 7) = $$getScope^UCGM( PSL.var)

	if struct("s", PSL.subRou, varPtr, PSL.var).exists() do {
		set z.piece( TAB, 2) = ""
		set z.piece( TAB, 5) = seq

		/*  FSCW CR14919: store (standardized) SELECT-clause only
		    The piece is used by Row classes (together with piece 6),
		    and it is probably not needed to set it to "".
		    In all cases it seems appropriate to "sync" pieces 4 and 6.
		    */
		if struct( "s", PSL.subRou, varPtr, PSL.var).piece( TAB, 4) '= select set z.piece( TAB, 4) = ""
	}
	set struct( "s", PSL.subRou, varPtr, PSL.var) = z

	do openLbl.addCode( " N vOid")

	/* Reserve a line for the declaration of local variables in OPEN
	   section, and remember its value. */
	do openLbl.addCode( " ;")
	type Number newPtrO = openLbl.getLine()

	do openLbl.addCode( " S vOid=$O("_ PSL.oLvn_ "(""""),-1)+1")
	if ftemp do openLbl.addCode( " K ^DBTMP($J,vOid)")

	do openLbl.addCode( " S "_ PSL.oLvn_ "(vOid,0)=2")
	do openLbl.addCode( " S "_ PSL.oLvn_ "(vOid,-1)=""ResultSet""")
	do openLbl.addCode( " S "_ PSL.oLvn_ "(vOid,-2)=""$$"_ fetchLbl_ "^""_$T(+0)")

	kill split
	do splitCode^UCGMC( select, 0, "", split())
	do openLbl.addCode( " S "_PSL.oLvn_"(vOid,-3)="_ split(1).addQuotes())
	for i=2:2:split("").order(-1) do openLbl.addCode( " S "_ PSL.oLvn_ "(vOid,-3)="_ PSL.oLvn_ "(vOid,-3)_"_ split(i).addQuotes())

	do openLbl.addCode( " S "_PSL.oLvn_"(vOid,-4)="_ vsql("D").get().addQuotes())

	/* the $P(^) references DBTBL1.ACCKEY.
	   The combination of conditions will result in the suppression of the
	   line that ensures the first fetch, that is part of the OPEN CURSOR.
	   The reason for this code (and the way it is formulated) is unknown.

	if keyPtr.isNull(),$P($G(^DBTBL("SYSDEV",1,from,16)),"|",1)["*"
	else  do openLbl.addCode( " D "_ openLbl.getTag(1))
	================ */

	if codPtr do {
		/* There is initialization code or iteration code.
		   Include a call to this code from vOpen(), and ensure that the
		   line that corresponds to exe(1) will get a label. */
		do openLbl.addCode( " D "_ openLbl.getTag(1))
		do openLbl.addTag(1)
		if vsql(0).get() do openLbl.addTag( vsql(0))
	}

	do openLbl.addCode( " Q vOid")
	do openLbl.addCode( " ;")

	/* add vsql() replacements for first keyPtr nodes. These variables need
	   to "survive" after vOpen() and between vFetch(), so they are kept as
	   part of the object */
	for i=0:1:keyPtr do openLbl.addLvn( i, PSL.oLvn_ "(vOid,"_ i_ ")")

	// Add line that announces end-of-result (using tag 0)
	do openLbl.addTag(0)
	do openLbl.addCode( openLbl.getTag(0)_" S "_ PSL.oLvn_ "(vOid,0)=0 Q")

	type String x
	for i=1:1:codPtr do {
		set x=exe(i)

		if ftemp do {
			if x["sqlcur" set x=$$VarSub^UCPATCH(x,"sqlcur","vOid")
			if x["^DBTMP(%TOKEN" set x=$$VarSub^UCPATCH(x,"^DBTMP(%TOKEN","^DBTMP($J")
		}
		
		/* Handle access rights coding.
		   For line testing if no access rights, replace set of ER with
		   throw of err. */
		if x["$$vselectAccess^Record" do {
			
			type String tbl = x.piece("^Record", 2).piece("(", 1)
			
			set x = x.piece(" S ER=1", 1)_ " S $ZE=""0,""_$ZPOS_"",%PSL-E-ACCESS,""_$TR($$^MSG(6754,"""_ tbl_"""),$C(10,44),$C(32,126)),$EC="",U1001,"""
		}

		// Strip the following host variable tests (assumes $G() is at the end !!!!)
		if x["S ER=1" do {
			set x = x.piece(" ",1,2)
			if x [ "$G(" set x =x.piece("$G(",1)_ x.piece("$G(",2,999), x = x.extract( 1, x.length()-1)
		}
		else  if x["'?.N" set x=";"
		
		do openLbl.addExe( x)
	}

	/* Add the QUIT from subroutine through PSLSubrou.addExe().
	   This is done because SQL compare-greater-than-or-equal will generate
	   a jump-forward in case the "equals" does exist. If this occurs at
	   deepest iteration level, the code will "jump out of" the vOpen() code
	   "into" the vFetch() code (to the first line of the code that
	   constructs the result row). Unfortuantely the vL* labels are called
	   with DO vLNa1, whereas vFetchN() is a function that quits 0 or 1.
	   By adding the QUIT through addExe(), the label will occur at the line
	   that contains the QUIT.

	   Note that this implies that exe() code added as part of vFetchN() can
	   only deal with scratch variable replacement, and with calls to
	   already generated labels. It cannot add new labels, neither by
	   back-patching, not by prepending "forward" references.
	   */
	do openLbl.addExe( "Q")

	type Number hvO = openLbl.getLvnMax()

	do openLbl.addCode( " ;")
	do openLbl.addCode(fetchLbl_"(vOid) ;")
	do openLbl.addCode( " ;")
	if protect do openLbl.addCode( " N vd,vi ;=noOpti")

	/* Reserve a line for the declaration of local variables in FETCH
	   section, and remember its value. */
	do openLbl.addCode( " ;")
	type Number newPtrF = openLbl.getLine()

	if vsql(0).get(),'vsql("O").get() do {
		do openLbl.addCode( " I "_ PSL.oLvn_ "(vOid,0)=1 D "_ openLbl.getTag( vsql(0)))
		do openLbl.addCode( " I "_ PSL.oLvn_ "(vOid,0)=2 S "_ PSL.oLvn_ "(vOid,0)=1")
	}
	do openLbl.addCode( " ;")
	do openLbl.addCode( " I "_ PSL.oLvn_ "(vOid,0)=0 S "_PSL.oLvn_"(vOid)="""""_ $select(ftemp:" K ^DBTMP($J,vOid)",1:"")_ " Q 0")
	do openLbl.addCode( " ;")

	for i=codPtr+1:1:exe do {
		set x=exe(i)
		if ftemp do {
			if x["sqlcur" set x=$$VarSub^UCPATCH( x, "sqlcur", "vOid")
			if x["^DBTMP(%TOKEN" set x=$$VarSub^UCPATCH( x, "^DBTMP(%TOKEN", "^DBTMP($J")
		}
		if x["vd", 'protect set x = $$VarSub^UCPATCH( x,"vd", PSL.oLvn_ "(vOid)")
		do openLbl.addExe( x)
	}

	/* If counting requested, insert it here.
	   Note: Since code for SelectDbSet will also use this, and
	   DbSet.getRecord() will go through the standard getRecord code,
	   the rows will be counted twice. We may need to deal with that or
	   we should recognize that we are indeed doing two accesses (one for
	   search and one for the getRecord).
	   Also note that we count by passsing PSL.actual(2), which contains the
	   complete from-clause.
	   */
	if PSL.hasSetting("DEBUG", "DBIOCOUNT") do openLbl.addCode( " D "_ PSL.getSetting("DEBUG", "DBIOCOUNT")_ "("""_ PSL.actual(2)_ """,""READ"")")

	if protect do openLbl.addCode( " S "_ PSL.oLvn_ "(vOid)=vd S "_ PSL.oLvn_ "(vOid,.1)=vi")

	if vsql("O").get() do openLbl.addCode( " S "_ PSL.oLvn_ "(vOid,0)=0")

	/* Insert declarations for temporary vsqlN variables used in the OPEN
	   section ( keyPtr+1 .. hvO) */
	if hvO>keyPtr,'isAgFunc do {
		type Number i
		type String z
		set z="vsql"_(keyPtr+1)
		for i=keyPtr+2:1:hvO set z=z_",vsql"_i

		do openLbl.insCode( newPtrO, " N "_z)
	}

	/* Insert declarations for temporary vsqlN variables used in the FETCH
	   section ( keyPtr+1 .. hvF) */
	type Number hvF = openLbl.getLvnMax()
	if 'ftemp,hvF>keyPtr,'isAgFunc do {
		type Number i
		type String z
		set z="vsql"_(keyPtr+1)
		for i=keyPtr+2:1:hvF set z=z_",vsql"_i

		do openLbl.insCode( newPtrF, " N "_z)
	}

	do openLbl.addCode( " ;")
	do openLbl.addCode( " Q 1")
	quit

	// ---------------------------------------------------------------------
private selectDyn( String select
		, String from
		, String where
		, String orderby
		, String groupby
		, String parlist
		)	// Dynamic SQL statement runtime
	/* ---------------------------------------------------------------------
	Notes on dynamic select in relation to RDB:

	If the environment is not an RDB, the dynamic select code for M will be
	generated.  However, if the environment is an RDB, that means that there
	is the possibility that the select could be against either table(s) mapped
	to M or table(s) mapped to the RDB. If the from-clause is literal, the
	compiler can derive whether the query deals with MDB or RDB.
	If the from-clause is dynamic, code for both cases must be included, and
	the correct path is determined at runtime.

	An additional complication is the data-item protection (DIP) logic. For
	MDB queries (dynamic or not), the DP code is included in the exe()
	array, and will be executed automatically. However for RDB queries, the
	DIP logic must be handled on the PSL side. This includes a call to
	getExe^SQLPROT to obtain the code to execute at runtime, and above all
	it includes a FOR-loop to XECUTE these strings.
	
	Because the majority of the Db.select() occurrences will not include
	DIP, this subroutine will not only separate MDB code from RDB code, but
	will also try to separate RDB code that needs DIP from RDB code that
	does not need DIP.

	This leads to the following subroutines:
	vOpen0R/vFetch0R
		For RDB select without DP
	vOpen0P/vFetch0P
		For RDB select with DP
	vOpen0M/vFetch0M
		For MDB access in RDB environment
	vOpen0/vFetch0
		For (MDB access in) MDB environment, or as general
		dispatcher in case the code needs to defer until runtime

	NOTES:
	. See vResultSet for remarks about 'vOff' and the need to increment its
		value when passed to nested calls.
	*/
	type literal String COMMONFPL = "vSelect,vFrom,vWhere,vOrderby,vGroupby,vParlist,vOff"
	type literal Number SEQ = 0
	type literal String FETCHLBL = "vFetch"_ SEQ
	type literal String OPENLBL  = "vOpen"_ SEQ
	type literal String TAB = 9.char()

	type public String mcode, struct(,,,)
	type public Number msrc

	#ACCEPT CR=27800;Date=2007-10-09;PGM=Frans S.C. Witte;Group=DEPRECATED; use of type()
	type public String type(,)

	/* Make sure scope of var is NEW */
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if $$getScope^UCGM( PSL.var, PSL.varLevel)'="NEW" do PSL.error( "SCOPE: Identifier must be local scope for dynamic SQL:"_ PSL.var) quit
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	type Number varPtr = $$getNew^UCGM( PSL.var, PSL.varLevel)
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do warnGroup^UCGM( "DYNAMIC", "SQL SELECT statement")

	if where="" set where=""""""
	if orderby="" set orderby=""""""
	if groupby="" set groupby=""""""
	if parlist="" set parlist=""""""

	/* Try to derive as much knowledge as possible about the query.
	   In particular:
	   - If it is an MDB query, an RDB query, or unknown
	   - If it uses dataprotection (RDB only)
	   */
	type Boolean isRdb  = Runtime.isRdb
	type Boolean needM  = 1		// assume dynamic MDB code is needed
	type Boolean needP  = isRdb	// is dynamic RDB code with DIP needed?
	type Boolean needR  = isRdb	// is dynamic RDB code needed?
	type String  suffix = ""

	if isRdb do {
		do XvClose^UCDBR()	// always need close cursor code

		/* If literal from not for MDB, don't need to include */
		if from.isLiteral(),$$RsRdb^UCDBRT( from.stripQuotes()) set needM = 0

		/* If literal parlist does not specify /PROT, don't need to
		   include */
		if parlist.isLiteral(),("/"_parlist.stripQuotes())'["/PROT" set needP = 0

		/* Derive subroutine suffix of this call:
		   - if not RDB, the suffix will be empty
		   - else if more than one type of subroutine needed, the suffix will be ""
		   - else the suffix will be as needed.
		   */
		/* Note: with stronger datatyping rules, and proper
		   Boolean.toNumber() and Boolean.toString() methods this will
		   be reformulated using the .toNumber() methods */
		if needM + needR + needP > 1 quit

		if needR set suffix = "R" quit
		set suffix = "P" quit
	}

	if needM do {
		/* Make sure exe and vsql aren't in scope yet.
		   New exe & vsql at the line that var was scoped */
		type String mlvns = ",exe,sqlcur,vd,vi,vsql,vsub"
		type Number pce

		/* Check if any of the variables needed for dynamic select are already
		   in scope. If so, generate an error. Else add to type() */
		for pce = 2:1:mlvns.length(",") do {
			type PSLIdentifier lvn = mlvns.piece( ",", pce)
			
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			if $$getInst^UCGM( lvn) set pce = mlvns.length( ",") do PSL.error("SCOPE: Dynamic SQL variable already used: "_lvn)
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			do typeCrea^UCGM( lvn, "String", varPtr, "NEW", msrc+1, "")
		}
		if varPtr=(msrc+1) do {			// var is instantiated here
			type String f = "N "_ PSL.var
			if mcode[f set mcode = mcode.piece(f)_ f_ mlvns_ mcode.piece(f,2,999)
		}
		else  do patchNew^UCPATCH( PSL.var, mlvns, varPtr)
	}

	type String z = (msrc+1)_ TAB_ SEQ_ suffix_ TAB
	type String selExpr

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	if $$isLit^UCGM(select) do {
		// select is literal (good!). Able to resolve columns
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		if select="""*""", $$isLit^UCGM(from) set select = $$RsSelAll^UCDBRT( from.stripQuotes()).addQuotes()
		set selExpr = $$RsSelList^UCDBRT( select)
		set z = z_ TAB_ selExpr

		if selExpr.length() > PSL.maxLitLength do {

			// Use local var if posible
			type String expr,lvn
			set lvn = "", expr= selExpr.addQuotes()
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			for  set lvn = type( PSL.level,lvn).order() quit:lvn=""  if expr=$$getExpr^UCGM( lvn, PSL.level) quit
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			if '(lvn=""),'($$getScope^UCGM( lvn)="LITERAL") set select = lvn
		}
	}
	else  set selExpr=""

	if struct("s", PSL.subRou, varPtr, PSL.var).exists() do {
		set z.piece( TAB, 2) = ""
		set z.piece( TAB, 5) = SEQ_suffix
		if struct("s", PSL.subRou, varPtr, PSL.var).piece( TAB, 4) '= selExpr set z.piece( TAB, 4) = ""
	}
	set struct("s", PSL.subRou, varPtr, PSL.var) = z

	#ACCEPT GROUP=ACCESS;CR=35741;DATE=2008-10-23;PGM=Frans S.C. Witte
	set PSL.return = "$$"_ OPENLBL_ suffix_ "("_ $SELECT("M"[suffix:".exe,.vsql,",1:"")_select_","_from_","_where_","_orderby_","_groupby_","_parlist_","_($$getLevel^UCGM(PSL.var)-PSL.level+1)_")"

	if isRdb, suffix = "" do {
		// Generate general dispatcher
		if PSL.subrouExists( OPENLBL) quit

		type PSLSubrou sr = PSL.addSubrou( OPENLBL, "(exe,vsql,"_ COMMONFPL_ ")", "RDB dynamic OPEN CURSOR dispatcher", 0)

		do sr.addCode( " I '$$RsRdb^UCDBRT(vFrom) Q $$"_ OPENLBL_ "M(.exe,.vsql,"_ COMMONFPL_ "+1)")
		do sr.addCode( " I ""/""_vParlist[""/PROT"" Q $$"_ OPENLBL_ "P("_ COMMONFPL_ "+1)")
		do sr.addCode( " Q $$"_ OPENLBL_ "R("_ COMMONFPL_ "+1)")
		do sr.addCode( " ;")
		do sr.addCode( FETCHLBL_"(vOid) ; RDB dynamic FETCH dispatcher")
		do sr.addCode( " I vobj(vOid,-5)=0 Q $$"_ FETCHLBL_ "M(vOid)")
		do sr.addCode( " I $D(vobj(vOid,.1))>1 Q $$"_ FETCHLBL_ "P(vOid)")
		do sr.addCode( " Q $$"_ FETCHLBL_ "R(vOid)")
	}
	if needM do {
		// generate MDB dynamic select as vOpen0/vFetch0 (MDB) or vOpen0M/vFetch0M (RDB)
		if isRdb set suffix ="M"

		if PSL.subrouExists( OPENLBL_ suffix) quit

		type PSLSubrou sr = PSL.addSubrou( OPENLBL_ suffix, "(exe,vsql,"_ COMMONFPL_ ")", "Dynamic MDB ResultSet", 0)

		do sr.addCode( " N vOid")
		do sr.addCode( " N ER,vExpr,mode,RM,vOpen,vTok S ER=0 ;=noOpti")
		do sr.addCode( " ;")
		do sr.addCode( " S vExpr=""SELECT ""_vSelect_"" FROM ""_vFrom")
		do sr.addCode( " I vWhere'="""" S vExpr=vExpr_"" WHERE ""_vWhere")
		do sr.addCode( " I vOrderby'="""" S vExpr=vExpr_"" ORDER BY ""_vOrderby")
		do sr.addCode( " I vGroupby'="""" S vExpr=vExpr_"" GROUP BY ""_vGroupby")
		do sr.addCode( " S vExpr=$$UNTOK^%ZS($$SQL^%ZS(vExpr,.vTok),vTok)")
		do sr.addCode( " ;")
		do sr.addCode( " S sqlcur=$O("_ PSL.oLvn_"(""""),-1)+1")
		do sr.addCode( " ;")
		do sr.addCode( " I $$FLT^SQLCACHE(vExpr,vTok,.vParlist)")

		type String code = " E  S vOpen=$$OPEN^SQLM(.exe,vFrom,vSelect,vWhere,vOrderby,vGroupby,"
		set code = code_ "vParlist,"
		set code = code_ ","		// tok
		set code = code_ "1,"		// mode
		set code = code_ ","		// vdd
		set code = code_ "sqlcur)"	// cursor id
		set code = code_ " I 'ER D SAV^SQLCACHE(vExpr,.vParlist) s vsql=vOpen"
		do sr.addCode( code)

		do sr.addCode(" I ER S $ZE=""0,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(RM),$C(10,44),$C(32,126)),$EC="",U1001,""")
		do sr.addCode( " ;")
		do sr.addCode( " S vOid=sqlcur")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,0)=vsql")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,-1)=""ResultSet""")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,-2)=""$$"_ FETCHLBL_ suffix_ "^""_$T(+0)")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,-3)=$$RsSelList^UCDBRT(vSelect)")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,-4)=$G(vsql(""D""))")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,-5)=0")
		do sr.addCode( " Q vOid")

		do sr.addCode( " ;")

		do sr.addCode( FETCHLBL_ suffix_ "(vOid) ; MDB dynamic FETCH")

		do sr.addCode( " ;")
		do sr.addCode( " ; type public String exe(),sqlcur,vd,vi,vsql()")
		do sr.addCode( " ;")
		do sr.addCode( " I vsql=0 S "_PSL.oLvn_"(vOid)="""" Q 0")
		do sr.addCode( " S vsql=$$^SQLF(.exe,.vd,.vi,.sqlcur)")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid)=vd")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,0)=vsql")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,.1)=$G(vi)")
		do sr.addCode( " Q vsql")
	}

	if needP do selectPR("P")	// RDB select with dataprotection
	if needR do selectPR("R")	// RDB select without dataprotection
	quit

	// ---------------------------------------------------------------------
private selectPR( String suffix	// "P" for RS with dp, "R" for RS without DP
		)	// support subroutine to generate vOpen0P / vOpen0R
	/* ---------------------------------------------------------------------
	Support subroutine that generates the vOpen0P and vOpen0R subroutines
	
	This subroutine essentially uses the value "P" to include or exclude
	code for data protection.
	*/
	type literal String COMMONFPL = "vSelect,vFrom,vWhere,vOrderby,vGroupby,vParlist,vOff)"
	type literal String FETCHLBL  = "vFetch0"
	type literal String OPENLBL   = "vOpen0"

	if PSL.subrouExists( OPENLBL_ suffix) quit

	type PSLSubrou sr = PSL.addSubrou( OPENLBL_ suffix, "("_ COMMONFPL, "Dynamic RDB ResultSet with"_ ("out".piece(";",suffix'="P"))_ " dataprotection", 0)
	type String dpi()

	do sr.addCode( " N vExpr,vMap ;=noOpti")

	if suffix = "P" do {
		do sr.addCode(" N vDipx I (""/""_vParlist)[""/PROT"" N vQual D PARSPAR^%ZS(vParlist,.vQual),getExe^SQLPROT(vFrom,.vSelect,.vDipx,.vQual) ;=noOpti")
		set dpi(1) = "; need data protection"
	}

	/* Insert call to convert DQ query toRDB query */
	do sr.addCode( " S vExpr=$$RsDyRT^UCDBRT(vSelect,vFrom,vWhere,vOrderby,vGroupby,vParlist,.vMap)")


	do selSrOpen^UCDBR(  sr, FETCHLBL_ suffix, "@,vExpr,vMap,vDipx", dpi())
	do selSrFetch^UCDBR( sr, FETCHLBL_ suffix, 10, dpi())
	quit

	// ---------------------------------------------------------------------
selectRecords	// method Db.selectDbSet; returns DbSet
	/* ---------------------------------------------------------------------
	Transform into Db.select() and process it through select^UCDB
	*/
	type public PSLTable pslTbl()

	if PSL.actual(1).isNull() do PSL.error("Table Parameter Required") quit

	type PSLTable td = PSL.cachePSLTable(pslTbl(), PSL.actual(1).stripQuotes(), 0)
	type List   keys = td.primaryKeys

	if keys.isNull() do PSL.error("Unsupported table in DbSet class: "_ td.table) quit

	/* Convert parameters in PSL.actual() to match parameters expected by
	   select^UCDB */
	set PSL.actual(6) = ""			// no qualifiers
	set PSL.actual(5) = ""			// no GROUP BY
	set PSL.actual(4) = PSL.actual(3)	// ORDER BY from 3 to 4
	set PSL.actual(3) = PSL.actual(2)	// WHERE from 2 to 3
	set PSL.actual(2) = PSL.actual(1)	// FROM form 1 to 2
	set PSL.actual(1) = keys.toString().addQuotes()	// SELECT from primaryKeys

	do select
	set PSL.class = "DbSet"

	quit

	/* ================================
	The following section was designed to optimize processing by
	replacing the record building logic with references to the 
	keys directly.  It pushed the result one row ahead and needs work.
	Related subroutine is getRecord^UCRESULT

	set z=$G(type(varLevel,var,"fetch")),sub=$P(z,tab,1)
	if sub="" do ERROR^UCGM("Method compile error: "_$ZPOS) quit
	set f=tab_"S "_oLvn_"(vOid)=",d="_$C(9)_"

	set n=""
	for  set n=$O(append(sub,n),-1) quit:n=""  if append(sub,n)[f quit
	if n="" do ERROR^UCGM("Method compile error: "_$ZPOS) quit

	set z=append(sub,n),append(sub,n)=tab_";"

	set z=$E(z,$F(z,f),$L(z))
	for i=1:1:$L(z,d) set type(varLevel,var,"fetch",$P(keys,",",i))=$P(z,d,i)
	quit
	*/

	// ---------------------------------------------------------------------
private sql2akey( PSLTable td		// table descriptor
		, String where		// where clause
		)
	/* ---------------------------------------------------------------------
	Support function that translates the supplied where-clause into an
	accesskey (or into "", when the where-clause does not match the primary
	key of the table).
	
	OUTPUTS:
	. $$ = If the where-clause identifies the primary key, then the access
		key specification
		Else ""

	NOTES:
	. This function has the following limitations:
		- It expects boolean expressions that follow the pattern
			COLNAME = valexpr
		- It uses $$nextExpr^UCGM() to deal with the valexpr.
		  Unfortunately nextExpr^UCGM expects a PSL expression, whereas
		  valexpr is a SQL value expression. As usual the strlits are a
		  problem in this context.
		To deal with this, the following is used:
		- it calls $$TOKEN^%ZS(,,"'") to indicate SQL strlits
		- it calls $$nextExpr^UCGM(,,"",1) to prevent untokenizing
		- it calls $$sql2psl(SQLstrlits) to convert SQL strlits to PSL
		- it returns the untokenized value (after SQL-to-PSL convert)
	*/
	type String strlits
	type String akey

	if where.isNull() quit ""
	do {
		catch xcpt {
			set akey = ""
		}
		type String col
		type String key()
		type List   pkl = td.primaryKeys
		type String pred
		type Number prnr

		set akey = ""
		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set where = $$TOKEN^%ZS( where, .strlits, "'")

		for prnr=1:1:where.length(" AND ") do {
			set pred = where.piece(" AND ",prnr)
			set col = pred.piece("=").trim(0)
			set pred = pred.extract( pred.find( "="), pred.length()).trim(0)

			if 'pkl.contains( col) throw Class.new( "Error", "%PSL-E-INTERNAL,not a keycolumn")
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			if $$nextExpr^UCGM( pred, 0, "", 1) '= pred throw Class.new( "Error", "%PSL-E-INTERNAL,not a simple predicate")

			set key(col) = ""
			if 'akey.isNull() set akey = akey_ ","
			set akey = akey_  col_ "="_ pred
		}

		/* Note that condition below catches pkl.isNull() as well */
		if prnr'=pkl.count() throw Class.new( "Error", "%PSL-E-INTERNAL,invalid number of predicates")
		for prnr=1:1:pkl.count() if 'key( pkl.elementAt(prnr)).exists() throw Class.new( "Error", "%PSL-E-INTERNAL,missing keycolumn")

		#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
		set akey = $$UNTOK^%ZS(akey, $$sql2psl( strlits)).addQuotes()
	}
	quit akey

	// ---------------------------------------------------------------------
private sql2psl( String lits	// strlit tokens as produced by $$TOKEN^%ZS()
		)	// translate SQL strlits to PSL strlits
	/* ---------------------------------------------------------------------
	Support function that translates the single-quote delimited SQL strlits
	in lits to double-quote delimited PSL strlits.
	
	OUTPUTS:
	. $$ = The PSL version of all the strlits in lits
	*/
	type Number elm
	type String lit

	for elm=1:1:lits.length( 1.char()) {
		set lit = lits.piece( 1.char(), elm)
		quit:lit.extract() '= "'"
		set lits.piece( 1.char(), elm) = lit.stripQuotes("'").addQuotes()
	}
	quit lits

	// ---------------------------------------------------------------------
update	// void; Db.update(Table_name,column_expr,where_clause,filer_qualifier)
	/* ---------------------------------------------------------------------
	INPUTS:
	. actual(1) = table name (literal)
	. actual(2) = column expression (literal)
	. actual(3) = whereclause (literal)
	. actual(4) = filer qualifiers (literal)

	NOTES:
	. This subroutine used to call $$fileQual("Db.update",) and inserted the
		result in the generated call to Record.save().
		Because save^UCRECORD will also call $$fileQual(), two different
		set of values were added. This resulted in potential problems,
		as UCUTILN will not deal with duplicate qualifiers (e.g. insert
		/VALFK if the list already contains /VALFK). To prevent these
		problems $$filequal() will not be called here any more.
		This implies that the following qualifiers will no longer be
		processed:
		1) pslPrsr("SQLPARS") for Db.insert()
		2) parameters added due to prsr("DEBUG","FILEQUAL")="Db.update"
	. The treatment of the individual update expressions has a number of
		weakspots:
		- because the list is not tokenized, commas inside SQL strlits
			will blow up the interpretation
		- the conversion of SQL strlit to PSL strlit will fail the SQL
			strlit contains the SQL single quote or the PSL double
			quote.
		- constructs like COL = COL + :HV will only work if the spelling
			of COL is consistent across the entire expression. They
			will not work when SQL strlits occur in the expression,
			and they are vulnarable to operator precedence
			misconceptions.
	. The code generated for this method could be optimized even more:
		- on RDB, if the filer can be bypassed, a single SQL statement
			could be passed.
	*/
	type public PSLTable pslTbl()

	type String table = PSL.actual(1).stripQuotes()	// Table name
	type String updex = PSL.actual(2).stripQuotes()	// Column expression
	type String where = PSL.actual(3).stripQuotes() // where clause
	type String qual =  PSL.actual(4)		// Run-time qualifiers
	type String sqlstat = "UPDATE "_table_" SET "_updex
	
	if 'where.isNull() set sqlstat = sqlstat_ " WHERE "_ where
	
	type String auditParam = "0"

	type PSLTable td = PSL.cachePSLTable( pslTbl(), table, 0)
	type PSLBuffer buf = PSL.openBuffer( "()", sqlstat)

	type String akey = $$sql2akey( td, where), indent = ""
	type Boolean oneRow = 'akey.isNull() ! td.primaryKeys.isNull()
	
	/* Add check for audit logging - do not make table specific to avoid
	   mass recompiles. */
	if $$usingAuditLog^SQLAUDIT do {
		
		type String hostVars = where
		
		// Add update columns expression to where clause to capture host variables
		if 'updex.isNull() do {
		
			type String tok, upd
			
			#ACCEPT DATE=06/18/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
			set upd = $$TOKEN^%ZS(updex, .tok)
			#ACCEPT DATE=06/18/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
			set upd = $$UNTOK^%ZS(upd.replace(",", " AND "), tok)
			
			if hostVars.isNull() set hostVars = upd
			else  set hostVars = hostVars_ " AND ("_ upd_ ")"
		}
		
		set auditParam = $$addAuditLogCode("UPDATE", buf, td, sqlstat, hostVars)
	}

	// Build database set resultset + Db.getDbSet or Db.getRecord()
	if oneRow {
		do buf.add( "type Record"_table_" vRec = Db.getRecord( """_table_""","_ akey_ ",1)")
		do buf.add( "quit:vRec.getMode()=0")
	}
	else  {
		set indent = "  "
		do buf.add( "type DbSet vSet = Db.selectDbSet( """_table_""", """_where_""")")
		do buf.add( "while vSet.next() {")
		do buf.add( "  type Record"_table_" vRec = vSet.getRecord( """_table_""")")
	}
	do buf.add( indent_"do vRec.setAuditFlag(1)")

	// Build code to deal with individual columns being updated
	type Number I
	type String expr,value
	for I=1:1:updex.length(",") do {
		set expr=updex.piece(",",I)
		
		/* lvn 'value' will contain the assignment expression.
		   Because it will be treated as a PSL expression, all colons
		   in front of HOSTVARs must be removed.
		   */
		set value = expr.piece("=",2).translate(":","")
		
		if value.extract(1)="'" set value=""""_ value.extract(2, value.length()-1)_""""
		else  if value?.P set value=""""_value_""""

		set expr=expr.piece("=",1)
		//if $p(expr,"=",1)["." set expr=$p($p(expr,"=",1),".",2)_$p(expr,"=",2)
		if expr["." set expr = expr.piece( ".", 2)

		/* FSCW CR27800: Code below deals with constructs like:
			[COL =] COL + :HV
		   and translates them to
		   	[COL =] vRec.COL + :HV
		   Note that this translation only works if the spelling of COL
		   on the right side matches the spelling of COL on the left
		   side!
		   */
		if value?.E1P.E,value'["%",value'["""" do {
			type Number ptr
			type String temp
			set temp=value
			set ptr=temp.find(expr)
			//set value=$s(ptr-$l(expr)=1:"",1:$e(temp,1,ptr-$l(expr)-1))_"vRec."_$e(temp,ptr-$l(expr),1000)
			set value=temp.extract(1,ptr-expr.length()-1)_"vRec."_temp.extract(ptr-expr.length(),1000)
		}

		//set $p(expr,"=",1)=$$LOWER^%ZFUNC($P(expr,"=",1))
		set expr = expr.lowerCase()

		/* FSCW CR27800: Since expr does not contain "=" any more, the
		   next line is a no-op:
		if $e($p(expr,"=",2),1)="'" set $p(expr,"=",2)=""""_$e($p(expr,"=",2),2,$l($p(expr,"=",2))-1)_""""
		*/

		do buf.add( indent_"set vRec."_expr_"="_value)
	}

	// save the data and end the subroutine
	if 'td.isRdb do {
	
		do addMSaveBypass(buf, table, "vRec", qual, auditParam)
	}
	else  do buf.add( indent_"do vRec.save("_ qual_ ")")

	if 'oneRow do buf.add("}")
	do buf.add("quit")

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	do autoERRM^UCGM()

	// create label and insert code
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set PSL.return = $$findSubr^UCGM("vDbUpd","")	// Get next tag name
	do buf.insert( PSL.return, "void")
	set PSL.return = PSL.return_ "()"

	quit

	/* ****************************************************************** */
	/* CODE BELOW HAS NOT YET BEEN CONVERTED TO PSL			      */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
akey2sql( String akey
		, String fkeys
		, Number knum
		)	// void; access key to SQL whereclause
	/* ---------------------------------------------------------------------
	ARGUMENTS:
	. akey = the access key
		This function supports the following styles:
		* COLUMNNAME=:HOSTVAR
		* COLUMNNAME=:HOSTVAR simpleExprTail
		* COLUMNNAME='literal'
		* COLUMNNAME="literal" (discouraged)
		* COLUMNNAME=HOSTVAR (deprecated)
		* HOSTVAR (deprecated)
	. fkeys = ordered list of key columns
	. knum = optional variable that will receive the number of keys in
		akey. The caller can use this variable to detect if all keys
		were included.

	OUTPUTS:
	. $$ = the SQL whereclause that corresponds to the access key.
	. knum = number of keys in akey
	*/
	type String atom,expr,tok,val,where
	type Number ptr

	set knum = 0, ptr = 0
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set expr = $$TOKEN^%ZS(akey,.tok).translate( " "), where = ""

	#ACCEPT CR=18163; DATE=2005-11-24; PGM=FSCW; GROUP=BYPASS
	#BYPASS
	;
	for  set atom=$$ATOM^%ZS(expr,.ptr,",",tok,1) do  if ptr=0 quit
	.	;
	.	if atom="," quit
	.	set knum=knum+1
	.	if atom="" quit
	.	if where'="" set where=where_" AND "
	.	;
	.	; FSCW CR11441
	.	; In case the list contains other SQL compare operator, and no
	.	; spaces (eg single condition COLNAME>value)
	.	if $tr(atom,"<>")'=atom set where=where_atom quit
	.	;
	.	if atom'["=" set atom=$P(fkeys,",",knum)_"="_atom
	.	set val=$P(atom,"=",2),val=$$UNTOK^%ZS(val,tok)
	.	; for backward compatibility on hostvars
	.	if $E(val)'=":",'("'"[$E(val)),'$$isLit^UCGM(val) set val=":"_val
	.	if $E(val)="""" set val=$$QADD^%ZS($$QSUB^%ZS(val,""""),"'")
	.	set where=where_$P(atom,"=",1)_"="_val
	#ENDBYPASS
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	quit $$UNTOK^%ZS(where,tok)

	// ---------------------------------------------------------------------
getGbl(gblref,keyvars)	// void; Return Global reference
	/* ---------------------------------------------------------------------
	ARGUMENTS:
	. gblref = global reference as stored in DBTBL1
		E.g. PSLTable.global
	. keyvars = list of primary key variables
		A comma separated list of key values to be used in the
		construction of the reference. Literals shall be tokenized by the
		caller.
		The number of primary key variables determines how much of the
		total global reference is constructed and returned.

	OUTPUTS:
	. $$ = global reference with all supplied keyvars inserted, and
		remaining key levels dropped.

	NOTES:
	. The only call to this subroutine comes from toString^UCRECORD.
	*/
	type Number i,keyNum,ptr
	type String gkey,gkeys,ref,return,tok

	#ACCEPT CR=18163; DATE=2005-11-24; PGM=FSCW; GROUP=BYPASS
	#BYPASS
	;
	set gkeys=$$TOKEN^%ZS($P(gblref,"(",2,999),.tok)
	set return=$P(gblref,"(",1)
	;
	; ptr is used as character pointer in keyvars.
	set keyNum=0,ptr=0
	if gkeys'="" set return=return_"(" for i=1:1:$L(gkeys,",") do
	.	;
	.	set gkey=$$UNTOK^%ZS($P(gkeys,",",i),.tok)
	.	if $$isLit^UCGM(gkey) set return=return_gkey_"," quit
	.	;
	.	if keyNum,ptr=0 set i=$L(gkeys,",") quit  ; Partial
	.	;
	.	set keyNum=keyNum+1
	.	;;if lvn'="" S ref=lvn_keyNum
	.	;;;
	.	;;; FSCW CR14919: need to untokenize literal keys!
	.	;;;;E  S ref=$$ATOM^%ZS(akeys,.ptr,",",tok,1) I ptr S ptr=ptr+1
	.	;;E  S ref=$$ATOM^%ZS(akeys,.ptr,",",tok,0) I ptr S ptr=ptr+1
	.	;
	.	; extract next keyvar, which may be subscripted
	.	; if not yet at end-of-string, skip comma
	.	set ref=$$ATOM^%ZS(keyvars,.ptr,",",,1) if ptr set ptr=ptr+1
	.	;;if $E(ref)="'" S ref=""""_$P(ref,"'",2)_""""
	.	set return=return_ref_","
	;
	if $E(return,$L(return))="," set return=$E(return,1,$L(return)-1)_")"
	#ENDBYPASS
	quit return

	// ---------------------------------------------------------------------
private mapPSLvar( String expr
		)	// local String; Map PSL variables into SQL variables
	/* ---------------------------------------------------------------------
	Map PSL variables into SQL variables.
	
	OUTPUTS:
	. $$	This function returns an edited form of the supplied expression
		in which every occurrence of :PSLExprAtom is mapped to a valid
		SQL host variable name.

	NOTES:
	. This function first tokenizes SQL literals, then tokenizes PSL
		literals. The need for the first is obvious. The need for the
		second follows from the fact that the :PSLExprAtom may contain
		a construct that contains PSL literals. Because the single quote
		could be interpreted either as a SQL string literal delimiter or
		as the PSL unary NOT operator, the order of applying the calls
		to $$TOKEN^%ZS() is relevant. The current order assigns the SQL
		role of the quote a higher precedence than the PSL role of the
		quote. This effectively excludes the use of the PSL unary NOT
		from :PSLExprAtom, which seems reasonable.
	. As of CR14185, this function will treat all SQL binary operators as
		valid delimiters of the token to replace. This reduces the
		PSL Expression passed to $$valExpr^UCGM() to a SQL expression
		atom. Note that (SQL) binary operators inside parenthesis will
		be part of the atom passed to $$valExpr^UCGM() because the call
		to $$ATOM^%ZS() does not include the parenthesis in the list of
		delimiters.
	*/
	type Number i, y
	type String addnew, addset, atom, code, class, lvn, tok

	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set expr = $$TOKEN^%ZS( expr, .tok, "'")
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	set expr = $$TOKEN^%ZS( expr, .tok, """")
	set y = 0, addnew = "", addset = ""

	#ACCEPT CR=18163; DATE=2005-11-24; PGM=FSCW; GROUP=BYPASS
	#BYPASS
	for  set y=$F(expr,":",y) quit:y=0  do
	.	;
	.	; FSCW CR14185: All SQL binary operators shall delimit token
	.	;;set atom=$$ATOM^%ZS($E(expr,y,$L(expr)),0,",",tok,1)
	.	set atom=$$ATOM^%ZS($E(expr,y,$L(expr)),0,"+-*/|<>=,",tok,1)
	.	if $E(atom,$L(atom))=")" for  quit:$L(atom,"(")=$L(atom,")")  set atom=$E(atom,1,$L(atom)-1)
	.	if $$isVar^UCGM(atom),'(atom?.e1L.e) quit
	.	;
	.	;;set code=$$valExpr^UCGM(atom,.class,,0)
	.	set code=$$valExpr^UCGM(atom,.class)
	.	;
	.	; FRS - 07/01/03 - Add Support for Literal
	.	if $$isLit^UCGM(code) do  quit		; Literal type
	..		set expr=$E(expr,1,y-2)_$$QSWP^%ZS(code,"""","'")_$E(expr,y+$L(atom),$L(expr))
	..		set y=y+$L(atom)-$L(code)
	.	;
	.	if $$isVar^UCGM(code)&'(code?.e1L.e) do  quit
	..		set expr=$E(expr,1,y-1)_code_$E(expr,y+$L(atom),$L(expr))
	..		set y=y+$L(atom)-$L(code)
	.	;
	.	for i=1:1 set lvn="V"_i  quit:$$getNew^UCGM(lvn)=""
	.	;;do setScop^UCGM(lvn,level,msrc,"NEW")
	.	do setScope^UCGM(lvn,"","","NEW","Primitive")
	.	do setInst^UCGM(lvn,$$getDcLnr^UCGM,"")
	.	;
	.	set expr=$E(expr,1,y-1)_lvn_$E(expr,y+$L(atom),$L(expr))
	.	set y=y-$L(atom)+$L(lvn)
	.	;
	.	if addnew="" set addnew=lvn,addset=lvn_"="_code
	.	else  set addnew=addnew_","_lvn,addset=addset_","_lvn_"="_code
	;
	if '(addnew="") d
	.	if $e(mcode,$L(mcode))="," set mcode=$e(mcode,1,$l(mcode)-1)_"   "
	.	if $e(mcode,$L(mcode)-1)="."!(mcode=$C(9)) set mcode=mcode_"   "
	.	set mcode=$E(mcode,1,$L(mcode)-2)_" N "_addnew_" S "_addset_" "_$select(cmd="quit":"",1:$$UPCASE^UCGM($E(cmd))_" ")
	#ENDBYPASS
	
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte	
	set expr=$$UNTOK^%ZS(expr,.tok)
	quit expr
 #OPTION ResultClass ON
public String vSIG()	quit "61473^50060^Frans S.C. Witte^180506"	// Signature - LTD^TIME^USER^SIZE
