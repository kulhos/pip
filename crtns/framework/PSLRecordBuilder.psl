	#PACKAGE framework.psl
	#CLASSDEF extends=Primitive delimiter=9 public
	/*
	
	---- Comments --------------------------------------------------------
	The PSLRecordBuilder class is used to generate the source code for
	RecordTABLE classes.
	
	***** IMPORTANT NOTES *****
	
	ON CODING PSLRecordBuilder:
	Because the PSL methods	Class.new("RecordTABLE") and Db.getRecord() now
	invoke methods in the RecordTABLE code, PSLRecordBuilder cannot use
	these methods.  This includes use of the Db.Cache(), since it uses
	Db.getRecord.  Coding must use Db.select.
	
	ON BOOTING PSL:
	A very reduced copy of RecordDBTBL1.m and RecordDBTBL1D.m are
	maintained to be released to support the booting processing since
	the getRecord() method of each class is used early in the process.
	The one version should encompass both M and RDB access.

	***** END NOTES *****
	
	Every table will have a RecordTABLE class generated which will
	implement a set of public methods (e.g. vSave(), vBypassSave(), etc.)
	as well as various private methods to support these.  RecordTABLE
	code includes the action previously performed by the "filers" (e.g.,
	trigger execution, index and journal management), new methods, as
	well as incorporation of any user extensions from DBTBL25 procedures
	with the name RecordTABLE.
	
	PSLRecordBuilder is invoked by PSLParser if it is asked to generate
	RecordTABLE code, using method build().
	
	All variables used in the RecordTABLE code that have scope which could
	expose them to trigger code will begin with vRC and have at least one
	other lowercase character.  (RC = Record Code).
	
	Private methods will also start with vRC, allowing triggers to use
	labels that are all upper case, avoiding conflicts.  This will also
	avoid conflict with public methods, none of which will be all upper
	case.  Methods defined by user extensions should use names that	do
	not start with "v" and are not all upper case.
	
	Note that RecordTABLE classes only have columns as properties.  Anything
	else must be implemented as methods.
	
	Standard public methods generated into RecordTABLE code:
		
	  - Access authorization methods - vinsertOK(), vupdateOK(), vdeleteOK(), vselectOK()
	  - Access rights methods - vinsertAccess(), vupdateAccess(), vdeleteAccess(), vselectAccess()
	  - archive()
	  - vcheckAccessRights()
	  - Column list methods - columnList(), columnListBM()
	  - vhasLiterals()
	  - Index methods - updateIndexes (was VINDEX), 
	  		    rebuildIndexesAllRecs (was VIDXBLD),
	  		    rebuildIndexes (was VIDXBLD1)
	  - Logging methods - getLogging(), log(), logSelect()
	  - vcdmNew()
	  - Save methods - vSave(), vBypassSave()
	  
	Possible useful new methods for use in Record Class code:
	
		Record.audit(String audit()) - replace AUDIT^UCUTILN
		
		Record.isChangedNode(String node)) - replace 'vobj(dep,-100,49,"").order().isNull()
		
		Record.nodeExists(String node)) - replace vobj(dep,1).exists()
			[used for both M and RDB tables]
	

	---- Revision History ------------------------------------------------
	2009-06-09 - RussellDS - CR40921
		* Added code to strip leading or trailing (after decimal)
		  zeros from N and $ data types prior to filing, as part
		  of validateDD.  Added validateDD1 to move validation of
		  changes into filers instead of calling VDDUX^DBSFILER.
	
	2009-04-14 - RussellDS - CR39504
		* Added validation for data type "U"
	
	2009-04-02 - RussellDS - CR39242
		* Modified to generate public methods as final, unless the
		  table is a parent table.
	
	02/17/2009 - RussellDS - CR38301
		* Modified buildchkRequired to include keys in required
		  checking for insert.
	
	02/02/2009 - RussellDS - CR37982
		* Modified addRDBsaveCode to include check if table is parent
		  to determine if rdbSaveC or rdbSaveS is appropriate call.
	
	01/27/2009 - RussellDS - CR37914
		* Fixed problem with key change code where it wasn't checking
		  to see if record being changed to already exists.
	
	01/07/2009 - RussellDS - CR37434
		* Fixed problem in getJournalCode section related to incorrect
		  checking of oldNewFM
	
	2008-12-29, Frans S.C. Witte, CRs 35741/37405
		* Modified getTriggerCode() to generate setAuditFlag(true) for
		  formal parameter (in addition to generating it for 'this').

	12/01/2008 - RussellDS - CRs 35741/36952
		* Modified buildtriggers section to not use .isChanged()
		  method for insert or delete triggers.
		* Modified getIndexCode to use 254.byte() to handle
		  UTF-8 environments.
		* Modified to allow column names to support underscores.
		* Fixed problem with triggers where insert and delete triggers
		  were doing column checking.  Does not apply for those types
		  of triggers.
		  
	10/24/2008 - RussellDS - CRs 35741/35918
		* Corrected delimiterStr to exclude adding quotes when form
		  is .char()
		* Replaced use of SETERR^DBSEXECU with Runtime.setErrMsg,
		  except in bypass code
		* If compiling for booting, do not include calls to UCLREGEN.
	
	01/25/2008 - RussellDS - CR30801
		Created.  Note that much of this code was originally part of
		the filer generator (DBSFILB, DBSINDXB, DBSJRNC, DBSTRG, and
		DBSFILARCH).
	*/

	
	// ---------------------------------------------------------------------
	#PROPERTYDEF tableName class=String position=2 public readonly
		/* -------------------------------------------------------------
		The name of the table, upper case.
		
		This propery is populated on instantiation.
		*/
		
	// ---------------------------------------------------------------------
	#PROPERTYDEF tableNameLC class=String position=3 public readonly
		/* -------------------------------------------------------------
		The name of the table, lower case.
		
		This propery is populated on instantiation.
		*/
		
	// ---------------------------------------------------------------------
	#PROPERTYDEF delimiterStr class=String position=4 private
		/* -------------------------------------------------------------
		The string representation of the table's delimiter.
		
		This propery is populated on instantiation.
		*/
		
	// ---------------------------------------------------------------------
	#PROPERTYDEF triggerSeq = 1 class=Number position=5 private
		/* -------------------------------------------------------------
		Trigger sequence counter.  Used to assign trigger labels.
		*/
		
	// ---------------------------------------------------------------------
	#PROPERTYDEF indexSeq = 1 class=Number position=6 private
		/* -------------------------------------------------------------
		Index sequence counter.  Used to assign index labels.
		*/
		
	// ---------------------------------------------------------------------
	#PROPERTYDEF checkAccessRights class=List position=7 private
		/* -------------------------------------------------------------
		Access rights to check.  Used in various code building
		sections.
		*/
		
	// ---------------------------------------------------------------------
	#PROPERTYDEF auditLog class=List position=8 private
		/* -------------------------------------------------------------
		Audit log considerations.  Used in buildSave section.
		*/
			
	// ---------------------------------------------------------------------
	#PROPERTYDEF hasMoB class=Boolean position=9 private
		/* -------------------------------------------------------------
		The table has memo(s) and/or blob(s).  I.e., at least one.
		*/
		
	// ---------------------------------------------------------------------
	#PROPERTYDEF children class=List position=10 private
		/* -------------------------------------------------------------
		Children, if any, of this table.  If not null, this also
		indicates that this is a parent table.  If table is not a parent
		table, public methods will be final to avoid polymorphism
		overread since we do not want them overridden anyway.
		*/
		
	// ---------------------------------------------------------------------
	#PROPERTYDEF td class=SchemaTable node="td" private
		/* -------------------------------------------------------------
		Sections that are necessary to build for this table.
		
		This property is populated on instantiation - see the
		getSections() method.
		
		Possible members of the list are indexes, required, foreignKeys,
		defaults, journals, cascadeDelete, BI, BU, BD, AI, AU, AD,
		triggers, BUKO, AUKO, literals.
		
		Since not all private methods (sections) need to be built for
		a particular RecordTABLE, this list indicates which are needed.
		For example, if there are no before update triggers, there is
		no need to build methods associated with before update (BU)
		trigger invocation.
		*/
		
	// ---------------------------------------------------------------------
	#PROPERTYDEF sections class=List node="sections" private
		/* -------------------------------------------------------------
		Sections that are necessary for this table.
		
		This property is populated on instantiation.
		
		List may include - indexes,required,foreignKeys,defaults,journals,
				   cascadeDelete,triggers,literals,
				   BI,BU,BD,AI,AU,AD,BUKO,AUKO
		*/
		
	// ---------------------------------------------------------------------
	#PROPERTYDEF triggerAllIfConds() class=String node="trigAllIf" private
		/* -------------------------------------------------------------
		If all triggers of a specific type (BI, BU, BD, AI, AU, AD) have
		if conditions (DBTBL7.IFCOND), which indicate conditional
		inclusion in the RecordTABLE code, all the if condition values,
		joined by AND, will be in the respective subscript of this array.
		(1=BI, 2=BU, 3=BD, 4=AI, 5=AU, 6=AD).
		
		This information is used to build a #IF around the need to
		invoke before insert trigger processing.
		
		This property is populated on instantiation by the getSections
		method.
		*/
		
	// ---------------------------------------------------------------------
	#PROPERTYDEF trigBI   = 1 class=Number private literal
	#PROPERTYDEF trigBU   = 2 class=Number private literal
	#PROPERTYDEF trigBD   = 3 class=Number private literal
	#PROPERTYDEF trigAI   = 4 class=Number private literal
	#PROPERTYDEF trigAU   = 5 class=Number private literal
	#PROPERTYDEF trigAD   = 6 class=Number private literal
	#PROPERTYDEF trigDESC = "BI,BU,BD,AI,AU,AD" class=String private literal
		/* -------------------------------------------------------------
		Literals - used for indexes to location of trigger code in
		various arrays or strings
		*/

	// ---------------------------------------------------------------------
	#PROPERTYDEF oLvn = "vobj"	class=String public literal
		/* -------------------------------------------------------------
		This is a temporary property for Version 3 that lacks the PSL2M
		class. Because the methods of this class also call UC* modules
		that expect the public lvn oLvn, that variable is created in
		build() as well.
		*/
	
	// ---------------------------------------------------------------------
private void initialize( Object tableName)	// Constructor
	/* ---------------------------------------------------------------------
	The initialize method will set the name property.
	
	If running in boot phase, want to ignore various checks, like access
	rights and audit logging, and will not build triggers, journals or
	indexes to avoid references to the tables that control those.
	*/
	
	type String delimStr
	
	type SchemaTable td = Db.getSchemaTable(tableName)
	
	set this.td = td
	
	set this.tableName = {String}tableName
	set this.tableNameLC = {String}tableName.lowerCase()
	
	// Set delimiterStr
	if ((td.columnDelimiter < 32) or (td.columnDelimiter > 127)) set delimStr = (td.columnDelimiter_ ".char()")
	else  set delimStr = td.columnDelimiter.char().addQuotes()
	set this.delimiterStr = delimStr

	set this.checkAccessRights = td.checkAccessRights(true)
	if $$usingAuditLog^SQLAUDIT set this.auditLog = td.getLogging(true)
	else  set this.auditLog = false
	
	// Init sections list
	do this.getSections()
	
	set this.hasMoB = (td.hasMemo or td.hasBlob)
	
	// Get children, if any
	set this.children = Class.new("List")

	type ResultSet rs = Db.select("FID", "DBTBL1", "%LIBS='SYSDEV' AND PARFID=:this.tableName")
	
	while rs.next() set this.children = this.children.add(rs.getCol("FID"))
	
	quit
	
	
	// ---------------------------------------------------------------------
	/* *PSLdoc
	 * Build Record Class code for all tables.
	 * The PSLRecordBuilder.buildAll() method will construct RecordTABLE
	 * code for all tables defined in DBTBL1.
	 *
	 * @return	void
	 * @since 	V3.1
	 * @example
	 *		type static PSLRecordBuilder
	 *		do PSLRecordBuilder.buildAll()
	 */
	
public static void buildAll()
	// ---------------------------------------------------------------------
	
	type Number errCnt = 0

	type ResultSet rs = Db.select("FID", "DBTBL1")
	
	while rs.next() set errCnt = errCnt + $$run^PSLC("--element=Record"_ rs.getCol("FID")_ "~Filer Record"_ rs.getCol("FID"))
	
	quit
	
	
	// ---------------------------------------------------------------------
	/* *PSLdoc
	 * Build Record Class code for indicated table.
	 * The PSLRecordBuilder.build() method will construct the RecordTABLE
	 * code in the provided PSLTokenizer object.
	 *
	 * @return	void
	 * @since 	V3.1
	 * @example
	 *		type PSLRecordBuilder rb = Class.new("PSLRecordBuilder", tbl.upperCase())
	 *		do rb.build(tknzr)
	 */
	
public void build(PSLTokenizer tknzr)	// Tokenizer to contain code
	// ---------------------------------------------------------------------		 
	
	type String source()				// For use by various build methods
	type String tableName = this.tableName
	
	// Needed by calls from it, e.g., UCDB
	type String oLvn = this.oLvn
	
	do tknzr.appendLine("")
	do tknzr.appendLine(" // Record Class code for table "_ tableName)
	do tknzr.appendLine("")
	do tknzr.appendLine(" // Generated by PSLRecordBuilder on "_%CurrentDate.toString()_ " at "_ %CurrentTime.toString("24:60")_" by "_ %UserID.get())
	do tknzr.appendLine("")
	
	/* See, for example, DBSMDD, MDDPBS, OVR, and PBSTSSP.  These are 
	   tables definitions used for purposes other than physical tables.  */
	if 'this.td.isRdb, this.td.global.isNull() do this.addLine(source(), " // No global - no class") quit
	
	do this.buildnew(source())
	do tknzr.appendSrc(source())
	
	do this.buildgetRecord(source())
	do tknzr.appendSrc(source())
	
	do this.buildbypassSave(source())
	do tknzr.appendSrc(source())
	
	do this.buildsave(source())
	do tknzr.appendSrc(source())
	
	do this.buildcheckAccessRights(source())
	do tknzr.appendSrc(source())
	
	/* Audit logging is only applicable for a table in an MDB */
	if 'this.td.isRdb do {
		
		do this.buildlogMethods(source())
		do tknzr.appendSrc(source())
	}
	
	do this.buildcolumnLists(source())
	do tknzr.appendSrc(source())
	
	do this.buildvlegacy(source())
	do tknzr.appendSrc(source())
	
	do this.buildhasLiterals(source())
	do tknzr.appendSrc(source())
	
	do this.buildmiscValidations(source())
	do tknzr.appendSrc(source())
	
	do this.buildupdateDB(source())
	do tknzr.appendSrc(source())
	
	do this.builddelete(source())
	do tknzr.appendSrc(source())
	
	if this.sections.contains("defaults") do {
		
		do this.buildsetDefaults(source())
		do tknzr.appendSrc(source())
	}
	
	if this.sections.contains("required") do {
		
		do this.buildchkRequired(source())
		do tknzr.appendSrc(source())
	}
	
	if this.sections.contains("foreignKeys") do {
		
		do this.buildforeignKeys(source())
		do tknzr.appendSrc(source())
	}
	
	if this.sections.contains("triggers") do {
		
		do this.buildtriggers(source(), tknzr)
		do tknzr.appendSrc(source())
	}
	
	if (this.td.recordType > 1) do {
	
		do this.buildforceLoad(source())
		do tknzr.appendSrc(source())
	}

	do this.buildvalidateDD(source())
	do tknzr.appendSrc(source())
	
	if this.sections.contains("journals") do {
		
		do this.buildjournals(source(), tknzr)
		do tknzr.appendSrc(source())
	}
	
	if this.sections.contains("indexes") do {
		
		do this.buildindexes(source(), tknzr)
		do tknzr.appendSrc(source())
	}
	
	/* Always build if archivable since there may be application code
	   that references the methods. */
	if this.td.getArchivable() do {
		
		do this.buildarchiveMethods(source())
		do tknzr.appendSrc(source())
	}
	
	do this.buildkeyChanged(source())
	do tknzr.appendSrc(source())
	
	if this.sections.contains("cascadeDelete") do {
	
		do this.buildcascadeDelete(source())
		do tknzr.appendSrc(source())
	}
	
	do this.builderror(source())
	do tknzr.appendSrc(source())
	
	quit
	
	
	// ---------------------------------------------------------------------
private void buildarchive(String source(),	// Build code into source
			  PSLTable tdarch,	// Archive table descriptor
			  List keyNames,	// Names of keys
			  List keyTypes,	// Data types of keys
			  String keyValues,	// Key values assignment codde
			  String formalParams,	// Formatl parameters for method call
			  String comment,	// Key map comment
			  Boolean isNotArchived) // Build "shell" method
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE getArchiveFile method
	
	This method is only available for primary tables that are archived.
	
	The purpose of the getArchiveFile method is to archive selected data
	from the table associated with the RecordTABLE class.  The tasks that
	this method performs are:
	
		- Obtain current archive file, pointed to by environment
		  variable SCAU_ARCHIVE_CURRENT, to use as target to write
		  the selected data records
		    
		- Write selected records to the archive database, including
		  the primary table, sub-tables, and related tables.  Because
		  archiving is only provided for GT.M databases, M commands
		  will be used to move the data as global nodes, under
		  #BYPASS directives.  (At least one record will be retained
		  in the primary database for the main table and related tables.
		  This is necessary to support collation above the archive key.)
		    
		- Delete archived records from the primary database
		  
		- Update table DBARCHIVEIDX to reflect the archive index
		  information for both primary and related tables.  (Sub-tables
		  make use of the primary table index).
		  
		- Return count of number of records archived
	
	For efficiency, transactions will be committed and the index updated
	every 100 primary records, unless the table is archived at the top
	key (keycnt = 1), in which case will do it every archive key level
	since it's likely a big table.
	
	Note that if keycnt = 1, then formalParams will be null and keyValues
	will be 0.  This will occur for tables that are archived on the first key.
	
	Interrupt handling for tables with keycnt = 1 is included since these
	tables do not return to ARCHIVE^DBARCHIVE except when done, since there
	is no primary record selection.
	*/
	
	type List included = {List}(tdarch.getArchiveIncluded())
	type Number i, maxrecs
	type Number keycnt = keyNames.count()
	type String archiveKey = keyNames.elementAt(keycnt)
	type String archiveTable = tdarch.table
	type String archKeyType = keyTypes.elementAt(keycnt)
	type String code, globalKeys, globalRef, includedRefs(), lvpm(), where
	
	// If archive key is date, use it, otherwise find serial value column
	if keyTypes.elementAt(keycnt) = "Date" set where = keyNames.elementAt(keycnt)
	else  do {
		
		// If serial column specified, use that, otherwise, use first one
		type ResultSet rsarch = Db.select("SRLCOL", "DBUTARCHIVE", "ARCHTBL=:archiveTable")
		
		if rsarch.isEmpty() set where = ""
		else  if rsarch.next() set where = rsarch.getCol("SRLCOL")
		
		if where.isNull() do {
		
			type ResultSet rs = Db.select("DI", "DBTBL1D", "%LIBS='SYSDEV' AND FID=:archiveTable AND SRL=1")
		
			if rs.next() set where = rs.getCol("DI")
			// Archivable tables must have bottom date key or a serial column and cannot be a sub-table of another archivable table
			else  throw Class.new("Error", "%PSL-E-INVALID,"_ $$^MSG(6891, archiveTable))
		}
	}
	
	// Maximum records to process between commits and index updates
	if (keycnt = 1) set maxrecs = 1
	else  set maxrecs = 100
	
	/* For tables that are archived on the first key, e.g., the first key is a date, 
	   the second key of DBARCHIVEIDX is not used.  However, it cannot be null,
	   therefore it will be set to 0. */
	
	set where = where_ " <= :archiveDate"
	
	if (keycnt > 1) do {
		
		type String topWhere = ""
		
		for i = 1:1:keycnt - 1 do {
		
			type String key = keyNames.elementAt(i)
			
			if (i > 1) set topWhere = topWhere_ " AND "
			set topWhere = topWhere_ key_ " = :key"_ i
		}
		
		set where = topWhere_ " AND "_ where
	}
	
	// Save at least the last record
	set where = where_ " AND "_ archiveKey_ " < :maxVal"
	
	/* Build the global reference up to the archive key.
	   Need to deal with possible literals in the global, and, although
	   highly unlikely, may be comma in a literal so need to tokenize. */

	for i = 1:1:(keycnt - 1) set lvpm(i_ "*") = "key"_ i
	set lvpm(keycnt) = "archiveKey"
	set globalRef = $$getGbl^UCXDD(tdarch, "", lvpm())
	set globalRef = globalRef.extract(2, globalRef.length() - 1)_ ")"
	
	set globalKeys = "("_ globalRef.piece("(", 2, PSL.maxStringLength)
	
	for i = 1:1:included.count() do {
	
		type String incltbl = included.elementAt(i)
		type String ref
		
		type PSLTable tdincl = PSL.getPSLTable(incltbl, 0)
		
		set ref = tdincl.global
		set ref = ref.extract(2, PSL.maxStringLength).piece("(", 1)_ globalKeys
		
		set includedRefs(i) = ref
	}
	
	do this.addLine(source(), "")
	set code = "public static Number archive(String archiveDir, Number archiveNum,"
	set code = code_ " Date archiveDate"
	if (keycnt > 1) set code = code_ ", "_ formalParams
	set code = code_ ")"
	do this.addLine(source(), code)
	
	if isNotArchived do this.addLine(source(), " quit 0 // Shell method") quit
	
	if (keycnt > 1) do this.addLine(source(), "  // "_ comment)
	if (keycnt = 1) do this.addLine(source(), " type public String %INTRPT()")

	do this.addLine(source(), " type Boolean isDone")
	do this.addLine(source(), " type Number i, n, recordCnt")
	do this.addLine(source(), " type "_ archKeyType_ " archiveKey")
	
	set code = " type "_ archKeyType_ " maxVal"
	for i = 1:1:included.count() set code = code_ ", maxVal"_ included.elementAt(i)
	do this.addLine(source(), code)
	
	// Get maximum values for main and included tables to ensure keep at least one record
	do this.addLine(source(), " #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
	do this.addLine(source(), " #BYPASS")
		
	for i = 1:1:included.count() do this.addLine(source(), " new last"_ included.elementAt(i)_ " set last"_included.elementAt(i)_ "=""""")
	
	do this.addLine(source(), " set archiveKey=""""")
	do this.addLine(source(), " set maxVal=$O(^"_ globalRef_ ",-1)")
	do this.addLine(source(), " if maxVal="""" quit 0")
	for i = 1:1:included.count() do this.addLine(source(), " set maxVal"_ included.elementAt(i)_ "=$O(^"_ includedRefs(i)_ ",-1)")
	do this.addLine(source(), " #ENDBYPASS")
	
	do this.addLine(source(), " type ResultSet rs = Db.select("""_ archiveKey_ """, """_ archiveTable_ """, """_ where_ """, """_ archiveKey_ " ASC"")")

	do this.addLine(source(), " if rs.isEmpty() quit 0")

	do this.addLine(source(), " set recordCnt = 0")
	do this.addLine(source(), " set isDone = false")
	do this.addLine(source(), " while 'isDone do {")

        do this.addLine(source(), "  type String records()")

	do this.addLine(source(), "  for i = 1:1:"_ maxrecs_ " do { quit:isDone")

	do this.addLine(source(), "   if rs.next() set records(i) = rs.getCol("""_ archiveKey_ """)")
	do this.addLine(source(), "   else  set isDone = true")
	do this.addLine(source(), "  }")

	do this.addLine(source(), "  quit:'records(1).exists()")

	do this.addLine(source(), "  do Runtime.start(""BA"")")
	do this.addLine(source(), "  for i=1:1:100 quit:'records(i).exists()  do {")

	do this.addLine(source(), "   set recordCnt = recordCnt + 1")
	do this.addLine(source(), "   set archiveKey = records(i)")

	do this.addLine(source(), "   // Archive main record and sub-tables. Save index")
	do this.addLine(source(), "   #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
	do this.addLine(source(), "   #BYPASS")
	do this.addLine(source(), "   merge ^|archiveDir|"_ globalRef_ "=^"_ globalRef)
	do this.addLine(source(), "   kill ^"_ globalRef)
	
	// Deal with included tables
	for i = 1:1:included.count() do {
		
		type String incltbl = included.elementAt(i)
		
		do this.addLine(source(), "   ;")
		do this.addLine(source(), "   ; Related table "_ incltbl)
		do this.addLine(source(), "   if (archiveKey<maxVal"_ incltbl_ ") do")
		do this.addLine(source(), "   . merge ^|archiveDir|"_ incltbl_ "=^"_ includedRefs(i))
		do this.addLine(source(), "   . kill ^"_ includedRefs(i))
		do this.addLine(source(), "   . set last"_ incltbl_ "=archiveKey")
	}
	
	do this.addLine(source(), "   #ENDBYPASS")
	do this.addLine(source(), "  }")

	do this.addLine(source(), "  // Update index for current archive number with last "_ archiveKey)
	do this.addLine(source(), "  #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
	do this.addLine(source(), "  #BYPASS")
	
	// Update index for primary table, then included tables
	do this.addLine(source(), "  set n=$O(^DBARCHX("""_ archiveTable_ ""","_ keyValues_ ",""""),-1)")
	do this.addLine(source(), "  if n'="""",^(n)=archiveNum kill ^(n)")
	do this.addLine(source(), "  set ^DBARCHX("""_ archiveTable_ ""","_ keyValues_ ",archiveKey)=archiveNum")
	do this.addLine(source(), "  ;")
	
	for i=1:1:included.count() do {
		
		type String incltbl = included.elementAt(i)
		
		do this.addLine(source(), "  if (last"_ incltbl_ "'="""") do")
		do this.addLine(source(), "   . set n=$O(^DBARCHX("""_ incltbl_ ""","_ keyValues_ ",""""),-1)")
		do this.addLine(source(), "   . if (n'=""""),(^(n)=archiveNum) kill ^(n)")
		do this.addLine(source(), "   . set ^DBARCHX("""_ incltbl_ ""","_ keyValues_ ",archiveKey)=archiveNum")
		do this.addLine(source(), "   . if (archiveKey'<last"_ incltbl_ ") set last"_ incltbl_ "=""""")
		do this.addLine(source(), "  ;")
	}
	
	do this.addLine(source(), "  #ENDBYPASS")
	
	do this.addLine(source(), "  do Runtime.commit()")
	
	
	/* For tables archived at the top key, need to deal with interrupt handling
	   here.  Check Interrupt status for stop.  Don't clear %INTRPT if it is a
	   STOP, since it needs to be carried back to ARCHIVE^DBARCHIVE so that it
	   knows we were interrupted.
	*/
	if (keycnt = 1) do {
		
		do this.addLine(source(), "  if %INTRPT.data() > 1 do INTRPT^IPCMGR")
		do this.addLine(source(), "  if '%INTRPT.get().isNull() do {")

		do this.addLine(source(), "   if %INTRPT = ""STOP"" set isDone = true")
		do this.addLine(source(), "   else  set %INTRPT = """"")
		do this.addLine(source(), "  }")
	}

	do this.addLine(source(), " }")
	
	do this.addLine(source(), " quit recordCnt")

	quit
	
	
	// ---------------------------------------------------------------------
private void buildarchiveMethods(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE archive and getArchiveFile methods
	*/
	
	type Boolean isNotArchived
	type List archiveKeys
	type Number delim, i, keycnt
	type String archiveKey, archiveTable, comment, formalParams, keyNames, keyTypes, keyValues
	
	kill source
	
	set archiveTable = this.td.getArchiveTable()
	
	/* If not actually archived, but is archivable, set up
	   archive methods, but generate them to do nothing.  This 
	   is needed since some application code, e.g., UARCHIST,
	   references the methods. */
	if archiveTable.isNull() do {
		
		set archiveTable = this.tableName
		set isNotArchived = true
	}
	else  set isNotArchived = false
		
	type PSLTable tdarch = PSL.getPSLTable(archiveTable, 0)
	
	set delim = tdarch.columnDelimiter
	set archiveKeys = {List}(tdarch.primaryKeys)
	set keycnt = tdarch.getArchiveKey()
	set archiveKey = archiveKeys.elementAt(keycnt)
	
	set (formalParams, keyNames, keyTypes, keyValues) = ""
	set comment = ""
	for i = 1:1:keycnt do {
		
		type SchemaColumn cd = Db.getSchemaColumn(archiveTable, archiveKeys.elementAt(i))
		
		set keyNames = keyNames_ cd.column_ ","
		set keyTypes = keyTypes_ cd.getClass()_ ","
		
		if (i < keycnt) do {
			
			set formalParams = formalParams_ cd.getClass()_ " key"_ i_ ", "
			set keyValues = keyValues_ "key"_ i_ "_"_ delim_ ".char()_"
			set comment = comment_ "key"_ i_ " = "_ cd.column_ ", "
		}
		else  set comment = comment_ "archiveKey = "_ cd.column
	}
	
	set formalParams = formalParams.extract(1, formalParams.length() - 2)
	set keyNames = keyNames.extract(1, keyNames.length() - 1)
	set keyTypes = keyTypes.extract(1, keyTypes.length() - 1)
	set keyValues = keyValues.extract(1, keyValues.length() - (delim.toString().length() + 9))
	
	if keyValues.isNull() set keyValues = "0"
	
	// Generate code for RecordTABLE.archive() method if a primary archive table
	if (this.tableName = archiveTable) do this.buildarchive(source(), tdarch, keyNames, keyTypes, keyValues, formalParams, comment, isNotArchived)
	
	// Generate code for RecordTABLE.getArchiveFile() method
	do this.buildgetArchiveFile(source(), tdarch, keyNames, keyTypes, keyValues, formalParams, comment, isNotArchived)
	
	quit	

	
	// ---------------------------------------------------------------------
private void buildbypassSave(String source())		// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE bypassSave method
	*/
	
	type String code
	
	#ACCEPT Date=06/10/2008; Pgm=RussellDS; CR=30801; Group=ACCESS
	type String bypassQual = $$bypassQual^UCRECORD
	 
	kill source
	
	do this.addLine(source(), "")
	
	if this.children.isNull() set code = "final "
	else  set code = ""
	
	do this.addLine(source(), "public "_ code_ "void vBypassSave()")

	// bypassSave always from PSL, so auditLogSeq can be zero
	do this.addLine(source(), " do this.vSave("_ bypassQual.addQuotes()_ ",0)")
	do this.addLine(source(), " quit")

	quit
		
	
	// ---------------------------------------------------------------------
private void buildcascadeDelete(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCcascadeDelete() method.
	*/
	
	type List fkeys, fktblKeys, ptkeys
	type Number i, rsseq
	type String code, ermsg, table, tbl1ffid, where
	
	kill source
	
	set ptkeys = {List}(this.td.primaryKeys.lowerCase())
	
	do this.addLine(source(), "")
	do this.addLine(source(), "private void vRCcascadeDelete(List vRCparams)")
	
	set rsseq = 0
	set table = this.tableName
	
	while 'table.isNull() do {
	
		type ResultSet rs = Db.select("FID,FKEYS,DEL", "DBTBL1F", "%LIBS='SYSDEV' AND TBLREF=:table")
		
		while rs.next() do {
			
			set tbl1ffid = rs.getCol("FID")
		
			if 'Db.isSchemaTable(tbl1ffid) throw Class.new("Error", "%PSL-E-INVALID,Aborted - invalid foreign key table "_ tbl1ffid)
			
			set fkeys = {List}(rs.getCol("FKEYS"))
			
			type PSLTable tdfd = PSL.getPSLTable(tbl1ffid, 0)
			
			set fktblKeys = {List}(tdfd.primaryKeys)
			
			set where = ""
			for i = 1:1:fkeys.count() set where = where_ fkeys.elementAt(i)_"=:this."_ this.colName(ptkeys.elementAt(i), "LC", true)_ " AND "
			set where = where.extract(1, where.length() - 5)
			
			if 'rs.getCol("DEL") do {		// Restricted
			
				// Referential integrity error ~p1
				set ermsg = "$$^MSG(8563, """_ tbl1ffid_ "("_ fkeys_ ") -> "_ this.tableName_ "("_ this.td.primaryKeys_ ")"").replace("","",""~"")"
					
				set code = " if Db.isDefined("""_ tbl1ffid_ ""","_ where.addQuotes()_ ",1)"
				set code = code_ " do this.throwError("_ ermsg_ ")"
				do this.addLine(source(), code)
			}
			else  do {		// Cascade
				
				set code = " do Db.delete("""_ tbl1ffid_ ""","_ where.addQuotes()_ ", vRCparams)"
				do this.addLine(source(), code)
				
				if ({List}"ACN,CIF,DEP,LN").contains(tbl1ffid) do {
					
					/* write info message " ** Warning ** Review cascade delete definition"
					   write code
					*/
				}
			}
		}
		
		/* If table has a parent, then get it's foreign key relationships
		   and continue.*/
		type PSLTable td2 = PSL.getPSLTable(table, 0)
		
		set table = td2.parentTable
	}
	
	do this.addLine(source(), " quit")
	
	quit
	
	
	// ---------------------------------------------------------------------
private void buildcheckAccessRights(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE access rights methods - vcheckAccessRights(),
	insertAccess(), updateAccess(), deleteAccess, selectAccess()
	*/
	
	type Number deleterts, insertrts, selectrts, updaterts
	type String deleteRestrict, insertRestrict, selectRestrict, updateRestrict
	
	kill source
	
	do this.addLine(source(), "")
	do this.addLine(source(), "public static List vcheckAccessRights()")
	
	do this.addLine(source(), " quit "_ this.checkAccessRights.addQuotes())
	
	set (deleteRestrict, insertRestrict, selectRestrict, updateRestrict) = ""
	
	/* Add each of the operationAccess() methods
	   If there is no access rights checking necessary, still set up the
	   methods, but with full access. */
	if this.checkAccessRights.isNull() set (insertrts, updaterts, deleterts, selectrts) = 1
	else  do {
	
		type ResultSet rs = Db.select("INSERTRTS,UPDATERTS,DELETERTS,SELECTRTS,INSRESTRICT,UPDRESTRICT,DELRESTRICT,SELRESTRICT", "DBACCRTS", "TABLENAME=:this.tableName AND USERCLASS='PUBLIC'")

		if rs.isEmpty() set (insertrts, updaterts, deleterts, selectrts) = 0
		else  if rs.next() do {
			
			set insertRestrict = rs.getCol("INSRESTRICT")
			set updateRestrict = rs.getCol("UPDRESTRICT")
			set deleteRestrict = rs.getCol("DELRESTRICT")
			set selectRestrict = rs.getCol("SELRESTRICT")
		
			if (rs.getCol("INSERTRTS") and 'insertRestrict.isNull()) set insertrts = 2
			else  if rs.getCol("INSERTRTS") set insertrts = 1
			else  set insertrts = 0
			
			if (rs.getCol("UPDATERTS") and 'updateRestrict.isNull()) set updaterts = 2
			else  if rs.getCol("UPDATERTS") set updaterts = 1
			else  set updaterts = 0
			
			if (rs.getCol("DELETERTS") and 'deleteRestrict.isNull()) set deleterts = 2
			else  if rs.getCol("DELETERTS") set deleterts = 1
			else  set deleterts = 0
			
			if (rs.getCol("SELECTRTS") and 'selectRestrict.isNull()) set selectrts = 2
			else  if rs.getCol("SELECTRTS") set selectrts = 1
			else  set selectrts = 0
		}
	}
	
	/* Build *Access() and *OK() (vinsertAccess(), vinsertOK(), etc.), methods
	   for each of the four operations. */
	do this.addCheckRightsCode(source(), "INSERT", insertrts, insertRestrict)
	do this.addCheckRightsCode(source(), "UPDATE", updaterts, updateRestrict)
	do this.addCheckRightsCode(source(), "DELETE", deleterts, deleteRestrict)
	do this.addCheckRightsCode(source(), "SELECT", selectrts, selectRestrict)
	
	quit
	
	
	// ---------------------------------------------------------------------	
private void addCheckRightsCode(String source(),	// Build code into source
				String operation,	// Operation to generate code for (uppercase)
				Number publicRight,	// PUBLIC right for the operation
				String publicRestrict)	// Restrict clause for PUBLIC
	/* ---------------------------------------------------------------------	
	Add the code for one operation and add it to the code being built.  This
	will build the v'operation'Access() and invoke addRightsOKCode to add the
	v'operation'OK() methods.
	
	The Access methods are static and return values of 0 = no access,
	1 = access, or 2 = access based on a restrict clause.
	
	Although in cases where there is no restrict clause, the OK methods could
	be static, in the event of a restrict clause they require an instantiated
	record and therefore are all instance methods.  In all cases, they return
	true if the userclass has access to the row, otherwise false.
	
	The vselectAccess method includes two additional parameters, restrict, which
	is the restrict clause associated with the userclass as a return value,
	and from, which is a string of joined tables involved in the restrict clause
	as a return value.  These returned values will be used in constructing
	SELECT statements to filter the results.
	   
	This method is used by method buildcheckAccessCode.
	*/
	
	type Boolean isSelect = (operation = "SELECT")
	type List withRts = Class.new("List")
	type List withRestrict = Class.new("List")
	type String operationLC = operation.lowerCase()
	type String restrictByUcls()
	type String where
	
	do this.addLine(source(), "")
	
	if 'isSelect do {
	
		do this.addLine(source(), "public static Number v"_ operationLC_ "Access( String userclass)")
	}
	else  do {
		
		do this.addLine(source(), "public static Number vselectAccess( String userclass, ret String restrict, ret String from)")
		
		do this.addLine(source(), " set (restrict, from) = """"")
	}
	
	set where = "USERCLASS <> 'PUBLIC' AND TABLENAME='"_ this.tableName_ "'"
	
	// rights depend on individual userclass, so return 0 unless a userclass has rights
	if (publicRight = 0) do {
		
		type String select = "USERCLASS,"_ operation_ "RTS,"_ operation.extract(1, 3)_"RESTRICT"
		
		set where = where_ " AND "_operation_ "RTS > 0"
		
		#ACCEPT Date=03/16/2008; Pgm=RussellDS; CR=30801; Group=Dynamic
		type ResultSet rs = Db.select(select, "DBACCRTS", where)
		
		while rs.next() do {
			
			if 'rs.getCol(3).isNull() do {
			
				set withRestrict = withRestrict.add(rs.getCol("USERCLASS"))
				if isSelect do this.addSelectRestrict(source(), rs.getCol("USERCLASS"), rs.getCol(3))
				set restrictByUcls(rs.getCol("USERCLASS")) = rs.getCol(3)
			}
			else  set withRts = withRts.add(rs.getCol("USERCLASS"))
		}
		
		if (withRts.count() > 1) do this.addLine(source(), " if {List}("""_ withRts_ """).contains(userclass) quit 1")
		else  if (withRts.count() = 1) do this.addLine(source(), " if (userclass = """_ withRts_ """) quit 1")
		
		if (withRestrict.count() > 1) do this.addLine(source(), " if {List}("""_ withRestrict_ """).contains(userclass) quit 2")
		else  if (withRestrict.count() = 1) do this.addLine(source(), " if (userclass = """_ withRestrict_ """) quit 2")
		
		do this.addLine(source(), " quit 0")
	}
	
	// rights are 1 except for userclasses with restrict clauses, which are 2
	else  if (publicRight = 1) do {
		
		type String select = "USERCLASS,"_ operation.extract(1, 3)_ "RESTRICT"
		
		set where = where_ " AND "_ operation.extract(1, 3)_ "RESTRICT IS NOT NULL"
		
		#ACCEPT Date=03/16/2008; Pgm=RussellDS; CR=30801; Group=Dynamic
		type ResultSet rs = Db.select(select, "DBACCRTS", where)
		
		while rs.next() do {
			
			set withRestrict = withRestrict.add(rs.getCol("USERCLASS"))
			if isSelect do this.addSelectRestrict(source(), rs.getCol("USERCLASS"), rs.getCol(2))
			set restrictByUcls(rs.getCol("USERCLASS")) = rs.getCol(2)
		}

		if (withRestrict.count() > 1) do this.addLine(source(), " if {List}("""_ withRestrict_ """).contains(userclass) quit 2")
		else  if (withRestrict.count() = 1) do this.addLine(source(), " if (userclass = """_ withRestrict_ """) quit 2")
		
		do this.addLine(source(), " quit 1")
	}
	
	// rights are 2, except for userclasses that are 1, without restrict clauses
	else  do {
		
		type String select = "USERCLASS,"_ operation_ "RTS,"_ operation.extract(1, 3)_"RESTRICT"
		
		set where = where_ " AND "_ operation_ "RTS > 0"
		
		#ACCEPT Date=03/16/2008; Pgm=RussellDS; CR=30801; Group=Dynamic
		type ResultSet rs = Db.select(select, "DBACCRTS", where)
		
		set restrictByUcls("PUBLIC") = publicRestrict
		
		// Initialize from/restrict to PUBLIC value
		if isSelect do this.addSelectRestrict(source(), "PUBLIC", publicRestrict)
		
		while rs.next() do {
			
			if 'rs.getCol(3).isNull() set restrictByUcls(rs.getCol("USERCLASS")) = rs.getCol(3)
			else  set withRts = withRts.add(rs.getCol("USERCLASS"))
			
			// Set from/restrict based on this userclass - restrict may be null
			if isSelect do this.addSelectRestrict(source(), rs.getCol("USERCLASS"), rs.getCol(3))
		}
		
		if (withRts.count() > 1) do this.addLine(source(), " if {List}("""_ withRts_ """).contains(userclass) quit 1")
		else  if (withRts.count() = 1) do this.addLine(source(), " if (userclass = """_ withRts_ """) quit 1")
		
		do this.addLine(source(), " quit 2")
	}
	
	// Build OK() method for check restrict access by userclass
	do this.addRightsOKCode(source(), operationLC, publicRight, withRts, restrictByUcls()) 

	quit
	
	
	// ---------------------------------------------------------------------	
private void addLogSQLCode(String source(),		// Build code into source
			   String operation)		// insert, update, delete
	/* ---------------------------------------------------------------------
	Add the code for the call to logging in the save() method.
	
	We call auditLog^SQLAUDIT only if this statement hasn't yet been logged.
	If we're executing the statement from SQL, Db.update, or Db.delete, it
	will have been logged and vauditLogSeq will not be zero.  If it hasn't
	been logged, then we're dealing with PSL and need to construct the
	equivalent SQL statement(s) and log them.  (There may be more than one
	if there are memo/blob columns involved, but SQL(1) will always be the
	main statement.)  If we log it here, we don't need to return the value
	of vauditLogSeq, since it's just this one statement being logged, and
	there won't be subsequent detail logged outside of here.
	
	UPDATE and DELETE may also log detail, based on userclass options.  This
	may be done for the PSL UPDATE or DELETE using the DBAUDITLOG SEQ value
	obtained during the .save() call, or my be logged under a prior SEQ value
	if a SQL or Db.update/delete that involved multiple rows.
	
	Called by buildsave().
	*/

	type Boolean isPositiveList
	type List userclasses
		
	if $$shouldLog^SQLAUDIT(this.tableName, operation, "log", .userclasses, .isPositiveList) do {
		
		type String code, gblRef, uclsCheck
		
		// Build global reference for UPDATE (main and detail) and DELETE (detail)
		if (operation '= "insert") do {
		
			set gblRef = $$getGbl^UCXDD(this.td, "this")
			set gblRef = gblRef.replace(PSL.oLvn_ "(this,", "origdata(")
			
			if 'this.td.getArchiveTable().isNull() set gblRef = "^|"_ PSL.oLvn_ "(this,-99)|"_ gblRef.extract(2, gblRef.length())
			if gblRef.endsWith(",") set gblRef = gblRef.extract(1, gblRef.length() - 1)
		}
		
		set code = this.getAuditUCLSChk(userclasses, isPositiveList)
		if 'code.isNull() set code = ", "_ code
		
		// If auditLog sequence is zero, hasn't been logged yet
		do this.addLine(source(), "  if (vauditLogSeq.get() '> 0)"_ code_ " do {")
		
		if this.hasMoB do {
			
			do this.addLine(source(), "   type Number n")
			do this.addLine(source(), "   type String x")
		}
		do this.addLine(source(), "   type String map(), origdata(), SQL()")
		
		do this.addLine(source(), "   do this.getColumnMap(map())")
		
		/* We need original data for UPDATE in order to build the SQL
		   statement, and we have to get this from the database since
		   there's no guarantee auditing is on or has been on for the
		   entire set of changes.
		   
		   origdata() will have the same node structure as map().  The
		   only nodes that need to be loaded are the keys and nodes that
		   correspond to data loaded in vobj (since that is all that 
		   would have changed)
		*/
		
		if (operation = "update") do {
			
			if 'this.td.primaryKeys.isNull() do {
			
				type List keys = this.td.primaryKeys
				type Number i
				
				for i = 1:1:keys.count() do this.addLine(source(), "   set origdata("_ (-i - 2)_ ") = this."_ keys.elementAt(i).lowerCase()_ ".oldVal")
			}
			
			do this.addLine(source(), "   #ACCEPT Date=06/02/2008; Pgm=RussellDS; CR=30801; Group=BYPASS")
			do this.addLine(source(), "   #BYPASS")
			do this.addLine(source(), "   N N,NODE")
			do this.addLine(source(), "   I $D(vobj(this))#2 S origdata(-1)=$G("_ gblRef_ "))")
			do this.addLine(source(), "   S N=-1")
			do this.addLine(source(), "   F  S N=$O(vobj(this,N)) Q:N=""""  D")
			
			if this.hasMoB do {
				
				do this.addLine(source(), "   . I $D(vobj(this,N,1)) D  Q")
				do this.addLine(source(), "   ..  N M,MBREF")
				do this.addLine(source(), "   ..  S MBREF=N_"",1"",(M,origdata(MBREF))=""""")
				do this.addLine(source(), "   ..  F  S M=$O("_ gblRef_ ",N,M)) Q:M=""""  S origdata(MBREF)=origdata(MBREF)_^(M)")
			}
			
			do this.addLine(source(), "   . I N?1""v""1.N S NODE=-$E(N,2,$L(N))")
			do this.addLine(source(), "   . E  S NODE=N")
			do this.addLine(source(), "   . S origdata(N)=$G("_ gblRef_ ",NODE))")
			do this.addLine(source(), "   #ENDBYPASS")
		}
		
		do this.addLine(source(), "   do buildSQL^SQLAUDIT(this, "_ this.delimiterStr_ ", map(), origdata(), SQL())")
			
		do this.addLine(source(), "   set vauditLogSeq = $$auditLog^SQLAUDIT("""_ operation.upperCase()_ """, """_ this.tableName_ """, SQL(1), """")")
		
		/* For memo/blob audit entries, we don't need to save the audit log
		   sequence.  We only need the main one for logging before image detail.*/
		if this.hasMoB do this.addLine(source(), "   for n = 2:1 quit:'SQL(n).exists()  set x = $$auditLog^SQLAUDIT(""update"", """_ this.tableName_ """, SQL(n), """")")
		
		do this.addLine(source(), "  }")
		
		// Deal with detail logging
		set userclasses = ""
		if (operation '= "insert"), $$shouldLog^SQLAUDIT(this.tableName, operation, "detail", .userclasses, .isPositiveList) do {
			
			type Boolean isPositiveList2, logData
			type List userclasses2
			
			set logData = $$shouldLog^SQLAUDIT(this.tableName, operation, "detail+", .userclasses2, .isPositiveList2)
		
			set code = this.getAuditUCLSChk(userclasses, isPositiveList)
			do this.addLine(source(), "  // Audit log - detail")
			if 'code.isNull() set code = "if "_ code_ " "
			do this.addLine(source(), "  "_ code_"do {")
			
  			do this.addLine(source(), "   type Number RECSEQ")
  			do this.addLine(source(), "   type String keys")
  			if logData do this.addLine(source(), "   type String origdata()")
  			
  			set code = ""
  			
  			/* If we are logging the data as well, then set up keys in
  			   origdata() since we'll need them in the bypassed references
  			   to the global.  Otherwise, don't bother and just build keys
  			   with the .oldVal key column references */
  			if 'this.td.primaryKeys.isNull() do {
			
				type List keys = this.td.primaryKeys
				type Number i
				
				for i = 1:1:keys.count() do {
					
					if logData do {
					
						do this.addLine(source(), "   set origdata("_ (-i - 2)_ ") = this."_ this.colName(keys.elementAt(i), "LC", true)_ ".oldVal")
						set code = code_ """"_ keys.elementAt(i)_ "=""_ origdata("_ (-i -2)_ ")"
					}
					else  set code = code_ """"_ keys.elementAt(i)_ "=""_this."_ this.colName(keys.elementAt(i), "LC", true)_ ".oldVal"
					
					type PSLColumn cd = PSL.getPSLColumn(this.tableName, keys.elementAt(i))
					
					if ({List}"T,U,F").contains(cd.dataType) set code = code_ ".addQuotes(""'"")"
					set code = code_ "_ "",""_ "
				}
				
				set code = code.extract(1, code.length() - 7)
			}
  	
  			do this.addLine(source(), "   set keys = "_ code)
  	
  			do this.addLine(source(), "   set RECSEQ = $$auditLogDetail^SQLAUDIT(vauditLogSeq, keys)")
  	
  			/* Before image data - if the same userclass checking conditions
  			   apply to detail and detail+, we don't need to re-check them. */
  			if logData do {
  				
  				type String space = ""
  	
  				if '((isPositiveList = isPositiveList2) and (userclasses = userclasses2)) do {
  				
  					set space = " "
  					
  					set code = this.getAuditUCLSChk(userclasses2, isPositiveList2)
					do this.addLine(source(), "   if "_ code_ " do {")
  				}
  	
  				do this.addLine(source(), space_ "   #ACCEPT Date=06/02/2008; Pgm=RussellDS; CR=30801; Group=BYPASS")
				do this.addLine(source(), space_ "   #BYPASS")
  				do this.addLine(source(), space_ "   merge ^DBAUDITLOG(+$H,$J,vauditLogSeq,RECSEQ,""*"")="_ gblRef_ ")")
  				do this.addLine(source(), space_ "   #ENDBYPASS")
  				
  				if (space = " ") do this.addLine(source(), "   }")
  			}
  	
  			do this.addLine(source(), "  }")
		}
	}
	
	quit
	
	
private String getAuditUCLSChk(List userclasses,	// User class list
			       Boolean isPositiveList)	// List is positive or negative
			       
	/*
	Return the code necessary to perform the runtime check against the list of
	userclasses.  If the list is positive, it means that the condition applies
	only to userclasses in the list, otherwise, it applies to userclasses not
	in the list.
	*/
	
	type String uclsCheck
			
	if (userclasses.count() = 0) set uclsCheck = ""		// No check necessary, do them all
	else  if (userclasses.count() = 1) set uclsCheck = "(%UserClass = "_userclasses.addQuotes()_ ")"
	else  set uclsCheck = "({List}"_ userclasses.addQuotes()_ ").contains(%UserClass)"
	
	/* Positive list will always have elements.  Negative list may
	   be empty, in which case there is not checking as it means
	   that PUBLIC is being logged and there are no exceptions. */
			
	if 'isPositiveList, 'uclsCheck.isNull() set uclsCheck = "'"_ uclsCheck
	
	quit uclsCheck
	
	
	// ---------------------------------------------------------------------	
private void addRightsOKCode(String source(),		// Build code into source
			     String operationLC,	// Operation to generate code for (lowercase)
			     Number publicRight,	// PUBLIC right for the operation
			     List withRts,		// Userclasses with rights = 1
			     String restrictByUcls())	// restrict clauses by userclass
	/* ---------------------------------------------------------------------
	Add the code for the v'operation'OK() method, and any necessary supporting
	methods.
	
	The OK() methods (vinsertOK(), etc.) are used to check access rights against
	an instantiated record, which may or may not include restrict clauses.  In
	general, the Access() methods should be used to check rights against a
	table, and may be sufficient to resolve access.  If there is one or more
	restrict clauses associated with access, however, it may be necessary to
	call the OK() method.
	
	For updateRestrict rights, the queries are executed against the original
	record, not the record as modified.  This is done through use of the
	.oldVal property.
	
	For any table with selectRestrict access rights, methods
	vselectOptmOK and vselectOptmOKn (n = 1-n, per userclass with restrict) will
	be built as optimized checks for use by vRCgetRecordnOpt code.  These
	methods are also built as static since bypass code manages the passing
	of the loaded record and we don't want the compiler adding it.
	
	NOTE THAT IT IS CRITICAL that if the vselectOptmOKn signature (label or
	key names) are changed, the change must be coordinated with UCREC4OP
	since UCREC4OP provides optimization compilation based on the signature.
	
	For each userclass with a restrict clause, an OKn() method will be generated
	and used by the OK() method's dipatch code.
	
	Three forms of OK() code are possible (using INSERT example), based on
	the PUBLIC access right.
	
	  If no PUBLIC access:
	  
	  	// For any userclasses with restrict clause
	  	if (userclass = "uclsx") quit this.insertOK1()
	  	...
	  	// For any userclasses with rights, but no restrict clause
	  	if {List}userclasses.contains(userclass) quit true
	  	// Any remaining follow PUBLIC and don't have access
	  	quit false
	
	  If PUBLIC access and no restrict clause:
	  
	  	// For any userclasses with restrict clause
	  	if (userclass = "uclsx") quit this.insertOK1()
	  	...
	  	// Any remaining follow PUBLIC and have access
	  	quit true
	  	
	  If PUBLIC access and restrict clause:
	  
	  	// For any userclasses with rights, but no restrict clause
	  	if {List}userclasses.contains(userclass) quit true
	  	// For any userclasses with restrict clause
	  	if (userclass = "uclsx") quit this.insertOK1()
	  	// Any remaining follow PUBLIC restrict clause
	  	quit this.insertOKn()	// PUBLIC restrict
	   
	This method is used by method addCheckRightsCode, and will call itself
	when processing SELECT if there are select restrictions in order to
	build the selectOptmOK methods.
	*/
	
	type Boolean isSelectOptm = (operationLC = "selectOptm")	// Optimized select
	type Number i
	type Number seq = 0
	type String code, comment, optmApl
	type String objRef = "this"
	type String optmFpl = ""
	type String ucls = ""
	type String restrictCode()
	
	do this.addLine(source(), "")
	
	if isSelectOptm do {
		
		set objRef = "Record"_ this.tableName
		
		set optmApl = this.tableNameLC			// Actual parameters
		set optmFpl = "String userclass, "		// Formal parameters
		set optmFpl = optmFpl_ objRef_ " "_ this.tableNameLC	
		for i = 1:1:this.td.primaryKeys.count() do {
			
			set optmApl = optmApl_ ", vkey"_ i
			set optmFpl = optmFpl_ ", String vkey"_ i
		}
	}
	
	if (publicRight = 0) set comment = "none"
	else  if (publicRight = 1) set comment = "allowed, no restrict clause"
	else  set comment = "allowed, with restrict clause"
	set code = " Boolean v"_ operationLC_ "OK("
	if 'isSelectOptm do {
	
		if this.children.isNull() set code = " final"_ code
		set code = "public"_ code_ "String userclass)"
	}
	else  set code = "public static"_ code_ optmFpl_ ")"
	do this.addLine(source(), code_ "  // PUBLIC access is "_ comment)
	
	// Build dispatch code for restrict(s) and info to build OKn() methods
	for  set ucls = restrictByUcls(ucls).order() quit:ucls.isNull()  if (ucls '= "PUBLIC") do {
		
		set seq = seq + 1
		set code = " if (userclass = """_ ucls_ """) quit "_ objRef_ "."_ operationLC_ "OK"_ seq_ "("
		if 'isSelectOptm set code = code_ ")"
		else  set code = code_ optmApl_ ")"
		set restrictCode(seq) = code_ 9.char()_ ucls_ 9.char()_ restrictByUcls(ucls)
	}
	
	if (publicRight = 0) do {
		
		// Add any userclasses with restrict clauses
		for i = 1:1:seq do this.addLine(source(), restrictCode(i).piece(9.char(), 1))

	  	// Handle any userclasses with rights, but no restrict clause
	  	if (withRts.count() > 1) do this.addLine(source(), " if {List}("""_ withRts_ """).contains(userclass) quit true")
	  	if (withRts.count() = 1) do this.addLine(source(), " if (userclass = """_ withRts_ """) quit true")

	  	// Any remaining follow PUBLIC and don't have access
	  	do this.addLine(source(), " quit false")
	}
	
	else  if (publicRight = 1) do {
		
		// Add any userclasses with restrict clauses
		for i = 1:1:seq do this.addLine(source(), restrictCode(i).piece(9.char()))

	  	// Any remaining follow PUBLIC and have access
	  	do this.addLine(source(), " quit true")
	}
	
	else  do {
		
		// Handle any userclasses with rights, but no restrict clause
	  	if (withRts.count() > 1) do this.addLine(source(), " if {List}("""_ withRts_ """).contains(userclass) quit true")
	  	if (withRts.count() = 1) do this.addLine(source(), " if (userclass = """_ withRts_ """) quit true")

	  	// Add remaining PUBLIC restrict clause
	  	set seq = seq + 1
	  	set code = " quit "_ objRef_ "."_ operationLC_ "OK"_ seq_ "("
		if 'isSelectOptm set code = code_ ")"
		else  set code = code_ optmApl_ ")"
		set restrictCode(seq) = code_ 9.char()_ "PUBLIC"_ 9.char()_ restrictByUcls("PUBLIC")
		
	  	// Add any userclasses with restrict clauses
		for i = 1:1:seq do this.addLine(source(), restrictCode(i).piece(9.char()))
	}
	
	/* Now add OKn() methods.
	   If there are other tables involved (join), then the OKn method is
	   built under a catch block.  This is because the getRecord() method
	   will be used to load the record from any other table and if the
	   userclass does not have access to that record, it will the getRecord
	   method will throw an error.  We don't want an error thrown here, we
	   want to catch it and return false, i.e., no access to this record. */
	for i = 1:1:seq do {
		
		type Boolean otherTables = false
		type Number n, seq
		type String input(), pslobj(), pslqry(), tableRef, tables
		type String from = this.tableName
		type String pad = " "
		type String where = restrictCode(i).piece(9.char(), 3)
		
		do this.addLine(source(), "")
		
		set code = "Boolean "_ operationLC_ "OK"_ i_ "("
		if 'isSelectOptm set code = "private "_ code_ optmFpl_ ")"
		else  set code = "private static "_ code_ optmFpl.piece(",", 2, PSL.maxStringLength)_ ")"	// Strip userclass
		do this.addLine(source(), code)
		
		do this.addLine(source(), " // Userclass = "_ restrictCode(i).piece(9.char(), 2))
		do this.addLine(source(), " // restrict = "_ where)
		
		/* Convert restrict clause to runtime query logic using UCQRYBLD */
		
		if where.beginsWith("[FROM ") do {
		
			set from = where.piece("[FROM ", 2).piece("]", 1)
			set where = where.piece("]", 2, PSL.maxStringLength).trim()
		}
		
		/* If any host variables, substitute, since SQL processing
		   will turn all to uppercase.  Only system keywords are
		   valid in this context, but we don't check that, just
		   substitute. */
		   
		if where.isLike("%:%") do {

			type Number cnt, ptr
			type String atom, newwhere, tok
			
			#ACCEPT Date=06/10/2008; Pgm=RussellDS; CR=30801; Group=ACCESS
			set where = $$TOKEN^%ZS(where, .tok)
			set newwhere = where
			
			set (cnt, ptr) = 0
			#ACCEPT Date=06/10/2008; Pgm=RussellDS; CR=30801; Group=ACCESS
			for  set atom = $$ATOM^%ZS(where, .ptr, "*/+-|,()<=>", 1) do { quit:(ptr = 0)
				
				if atom.beginsWith(":") do {
			
					set cnt = cnt + 1
					do this.addLine(source(), " type String VAR"_ cnt_ " = "_ atom.extract(2, PSL.maxStringLength))
					set newwhere = newwhere.replace(atom, ":VAR"_ cnt)
				}
			}
			
			#ACCEPT Date=06/10/2008; Pgm=RussellDS; CR=30801; Group=ACCESS
			set where = $$UNTOK^%ZS(newwhere, tok)
		}
		
		set input("WHERE") = where
		set input("FROM") = from
		
		if (operationLC = "update") set tableRef = "this.oldVal"
		else  if 'isSelectOptm set tableRef = "this"
		else  set tableRef = this.tableNameLC
		
		do ^UCQRYBLD(input(), this.tableName_ "="_ tableRef, .tables, pslobj(), pslqry())
		
		if (pslobj.data() > 0) do {
			
			set otherTables = true
			set pad = "  "
			do this.addLine(source(), " type Boolean accessOK = true")
			do this.addLine(source(), " do {")
			do this.addLine(source(), "  catch "_ operationLC_ i_ "OKerr {")
			do this.addLine(source(), "   set accessOK = false")
			do this.addLine(source(), "  }")
		
			// Insert object instantiation code for any other tables referenced.
			set (n, seq) = ""
			for  set n = pslobj(n).order() quit:n.isNull()  do {
				for  set seq = pslobj(n, seq).order() quit:seq.isNull()  do this.addLine(source(), pad_ pslobj(n, seq))
			}
		}
		
		// Insert query logic
		set seq = ""
		for  set seq = pslqry(seq).order() quit:seq.isNull()  do {

			do this.addLine(source(), pad_ "if "_ pslqry(seq))
			if 'otherTables do this.addLine(source(), pad_ "else  quit false")
			if otherTables do this.addLine(source(), pad_ "else  set accessOK = false quit")
		}
		
		if otherTables do {
			
			do this.addLine(source(), " }")
			do this.addLine(source(), " quit accessOK")
		}
		else  do this.addLine(source(), " quit true")
	}
	
	if 'isSelectOptm, operationLC = "select", (restrictByUcls.data() > -1) do this.addRightsOKCode(source(), "selectOptm", publicRight, withRts, restrictByUcls()) 
	
	quit
	
	
	// ---------------------------------------------------------------------
private void addSelectRestrict(String source(),		// Build code into source
			       String userclass,	// Userclass associated with restrict
			       String restrict)		// Restrict clause
	/* ---------------------------------------------------------------------	
	Add the code to set the return values for restrict and from parameters
	associated with this userclass for the selectAccess method.
	
	For PUBLIC we initialize to the from/restrict values, otherwise
	we only set based on userclass.
	
	This method is used by method addCheckRightsCode.
	*/
	
	type String code = ""
	type String from = ""
	
	if restrict.beginsWith("[FROM ") do {
		
		set from = restrict.piece("[FROM ", 2).piece("]", 1)
		set restrict = restrict.piece("]", 2, PSL.maxStringLength).trim()
	}
	
	if (userclass '= "PUBLIC") set code = " if (userclass = """_ userclass_ """)"

	do this.addLine(source(), code_ " set restrict = """_ restrict_ """, from = """_ from_ """")
	
	quit
		
	
	// ---------------------------------------------------------------------
private void buildchkRequired(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCchkReqForInsert, vRCchkReqForUpdate, and
	vRCrequiredErr methods.
	
	Checks for required columns.  This section is only build for MDB
	tables, as RDB checking is handled by the DB.
	*/
	
	type List keys = this.td.primaryKeys
	type List required = this.td.requiredList
	type Number i, nodcnt()
	type Number rectype = this.td.recordType
	type String column, columnLC, nod, pos, sort(,), spaces
	
	kill source

	do this.addLine(source(), "")

	// Build insert section first	
	do this.addLine(source(), "private void vRCchkReqForInsert()")

	for i = 1:1:required.count() do {
		
		set column = required.elementAt(i)
		set columnLC = column.lowerCase()
		
		quit:column.isLiteral()			// Legacy literal keys
		
		type SchemaColumn cd = Db.getSchemaColumn(this.tableName, column)
		quit:'cd.computation.isNull()		// Computeds aren't required
		
		do this.addLine(source(), " if this."_ this.colName(columnLC, "LC", true) _ ".isNull() do this.vRCrequiredErr("_ this.colName(column, "UC", false).addQuotes()_ ")")
		
		// For multi-node global, build array sorted by node for use by update section
		if (rectype > 1) do {
			
			set nod = cd.getOldNode(1)
		
			set pos = +cd.position
			if 'cd.subfieldTag.isNull() set pos = pos_ "~"_ cd.subfieldTag
			set sort(nod, pos) = columnLC
			set nodcnt(nod) = nodcnt(nod).get() + 1
		}
	}

	do this.addLine(source(), " quit")
	do this.addLine(source(), "")

	// Build update section
	do this.addLine(source(), "private void vRCchkReqForUpdate()")
	
	do this.addLine(source(), " type public String vobj(,,,)")
	
	/* First check the keys - may be no keys for CUVAR-like tables */
	for i = 1:1:keys.count() do {

		set column = keys.elementAt(i)
		do this.addLine(source(), " if this."_ this.colName(column, "LC", true) _".isNull() do this.vRCrequiredErr("_ this.colName(column, "UC", false).addQuotes()_ ")")
	}

	/* If multi-node table, optimize by checking if any changes on a node.  If there is
	   only one required column on a node, don't bother with the node check. */
	set (nod, pos) = ""
	for  set nod = sort(nod).order() quit:nod.isNull()  do {
		
		if (nodcnt(nod) > 1) do {
			
			do this.addLine(source(), " if (vobj(this,-100,"_ nod_ ").data() > 9) do {")
			set spaces = "  "
		}
		else  do {
		
			do this.addLine(source(), " // Node "_ nod_ " - only one required column")
			set spaces = " "
		}

		for  set pos = sort(nod, pos).order() quit:pos.isNull()  do {
			
			set column = sort(nod, pos)
			do this.addLine(source(), spaces_ "if this.isChanged("_ this.colName(column, "UC", false).addQuotes()_ "), this."_ this.colName(column, "LC", true)_ ".isNull() do this.vRCrequiredErr("_ this.colName(column, "UC", false).addQuotes()_ ")")
		}

		if (nodcnt(nod) > 1) do this.addLine(source(), " }")
	}
	
	/* For record type 1, all at one level, no node checking necessary */
	if (this.td.recordType = 1) for i = 1:1:required.count() do {
		
		set column = required.elementAt(i)
		
		if 'keys.contains(column) do this.addLine(source(), " if this.isChanged("_ this.colName(column, "UC", false).addQuotes()_ "), this."_ this.colName(column, "LC", true)_ ".isNull() do this.vRCrequiredErr("_ this.colName(column, "UC", false).addQuotes()_ ")")
	}

	do this.addLine(source(), " quit")
	do this.addLine(source(), "")
	
	// This method will call throwError to set up verrors() array
	do this.addLine(source(), "private static void vRCrequiredErr(String column)")

	do this.addLine(source(), " type Boolean ER = false")
	do this.addLine(source(), " type String RM = """"")
	
	do this.addLine(source(), " do Runtime.setErrMSG("""_ this.tableName_ """, 1767, """_ this.tableName_ ".""_ column)")
	do this.addLine(source(), " if ER do Record"_ this.tableName_ ".throwError(RM.get())")
	
	do this.addLine(source(), " quit")
	
	quit
	
	
	// ---------------------------------------------------------------------
private void buildcolumnLists(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE columnList(), columnListBM(), and columnListCMP() methods.
	
	Build getColumnMap() if this table is using audit logging.
	
	columnList() will return a list of all columns that would be selected
	with SELECT *, i.e., all columns except computeds and Blob and Memo.
	
	columnListBM() will return a tab delimited list of all Blob and Memo
	columns
	
	columnListCMP() will return a tab delimited list of all computed
	columns
	
	getColumnMap() will return a map array of the following form:
	
		map(-n) = key column info (-n = -3 (key1), -4 (key2), etc.)
		map(-1) = column info for columns at top level
		map(n) = column info for columns at node 'n'
		map("vn") = column info for negative nodes
		
		column info = column name : type : piece : sub-field info
		sub-field info = sfd1~sfd2~sfp~sft (see DBTBL1D)
		
		column info is separated by semi-colons
		
		computed columns do not appear in the map
		
	The getColumnMap method is used by buildSQL^SQLAUDIT to construct SQL
	statements for audit log filing.
	*/
	
	type literal Number MAXAUDIT = 200
	type literal Number MAXCOLS = 20
	
	type Boolean isAuditLog = 'this.auditLog.isNull()
	type String columns = ""
	type String columnsBM = ""
	type String columnsCMP = ""
	type String CMP, DI, map(), SFD, sorted(), TYP
	
	kill source
	
	/* Cannot user order by with PSLBOOT */
	type ResultSet rs = Db.select("DI,TYP,SFD,CMP", "DBTBL1D", "%LIBS='SYSDEV' AND FID=:this.tableName")
	
	while rs.next() if 'rs.getCol("DI").isLiteral() set sorted(rs.getCol("DI")) = rs.getCol("TYP")_ "|"_ rs.getCol("SFD")_ "|"_ rs.getCol("CMP")
	
	set DI = ""
	for  set DI = sorted(DI).order() quit:DI.isNull()  do {
		
		set TYP = sorted(DI).piece("|", 1)
		set SFD = sorted(DI).piece("|", 2)
		set CMP = sorted(DI).piece("|", 3).replace(" ", "")	// Blobs and Memos have CMP = " "
		
		if 'CMP.isNull() set columnsCMP = columnsCMP_ DI_ ","
		else  if ({List}"B,M").contains(TYP) set columnsBM = columnsBM_ DI_ ","
		else  set columns = columns_ DI_ ","
		
		if isAuditLog, CMP.isNull() do {
			
			type PSLColumn cd = PSL.getPSLColumn(this.tableName, DI)
			type String nod = cd.getCurrentNode()
			
			// Skip masterfields (sub-fields will handle the data)
			if (cd.masterfieldType = 0) do {
			
				type String colInfo = cd.column_ ":"_ cd.dataType_ ":"_ cd.position
			
				if 'SFD.isNull() set colInfo = colInfo_ ":"_ SFD
			
				if (nod < 0) set map(nod) = colInfo
				else  if nod.isNull() set map(-1) = map(-1).get()_ colInfo_ ";"
				else  set map(nod) = map(nod).get()_ colInfo_ ";"
			}
		}
	}
	
	set columns = columns.extract(1, columns.length() - 1)
	set columnsBM = columnsBM.extract(1, columnsBM.length() - 1)
	set columnsCMP = columnsCMP.extract(1, columnsCMP.length() - 1)
	
	do this.addLine(source(), "")
	do this.addLine(source(), "public static List columnList()")
	
	if (columns.length(",") '> MAXCOLS) do {
		
		do this.addLine(source(), " quit {List}("""_ columns_ """.replace("","", 9.char()))"))
	}
	else  do {
		
		do this.addLine(source(), " type String columns = """"")
		
		while 'columns.isNull() do {
		
			do this.addLine(source(), " set columns = columns_ """_ columns.piece(",", 1, MAXCOLS)_ ",""")
			set columns = columns.piece(",", MAXCOLS + 1, columns.length(","))
		}
		
		do this.addLine(source(), " quit {List}(columns.extract(1, columns.length() - 1).replace("","", 9.char()))")
	}
	
	do this.addLine(source(), "")
	do this.addLine(source(), "public static List columnListBM()")
	
	if columnsBM.isNull() do {
		
		do this.addLine(source(), " quit {List}""""")
	}
	else  do this.addLine(source(), " quit {List}("""_ columnsBM_ """.replace("","", 9.char()))"))
	
	do this.addLine(source(), "")
	do this.addLine(source(), "public static List columnListCMP()")
	
	if (columnsCMP.length(",") '> MAXCOLS) do {
		
		do this.addLine(source(), " quit {List}("""_ columnsCMP_ """.replace("","", 9.char()))"))
	}
	else  do {
		
		do this.addLine(source(), " type String columns = """"")
		
		while 'columnsCMP.isNull() do {
		
			do this.addLine(source(), " set columns = columns_ """_ columnsCMP.piece(",", 1, MAXCOLS)_ ",""")
			set columnsCMP = columnsCMP.piece(",", MAXCOLS + 1, columnsCMP.length(","))
		}
		
		do this.addLine(source(), " quit {List}(columns.extract(1, columns.length() - 1).replace("","", 9.char()))")
	}
	
	// Build getColumnMap()
	if isAuditLog do {
		
		type Number i
		type String n
		
		do this.addLine(source(), "")
		do this.addLine(source(), "private static void getColumnMap(String map())")
		do this.addLine(source(), "")
		
		set n = ""
		for  set n = map(n).order() quit:n.isNull()  do {
			
			type String node = n
			
			if 'node.isNumber() set node = node.addQuotes()
			
			set map(n) = map(n).extract(1, map(n).length() - 1)
			
			do this.addLine(source(), " set map("_ node_ ") = "_ map(n).extract(1, MAXAUDIT).addQuotes())
			for i = (MAXAUDIT + 1):MAXAUDIT quit:map(n).extract(i, i + (MAXAUDIT - 1)).isNull()  do this.addLine(source(), " set map("_ node_ ") = map("_ node_ ")_ "_ map(n).extract(i, i + (MAXAUDIT - 1)).addQuotes())
		}
		
		do this.addLine(source(), " quit")
	}
	
	quit

	
	// ---------------------------------------------------------------------
private void builddelete(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCdelete method
	*/
	
	type List keys = this.td.primaryKeys
	
	kill source
	
	do this.addLine(source(), "")
	do this.addLine(source(), "private void vRCdelete(List vRCparams, String vRCaudit(), Boolean isKeyChange)")

	#IF CUVAR.PUBLISH
	do this.addLine(source(), " type public Number %SVCHNID")
	#END
	
	if this.td.isRdb do {
		
		type String code = " type String keyVals"
		
		if 'keys.isNull() do {
		
			type Number i
		
			for i = 1:1:keys.count() set code = code_", vkey"_ i
		}
		
		do this.addLine(source(), code_ ", retVal")
	}
	
	if (this.td.recordType > 1) do this.addLine(source(), " if 'isKeyChange.get(), this.isChanged() do this.throwError(""Deleted object cannot be modified"")")

	#IF CUVAR.PUBLISH
	if 'this.td.publishPGM.isNull() do this.addLine(source(), " if (%SVCHNID.get() <> 5) do "_ this.td.publishPGM)
	#END
	
	if this.sections.contains("cascadeDelete") do this.addLine(source(), " if vRCparams.contains(""CASDEL"", ""/"") do this.vRCcascadeDelete(vRCparams)")
	if this.sections.contains("indexes") do this.addLine(source(), " if vRCparams.contains(""INDEX"", ""/"") do this.updateIndexes(3, vRCaudit())")
	if this.sections.contains("journals") do this.addLine(source(), " if vRCparams.contains(""JOURNAL"", ""/"") do this.vRCjournals(3, vRCaudit())")

	if this.td.isAutoLog do this.addLine(source(), " if 'vRCparams.contains(""NOLOG"", ""/"") do ^DBSLOGIT(this, 3)")

	if 'this.td.isRdb do {
	
		type String code = " kill "
		type String globalRef = $$getGbl^UCXDD(this.td, "this")
				
		if (this.td.recordType < 10), 'this.hasMoB set code = " ZWI "
		
		do this.addLine(source(), " #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS")
		do this.addLine(source(), " #BYPASS")
		
		// Cannot depend on key count (see table CMSOPT, for example)
		if globalRef.endsWith(",") set globalRef = globalRef.extract(1, globalRef.length() - 1))_ ")"
		else  set globalRef = globalRef.extract(1, globalRef.length() - 1))
			
		do this.addLine(source(), code_ globalRef)

		do this.addLine(source(), " #ENDBYPASS")
	}
	// RDB
	else  do {

		type Number i
		type String sql()
		
		if keys.isNull() do {
			
			do this.addLine(source(), " set keyVals = """"")
		}
		else  do {
			
			type String code = ""
			
			for i = 1:1:keys.count() do {
				
				type Boolean isNum = false
				type String key = keys.elementAt(i)
				type String keyLC = key.lowerCase()
				
				type SchemaColumn cd = Db.getSchemaColumn(this.tableName, key)
				
				if ({List}"N,$,L").contains(cd.dataType) set isNum = true
				
				if 'code.isNull() set code = code_ "_ " _ this.delimiterStr_ "_ "
				set code=code_ "this."_ keyLC
				do this.addLine(source(), " set vkey"_ i_ " = this."_ this.colName(keyLC, "LC", true))
			}

			do this.addLine(source(), " set keyVals = "_code_ "_ "_ this.delimiterStr)
		}
		
		if keys.isNull() set sql(1) = "DELETE FROM "_ this.tableName
		else  do {
			
			type List nattable = Class.new("List")
			type String whereKeyNat
			
			set whereKeyNat = this.getWhereKey("", true, .nattable)
			
			// Handle wide tables (one table split into multiple)
			for i = 1:1:nattable.count() set sql(i) = "DELETE FROM "_nattable.elementAt(i)_ " WHERE "_ whereKeyNat
		}
		
		// If we get error on delete, catch and re-throw as DBFILER error
		do this.addLine(source(), " catch delError {")
		do this.addLine(source(), "  do this.throwError(delError.description)")
		do this.addLine(source(), " }")
		
		for i = 1:1 quit:'sql(i).exists()  do this.addLine(source(), " set retVal = $$EXECUTESQL^%DBAPI("""","_ sql(i).addQuotes()_ ","_ this.delimiterStr_ ", keyVals)")
	}

	do this.addLine(source(), " quit")

	quit	
	
		
	// ---------------------------------------------------------------------
private void builderror(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE throwError() method.
	*/
	
	kill source
	
	do this.addLine(source(), "")
	do this.addLine(source(), "private static void throwError(String MSG)")

	do this.addLine(source(), " throw Class.new(""Error"", ""%PSL-E-DBFILER,""_ MSG.replace("","",""~""))")
	
	do this.addLine(source(), " quit")
	
	quit
	
	
	// ---------------------------------------------------------------------
private void buildforceLoad(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCforceLoad method

	For multi-node tables, need to ensure all data is loaded for certain
	operations.  The vRCforceLoad method will force incremental loading
	of any remaining data.  Do this directly with globals.  For RDB
	generate code to load a column from each split table.
	*/
	
	kill source
	
	do this.addLine(source(), "")
	do this.addLine(source(), "private void vRCforceLoad()")

	if 'this.td.isRdb do {
			
		type Boolean hasNegNodes = this.td.nodeQuotedList.isLike("%""v%")
		type String code, globalRef
		
		set globalRef = $$getGbl^UCXDD(this.td, "this")_ "n)"
			
		do this.addLine(source(), " type String n = """"")
		if hasNegNodes do this.addLine(source(), " type String vn")
		do this.addLine(source(), " #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS")
		do this.addLine(source(), " #BYPASS")
		
		set code = " for  set n=$order("_ globalRef_ ") quit:n=""""  "
		if hasNegNodes set code = code_"s vn=$S(n<0:""v""_-n,1:n) if '$D(vobj(this,vn)),$D("_ globalRef_ ")#2 set vobj(this,vn)=^(n)"
		else  set code = code_"if '$D(vobj(this,n)),$D("_ globalRef_ ")#2 set vobj(this,n)=^(n)"
		do this.addLine(source(), code)
		
		do this.addLine(source(), " #ENDBYPASS")
		do this.addLine(source(), " quit")
	}
		
	else  do {
		
		type public String %DB
			
		do this.addLine(source(), " type String X")
			
		type ResultSet rs = Db.select("DISTINCT RTBL", "DBMAP", "DB=:%DB AND TBL=:this.tableName", "RTBL ASC")
		while rs.next() do {
			
			type String rtbl = rs.getCol("RTBL")
			
			type ResultSet rs2 = Db.select("COL", "DBMAP", "DB=:%DB AND TBL=:this.tableName AND RTBL=:rtbl")
				
			if rs2.next() do this.addLine(source(), " set X = this."_ rs2.getCol("COL"))
		}
		
		do this.addLine(source(), " quit")
	}
	
	quit
	
		
	// ---------------------------------------------------------------------
private void buildforeignKeys(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCsetForeignKeys and vRCcheckForeignKeys methods
	
	vRCsetForeignKeys sets up foreign key info for SQLBUF.  vfkey() is used
	by SQLBUF to check foreign keys once all updates to all tables have
	complete.
	
	vRCcheckForeignKeys checks foreign keys when not under a buffer.
	*/
	
	type List requiredList
	type String fkey, fkeys(), table
	
	kill source
	
	// load all the foreign key definitions for this table and it's ancestors into the fkeys() array
	set table = this.tableName
	while 'table.isNull() do {

		type ResultSet rs = Db.select("FKEYS,TBLREF", "DBTBL1F", "FID = :table AND TBLREF IS NOT NULL")
		while rs.next() set fkeys(rs.getCol("FKEYS")) = rs.getCol("TBLREF")

		if this.tableName = table set table = this.td.parentTable
		else  do {
			
			type PSLTable td2 = PSL.getPSLTable(table, 0)
			set table = td2.parentTable
		}
	}
	
	do this.addLine(source(), "")
	
	// Build set foreign key logic used by SQLBUF first
	do this.addLine(source(), "private void vRCsetForeignKeys()")
	
	do this.addLine(source(), " type public String vfkey()")

	set fkey = ""
	for  set fkey = fkeys(fkey).order() quit:fkey.isNull()  do {
		
		type Number fknum, i
		type String code, fktable, globalKeys, lastKey, newKeys, tok
		
		set fktable = fkeys(fkey)
	
		type PSLTable tdfk = PSL.getPSLTable(fktable, 0)
		
		set globalKeys = tdfk.global.piece("(", 2, 99)

		// Add node checking logic
		if 'tdfk.existsNode.isNull() set globalKeys = globalKeys_ ","_ tdfk.existsNode
		
		// Tokenize to prevent problems with quoted strings containing commas
		#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
		set globalKeys = $$TOKEN^%ZS(globalKeys, .tok)
		set newKeys = ""
		set fknum = 1
		for i = 1:1:globalKeys.length(",") do {	 // Map each key
			
			type String key = globalKeys.piece(",", i)
			
			// Deal with literals
			if key.isNumber()			// Leave numbers alone
			#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
			else  if key.beginsWith(0.char()) set key = $$UNTOK^%ZS(key, tok).addQuotes()
			// Deal with foreign keys - replace with this.column reference
			else  do {
				
				set key = fkey.piece(",", fknum)
				set fknum = fknum + 1
				set lastKey = key
				set key = """""""""_"_"this."_ this.colName(key, "LC", true)_"_"""""""""
			}
			set newKeys = newKeys_ key_ "_"",""_"
		}

		set newKeys = newKeys.extract(1, newKeys.length() - 5)

		set code = " if 'this."_ this.colName(lastKey, "LC", true)_ ".isNull()"
		set code = code_ " set vfkey("""_ tdfk.global.piece("(", 1)_ "(""_"_ newKeys_"_"")"")="
		set code = code_ """"_ this.tableName_ "("_ fkey_ ") -> "_ fktable_ """"
		
		do this.addLine(source(), code)
	}

	do this.addLine(source(), " quit")
	do this.addLine(source(), "")
	
	// Build check foreign key logic used when not under SQL buffer
	do this.addLine(source(), "private void vRCcheckForeignKeys()")

	set requiredList = this.td.requiredList

	set fkey = ""
	for  set fkey = fkeys(fkey).order() quit:fkey.isNull()  do {
		
		type List fktableKeys
		type Number i
		type String code, fktable, newKeys, noreqKeys
	
		set fktable = fkeys(fkey)
		
		type PSLTable fktbl = PSL.getPSLTable(fktable, 0)
		
		set fktableKeys = fktbl.primaryKeys
		
		set (newKeys, noreqKeys) = ""
		for i = 1:1:fkey.length(",") do {
			
			type String key = fkey.piece(",", i)

			set newKeys = newKeys_ fktableKeys.elementAt(i)_ "=:this."_ this.colName(key, "LC", true)_ ","

			if 'requiredList.contains(key) set noreqKeys = noreqKeys_ "'this."_ this.colName(key, "LC", true)_ ".isNull(),"
		}

		set code = " if 'Db.isDefined("""_ fktable_ ""","_ newKeys.extract(1, newKeys.length() - 1).addQuotes()_ ")"
		// Referential integrity error ~p1
		set code = code_ " do Record"_ this.tableName_ ".throwError($$^MSG(8563,"""_ this.tableName_ "("_ fkey_ ") -> "_ fktable_ """))"
		if 'noreqKeys.isNull() set code = " if "_ noreqKeys.extract(1, noreqKeys.length() - 1) _ code

		do this.addLine(source(), code)
	}

	do this.addLine(source(), " quit")
	
	quit
		

	// ---------------------------------------------------------------------
private void buildgetArchiveFile(String source(),	// Build code into source,
				 PSLTable tdarch,	// Archive table descriptor
				 List keyNames,		// Archive key names
				 List keyTypes,		// Archive key data types
				 String keyValues,	// Key values assignment code
				 String formalParams,	// Formal parameters for method call
				 String comment,	// Key map comment
				 Boolean isNotArchived) // Build "shell" method
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE getArchiveFile method
	
	This method is only available for tables that are archived.
	
	The purpose of the getArchiveFile() method is to return the specific or
	next/previous archive file based on input.
	
	Generated code requires input of table name since a primary RecordTABLE
	class is also responsible for archiving sub-tables, related tables
	(DBUTARCHIVE.INCLUDED), and sub-tables of related tables.
	
	Options to getArchiveFile:
		 0 -  return archive file the record would be in (null indicates
		      primary file).  A null value passed in for the archive key
		      will return the first archive file, if the main keys are
		      archived, otherwise a null, for the primary file.
		 1 -  collate forward from given record to find next archive
		      file.  I.e., what is the next archive file after the file
		      that this record is/would be in.  Null indicates end of 
		      archives and now in primary.
		 -1 - collate backward from given record to find prior archive
		      file.  I.e., what is the prior archive file before the file
		      that this record is/would be in.  Null indicates end of 
		      archives.
	
	getArchiveFile method returns:
	
		Archive file name, or null
		
		Expanded file name for the archive global directory to be
		able to be used in extended references.  E.g. if index value for
		next archive file is 19, translates environment variable
		SCAU_ARCHIVE_19, and returns that value.
		
		Null if there are no further archives.  If direction is forward,
		this indicates end of list, primary and then all archives.  If
		direction is reverse, this indicates done with archives and now
		in primary file.
		
	Note that if keycnt = 1, then keycode and keyvals will be 0.  This will
	occur for tables that are archived on the first key.
	*/
	
	type Boolean isOneTable = false
	type List archincl = {List}(tdarch.getArchiveIncluded())
	type List archsubs = {List}(tdarch.getArchiveSubs())
	type Number i
	type Number keycnt = keyTypes.count()
	type String archiveTable = tdarch.table
	type String code, indexTable, throwcode
	
	if archsubs.isNull(), archincl.isNull() set isOneTable = true
	
	do this.addLine(source(), "")
	set code = "public static String getArchiveFile(String archiveTable, Number option, "
	if (keycnt > 1) set code = code_ formalParams_ ", "
	do this.addLine(source(), code_ keyTypes.elementAt(keycnt)_ " archiveKey)")
	
	if isNotArchived do this.addLine(source(), " quit """" // Shell method") quit
	
	do this.addLine(source(), " // "_ comment)
	
	do this.addLine(source(), " type Number archiveNum")
	
	set code = " type String "
	if 'isOneTable set code = code_ "indexTable, "
	set code = code_ "archiveFile, keyValues"
	do this.addLine(source(), code)
	
	/* Determine which table's index to use.  Sub-tables of primary use the
	   primary index.  Related tables use their own.  Sub-tables of related
	   tables use the related table index. */
	
	// ~p1 is not an archived table
	set throwcode = "throw Class.new(""Error"", ""%DQ-E-DBFILER,""_ $$^MSG(6901, archiveTable).replace("","",""~""))"
	
	// Just the primary
	if isOneTable do {
		
		set indexTable = archiveTable.addQuotes()
		
		set code = " if (archiveTable '= "_ indexTable_ ") "_ throwcode
		do this.addLine(source(), code)
	}
	
	/* Check sub-tables, related tables, and subs-tables of related tables.
	   Include comments in the generated source in this case as it may aid
	   debugging. */
	else  do {
		
		set indexTable = "indexTable"
	
		do this.addLine(source(), " // Primary table")
		do this.addLine(source(), " if (archiveTable = """_ archiveTable_ """) set indexTable = """_ archiveTable_ """")

		if 'archsubs.isNull() do {
		
			do this.addLine(source(), " // Sub-table of primary")
			if (archsubs.count() = 1) set code = " else  if """_ archsubs_ """ = archiveTable set indexTable = """_ archiveTable_ """"
			else  set code = " else  if ({List}"""_ archsubs_ """).contains(archiveTable) set indexTable = """_ archiveTable_ """"
			do this.addLine(source(), code)
		}
		if 'archincl.isNull() do {
		
			type Boolean addCmt = true
			type Number i
		
			do this.addLine(source(), " // Included With (related) table")
			if (archincl.count() = 1) set code = " else  if """_ archincl_ """ = archiveTable set indexTable = archiveTable"
			else  set code = " else  if ({List}"""_ archincl_ """).contains(archiveTable) set indexTable = archiveTable"
			do this.addLine(source(), code)
			
			for i = 1:1:archincl.count() do {
		
				type List inclsubs
				type String incltbl
				
				set incltbl = archincl.elementAt(i)
				
				type PSLTable tdincl = PSL.getPSLTable(incltbl)
	
				set inclsubs = {List}(tdincl.getArchiveSubs())
		
				if 'inclsubs.isNull() do {
	
					if addCmt do this.addLine(source(), " // Sub-tables of related tables")
					set addCmt = false
					if (inclsubs.count() = 1) set code = " else  if """_ inclsubs_ """ = archiveTable set indexTable = """_ incltbl_ """"
					else  set code = " else  if {List}"""_ inclsubs_ """.contains(archiveTable) set indexTable = """_ incltbl_ """"
					do this.addLine(source(), code)
				}
			}
		}
		
		do this.addLine(source(), " else  "_ throwcode)
	}

	do this.addLine(source(), " set keyValues = "_ keyValues)
	
	do this.addLine(source(), " // Find archive this record would be in")
	do this.addLine(source(), " if (option = 0) do { quit archiveFile")
	do this.addLine(source(), "  type Number n")

	do this.addLine(source(), " #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
	do this.addLine(source(), " #BYPASS")
	do this.addLine(source(), " set n=$O(^DBARCHX("_ indexTable_ ",keyValues,archiveKey-1E-10))")
	do this.addLine(source(), " if n="""" set archiveFile=""""")
	do this.addLine(source(), " else  do")
	do this.addLine(source(), " .  set archiveNum=^DBARCHX("_ indexTable_ ",keyValues,n)")
	do this.addLine(source(), " .  set archiveFile=$ZTRNLNM(""SCAU_ARCHIVE_""_archiveNum)")
	do this.addLine(source(), " #ENDBYPASS")
        do this.addLine(source(), " }")
	
	do this.addLine(source(), " // Find next/previous archive")
	do this.addLine(source(), " #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
	do this.addLine(source(), " #BYPASS")
	do this.addLine(source(), " if (option=1),(archiveKey'=""""),'$D(^DBARCHX("_ indexTable_ ",keyValues,archiveKey)) set archiveKey=$O(^DBARCHX("_ indexTable_ ",keyValues,archiveKey))")
	do this.addLine(source(), " set archiveKey=$O(^DBARCHX("_ indexTable_ ",keyValues,archiveKey),option)")
	do this.addLine(source(), " if archiveKey="""" set archiveFile=""""")
	do this.addLine(source(), " else  do")
	do this.addLine(source(), " .  set archiveNum=^DBARCHX("_ indexTable_ ",keyValues,archiveKey)")
	do this.addLine(source(), " .  set archiveFile=$ZTRNLNM(""SCAU_ARCHIVE_""_archiveNum)")
	do this.addLine(source(), " #ENDBYPASS")
	do this.addLine(source(), "")
	do this.addLine(source(), " quit archiveFile")
	
	quit
	
	
	// ---------------------------------------------------------------------
void buildgetRecord(String source())		// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCgetRecord*() methods.
	
	There are four methods built in support of the Db.getRecord() method:
	
	  - vRCgetRecord0 - classNew = false, no optimization
	  - vRCgetRecord1 - classNew = true, no optimization
	  - vRCgetRecord0Opt - classNew = false, use optimization
	  - vRCgetRecord1Opt - classNew = true, use optimization
	
	Used by PSL Db.getRecord() to instantiate a RecordTABLE object.
	*/
	
	type Number i
	type String code = $$getRecSrCode^UCDB(this.td, "vOid")
	
	kill source
	
	for i = 1:1:code.length(9.char()) do this.addLine(source(), code.piece(9.char(), i))
	
	quit
			
	
	// ---------------------------------------------------------------------
private void buildhasLiterals(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vhasLiterals method
	
	Used by UCSYSMAP and UCXDD
	*/
	
	type String code = "public static Boolean vhasLiterals() quit "
	
	kill source

	do this.addLine(source(), "")

	if this.sections.contains("literals") set code = code_ "true"
	else  set code = code_ "false"
	
	do this.addLine(source(), code)
	
	quit
	
		
	// ---------------------------------------------------------------------
private void buildindexes(String source(),		// Build code into source
			  PSLTokenizer tknzr)		// Tokenizer object
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE updateIndexes and related index methods.
	*/
	
	type Number i,  j
	type String code, indexes()
		
	kill source
	
	// Add indexes to tknzr source and build indexes() info.
	type ResultSet rs = Db.select("INDEXNM,IDXDESC,GLOBAL,ORDERBY,UPCASE", "DBTBL8", "%LIBS='SYSDEV' AND FID = :this.tableName")

	while rs.next() do this.getIndexCode(indexes(), rs.getCol("INDEXNM"), rs.getCol("IDXDESC"), rs.getCol("GLOBAL"), rs.getCol("ORDERBY"), rs.getCol("UPCASE"), tknzr)
	
	/* Add logic for methods rebuildIndexes (for one record) and rebuildIndexesTable
	   (for entire table - used by external calls */
	   
	do this.addLine(source(), "")
	   
	do this.addLine(source(), "public static void rebuildIndexesAllRecs(List indexList)")
	
	do this.addLine(source(), " type String audit()")
	
	do this.addLine(source(), " if indexList.isNull() set indexList = ""*""")	// Build all

	do this.addLine(source(), " type DbSet ds=Db.selectDbSet("""_ this.tableName_ """)")

	do this.addLine(source(), " while ds.next() do {")
	do this.addLine(source(), "  type Record"_ this.tableName_ " "_ this.tableNameLC_ " = ds.getRecord("""_this.tableName_ """)")
	
	do this.addLine(source(), "  if indexList.contains(""*"") do "_ this.tableNameLC_ ".updateIndexes(0, audit()) quit")
	
	for i = 1:1:this.indexSeq - 1 do this.addLine(source(), "  if indexList.contains("""_ indexes(i).piece("|", 1)_ """) do "_ this.tableNameLC_ ".vRCIdx"_ i_ "(0)")
	
	do this.addLine(source(), " }")
	do this.addLine(source(), " quit")
	
	do this.addLine(source(), "")
	
	if this.children.isNull() set code = "final "
	else  set code = ""
	
	do this.addLine(source(), "public "_ code_ "void rebuildIndexes(List indexList)")
	
	do this.addLine(source(), " type String audit()")
	
	do this.addLine(source(), " if indexList.contains(""*"") do this.updateIndexes(0, audit()) quit")
	
	for i = 1:1:this.indexSeq - 1 do this.addLine(source(), "  if indexList.contains("""_ indexes(i).piece("|", 1)_ """) do this.vRCIdx"_ i_ "(0)")
	
	do this.addLine(source(), " quit")
	
	do this.addLine(source(), "")
	do this.addLine(source(), "private void updateIndexes(Number processMode, String audit())")
	
	do this.addLine(source(), " if (processMode = 1) do {")
	
	/* If the number of table indices is less than 10, for each index build
	   code that determines if any of the columns in the index have been
	   modified.  If so, call the applicable method to update the index.
	*/
	if (this.indexSeq < 10) do {
		
		type String column
		
		for i = 1:1:this.indexSeq - 1 do {
			
			type List nonKeys = {List}(indexes(i).piece("|", 2))
			type String code = ""

			for j = 1:1:nonKeys.count() do {
				
				set column = nonKeys.elementAt(j)
				
				if 'column.isNull() do {
			
					set code = code_ "this.isChanged("_ this.colName(column, "UC", false).addQuotes()_ ") or "
				}
			}
			
			if 'code.isNull() do {
			
				set code = "  if "_ code.extract(1, code.length() - 4)
				set code = code_ " do this.vRCIdx"_ i_ "(1)"
				
				do this.addLine(source(), code)
			}
		}
	}
	/* Otherwise, build code that determines if the modified column(s) are
	   found in the index 'map'.  If so, call the method(s) associated
	   with the column to update the index.
	*/
	else  do {
		
		type List nonKeys
		type String code = ""
		type String columns
		
		do this.addLine(source(), "  type Number idxnum, ptr")
		do this.addLine(source(), "  type String column, map")
		
		for i = 1:1:this.indexSeq - 1 do {
			
			set nonKeys = {List}(indexes(i).piece("|", 2))
			set columns = ""
			
			// Remove nulls from nonKeys list
			for j = 1:1:nonKeys.count() if 'nonKeys.elementAt(j).isNull() set columns = columns_ nonKeys.elementAt(j)_ ","
			
			set code = code_ ","_ columns_ ",~"_ i_ "~|"
		}
		
		for i = 1:400:code.length() do {
			
			type String setmap = "  set map = "
			
			if (i <> 1) set setmap = setmap_ "map_ "
			
			do this.addLine(source(), setmap_ code.extract(i, i + 399).addQuotes())
		}
		
		do this.addLine(source(), "  set ptr = 0")
		do this.addLine(source(), "  set column = """"")
		do this.addLine(source(), "  for  set column = audit(column).order() quit:column=""""  do {")
		do this.addLine(source(), "   for  set ptr = map.find(("",""_ column_ "",""), ptr) quit:(ptr = 0)  do {")
		do this.addLine(source(), "    set idxnum = map.extract(ptr, PSL.maxStringLength).piece(""~"", 2)")
		do this.addLine(source(), "    set map.piece(""|"", idxnum) = """"")
		
		for i = 1:1:this.indexSeq - 1 do this.addLine(source(), "     if (idxnum = "_ i_ ") do this.vRCIdx"_ i_ "(1) quit")
		
		do this.addLine(source(), "   }")
		do this.addLine(source(), "  }")
	}
	
	do this.addLine(source(), " }")
	do this.addLine(source(), " else  do {")
	
	for i = 1:1:this.indexSeq - 1 do this.addLine(source(), "  do this.vRCIdx"_ i_ "(processMode)")
	
	do this.addLine(source(), " }")		
	do this.addLine(source(), " quit")
	
	quit
	

	// ---------------------------------------------------------------------
private void buildjournals(String source(),		// Build code into source
			   PSLTokenizer tknzr)		// Tokenizer object
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCjournals and related journal methods.
	*/
	
	type Boolean hasIfConds = false
	type String ifConds(), journals(), sort(,,,,,)
	
	kill source
	
	do this.addLine(source(), "")
	do this.addLine(source(), "private void vRCjournals(Number processMode, String vRCaudit())")

	/* %TSRC supposedly carries an indication of the transaction type, as
	   set up in the journal file definition, Financial, On-line, or Batch.
	   However, it is not clear what should set this up.  At this point,
	   I cannot find anything that does.  */
	do this.addLine(source(), " type public String %TSRC")
	do this.addLine(source(), " type String TSRC")

	do this.addLine(source(), " if %TSRC.get().isNull() set TSRC = ""O""")
	do this.addLine(source(), " else  set TSRC = %TSRC")
	
	/* Sort journal entries.  Use a two pass process to optimize final code.  First
	   sort creates:
	   
	      SORT(MODE,TRANTYPE,EFDOPT,PRIO,'INCOLUMN.isNull(),JRNID) = INCOLUMN
	    
	   Each of the first three levels may contain multiple options, e.g "I,U,D".  If
	   a level only consists of all the options, then tests for an option value are
	   not necessary, and hence can be optimized.  If that's not the case, then the
	   elements of that level need to be broken into individual components.  (For
	   example, "I,U" needs to be broken into I and U.  This "break" is done as a
	   second step in creating the final SORT array.
	   
	   Note:  mode = I,U,D
	   	  trantype = F,O,B
	   	  efd = N,E
	   	  
	   Structure also considers priority order, and allows optimization for journals
	   which have INCOLUMN values to test prior to call to journal section.
	*/
	
	do this.getJournalCode(journals(), sort(,,,,,), .hasIfConds, ifConds(), tknzr)
	
	/* Build dispatch code
	
	   If any of the first three levels of SORT are all options for that level,
	   i.e., "I,U,D", then we don't need to test that condition, so don't need
	   to build code for it.
	   
	   If there is only one priority at a level, we can optimize updates related
	   to INCOLUMN by quiting before testing for column changes.
	   
	   Promote ifconds, if any, and if possible, based on ifConds().  See
	   getJournalCode() for structure.  (Note that more work could be done on
	   this to avoid nested repetition of ifconds, particularly if there is
	   only one journal at an M-T-E level with an ifcond, but at this point,
	   given that they'll be resolved anyway at compile time, it's not worth
	   the effort.
	*/

	type Boolean hasMultiPrio, hitMode, hitTrantype, setQuit
	type Number incol, prio
	type String code, efdopt, jrnid, mode, trantype, ws	

	set (efdopt, mode, prio, trantype) = ""
	set ws = " "

	set hitMode = false
	for  set mode = sort(mode).order() quit:mode.isNull()  do {
		
		if hasIfConds, 'ifConds(mode).isNull() do this.addLine(source(), " #IF "_ ifConds(mode))
		
		if (mode '= "I,U,D") do {
		
			set code = "if (processMode = "_ mode.translate("IUD", "013")_ ") do { quit"
			do this.addLine(source(), ws_ code)
			set ws = ws_ " "
			set hitMode = true
		}

		set hitTrantype = false
		for  set trantype = sort(mode, trantype).order() do { quit:trantype.isNull()
			
			// Close structured do from mode, if necessary
			if trantype.isNull() do { quit
				
				if hitMode do this.addLine(source(), " }")
				set ws = " "
			}
			
			if hasIfConds, 'ifConds(mode_ "-"_ trantype).isNull() do this.addLine(source(), ws_ "#IF "_ ifConds(mode_ "-"_ trantype))
			
			if (trantype '= "F,O,B") do {
			
				set code = "if (TSRC = """_ trantype_ """) do { quit"
				do this.addLine(source(), ws_ code)
				set ws = ws_ " "
				set hitTrantype = true
			}
			
			for  set efdopt = sort(mode, trantype, efdopt).order() do { quit:efdopt.isNull()
				
				// Close structured do from trantype, if necessary
				if efdopt.isNull() do { quit
					
					set ws = ws.extract(1, ws.length() - 1)
					if hitTrantype do this.addLine(source(), ws_ "}")
				}
				
				if hasIfConds, 'ifConds(mode_ "-"_ trantype_ "-"_ efdopt).isNull() do this.addLine(source(), ws_ "#IF "_ ifConds(mode_ "-"_ trantype_ "-"_ efdopt))
				
				if (efdopt '= "N,E") do {
				
					if (efdopt = "E") set code = "%EffectiveDate.get()"
					else  set code = "(%EffectiveDate.get() '> 0)"
					
					set code = "if "_ code_" do {"
					do this.addLine(source(), ws_ code)
					set ws = ws_ " "
				}
				
				set setQuit = false
				set hasMultiPrio = (sort(mode, trantype, efdopt, "").order() '= sort(mode, trantype, efdopt, "").order(-1))
				
				set prio = ""
				for  set prio = sort(mode, trantype, efdopt, prio).order() quit:prio.isNull()  do {

					/* Determine if any priorities past this one have journals that
					   aren't dependend on specific columns (INCOLUMN).  moreLvl0
					   indicates if there are journals for any priority that do not
					   depend on columns.  */
					
					type Boolean moreLvl0 = false
					
					if hasMultiPrio do {
						
						type String x = prio
						
						for  set x = sort(mode, trantype, efdopt, x).order() quit:x.isNull()  if (sort(mode, trantype, efdopt, x, 0).data() > 0) set moreLvl0 = true
					}

					set incol = ""
					for  set incol = sort(mode, trantype, efdopt, prio, incol).order() quit:incol.isNull()  do {
						
						type Boolean columnDeclared = false
						
						/* If single priority, or if multiple, but no further not-INCOLUMN
						   journals, then can quit if vx not defined */
						if (incol > 0), 'moreLvl0, 'setQuit do {
							
							do this.addLine(source(), ws_ "quit:(vRCaudit.data() '> 0)")
							set setQuit = true	// Only add one quit on vRCaudit at EFD level
						}
				
						set jrnid = ""
						for  set jrnid = sort(mode, trantype, efdopt, prio, incol, jrnid).order() quit:jrnid.isNull()  do {
							
							type Boolean addEndIf = false
							type String incolumn = sort(mode, trantype, efdopt, prio, incol, jrnid)
							
							if 'journals(jrnid).piece(9.char(), 3).isNull() do {
							
								do this.addLine(source(), ws_ "#IF "_ journals(jrnid).piece(9.char(), 3))
								set addEndIf = true
							}
							
							set code = "do this.vRCJrn"_ journals(jrnid).piece(9.char(), 1)_ "(vRCaudit()"
							
							if (incol = 0) set code = code_ ")"
							// If INCOLUMN(s), pass added parameter
							else  do {
								
								if incolumn.isLike("%,%") do {
									
									set code = code_ ", column)"
									/* If not OldValue, NewValue of FMTable, just
									   one journal entry, not per column, so quit
									   after one. */
									if journals(jrnid).piece(9.char(), 2).isNull() set code = code_ " quit"
								}
								else  set code = code_ ", """_ incolumn_ """)"
							} 

							set code = code_ "  // JRNID="_ jrnid
							set code = code_ " Mode="_ mode
							set code = code_ " Tran="_ trantype
							set code = code_ " EFD="_ efdopt
							set code = code_ " Seq="_ prio
							
							// Add testing for column changes before journal call
							if (incol = 1) do {
								
								// Only one column included
								if 'incolumn.isLike("%,%") set code = "if this.isChanged("_ this.colName(incolumn, "UC", false).addQuotes()_ ") "_ code
								else  do {
									
									type Number i
									type String morecode = "for column = "
									
									if 'columnDeclared do {
										
										do this.addLine(source(), ws_ "type String column")
										set columnDeclared = true
									}
									
									for i = 1:1:incolumn.length(",") set morecode = morecode_ incolumn.piece(",", i).addQuotes()_ ", "
									set code = morecode.extract(1, morecode.length() - 2)_ " if vRCaudit(column).exists() "_ code
								}
							}
							
							do this.addLine(source(), ws_ code)
							
							if addEndIf do this.addLine(source(), ws_ "#ENDIF")
						}
					}
				}
					
				if (efdopt '= "N,E") do {		// Close this EFD loop
					
					set ws = ws.extract(1, ws.length() - 1)
					do this.addLine(source(), ws_ "}")
				}
				
				if hasIfConds, 'ifConds(mode_ "-"_ trantype_ "-"_ efdopt).isNull() do this.addLine(source(), ws_ "#ENDIF")
			}
			
			if hasIfConds, 'ifConds(mode_ "-"_ trantype).isNull() do this.addLine(source(), ws_ "#ENDIF")
		}
		
		if hasIfConds, 'ifConds(mode).isNull() do this.addLine(source(), " #ENDIF")
	}
	
	do this.addLine(source(), " quit")
	
	quit
	

	// ---------------------------------------------------------------------
private void buildkeyChanged(String source())		// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCkeyChanged method.
	       
	Key change logic is similar for both MDB and RDBs:
	
		- Create the new parent record
		- Create new versions of the children
		- Delete the old children
		- Delete the old parent
		
	   This logic prevents constraint errors due to either missing
	   children or missing parents during the change.
	   
	   Only the update triggers are fired for the record since
	   we treat it as an update (of the keys), not a logical
	   insert/delete.
	*/
	
	type Boolean hasIndex = this.sections.contains("indexes")
	type List keysLC = {List}(this.td.primaryKeys.lowerCase())
	type Number i, keycnt
	type String nattable
	type String newkeys = ""
	
	kill source
	
	set keycnt = keysLC.count()
	
	do this.addLine(source(), "")
	do this.addLine(source(), "private void vRCkeyChanged(List vRCparams, String vRCaudit())")
	
	if (keycnt = 0) do this.addLine(source(), " quit") quit
	
	do this.addLine(source(), " type String newkeys, oldkeys, vRCauditIns()")
	
	// If there are after update triggers, save parameters
	if this.sections.contains("AU") do this.addLine(source(), " type String oldparams = vRCparams")
	
	// Save old and new key values (regardless if particular ones have changed)
	for i = 1:1:keycnt do {
		
		do this.addLine(source(), " type String newKey"_ i_ " = this."_ this.colName(keysLC.elementAt(i), "LC", true)_ ".curVal")
		do this.addLine(source(), " type String oldKey"_ i_ " = this."_ this.colName(keysLC.elementAt(i), "LC", true)_ ".oldVal")
		
		set newkeys = newkeys_ "newKey"_ i_ "_"",""_"
	}
	
	// Make sure "new" record doesn't already exist
	do this.addLine(source(), " if Db.isDefined("""_ this.tableName_ ""","_ this.getWhereKey("this", false, .nattable).addQuotes()_ ") do this.throwError($$^MSG(2327))")
	
	// Build newkey and oldkey string for use by CASUPD^DBSEXECU
	set newkeys = newkeys.extract(1, newkeys.length() - 5)
	do this.addLine(source(), " set newkeys = "_ newkeys)
	do this.addLine(source(), " set oldkeys = "_ newkeys.replace("new", "old"))
	
	// Move old keys into record
	for i = 1:1:keycnt do this.addLine(source(), " set this."_ this.colName(keysLC.elementAt(i), "LC", true)_ " = oldKey"_ i)

	// Switch index off
	if 'this.td.isRdb do this.addLine(source(), " set vRCparams = $$setPar^UCUTILN(vRCparams, ""NOINDEX"")")
	
	// Ensure all data is loaded locally
	if (this.td.recordType > 1) do this.addLine(source(), " do this.vRCforceLoad()")
	
	if 'this.td.isRdb, this.sections.contains("required") do this.addLine(source(), " if vRCparams.contains(""VALREQ"", ""/"") do this.vRCchkReqForInsert()")

	// If before update triggers (non-key or key columns), handle
	if this.sections.contains("BU") do this.addLine(source(), " if vRCparams.contains(""TRIGBEF"", ""/"") do this.vRCbeforeUpdTrigs(vRCparams, vRCaudit())")

	do this.addLine(source(), " if vRCparams.contains(""VALDD"", ""/"") do this.vRCvalidateDD(1)")
	do this.addLine(source(), " do this.vRCmiscValidations(vRCparams, 1)")
	do this.addLine(source(), " do this.vRCupdateDB(1, vRCparams, vRCaudit(), vRCauditIns())")

	// Move new keys into record
	for i = 1:1:keycnt do this.addLine(source(), " set this."_ this.colName(keysLC.elementAt(i), "LC", true)_ " = newKey"_ i)
	
	// Create new copy to insert
	do this.addLine(source(), " type Record"_ this.tableName_" newrec = this.copy()")
	do this.addLine(source(), " do newrec.setMode(0)")
	do this.addLine(source(), " do newrec.save($$initPar^UCUTILN(""/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/""))")

	do this.addLine(source(), " do {")
	
	/* Cascade update
	   NOTE:  Eventually will want to use public new approach, e.g.
	     type public new Number %ProcessMode = 1 */
	do this.addLine(source(), "  type Number %ProcessMode = 1")
	do this.addLine(source(), "  type Boolean ER = false")
	do this.addLine(source(), "  type String RM = """"")
	do this.addLine(source(), "  #ACCEPT Date=10/24/2008; Pgm=RussellDS; CR=30801; Group=ACCESS")
	do this.addLine(source(), "  do CASUPD^DBSEXECU("""_ this.tableName_ """, oldkeys , newkeys)")
	do this.addLine(source(), "  if ER do this.throwError(RM.get())")
	do this.addLine(source(), " }")
	
	/* Set keys back to old keys, then delete old record.  Do this prior
	   to firing after update triggers to be sure the old record is gone
	   in the event the after update triggers do anything against the DB. */
	for i = 1:1:keycnt do this.addLine(source(), " set this."_ this.colName(keysLC.elementAt(i), "LC", true)_ " = oldKey"_ i)
	
	do this.addLine(source(), " set vRCparams = $$initPar^UCUTILN(""/NOVAL/NOCASDEL/NOJOURNAL/NOTRIGBEF/NOTRIGAFT/"")")
	do this.addLine(source(), " do this.vRCdelete(vRCparams, vRCaudit(), true)")
		
	// Reset keys to new value (once again) so that vobj is correct
	for i = 1:1:keycnt do this.addLine(source(), " set this."_ this.colName(keysLC.elementAt(i), "LC", true)_ " = newKey"_ i)
	
	// If after update triggers (non-key or key columns), handle
	if this.sections.contains("AU") do {
		
		do this.addLine(source(), " set vRCparams = oldparams")
		do this.addLine(source(), " if vRCparams.contains(""TRIGAFT"", ""/"") do this.vRCafterUpdTrigs(vRCparams)")
	}

	do this.addLine(source(), " quit")

	quit
	
	
	// ---------------------------------------------------------------------
private void buildlogMethods(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE logging methods - vgetLogging(), vlogSelect(), and
	logUserclass()
	
	Build in all cases - needs to be built for all RecordTABLE code prior
	to turning on audit logging, since may be called during RecordTABLE
	code generation once audit logging is enabled.
	*/
	
	type Boolean isPositiveList
	type List userclasses
	type String operation
	
	kill source
	
	// Build getLogging() method	
	do this.addLine(source(), "")
	
	do this.addLine(source(), "public static List vgetLogging()")
	
	do this.addLine(source(), " quit "_ this.auditLog.addQuotes())
	do this.addLine(source(), "")
	
	/* Build logUserclass() method - do we log the operation for this
	   userclass? */
	do this.addLine(source(), "public static Boolean logUserclass(String operation)")
	for operation = "INSERT", "UPDATE", "DELETE", "SELECT" do {
		
		type Boolean isPositiveList
		type String code, test, userclasses
		
		set code = " if (operation = """_ operation_ """)"
		if (operation '= "INSERT") set code = " else "_ code
		
		if $$shouldLog^SQLAUDIT(this.tableName, operation, "log", .userclasses, .isPositiveList) do {
			
			set test = this.getAuditUCLSChk(userclasses, isPositiveList)
			if 'test.isNull() set code = code_ ", "_ test
			set code = code_ " quit true"
		}
		else  set code = code_ " quit false"
		
		do this.addLine(source(), code)
	}
	do this.addLine(source(), " quit false")
		
	do this.addLine(source(), "")
	
	do this.addLine(source(), "public static Number vlogSelect(String statement, String using)")
		
	if $$shouldLog^SQLAUDIT(this.tableName, "SELECT", "log", .userclasses, .isPositiveList) do {
		
		type String code = " quit $$auditLog^SQLAUDIT(""SELECT"", """_ this.tableName_ """, statement, using)"
		type String test = this.getAuditUCLSChk(userclasses, isPositiveList)
		
		if 'test.isNull() do {
			
			do this.addLine(source(), " if "_ test_ code)
			do this.addLine(source(), " quit 0")
		}
		else  do this.addLine(source(), code)
	}
	else  do this.addLine(source(), " quit 0")
	do this.addLine(source(), "")
	
	quit
		
	
	// ---------------------------------------------------------------------
private void buildmiscValidations(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCmiscValidations method
	*/
	
	type String code, nattable
	
	kill source
	
	do this.addLine(source(), "")
	do this.addLine(source(), "private void vRCmiscValidations(List vRCparams, Number processMode)")

	// Validate mode versus current DB state 
	set code = " if vRCparams.contains(""VALST"", ""/"") if '(''Db.isDefined("""_ this.tableName_ ""","
	set code = code_ this.getWhereKey("this", false, .nattable).addQuotes()_ ") = ''processMode) do {"
	do this.addLine(source(), code)
	
	do this.addLine(source(), "  type String errmsg")
	do this.addLine(source(), "  if (processMode <> 0) set errmsg = $$^MSG(7932)")	// Record not defined
	do this.addLine(source(), "  else  set errmsg = $$^MSG(2327)")			// Record already exists
	
	do this.addLine(source(), "  do this.throwError(errmsg)")
	do this.addLine(source(), " }")
	
	if this.sections.contains("foreignKeys") do {
		
		do this.addLine(source(), " if vRCparams.contains(""VALFK"", ""/"") do this.vRCcheckForeignKeys()")
		do this.addLine(source(), " if vRCparams.contains(""VALRI"", ""/"") do this.vRCsetForeignKeys()")
	}
	
	do this.addLine(source(), " quit")
	
	quit
	
	
	// ---------------------------------------------------------------------
void buildnew(String source())		// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vcdmNew() method.
	
	Used by PSL Class.new("RecordTABLE", ) to instantiate a	new RecordTABLE
	object.
	*/
	
	type Number i
	type String code = this.td.getNewMethodCode("vcdmNew")
	
	kill source
	
	do this.addLine(source(), "")
	for i = 1:1:code.length(9.char()) do this.addLine(source(), code.piece(9.char(), i))
	
	quit
		

	// ---------------------------------------------------------------------
private void buildsetDefaults(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCsetDefaults method
	
	Sets default values for columns.
	*/
	
	type List dftList = this.td.defaultList
	type List keys = this.td.primaryKeys
	type Number i
	
	kill source
	
	do this.addLine(source(), "")
	do this.addLine(source(), "private void vRCsetDefaults()")

	for i = 1:1:dftList.count() do {

		type String column = dftList.elementAt(i)
		type String columnLC = column.lowerCase()
		type String defaultValue
		
		type SchemaColumn cd = Db.getSchemaColumn(this.tableName, column)

		quit:cd.default.isNull()
		quit:'cd.computation.isNull()		// Computeds can't have default values
		
		set defaultValue = this.translateKeyWords(this.td, cd.default, cd.dataType, true)

		if 'defaultValue.isNull() do this.addLine(source(), " if this."_ this.colName(columnLC, "LC", true)_ ".isNull() set this."_ this.colName(columnLC, "LC", true)_ " = "_defaultValue)
	}

	do this.addLine(source(), " quit")
	
	quit	

	
	// ---------------------------------------------------------------------
private void buildsave(String source())		// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE save method
	
	Valid save parameters:
	
		/[NO]CASDEL   - Cascade delete
		/[NO]FRMFILER - Called from another filer
		/[NO]INDEX    - Update Indexes
		/[NO]JOURNAL  - Journal update
		/[NO]TRIGAFT  - After update triggers
		/[NO]TRIGBEF  - Before update triggers
		/[NO]UPDATE   - Update primary table
		/[NO]VALDD    - Validate column values
		/[NO]VALFK    - Validate foreign keys
		/[NO]VALREQ   - Validate not null values
		/[NO]VALRI    - Validate transaction integrity
		/[NO]VALST    - Validate database state
	*/
	
	type Boolean addIf
	type Boolean isParent = false
	type List checkRights = this.checkAccessRights
	type Number i
	type String code, nattable
	
	kill source
	
	do this.addLine(source(), "")
	
	if this.children.isNull() set code = "final "
	else  set code = ""
	
	do this.addLine(source(), "public "_ code_ "void vSave(List vRCparams, Number vauditLogSeq)")
	
	/* If parent table, deal with inheritance by calling appropropriate
	   save method for the appropriate child.  Note that we won't need
	   to worry about this on Java, since that will handle inheritance
	   naturally.
	   
	   The record must contain the proper class in vobj(this,-1).
	*/
	#IF 1
	/* ======== BEGIN TARGET = M ======== */
	for i=1:1:this.children.count() do {
		
		type String childTbl = this.children.elementAt(i)
		type String mcode
		
		if 'isParent do {
		
			do this.addLine(source(), " #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
			do this.addLine(source(), " #BYPASS")
			set isParent = true
		}
		
		set mcode = " I "_ this.oLvn_ "(this,-1)=""Record"_ childTbl_ """ D vSave^Record"_ childTbl_ "(this,vRCparams,.vauditLogSeq) Q"
		do this.addLine(source(), mcode)		
	}
	if isParent do this.addLine(source(), " #ENDBYPASS")
	#ENDIF
	/* ======== END TARGET = M ======== */

	do this.addLine(source(), " type public String verrors()")
	
	do this.addLine(source(), " type String vRCaudit(), vRCauditIns()")	// Audit column arrays

	// Note - eventually replace following with public type new %ProceesMode
	do this.addLine(source(), " type Number %ProcessMode = this.getMode()")	// Used by triggers
	
	do this.addLine(source(), " if vRCparams.get().isNull() set vRCparams = "_$$fileQual^UCDB("Record.save",""))
	
	/* Ensure that not trying to update archived data */
	if 'this.td.isRdb, 'this.td.getArchiveTable().isNull() do {
		
		type String archTable = this.td.getArchiveTable()
		type String archRecRef = "Record"_ archTable
		
		type PSLTable archtd = PSL.getPSLTable(archTable)
	
		type List acckeys = this.td.primaryKeys
		type Number keycnt = archtd.getArchiveKey()
		type String archkey = acckeys.elementAt(keycnt)
		type Number i
		
		do this.addLine(source(), " if (%ProcessMode '= 2), 'vRCparams.contains(""NOUPDATE"", ""/"") do {")
		
		if (this.tableName = archTable) set archRecRef = "this"
		else  do this.addLine(source(), "  type static "_ archRecRef)
		
		set code = "  if "_ archRecRef_ ".getArchiveFile("""_ this.tableName_ """, 0," 
	
		for i = 1:1:keycnt - 1 set code = code_ "this."_ this.colName(acckeys.elementAt(i), "LC", true)_ ", "
		set code = code_ "this."_this.colName(archkey, "LC", true)_")"
		
		// Cannot modify records in archive file
		set code = code_ " do this.throwError($$^MSG(6906))"
		
		do this.addLine(source(), code)
		do this.addLine(source(), " }")
	}
	
	/* Need to call AUDIT^UCUTILN even in insert mode to make sure that vobj
	   -100 level is updated correctly.  Use different array for insert vs.
	   update so that can pass to DBSLOGIT, but not impact the array we
	   pass to update journals.
	*/

	// Create record	
	do this.addLine(source(), " if (%ProcessMode = 0) do {")
	
	// Handle audit logging
	if this.auditLog.contains("insert") do this.addLogSQLCode(source(), "insert")

	do this.addLine(source(), "  do AUDIT^UCUTILN(this, vRCauditIns(), "_ this.td.recordType_ ", "_ this.delimiterStr_ ")")
	if this.sections.contains("defaults") do this.addLine(source(), "  do this.vRCsetDefaults()")
	if this.sections.contains("BI") do {
		
		if 'this.triggerAllIfConds(this.trigBI).isNull() set addIf = true
		else  set addIf = false
		
		if addIf do this.addLine(source(), "  #IF "_ this.triggerAllIfConds(this.trigBI))
		do this.addLine(source(), "  if vRCparams.contains(""TRIGBEF"", ""/"") do this.vRCbeforeInsTrigs(vRCparams)")
		if addIf do this.addLine(source(), "  #ENDIF")
	}
	/* Do access rights checking after before insert trigger in case it
	   changes values that might be used in a restrict clause. */
	// No access rights for table ~p1
	if (checkRights.contains("insert") or checkRights.contains("insertRestrict")) do this.addLine(source(), "  if 'this.vinsertOK(%UserClass) throw Class.new(""Error"", ""%PSL-E-ACCESS,""_ $$^MSG(6754,"""_ this.tableName_ """))")
	if this.sections.contains("required") do this.addLine(source(), "  if vRCparams.contains(""VALREQ"", ""/"") do this.vRCchkReqForInsert()")
	do this.addLine(source(), "  if vRCparams.contains(""VALDD"", ""/"") do this.vRCvalidateDD(%ProcessMode)")
	do this.addLine(source(), "  do this.vRCmiscValidations(vRCparams, %ProcessMode)")
	do this.addLine(source(), "  do this.vRCupdateDB(%ProcessMode, vRCparams, vRCaudit(), vRCauditIns())")
	if this.sections.contains("AI") do {
		
		if 'this.triggerAllIfConds(this.trigAI).isNull() set addIf = true
		else  set addIf = false
		
		if addIf do this.addLine(source(), "  #IF "_ this.triggerAllIfConds(this.trigAI))
		do this.addLine(source(), "  if vRCparams.contains(""TRIGAFT"", ""/"") do this.vRCafterInsTrigs(vRCparams)")
		if addIf do this.addLine(source(), "  #ENDIF")
	}

	
	/* restrictionlevel = -1 indicates that we're building an M copy
	   of this procedure for distribution for bootstrap and upgrades.
	   In that case, we ignore calling UCLREGEN during the initial phase,
	   until this procedure is recompiled on-site. */
	
	if this.sections.contains("literals"), (PSL.getSetting("boot","restrictionlevel") '= -1) do this.addLine(source(), "  do SET^UCLREGEN("""_ this.tableName_ """, ""*"")")

	do this.addLine(source(), " }")
	
	// Update record
	do this.addLine(source(), " else  if (%ProcessMode = 1) do {")
	if (this.td.recordType > 1) do this.addLine(source(), "  quit:'this.isChanged()")
	
	// Handle audit logging
	if this.auditLog.contains("update") do this.addLogSQLCode(source(), "update")
	
	do this.addLine(source(), "  do AUDIT^UCUTILN(this, vRCaudit(), "_ this.td.recordType_ ", "_ this.delimiterStr_ ")")
	
	if 'this.td.primaryKeys.isNull() do {
	
		type List keys = this.td.primaryKeys
		type Number i
		
		set code = "  if "
		for i = 1:1:keys.count() set code = code_ "this.isChanged("_ this.colName(keys.elementAt(i), "UC", false).addQuotes()_ ") or "
		set code = code.extract(1, code.length() - 4)
		
		do this.addLine(source(), code_ " do this.vRCkeyChanged(vRCparams, vRCaudit()) quit")
	}
	if this.sections.contains("BU"), 'this.sections.contains("BUKO") do {
	
		if 'this.triggerAllIfConds(this.trigBU).isNull() set addIf = true
		else  set addIf = false
		
		if addIf do this.addLine(source(), "  #IF "_ this.triggerAllIfConds(this.trigBU))	
		do this.addLine(source(), "  if vRCparams.contains(""TRIGBEF"", ""/"") do this.vRCbeforeUpdTrigs(vRCparams, vRCaudit())")
		if addIf do this.addLine(source(), "  #ENDIF")
	}
	/* Do access rights checking after before update trigger in case it
	   changes values that might be used in a restrict clause. */
	// No access rights for table ~p1
	if (checkRights.contains("update") or checkRights.contains("updateRestrict")) do this.addLine(source(), "  if 'this.vupdateOK(%UserClass) throw Class.new(""Error"", ""%PSL-E-ACCESS,""_ $$^MSG(6754,"""_ this.tableName_ """))")
	if this.sections.contains("required") do this.addLine(source(), "  if vRCparams.contains(""VALREQ"", ""/"") do this.vRCchkReqForUpdate()")
	do this.addLine(source(), "  if vRCparams.contains(""VALDD"", ""/"") do this.vRCvalidateDD1()")
	do this.addLine(source(), "  do this.vRCmiscValidations(vRCparams, %ProcessMode)")
	do this.addLine(source(), "  do this.vRCupdateDB(%ProcessMode, vRCparams, vRCaudit(), vRCauditIns())")
	if this.sections.contains("AU"), 'this.sections.contains("AUKO") do {
	
		if 'this.triggerAllIfConds(this.trigAU).isNull() set addIf = true
		else  set addIf = false
		
		if addIf do this.addLine(source(), "  #IF "_ this.triggerAllIfConds(this.trigAU))	
		do this.addLine(source(), "  if vRCparams.contains(""TRIGAFT"", ""/"") do this.vRCafterUpdTrigs(vRCparams)")
		if addIf do this.addLine(source(), "  #ENDIF")
	}
	/* See earlier comments related to UCLREGEN during boot compilation */
	if this.sections.contains("literals"), (PSL.getSetting("boot","restrictionlevel") '= -1) do {

		
		/* Note that checking of SYSMAPLITDTA is done at run-time to simplify
		   overall processing.  No need to make sure that if literal is used that
		   the RecordTABLE code already exists to check it, since just need to
		   make sure the RecordTABLE code has the runtime code to check any
	   	   literals for this table.  This shouldn't be a performance issue since
	   	   tables that are used with literals have low change rates.  If it turns
	   	   out to be a problem, could change logic to generate column specific
	   	   checking. 
		*/
		do this.addLine(source(), "  do {")
		do this.addLine(source(), "   type ResultSet rslits = Db.select(""DISTINCT COLUMN"", ""SYSMAPLITDTA"", ""TABLE='"_ this.tableName_ "'"")")
		do this.addLine(source(), "   while rslits.next() if vRCaudit(rslits.getCol(1)).exists() do SET^UCLREGEN("""_ this.tableName_ """, rslits.getCol(1))")
		do this.addLine(source(), "  }")
	}
	do this.addLine(source(), " }")
	
	// Verify record
	do this.addLine(source(), " else  if (%ProcessMode = 2) do {")
	if this.sections.contains("required") do this.addLine(source(), "  if vRCparams.contains(""VALREQ"", ""/"") do this.vRCchkReqForInsert()")
	do this.addLine(source(), "  if vRCparams.contains(""VALDD"", ""/"") do this.vRCvalidateDD(%ProcessMode)")
	do this.addLine(source(), "  do this.vRCmiscValidations(vRCparams, 2)")
	if this.sections.contains("indexes")	do this.addLine(source(), "  if vRCparams.contains(""INDEX"", ""/"") do this.updateIndexes(%ProcessMode, vRCaudit())")
	if this.sections.contains("AI") do {
		
		if 'this.triggerAllIfConds(this.trigAI).isNull() set addIf = true
		else  set addIf = false
		
		if addIf do this.addLine(source(), "  #IF "_ this.triggerAllIfConds(this.trigAI))	
		do this.addLine(source(), "  if vRCparams.contains(""TRIGAFT"", ""/"") do this.vRCafterInsTrigs(vRCparams)")
		if addIf do this.addLine(source(), "  #ENDIF")
	}
	do this.addLine(source(), " }")
	
	// Delete record	
	do this.addLine(source(), " else  if (%ProcessMode = 3) do {")
	// No record exists
	do this.addLine(source(), "  quit:'Db.isDefined("""_ this.tableName_ ""","_ this.getWhereKey("this", false, .nattable).addQuotes()_ ")")  
	
	// Handle audit logging
	if this.auditLog.contains("delete") do this.addLogSQLCode(source(), "delete")
	
	if this.sections.contains("BD") do {
		
		if 'this.triggerAllIfConds(this.trigBD).isNull() set addIf = true
		else  set addIf = false
		
		if addIf do this.addLine(source(), "  #IF "_ this.triggerAllIfConds(this.trigBD))
		do this.addLine(source(), "  if vRCparams.contains(""TRIGBEF"", ""/"") do this.vRCbeforeDelTrigs(vRCparams)")
		if addIf do this.addLine(source(), "  #ENDIF")
	}
	/* Do access rights checking after before delete trigger in case it
	   changes values that might be used in a restrict clause. */
	// No access rights for table ~p1
	if (checkRights.contains("delete") or checkRights.contains("deleteRestrict")) do this.addLine(source(), "  if 'this.vdeleteOK(%UserClass) throw Class.new(""Error"", ""%PSL-E-ACCESS,""_ $$^MSG(6754,"""_ this.tableName_ """))")
	do this.addLine(source(), "  do this.vRCdelete(vRCparams, vRCaudit(), false)")
	if this.sections.contains("AD") do {
		
		if 'this.triggerAllIfConds(this.trigAD).isNull() set addIf = true
		else  set addIf = false
		
		if addIf do this.addLine(source(), "  #IF "_ this.triggerAllIfConds(this.trigAD))
		do this.addLine(source(), "  if vRCparams.contains(""TRIGAFT"", ""/"") do this.vRCafterDelTrigs(vRCparams)")
		if addIf do this.addLine(source(), "  #ENDIF")
	}
	
	/* See earlier comments related to UCLREGEN during boot compilation */
	if this.sections.contains("literals"), (PSL.getSetting("boot","restrictionlevel") '= -1) do this.addLine(source(), "  do SET^UCLREGEN("""_ this.tableName_ """, ""*"")")
	do this.addLine(source(), " }")

	do this.addLine(source(), " quit")

	quit
	
		
	// ---------------------------------------------------------------------
private void buildtriggers(String source(),	// Build code into source
			   PSLTokenizer tknzr)	// Tokenizer object
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCbeforeInsTrigs, vRCbeforeUpdTrigs, vRCbeforeDelTrigs,
	vRCafterInsTrigs, vRCafterUpdTrigs, vRCafterDeltrigs, as well as the
	individual trigger methods.
	
	Individual triggers use methods names of vRCTrigN, where N is a
	sequence number from property triggerSeq.  Individual triggers are
	not named based on the type of trigger since a single trigger my
	be invoked by more than one type of action (BI, BU, BD, AI, AU, AD).
	
	Labels within triggers should use all uppercase names which will avoid
	conflicts with RecordTABLE methods.
	  
	Numeric indexes are used in the arrays in this method, with associations
	defined by literal trigBI, trigBU, etc.
	
	vRCparams is passed to individual triggers (as vpar on the receiving
	end) as vpar to retain backward compatibility for what was once public
	scope use.
	*/
	
	/* dispatch structure - created by getTriggerCode method
	
		dispatch(trigType, 1, trigSeq) = ""		// triggers without columns
		dispatch(trigType, 2, columns) = trigSeq,trigSeq,...
	*/
	
	type List keys = {List}(this.td.primaryKeys)
	type Number i
	type String code, dispatch(,,), ifConds()
	
	kill source
	
	/* Add triggers to tknzr source and build dispatch info.  Note that this
	   approach has triggers come before the dispatch methods in the generated code */
	type ResultSet rs = Db.select("TRGID,ACTBI,ACTBU,ACTBD,ACTAI,ACTAU,ACTAD,COLUMNS,DES,IFCOND", "DBTBL7", "%LIBS='SYSDEV' AND TABLE = :this.tableName")

	while rs.next() do this.getTriggerCode(dispatch(,,), ifConds(), rs.getCol("TRGID"), rs.getCol("ACTBI"), rs.getCol("ACTBU"), rs.getCol("ACTBD"), rs.getCol("ACTAI"), rs.getCol("ACTAU"), rs.getCol("ACTAD"), rs.getCol("COLUMNS"), rs.getCol("DES"), rs.getCol("IFCOND"), tknzr)

	// Build dispatch sections
	for i = 1:1:6 if (dispatch(i).data() > 0) do {
		
		type Boolean isUpdate = ((i = this.trigBU) or (i = this.trigAU))
		type Number j, n
		
		if (i = this.trigBI) set code = "beforeInsTrigs(List vRCparams)"
		else  if (i = this.trigBU) set code = "beforeUpdTrigs(List vRCparams, String vRCaudit())"
		else  if (i = this.trigBD) set code = "beforeDelTrigs(List vRCparams)"
		else  if (i = this.trigAI) set code = "afterInsTrigs(List vRCparams)"
		else  if (i = this.trigAU) set code = "afterUpdTrigs(List vRCparams)"
		else  if (i = this.trigAD) set code = "afterDelTrigs(List vRCparams)"
		
		do this.addLine(source(), "")
		do this.addLine(source(), "private void vRC"_ code)
		
		do this.addLine(source(), " type Boolean ER = false")
		do this.addLine(source(), " type Boolean vRCfire")
		do this.addLine(source(), " type String RM = """"")
		
		/* Because legacy triggers may be written expecting the keys to
		   be available, by name, as public variables, set them up.
		   Eventually, if triggers get cleaned up, this should go away.
		   Also, once we support 'public new' approach, switch to that.
		   
		   NOTE that this will not work for any column names that contain
		   underscores, so those are skipped.  Since support of underscore
		   is a new feature, triggers written for them should not expect
		   a variable with that key name to be available.
		*/
		   
		for j = 1:1:keys.count() if 'keys.elementAt(j).isLike("%_%") do this.addLine(source(), " type String "_ keys.elementAt(j)_ " = this."_ keys.elementAt(j).lowerCase())
		
		// For update triggers, if no changes, just quit
		if isUpdate do this.addLine(source(), " quit:'this.isChanged()")
		
		/* Pass 'this' as actual parameter to triggers to support older code in triggers
		   that was able to reference the instance by the table name, e.g., dep.cid.  The
		   trigger's formal parameters are constructed to accept this parameter. */
		
		// Non-column related triggers first
		set n = ""
		for  set n = dispatch(i, 1, n).order() quit:n.isNull()  do {
			
			if ifConds(n).exists() do this.addLine(source(), " #IF "_ ifConds(n))
			do this.addLine(source(), " do this.vRCTrig"_ n_ "(this, vRCparams) if ER do this.throwError(RM.get())")
			if ifConds(n).exists() do this.addLine(source(), " #ENDIF")
		}
		
		// Then column related triggers
		for  set n = dispatch(i, 2, n).order() quit:n.isNull()  do {
			
			type List columns = {List}n
			type List triggers = {List}dispatch(i, 2, n)
			type Number j
			
			/* For insert and delete, just fire the triggers.  For
			   update, only fire if column changed. */
			
			/* Build column changed check for all columns involved */
			if isUpdate do {
				
				do this.addLine(source(), " set vRCfire = false")
				
				for j = 1:1:columns.count() do {
				
					set code = ""
					if (j = 1) set code = " if "
					else  set code = " else  if "
				
					do this.addLine(source(), code_ "this.isChanged("""_ columns.elementAt(j)_ """) set vRCfire = true")
				}
				
				set code = " if vRCfire"
			}
			else  set code = ""
			
			/* If single trigger for these columns or is not update,
			   do it in-line, otherwise, do the various triggers under a do */
			if isUpdate, (triggers.count() > 1) do {
				
				do this.addLine(source(), code_ " do {")
				set code = " "
			}
			for j = 1:1:triggers.count() do {
				
				type Number trigSeq = triggers.elementAt(j)
				
				if ifConds(trigSeq).exists() do this.addLine(source(), " #IF "_ ifConds(trigSeq))
				do this.addLine(source(), code_ " do this.vRCTrig"_ trigSeq_ "(this, vRCparams) if ER do this.throwError(RM.get())")
				if ifConds(trigSeq).exists() do this.addLine(source(), " #ENDIF")
			}
			if isUpdate, (triggers.count() > 1) do this.addLine(source(), " }")
		}
		
		// Before update triggers may change values to be used by other triggers
		if (i = this.trigBU) do this.addLine(source(), " do AUDIT^UCUTILN(this, vRCaudit(), 10, "_ this.delimiterStr_ ")")
		
		do this.addLine(source(), " quit")
	}
	
	quit	
	
	
	// ---------------------------------------------------------------------
private void buildupdateDB(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCupdateDB method
	
	Code to update the appropriate DB on insert or update
	*/
	
	type String cdate = this.getLogCode(this.td.dateCreated, this.td.systemName, "D")
	type String ctime = this.getLogCode(this.td.timeCreated, this.td.systemName, "T")
	type String cuser = this.getLogCode(this.td.userCreated, this.td.systemName, "U")
	type String udate = this.getLogCode(this.td.dateUpdated, this.td.systemName, "D")
	type String utime = this.getLogCode(this.td.timeUpdated, this.td.systemName, "T")
	type String uuser = this.getLogCode(this.td.userUpdated, this.td.systemName, "U")
	
	kill source
	
	do this.addLine(source(), "")
	do this.addLine(source(), "private void vRCupdateDB(Number processMode, List vRCparams, String vRCaudit(), String vRCauditIns())")

	do this.addLine(source(), " if 'vRCparams.contains(""NOUPDATE"", ""/"") do {")
	
	#IF CUVAR.PUBLISH
	do this.addLine(source(), "  type public Number %SVCHNID")
	#END
	
	// If the same column is used for new and update, just do it once for either condition
	if 'cdate.isNull(), (cdate = udate) do {
	
		do this.addLine(source(), " "_ cdate)
		set (cdate, udate) = ""
	}
	if 'ctime.isNull(), (ctime = utime) do {
	
		do this.addLine(source(), " "_ ctime)
		set (ctime, utime) = ""
	}
	if 'cuser.isNull(), (cuser = uuser) do {
	
		do this.addLine(source(), " "_ cuser)
		set (cuser, uuser) = ""
	}

	if 'cdate.isNull() do this.addLine(source(), "  if (processMode = 0)"_ cdate)
	if 'ctime.isNull() do this.addLine(source(), "  if (processMode = 0)"_ ctime)
	if 'cuser.isNull() do this.addLine(source(), "  if (processMode = 0)"_ cuser)
	if 'udate.isNull() do this.addLine(source(), "  if (processMode = 1)"_ udate)
	if 'utime.isNull() do this.addLine(source(), "  if (processMode = 1)"_ utime)
	if 'uuser.isNull() do this.addLine(source(), "  if (processMode = 1)"_ uuser)

	if this.td.isAutoLog do {
		
		do this.addLine(source(), "  if 'vRCparams.contains(""NOLOG"", ""/"") do {")

		do this.addLine(source(), "   if (processMode = 1) do ^DBSLOGIT(this, 1, vRCaudit()) quit")
		do this.addLine(source(), "   do ^DBSLOGIT(this, 0, vRCauditIns())")
		
		do this.addLine(source(), "  }")
	}
	
	if this.td.isRdb do this.addRDBsaveCode(source())
	if 'this.td.isRdb do this.addMsaveCode(source())
	
	#IF CUVAR.PUBLISH
	if 'this.td.publishPGM.isNull() do this.addLine(source(), "  if (%SVCHNID.get() <> 5)  do "_ this.td.publishPGM)
	#END
	
	if this.sections.contains("journals") do this.addLine(source(), "  if vRCparams.contains(""JOURNAL"", ""/"") do this.vRCjournals(processMode, vRCaudit())")
	do this.addLine(source(), " }")

	if this.sections.contains("indexes") do this.addLine(source(), " if vRCparams.contains(""INDEX"", ""/""), ((processMode = 0) or this.isChanged()) do this.updateIndexes(processMode, vRCaudit())")

	do this.addLine(source(), " quit")
	
	quit
			
	
	// ---------------------------------------------------------------------
private void buildvalidateDD(String source())		// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vRCvalidateDD and vRCvalidateDD1 methods.
	
	The vRCvalidateDD method validates data dictionary attributes for process
	mode 0 and 2 against all columns for any node present.  vRCvalidateDD1
	deals with updates and validates only for columns that have changed.
	
	Build vRCvalidateDD as we go into source() and vRCvalidateDD1 into
	source2(), the merge at the end.
	*/
	
	type Boolean isDo = false
	type List keys = {List}(this.td.primaryKeys)
	type Number seq
	type String column, code, lookupTbl, lastKey, node, pattern, table, typ
	type String source2()
	
	type SchemaColumn columnsByNode(,)
	
	kill source
	
	do this.addLine2(source(), source2(), "")
	do this.addLine(source(), "private void vRCvalidateDD(Number processMode)")
	do this.addLine(source2(), "private void vRCvalidateDD1()")
	
	do this.addLine2(source(), source2(), " type public Cache %CACHE()")
	do this.addLine2(source(), source2(), " type Boolean ER = false")
	do this.addLine2(source(), source2(), " type String RM = """"")
	do this.addLine2(source(), source2(), " type String errmsg, X")

	/* If multi-node table and we're doing an integrity check
	   (%ProcessMode = 2), then we need to make sure that all
	   nodes are loaded. */
	if (this.td.recordType > 1) do this.addLine(source(), " if (processMode = 2) do this.vRCforceLoad()")
	
	/* Build list of columns sorted by node (appropriate to the
	   target database) */
	set table = this.tableName
	type ResultSet rs = Db.select("DI", "DBTBL1D", "FID = :table AND CMP IS NULL AND TYP NOT IN ('M','B')")
	
	while rs.next() do {
		
		set column = rs.getCol("DI")
		
		if 'column.isLiteral() do {
		
			type SchemaColumn cd = Db.getSchemaColumn(table, column)
		
			set columnsByNode(cd.node, column) = cd
		}
	}
	
	set lastKey = keys.elementAt(keys.count())
	set isDo = false

	set (node, column) = ""
	for  set node = columnsByNode(node).order() quit:node.isNull()  do {
		
		type String ws = ""				// White space
		
		/* For tables that use nodes, structure so that only check
		   for nodes that are defined */
		
		if isDo do this.addLine2(source(), source2(), " }")		// Close the do block
		set isDo = false
		
		if (this.td.recordType > 1), 'node.endsWith("*") do {
		
			set isDo = true
			set ws = " "
		
			if (this.td.recordType = 11), (node = lastKey) do {
				
				do this.addLine2(source(), source2(), " if vobj(this).exists() or 'vobj(this,"""").order().isNull() do {")
			}
			else  do {
				
				type String x
				
				if node.isNumber() do {
					
					if (node < 0) set x = ("v"_ -node).addQuotes()
					else  set x = node
				}
				else  set x = node.addQuotes()
				
				do this.addLine2(source(), source2(), " if vobj(this,"_ x_ ").exists() do {")
			}
		}
		
		for  set column = columnsByNode(node, column).order() quit:column.isNull()  do {
			
			type String colref = this.colName(column, "LC", true)
			type SchemaColumn cd = columnsByNode(node, column)

			set lookupTbl = cd.lookupTable
			set typ = cd.dataType

			if 'lookupTbl.isNull() do {
	
				if lookupTbl.isLike("%:NOVAL%") set lookupTbl = "" quit
		
				if lookupTbl.beginsWith("["), (lookupTbl ? 1"["1A.AN1"]".E) or (lookupTbl ? 1"[%".AN1"]".E) do { quit
					
					type List lutblKeys
					type String isDefRef = "Db"			// or Cache, if CTBL/STBL/UTBL table
					type String QRY = ""
				
					/* Attempt to use :QUERY info to provide missing keys
					   for multi-key tables if the values are literals.  Ignore
					   :DISTINCT, date item lists, etc.
					*/
				
					if lookupTbl.isLike("%:QU%") set QRY = lookupTbl.piece(":QU", 2).piece(" ", 2, PSL.maxStringLength)
				
					set lookupTbl = lookupTbl.piece("[", 2).piece("]", 1)
				
					if ((lookupTbl = table) or (lookupTbl = this.td.parentTable)) set lookupTbl= "" quit
				
					if 'Db.isSchemaTable(lookupTbl) throw Class.new("Error", "%PSL-E-INVALID,Aborted - invalid table linkage for column "_ column)
				
					type PSLTable tdlookup = PSL.getPSLTable(lookupTbl, 0)
					
					/* Use cache if we can.  See if the look-up table RecordTABLE class
					   exists yet.  If it does, OK to use cache, otherwise, we'll get
					   a compile error since the cache code uses .getRecord */
					
					if (tdlookup.global.beginsWith("^CTBL") or tdlookup.global.beginsWith("^STBL") or tdlookup.global.beginsWith("^UTBL")) do {
					
						type IO modIO = Class.new( "IO")
						if $$locate^UCIO( modIO, $$packageDirs^PSLC( "", ""), ":", "Record"_ lookupTbl_ ".pslx", 0) set isDefRef = "%CACHE("""_ lookupTbl_ """)"
					}
					
					set lutblKeys = tdlookup.primaryKeys

					// If more than a single key, try to use query info
					if (lutblKeys.count() > 1) do {
				
						type Number i
						type String key, keyname, keys, keyval, TOK
				
						if QRY.isNull() set lookupTbl = "" quit
						
						set QRY = QRY.stripQuotes()
						#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
						set QRY = $$TOKEN^%ZS(QRY, .TOK)
						
						set keys = ""
						for i = 1:1:lutblKeys.count() - 1 do { quit:lookupTbl.isNull()
							
							set keyname = lutblKeys.elementAt(i)
							set key = "["_ lookupTbl_ "]"_ keyname_ "="
							
							if (QRY '[ key) set lookupTbl = ""
							else  do {
								
								set keyval = QRY.piece(key, 2)
								#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
								set keyval = $$ATOM^%ZS(keyval, 0, ",:&", TOK, 0)
								if keyval.isNull() set lookupTbl = ""
								else  if '(keyval.isNumber() or (keyval ? 1"""".E1"""")) set lookupTbl = ""
								else  do {
									
									if keyval.beginsWith("""") set keyval = keyval.stripQuotes().addQuotes("'")
									set keys = keys_ keyname_ "="_ keyval_ ","
								}
							}
						}
						
						// Handle last key
						if 'lookupTbl.isNull() do {
						
							set keyname = lutblKeys.elementAt(lutblKeys.count())
							set keys = keys_ keyname_ "=:X"
							set lookupTbl = isDefRef_ ".isDefined("""_ lookupTbl_ """, """_ keys_ """)"
						}

					}
					else  set lookupTbl = isDefRef_ ".isDefined("""_ lookupTbl_ """, """_ lutblKeys_ "=:X"")"
				}

				// Ignore indirection or local arrays
				if lookupTbl.beginsWith("@") set lookupTbl = ""
				else  if (lookupTbl ? 1A.AN1"(") set lookupTbl = ""
				// Picklist
				else  if lookupTbl.beginsWith(",") do {
				
					type List newList, tbltok
					type Number i
					type String tok
				
					#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
					set tbltok = {List}($$TOKEN^%ZS(lookupTbl.extract(2, PSL.maxStringLength), .tok))
					set newList = Class.new("List")
					for i = 1:1:tbltok.count() set newList = newList.add(tbltok.elementAt(i).piece("#", 1))
					
					#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
					set lookupTbl = "{List}"_ $$UNTOK^%ZS(newList, tok).addQuotes()_ ".contains(X)"
				}

				if lookupTbl.beginsWith("^") throw Class.new("Error", "%PSL-E-INVALID,Aborted - invalid global reference for table look-up on column "_ column)
			
				if lookupTbl.isNull(true) set lookupTbl = ""
			}

			set code = " set X = this."_ colref_ " if 'X.isNull()"

			if 'lookupTbl.isNull() set code = code_ ", '"_ lookupTbl_ " do this.vRCvalidateDDerr("""_ column_ """, $$^MSG(1485, X))"
			else  if (typ = "F") do {

				set code = code_ " do DBSEDT^UFRE(""["_ table_ "]"_ column_ """, false)"
				set code = code_ " if ER do this.vRCvalidateDDerr("""_ column_ """, RM)"
			}
			else  do {
				
				type String min = cd.minimum
				type String max = cd.maximum
				type String pattern = cd.pattern
				
				/* Need numeric check on non-GTM databases since otherwise DB
			 	   may apply own rules.  E.g., Oracle will take 1.01 into a
			  	   numeric, no decimal, field, by truncating and treating as 1
				*/
				if ((typ = "$") or (typ = "N")) do {
					
					type String trimcode = "'this."_ colref_ ".isNull(), '(+this."_ colref_ " = this."_ colref_ ") set this."_ colref_ " = this.vRCtrimNumber(this."_ colref_ ")"
					
					// Trim any leading or trailing (after decimal point) zeros
					do this.addLine(source(), ws_ " if "_ trimcode)
					do this.addLine(source2(), " if this.isChanged("_ colref.upperCase().addQuotes()_ "), "_ trimcode)
				}				
		
				/* Don't need to perform length checks if not M database */
				if ((typ = "T") or (typ = "U")), min.isNull(), max.isNull(), pattern.isNull() do {
					
					if (typ = "U") do {
						
						// Invalid syntax - use UPPERCASE characters
						set code = " if (this."_ colref_ " '= this."_ colref_ ".upperCase()) do this.vRCvalidateDDerr("""_ column_ """, $$^MSG(1476))"
						
						do this.addLine2(source(), source2(), ws_ code)
					}
					
					if this.td.isRdb set code = ""
					// Field length (~p1) exceeded
					else  set code = " if (this."_ colref_ ".length() > "_ cd.length_ ") do this.vRCvalidateDDerr("""_ column_ """, $$^MSG(1076, "_ cd.length_ "))"
				}
				else  if ((typ = "$") or (typ = "N")), (cd.precision '> 0) do {
					
					// Data type is defined as ~p1
					if (cd.length = 1) set code = code_ ", (X '? 1N) do this.vRCvalidateDDerr("""_ column_ """, $$^MSG(742, ""N""))"
					else  set code = code_ ", (X '? 1."_ cd.length _"N), (X '? 1""-""1."_ (cd.length - 1)_ "N) do this.vRCvalidateDDerr("""_ column_ """, $$^MSG(742, ""N""))"
				}
				else  if ((typ = "B") or (typ = "M")) do {
					
					if this.td.isRdb set code = ""
					// Field length (~p1) exceeded
					else  set code = " if (this."_ colref_ ".length() > "_ cd.length_ ") do this.vRCvalidateDDerr("""_ column_ """, $$^MSG(1076, "_ cd.length_ "))"
				}
				// Data type is defined as ~p1
				else  if (typ = "D") set code = code_ ", (X '? 1.5N) do this.vRCvalidateDDerr("""_ column_ """, $$^MSG(742, ""D""))"
				else  if (typ = "C") set code = code_ ", (X '? 1.5N) do this.vRCvalidateDDerr("""_ column_ """, $$^MSG(742, ""C""))"	
				else  if (typ = "L") set code = " if '((this."_ column_ " = true) or (this."_ column_ " = false)) do this.vRCvalidateDDerr("""_ column_ """, $$^MSG(742, ""L""))"
				// Use DBSVER
				else  do {
					
					type String x
					
					if 'min.isNull() set min = this.translateKeyWords(this.td, min, typ, true)
					if 'max.isNull() set max = this.translateKeyWords(this.td, max, typ, true)

					// Build a parameter string to pass to DBSVER
					set x = typ.addQuotes()
					set x.piece(",", 2) = cd.length
					set x.piece(",", 3) = cd.isRequired
					set x.piece(",", 6) = min
					set x.piece(",", 7) = max
					set x.piece(",", 8) = cd.precision
					// Add last, since may contain commas
					if 'pattern.isNull() set x.piece(",", 5) = pattern.addQuotes()
					
					// Error ~p1
					set code = code_ " set errmsg = $$VAL^DBSVER("_ x_ ") if 'errmsg.isNull() do this.vRCvalidateDDerr("""_ column_ """, $$^MSG(979, """_ table_ "."_ column_ """_"" ""_errmsg))"
				}
			}
		
			if 'code.isNull() do {
			
				do this.addLine(source(), ws_ code)
				do this.addLine(source2(), ws_ " if this.isChanged("_ colref.upperCase().addQuotes()_ ") "_ code)
			}
		}
	}
	
	if isDo do this.addLine2(source(), source2(), " }")
	
	do this.addLine2(source(), source2(), " quit")
	
	do this.addLine2(source(), source2(), "")
	
	// Add source2() to bottom of source()
	set seq = ""
	for  set seq = source2(seq).order() quit:seq.isNull()  do this.addLine(source(), source2(seq))
	
	// Add error handling method for validation errors
	do this.addLine(source(), "private static void vRCvalidateDDerr(String column, String errmsg)")

	do this.addLine(source(), " type Boolean ER = false")
	do this.addLine(source(), " type String RM = """"")
	do this.addLine(source(), " do Runtime.setErrMSG("""_ table_ """, 979, """_ table_ ".""_ column_ "" ""_ errmsg)")
	do this.addLine(source(), " if ER do Record"_ table_ ".throwError(RM.get())")
	do this.addLine(source(), " quit")
	
	// Add method to trim leading and trailing (after decimal) from N & $ data types	
	do this.addLine(source(), "")
	do this.addLine(source(), "private static String vRCtrimNumber(String str)")

	do this.addLine(source(), " if str.beginsWith(""0"") set str = str.trim(-1, ""0"") if str.isNull() set str = ""0""")
        do this.addLine(source(), " if (str [ "".""), str.endsWith(""0"") set str = str.trim(1, ""0"") if str.endsWith(""."") set str = str.extract(1, str.length() - 1) if str.isNull() set str = ""0""")
 
        do this.addLine(source(), " quit str")
	
	quit
	
	
	// ---------------------------------------------------------------------
private void buildvlegacy(String source())	// Build code into source
	/* ---------------------------------------------------------------------		 
	Build RecordTABLE vlegacy method
	
	Legacy interface - only remaining user is EXT^DBSFILER for 
	%ProcessMode = 2.  Eliminate once that is gone.
	*/
	
	type List keys = this.td.primaryKeys
	type Number i
	type String code, codekeys
	
	kill source
	
	do this.addLine(source(), "")
	
	do this.addLine(source(), "public static void vlegacy(Number processMode, String params)")
	
	/* NOTE - because this is legacy code, it will not support files
	   that have keys using underscores in their names.  If any key
	   contains an underscore, the generated code section will simply
	   quit.
	*/
	if keys.isLike("%_%") do this.addLine(source(), " quit") quit

	do this.addLine(source(), " if (processMode = 2) do {")
	
	set codekeys = ""
	for i = 1:1:keys.count() do {
		
		type String key = keys.elementAt(i)
		
		do this.addLine(source(), "  type public String "_ key)
		set codekeys = codekeys_ key_ "=:"_ key_ ","
	}
	set codekeys = codekeys.extract(1, codekeys.length() - 1)
	
	set code = "  type Record"_ this.tableName_ " "_ this.tableNameLC_ " = Db.getRecord("""_ this.tableName_ """"
	
	// 0 keys = CUVAR-like tables
	if (keys.count() > 0) set code = code_ ", """_ codekeys_ """"
	
	set code = code_ ")"
	
	do this.addLine(source(), code)
	do this.addLine(source(), "  do "_ this.tableNameLC_ ".setMode(2)")
	do this.addLine(source(), "  do "_ this.tableNameLC_ ".save(params)")
	do this.addLine(source(), " }")

	do this.addLine(source(), " quit")
	
	quit
	

	// ---------------------------------------------------------------------
private void addMsaveCode(String source())	// Build code into source (*1)
	/* ---------------------------------------------------------------------		 
	Add code necessary to perform save to MDB (global) to source array.
	
	Used by buildupdateDB method.
	
	ARGUMENT NOTES:
	
		(*1)	This method appends to the source() array, so
			does not kill it like the various build methods
			do.
	*/

	type List mbNodes = Class.new("List")	// Memo & blob, nodes have special handling
		
	// Get list of memo and blob nodes
	if this.hasMoB do {
		
		type ResultSet rs = Db.select("DI", "DBTBL1D", "FID = :this.tableName and TYP ='B' or TYP = 'M'")
	
		while rs.next() set mbNodes = mbNodes.add(rs.getCol("DI"), ",", false)
	}
	
	if (this.td.recordType > 1) do {
		
		type List negNodes = Class.new("List")
		type Number i
			
		// Get list of negative nodes
		if this.td.nodeQuotedList.isLike("%""v%") do {
		
			/* Note - need to use <'0' instead of LIKE '-%' since the M SQL optimizer
			   has problems with that.  Need '0' to avoid possible future problems on
			   the Oracle side since NOD is a text field.  Since this may also get
			   nodes that aren't negative, filter those.
			*/
			type ResultSet rs = Db.select("NOD,DI", "DBTBL1D", "FID = :this.tableName and NOD<'0'")

			while rs.next() do {
		
				if rs.getCol("NOD").beginsWith("-") do {
		
					type PSLColumn colrec = PSL.getPSLColumn(this.tableName, rs.getCol("DI"))
		
					set negNodes = negNodes.add(colrec.getCurrentNode(1), ",", false)
				}
			}
		}
	
		do this.addLine(source(), "  type String n")
		
		// Handle memos and blobs first
		for i = 1:1:mbNodes.count() do {
	
			type String col = mbNodes.elementAt(i)
				
			type SchemaColumn colrec = Db.getSchemaColumn(this.tableName, col)
		
			do this.addLine(source(), "  if vobj(this,"_ colrec.getOldNode(false)_ ").exists() do {")
			do this.addLine(source(), "   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
			do this.addLine(source(), "   #BYPASS")
			do this.addLine(source(), "  "_ this.td.getSaveCode("this", "*"_ col, -1))
			do this.addLine(source(), "   #ENDBYPASS")
			do this.addLine(source(), "  }")
		}

		do this.addLine(source(), "  set n = -1")
		do this.addLine(source(), "  for  set n = vobj(this, n).order() quit:n.isNull()  do {")

		// Handle negative nodes
		for i = 1:1:negNodes.count() do {
		
			do this.addLine(source(), "   if n = "_ negNodes.elementAt(i)_ " do { quit")
			do this.addLine(source(), "   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
			do this.addLine(source(), "   #BYPASS")
			do this.addLine(source(), "   "_ this.td.getSaveCode("this", negNodes.elementAt(i), -1))
			do this.addLine(source(), "   #ENDBYPASS")
			do this.addLine(source(), "   }")
		}
	
		do this.addLine(source(), "   quit:'vobj(this,n).exists()")

		// Handle "non-special" nodes
		do this.addLine(source(), "   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
		do this.addLine(source(), "   #BYPASS")
		do this.addLine(source(), "  "_ this.td.getSaveCode("this", "n", -1))
		do this.addLine(source(), "   #ENDBYPASS")
		do this.addLine(source(), "  }")
	
		// Top level for type 11
		if (this.td.recordType = 11) do {
			
			// Allow global reference and M source code
			do this.addLine(source(), "  #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
			do this.addLine(source(), "  #BYPASS")
			do this.addLine(source(), "  if $D(vobj(this))"_ this.td.getSaveCode("this", "", -1))
			do this.addLine(source(), "  #ENDBYPASS")
		}
	}
	else  if (this.td.recordType = 1) do {
		
		do this.addLine(source(), "  #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
		do this.addLine(source(), "  #BYPASS")
		do this.addLine(source(), "  if $D(vobj(this))"_ this.td.getSaveCode("this", "", -1))
		do this.addLine(source(), "  #ENDBYPASS")
		
		if 'mbNodes.isNull() do {
			
			// Will only be a single column
			type SchemaColumn colrec = Db.getSchemaColumn(this.tableName, mbNodes.elementAt(1))
			
			do this.addLine(source(), "   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
			do this.addLine(source(), "   #BYPASS")
			do this.addLine(source(), "   if $D(vobj(this,"_ colrec.getCurrentNode(1)_ "))"_ this.td.getSaveCode("this", "*"_ mbNodes.elementAt(1), -1))
			do this.addLine(source(), "   #ENDBYPASS")
		}
	}
	
	quit


	// ---------------------------------------------------------------------
private void addRDBsaveCode(String source())	// Build code into source (*1)
	/* ---------------------------------------------------------------------		 
	Add code necessary to perform save to RDB to source array.
	
	Used by buildupdateDB method.
	
	ARGUMENT NOTES:
	
		(*1)	This method appends to the source() array, so
			does not kill it like the various build methods
			do.
	*/
			
	type String saveLabel, where
	
	/* Note that we don't care about being a parent table for a regular
	   save, since that will dispatch to the appropriate child table
	   RecordTABLE class.  However, this code is also used for key changes
	   so needs to consider multiple nodes for parent tables.
	*/
	if this.td.isOneNode(), 'this.td.isParent() set saveLabel = "rdbSaveS"
	else  set saveLabel = "rdbSaveC"
		
	set where = this.td.getPrimaryKeyWhere()
		
	/* If doing insert with memo or blob, need -152 node for
	   constructing where clause host variables. */
	if this.hasMoB do this.addLine(source(), "  if 'vobj(this,-152).exists()"_ this.td.getUpdateKey("this"))
	
 	do this.addLine(source(), "  do "_ saveLabel_ "^UCDBRT(this,"_ this.delimiterStr_ ","_ where.addQuotes()_ ")")
	
	quit

	
	// ---------------------------------------------------------------------
private String findTableRef(String ref,		// Reference to check for tables
			    ret List tableList,	// Current list of tables
			    String primTable,	// Primary table name
			    Boolean makeThis,	// Replace primary table with "this"
			    Boolean doLC)	// Make table.column lowercase
	/*
	Locate any tables in ref and add them to tableList.  Return ref with
	table.column references lowercased, if requested, and replace the
	RecordTable table reference with 'this'.
	
	Convert references to PSL.
	
	This method is used by the journal related methods.
	
	RETURNS:
		ref with table.column names either resolved to this.column
		or lower case table.column
	*/	

	type Number ptr = 0
	type String atom, atomUC
	type String delimiters = ",()+-*/\#'=><[]\*_:"
	type String return = ""
	type String tok = ""
	
	#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
	set ref = $$TOKEN^%ZS(ref, .tok)
	
	for  do { quit:(ptr = 0)

		#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
		set atom = $$ATOM^%ZS(ref, .ptr, delimiters, .tok, 1)
		
		if (atom ? 1A.AN.E1".".E.AN) do {				// table.column
			
			type String table = atom.piece(".", 1)
			
			// Ignore NEXTVAL - will be handled at journal construction
			if 'atom.isLike("%NEXTVAL%") do {
			
				type Boolean isOld = (table = "OLD")
				type Boolean isNew = (table = "NEW")
				type String col = atom.piece(".", 2)
			
				if ((table = primTable) or isOld or isNew), makeThis do {
					
					set table = "this"
					set col = this.colName(col, "LC", true)
				}
				else  set tableList = tableList.add(table.upperCase(), ",", false)
			
				// Replace table.column reference with object reference
				set atom = (table_ "."_ col).upperCase()
				if doLC set atom = atom.lowerCase()
				
				if isOld set atom = atom_ ".oldVal"
				else  if isNew set atom = atom_ ".curVal"
			}
		}
		
		// Ignore delimiters and quoted strings
		else  if (atom.length() > 1), 'atom.beginsWith(0.char()) set atom = this.translateKeyWords(this.td, atom, "", false)
		
		// Retain whitespace around and, or, not
		if (atom.length() > 1) do {
			
			set atomUC = atom.upperCase()
			if ({List}"AND,OR,NOT").contains(atomUC) set atom = " "_ atom_ " "
		}
		set return = return_ atom
	}
	
	#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
	if 'tok.isNull() set return = $$UNTOK^%ZS(return, tok)
	
	quit return
	

	// ---------------------------------------------------------------------
private void getIndexCode(String indexes(),	// Index info array
			  String indexnm,	// dbtbl8.indexnm
			  String idxdesc,	// dbtbl8.idxdesc
			  String global,	// dbtbl8.global
			  List orderby,		// dbtbl8.orderby
			  Boolean isUpcase,	// dbtbl8.upcase
			  PSLTokenizer tknzr)	// Tokenizer object
	/* ---------------------------------------------------------------------	
	Get the code for one index and add it to the RecordTABLE code being
	built.  Return information on indexes to allow building dispatch and
	index rebuild methods.
	
	Indexes are only built for MDB tables.
	   
	This method is used by method buildindexes.
	*/
	
	type literal String IKEYVAR = "ikey"
	
	type Boolean isAllKeys = true
	type List keys
	type Number i, indexSeq
	type String code, indexCode(), indexKey, indexKeys, nonKeys
	
	set indexSeq = this.indexSeq
	set this.indexSeq = indexSeq + 1	
	
	set keys = {List}(this.td.primaryKeys)
	set (indexKeys, nonKeys) = ""
	
	do this.addLine(indexCode(), "")
	do this.addLine(indexCode(), "private void vRCIdx"_ indexSeq_ "(Number processMode) // "_ indexnm_ " ("_ idxdesc_ ")")
	
	if isUpcase do this.addLine(indexCode(), " type Boolean deleteOK = false")
	
	// Analyze order by keys, build map of non-keys, and generate assignment code.
	
	for i = 1:1:orderby.count() do {
		
		set indexKey = orderby.elementAt(i)
		
		if indexKey.isLiteral() set indexKeys = indexKeys_ indexKey_ ","
		else  do {
			
			type Boolean isKey = false
			
			type PSLColumn cd = PSL.getPSLColumn(this.tableName, indexKey)
			
			if 'cd.computation.isNull() throw Class.new("Error", "%PSL-E-INVALID,Aborted - Index "_ indexnm_ " uses computed column "_ indexKey)
			
			if keys.contains(indexKey) set isKey = true
			else  do {
				
				set isAllKeys = false
				set nonKeys.piece(",", i) = indexKey
			}
			
			set indexKeys = indexKeys_ IKEYVAR_ i_ ","
			
			// Assign variable
			set code = " type String "_ IKEYVAR_ i_ " = this."_ this.colName(indexKey, "LC", true)
			if cd.isNullToZero, ((cd.dataType = "N") or (cd.dataType = "$")) set code = code_ ".toNumber().toString()"
			if isUpcase, ((cd.dataType = "F") or (cd.dataType = "T")) set code = code_ ".upperCase()"
			
			do this.addLine(indexCode(), code)
			
			// If not a key in primary table, assign default for null value
			if 'isKey do this.addLine(indexCode(), " if "_ IKEYVAR_ i_ ".isNull() set "_ IKEYVAR_ i_ " = 254.byte()")
		}
	}
	
	set indexKeys = indexKeys.extract(1, indexKeys.length() - 1)
			
	// Define global name
	if global.isNull() set global = "^XDBREF("""_ this.tableName_ "."_ indexnm_ ""","_ indexKeys_ ")"
	else  set global = "^"_ global_ "("_ indexKeys_ ")"
		
	// Add processing code - processMode = 2 is integrity check mode
	do this.addLine(indexCode(), " if (processMode = 2) do { quit")
	
	/* If record type is 1, then assure that tables with 
	   more nodes using this global do not cause integrity errors. */
	do this.addLine(indexCode(), "  #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
	do this.addLine(indexCode(), "  #BYPASS")
	if (this.td.recordType <> 1) set code = "  if '$D("_ global_ ") "
	else  do {
		
		type String globalRef = $$getGbl^UCXDD(this.td, "this")
		
		if globalRef.endsWith(",") set globalRef = globalRef.extract(1, globalRef.length() - 1)
		
		set code = "  if $D("_ globalRef_ "))#2,'$D("_ global_ ") "
	}

	set code = code_ "do SETERR^DBSEXECU("""_ this.tableName_ """,""MSG"",1225,"""_ this.tableName_ "."_ indexnm_ """)"
	
	do this.addLine(indexCode(), code)
	do this.addLine(indexCode(), "  #ENDBYPASS")
	do this.addLine(indexCode(), " }")
	
	do this.addLine(indexCode(), " #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
	do this.addLine(indexCode(), " #BYPASS")
	
	set code = " if (processMode<2) set "_ global_ "="""" "
		
	if isAllKeys set code = code_ "quit"		// No old entry to remove
	
	do this.addLine(indexCode(), code)
	do this.addLine(indexCode(), " #ENDBYPASS")
	
	do this.addLine(indexCode(), " quit:(processMode = 0)")
	
	if isUpcase do this.addLine(indexCode(), " if (processMode = 3) set deleteOK = true") 
		
	// Remove old entry
	for i = 1:1:nonKeys.length(",") set indexKey = nonKeys.piece(",", i) if 'indexKey.isNull() do {
	
		type String var = IKEYVAR_ i
	
		do this.addLine(indexCode(), " if this.isChanged("_ this.colName(indexKey, "UC", false).addQuotes()_ ") do {")
		set code = "  set "_ var_ " = this."_ this.colName(indexKey, "LC", true)_ ".oldVal"
		if isUpcase set code = code_".upperCase()"
		do this.addLine(indexCode(), code)
		do this.addLine(indexCode(), "  if "_ var_ ".isNull() set "_ var_ " = 254.byte("))
		if isUpcase do this.addLine(indexCode(), "  if ("_ var_ " '= this."_ this.colName(indexKey, "LC", true)_ ".upperCase()) set deleteOK = true")
		do this.addLine(indexCode(), " }")
	}
	
	if isUpcase do this.addLine(indexCode(), " quit:'deleteOK")		// Only case changed
	
	do this.addLine(indexCode(), " #ACCEPT DATE=02/26/2008; PGM=Dan Russell; CR=30801; Group=BYPASS")
	do this.addLine(indexCode(), " #BYPASS")
	do this.addLine(indexCode(), " kill "_ global)
	do this.addLine(indexCode(), " #ENDBYPASS")
	
	do this.addLine(indexCode(), " quit")
	
	do tknzr.appendSrc(indexCode())		// Add index code
	
	// Save list of non-key columns for optimization in IDXOPT
	set indexes(indexSeq) = indexnm_ "|"_ nonKeys

	quit
	
		
	// ---------------------------------------------------------------------
private void getJournalCode(String journals(),		// Journals array
			    String sort(,,,,,),		// Journal sort array
			    ret Boolean hasIfConds,	// Some ifcond exists
			    String ifConds(),		// If conditions by level
			    PSLTokenizer tknzr)		// Tokenizer object
	/* ---------------------------------------------------------------------
	Get the code for each journal and add it to the RecordTABLE code being
	built.  Return journals and sort arrays allow building dispatch code.
	   
	This method is used by method buildjournals.
	
	See buildjournals() for information on sort array.
	
	journals info:
		journals(journalID) = journalSeq TAB oldNewFM TAB ifCond
	*/
	
	type Number i, jrnseq
	type String code, column, primTable, value
	
	set primTable = this.tableName
	
	type ResultSet rs = Db.select("JRNID,DES,EFD,EXCOLUMN,IFCOND,INCOLUMN,MODE,QUERY1,QUERY2,SEQ,SUBTABLE,TRANTYPE", "DBTBL9", "%LIBS='SYSDEV' AND PRITABLE=:this.tableName")
	
	set jrnseq = 0
	while rs.next() do {
		
		type Boolean isDo = false
		type List incolumn = {List}(rs.getCol("INCOLUMN"))
		type List jrnkeys
		type List oldNewFM = Class.new("List")
		type List tableList = Class.new("List")
		type String jrnid = rs.getCol("JRNID")
		type String mode = rs.getCol("MODE")
		type String columnMap(), jrnCode(), jrnTableLC, jrnTableUC, key, lastkey
		type String ws = " "
		
		/* Build the individual journal code */
		set jrnTableUC = rs.getCol("SUBTABLE")
		set jrnTableLC = jrnTableUC.lowerCase()
		
		if 'Db.isSchemaTable(jrnTableUC) throw Class.new("Error", "%PSL-E-INVALID,Aborted - invalid table name ("_ jrnTableUC_ ") for journal "_ this.tableName_ " - "_ jrnid)

		type PSLTable tdjrn = PSL.getPSLTable(jrnTableUC, 0)
		
		set jrnkeys = {List}(tdjrn.primaryKeys)
		set lastkey = jrnkeys.elementAt(jrnkeys.count())
		
		// Build MAP and determine if any other tables involved
		type ResultSet rs9d = Db.select("COLNAM,MAP", "DBTBL9D", "%LIBS='SYSDEV' AND PRITABLE=:this.tableName AND JRNID=:jrnid")
	
		// Only save map for columns that are mapped to some value
		set tableList = tableList.add(this.tableName, ",", false)
	
		while rs9d.next() if rs9d.getCol("MAP")'="" do {
		
			set value = rs9d.getCol("MAP")
			
			/* oldNewFM also indicates need to create separate entries for
			   each column. */
			if value.isLike("%OldValue%") set oldNewFM = oldNewFM.add("old", ",", 0)
			if value.isLike("%NewValue%") set oldNewFM = oldNewFM.add("new", ",", 0)
			if value.isLike("%FmTable%") set oldNewFM = oldNewFM.add("fm", ",", 0)
			
			// Get other tables and translate keywords
			set value = this.findTableRef(value, .tableList, primTable, true, true)
			set columnMap(rs9d.getCol("COLNAM")) = value
		}
		
		set jrnseq = jrnseq + 1
		set journals(jrnid) = jrnseq _ 9.char()_ oldNewFM_ 9.char()_ rs.getCol("IFCOND")
		set sort(mode, rs.getCol("TRANTYPE"), rs.getCol("EFD"), rs.getCol("SEQ"), 'incolumn.isNull(), jrnid) = incolumn
		if 'rs.getCol("IFCOND").isNull() set hasIfConds = true
	
		do this.addLine(jrnCode(), "")
		set code = "private void vRCJrn"_ jrnseq_ "(String vRCaudit()"
	
		// If INCOLUMN, then include parameter passed as well
		if 'incolumn.isNull() set code = code_ ", String column"
		
		do this.addLine(jrnCode(), code_ ")")
		do this.addLine(jrnCode(), " // "_ jrnid_ " - "_ rs.getCol("DES"))
		
		if (mode = "U"), incolumn.isNull() do this.addLine(jrnCode(), " type String column = """"")
		do this.addLine(jrnCode(), " type String lastkey")
		
		/* Set up variables for key values, since may be complex.  Last key
		   will be assigned last, since may be in loop for next value */
		if (jrnkeys.count() > 1) do {

			set code = " type String "
			for i = 1:1:jrnkeys.count() - 1 set code = code_ "key"_ i_ ", "
			do this.addLine(jrnCode(), code.extract(1, code.length() - 2))
		}
	
		// If queries or multiple tables, add code to load other objects and execute queries
		do this.getJrnQueryCode(jrnCode(), tableList, rs.getCol("QUERY1"), rs.getCol("QUERY2"))
		
		// Assign key values
		if (jrnkeys.count() > 1) for i = 1:1:jrnkeys.count() - 1 do this.addLine(jrnCode(), " set key"_ i_ " = "_ columnMap(jrnkeys.elementAt(i)))

		// If update mode, generate journal for each change
		if (mode = "U") do {
		
			type List excolumn = rs.getCol("EXCOLUMN")
	
			// No include or exclude - do them all
			if incolumn.isNull(), excolumn.isNull() do {
				
				set code = " for  set column = vRCaudit(column).order() quit:column.isNull()  do {"
				if oldNewFM.isNull() set code = code_ " quit"
				
				do this.addLine(jrnCode(), code)
				
				set isDo = true
			}
			else  if 'excolumn.isNull() do {
			
				set code = " for  set column = vRCaudit(column).order() quit:column.isNull()"
		
				// Piece 3 of vx = 1 indicates journal flag off for this column
				set code = code_ "  if 'vRCaudit(column).piece(""|"",3)"
				
				set code = code_ ", '({List}"""_ excolumn_ """).contains(column) do {"
				if oldNewFM.isNull() set code = code_ " quit"
				
				do this.addLine(jrnCode(), code)
				
				set isDo = true
			}
			
			if isDo set ws = "  "
		}
		
		// Set up lastkey
		if columnMap(lastkey).isLike("%NEXTVAL%") do {
			
			type String value
			
			set code = ""
			for i = 1:1:jrnkeys.count() - 1 do {
				
				set key = jrnkeys.elementAt(i)
				set value = columnMap(key)
				if 'value.isLiteral() set value = ":"_ value
				set code = code_ key_ "="_ value_ ","
			}
			if code.endsWith(",") set code = code.extract(1, code.length() - 1)
			set code = "Db.nextVal("""_ jrnTableUC_ ""","_ code.addQuotes()_ ")"
		}
		else  set code = columnMap(lastkey)
		
		do this.addLine(jrnCode(), ws_ "set lastkey = "_ code)

		set code = "type Record"_ jrnTableUC_ " "_ jrnTableLC_ " = Db.getRecord("""_ jrnTableUC_ """, """
		for i = 1:1:jrnkeys.count() - 1 set code = code_ jrnkeys.elementAt(i)_ "=:key"_ i_ ","
		set code = code_ lastkey_ "=:lastkey"", true)"
		
		do this.addLine(jrnCode(), ws_ code)

		// Set values into non-key columns
		set column = ""
		for  set column = columnMap(column).order() quit:column.isNull()  if 'jrnkeys.contains(column) do {
		
			set code = "set "_ jrnTableLC_ "."_ this.colName(column, "LC", true)_ " = "_ columnMap(column)
			do this.addLine(jrnCode(), ws_ code)
		}
		
		do this.addLine(jrnCode(), ws_ "do "_ jrnTableLC_ ".save(""/NOVALFK/NOVALDD/NOVALRI"")")
		
		if isDo do this.addLine(jrnCode(), " }")
		
		do this.addLine(jrnCode(), " quit")
		
		do tknzr.appendSrc(jrnCode())		// Add journal code
	}
	
	// All journals processed, finish final processing on sort
	do this.setJournalSort(sort(,,,,,))
	
	/* If there are any if conditions, determine if there are levels (mode,
	   trantype, efdopt) where all associated queries have ifconds.  If
	   they all do, then we can promote the set of all the tests, not just
	   have the individual test around  the call the each individual journal.
	   
	   ifConds() structure is:
	   
	   	ifConds(M-T-E)=(ifcond1) and (ifcond2) ... if all journals for
	   		the "level" (combination of M-T-E) have ifconds,
	   		otherwise it will be null
	   		
	   		M-T-E includes M, M-T, and M-T-E to deal with each
	   		level we build for journal dispatch
	   		
	   Build withIf(M-T-E) = List of journals with ifconds.  If a journal
	   		does not have ifcond, add * to list as indicator
	*/
	if hasIfConds do {
		
		type List withIf()
		type String efdopt, incol, jrnid, mode, mteStr, mtStr, prio, trantype, x
		
		set (efdopt, incol, jrnid, mode, prio, trantype) = ""
		
		for  set mode = sort(mode).order() quit:mode.isNull()  do {
			set withIf(mode) = Class.new("List")
			for  set trantype = sort(mode, trantype).order() quit:trantype.isNull()  do {
				set mtStr = mode_ "-"_ trantype
				set withIf(mtStr) = ""
				for  set efdopt = sort(mode, trantype, efdopt).order() quit:efdopt.isNull()  do {
					set mteStr = mode_ "-"_ trantype_ "-"_ efdopt
					set withIf(mteStr) = ""
					for  set prio = sort(mode, trantype, efdopt, prio).order() quit:prio.isNull()  do {
						for  set incol = sort(mode, trantype, efdopt, prio, incol).order() quit:incol.isNull()  do {
							for  set jrnid = sort(mode, trantype, efdopt, prio, incol, jrnid).order() quit:jrnid.isNull()  do {
								
								if journals(jrnid).piece(9.char(), 3).isNull() set x = "*"
								else  set x = jrnid
		
								set withIf(mode) = withIf(mode).add(x, ",", false)
								set withIf(mtStr) = withIf(mtStr).add(x, ",", false)
								set withIf(mteStr) = withIf(mteStr).add(x, ",", false)
							}
						}
					}
				}
			}
		}
		
		set x = ""
		for  set x = withIf(x).order() quit:x.isNull()  do {
			
			if withIf(x).contains("*") set ifConds(x) = ""
			else  do {
				
				type Number i
				type String code = ""
				
				for i = 1:1:withIf(x).count() set code = code_ "("_ journals(withIf(x).elementAt(i)).piece(9.char(), 3)_") and "
				
				set ifConds(x) = code.extract(1, code.length() - 5)
			}
		}
	}
		
	quit
	

	// ---------------------------------------------------------------------
private void getJrnQueryCode(String jrnCode(),		// Journal code array
			     List tableList,		// Tables involved
			     String query1,		// dbtbl9d.query1
			     String query2)		// dbtbl9d.query2
	/*
	Add query and additional tables related code to journal code array.
	
	This method is used by the getJournalCode() method.	
	*/
	
	type Boolean isDummyQry = false
	type Boolean isVarInsert = false
	type List qrybldTbls = Class.new("List")
	type Number i
	type Number varSeq = 0
	type String code, input(), pslobj(), pslqry(), query, varSub()
	
	// Nothing to add
	quit:(query1.isNull() and query2.isNull() and (tableList.count() '> 1))
	
	/* Check queries for additional table references and add to TABLES.
	
	   If query contains complex variable insertion, e.g., <<$$func(...)>> etc, 
	   replace variable insertion with a variable in the query and assign the
	   variable insertion code to the variable.  Otherwise, UQRYBLD can't
	   handle it.
	*/
	
	if (query1.isNull() and query2.isNull()) set query = ""
	else  do {
		
		type String tok
		
		if query1.isNull(), 'query2.isNull() set query = query2
		else  if query2.isNull() set query = query1
		else  set query = "("_ query1_ ") and ("_ query2_ ")"
		
		if query.isLike("%<<%") set isVarInsert = true
		
		set query = this.findTableRef(query, .tableList, this.tableName, isVarInsert, isVarInsert)
		
		/* Variable insertion using functions is currently allowed,
		   e.g. <<$^ABC(table.column)>>=1.  However, use of public
		   scope variables is not.  Replace the variable insertion
		   with a variable, QRYn.
		*/
		
		#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
		set query = $$TOKEN^%ZS(query, .tok)
		
		if isVarInsert do {
			
			type String expression
			type String newquery = ""
			
			while 'query.isNull() do {
			
				set newquery = newquery_ query.piece("<<", 1)_ "<<"
				set expression = query.piece("<<", 2).piece(">>", 1)
				// Handled "less than", e.g., X<<<$$^ABC>>
				if expression.beginsWith("<") do {
					
					set newquery = newquery_ "<"
					set expression = expression.extract(2, PSL.maxStringLength)
				}
				
				set varSeq = varSeq + 1
				#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS
				set varSub(varSeq) = $$UNTOK^%ZS(expression, tok)
				set newquery = newquery_ "QRY"_ varSeq_ ">>"
				
				// Add declaration for this variable
				do this.addLine(jrnCode(), " type String QRY"_ varSeq)
				
				set query = query.piece(">>", 2, PSL.maxStringLength)
				if 'query.contains("%<<%") do {
				
					set newquery = newquery_ query
					set query = ""
				}
			}
			
			set query = newquery
		}
		
		#ACCEPT DATE=03/11/2008; PGM=Dan Russell; CR=30801; Group=ACCESS	
		set query = $$UNTOK^%ZS(query, tok)
	}
		
	// If all we are dealing with is a need to load other table info use a dummy query
	if query.isNull(), (tableList.count() > 1) do {
		
		set isDummyQry = true
		set query = "1>0"
	}

	// Convert to SQL FROM and WHERE to allow call to UCQRYBLD
	#ACCEPT Date=06/10/2008; Pgm=RussellDS; CR=30801; Group=ACCESS
	set input("WHERE") = $$WHERE^SQLCONV(query, tableList)
	#ACCEPT Date=06/10/2008; Pgm=RussellDS; CR=30801; Group=ACCESS
	set input("FROM") = $$DQJOIN^SQLCONV(tableList)
	
	do ^UCQRYBLD(input(), this.tableName_ "=this", , pslobj(), pslqry())
	
	/* Insert object instantiation code for any other tables referenced.
	   Replace object names generated by UCQRYBLD with lowercase table name
	   to match references used in journal map.
	   
	   Also, modify getRecord to use 1 as third parameter to ensure that this won't
	   fail in the even there is no record.  For journal file mapping, there may be
	   cases where a related record doesn't exist.  In that case, a journal file
	   query can be used to not continue if the record doesn't exist.  Or, if null
	   entries are OK, to continue.  This is the approach used in prior code.  For
	   an example, see the HIST journal.
	*/
	if (pslobj.data() > 0) do {
		
		type Number n, seq
		
		set (n, seq) = ""
		for  set n = pslobj(n).order() quit:n.isNull()  do {
			for  set seq = pslobj(n, seq).order() quit:seq.isNull()  do {
				
				set code = pslobj(n, seq)
				
				if (seq = 1) do {
					
					type String qrybldObj = code.piece("=", 1).piece(" ", 3).trim()
					type String table = pslobj(n).piece("|", 1).lowerCase()
					
					set code = code.replace(qrybldObj, table)
					set qrybldTbls = qrybldTbls.add(qrybldObj_ "|"_ table, ",", false)
					
					// Add 3rd parameter
					set code = code.extract(1, code.length() - 1)_ ", true)"
				}
				do this.addLine(jrnCode(), " "_ code)
			}
		}
	}
		
	// If any variable substition for queries, set it
	if (varSeq > 0) for i = 1:1:varSeq do this.addLine(jrnCode(), " set QRY"_ varSeq_ " = "_ varSub(i))
	
	// Insert query logic - for tables instantiated by query logic, replace object names
	if 'isDummyQry do {
	
		type Number seq
		type String qrybldTbl, table
		
		set seq = ""
		for  set seq = pslqry(seq).order() quit:seq.isNull()  do {
			
			for i = 1:1:qrybldTbls.count() do {
			
				set qrybldTbl = qrybldTbls.elementAt(i).piece("|", 1)
				set table = qrybldTbls.elementAt(i).piece("|", 2)
				
				set pslqry(seq) = pslqry(seq).replace(qrybldTbl, table)
			}
			do this.addLine(jrnCode(), " if "_ pslqry(seq))
			do this.addLine(jrnCode(), " else  quit")
		}
	}
	
	quit
	
		
	// ---------------------------------------------------------------------
private void setJrnSortSplit(String sort(,,,,,),	// Sort array
			     String mode,		// Mode key in sort
			     String modeval,		// Individual mode value
			     String trantype,		// Trantype key in sort
			     String trantypeval,	// Individual trantype value
			     String efdopt,		// Efdopt key in sort
			     String efdoptval)		// Individual efdopt value
	/* ---------------------------------------------------------------------		 
	Split journal sort array method.
	
	Used by setJournalSort() method
	*/
	
	type String incol, jrnid, prio		

	set (incol, jrnid, prio) = ""
	for  set prio = sort(mode, trantype, efdopt, prio).order() quit:prio.isNull()  do {
		for  set incol = sort(mode, trantype, efdopt, prio, incol).order() quit:incol.isNull()  do {
			for  set jrnid = sort(mode, trantype, efdopt, prio, incol, jrnid).order() quit:jrnid.isNull()  do {
				set sort(modeval, trantypeval, efdoptval, prio, incol, jrnid) = sort(mode, trantype, efdopt, prio, incol, jrnid)
			}
		}
	}
	
	quit
	
	
	// ---------------------------------------------------------------------
private String getLogCode(String column,	// Column name
			  String system,	// td.systemName
			  String typ)		// data type
	/* ---------------------------------------------------------------------
	Get appropriate code for log colums
	*/
	
	type String code = ""

	if 'column.isNull(), Db.isSchemaColumn(this.tableName, column) do {
	
		set code = " set this."_ this.colName(column, "LC", true)_ " = "
		if (typ = "D") set code = code_ $select(system = "PBS":"%SystemDate", 1:"%CurrentDate")
		else  if (typ = "T") set code = code_ "%CurrentTime"
		else  if (typ = "U") do {
			
			type PSLColumn cd = PSL.getPSLColumn(this.tableName, column.upperCase())
		
			// Ensure truncate value in case too long
			set code = code_ $select(system = "DBS":"%UserName", 1:"%UserID")_".extract(1, "_ cd.length_ ")"
		
			// For DBS, allow change from external interfaces
			if (system = "DBS") set code = " if 'this.isChanged("_ this.colName(column, "UC", false).addQuotes()_ ", ""USER"")"_ code
		}
	}

	quit code
		
	
	// ---------------------------------------------------------------------
private void getSections()
	/* ---------------------------------------------------------------------		 
	Get applicable sections for this table.
	
	See sections property.
	*/
	
	type Boolean hasTrigger(), hasTriggerKO(), isDone
	type List keys = this.td.primaryKeys
	type Number i
	type String ifCond()
	
	set this.sections = Class.new("List")
		
	set isDone = false
	
	if 'this.td.isRdb do {
	
		type String table
	
		type ResultSet rsi = Db.select("FID", "DBTBL8", "FID = :this.tableName")
		if 'rsi.isEmpty() set this.sections = this.sections.add("indexes")
		
		if 'this.td.requiredList.isNull() set this.sections = this.sections.add("required")
		
		// Check for foreign keys, this table plus all ancestors
		set table = this.tableName
		while 'table.isNull() do {

			type ResultSet rsfk = Db.select("FKEYS", "DBTBL1F", "FID = :table AND TBLREF IS NOT NULL")
			if 'rsfk.isEmpty() do { quit
			
				set this.sections = this.sections.add("foreignKeys")
				set table = ""				// We're done
			}

			// Check ancestor
			if this.tableName = table set table = this.td.parentTable
			else  do {
			
				type PSLTable td2 = PSL.getPSLTable(table, 0)
				set table = td2.parentTable
			}
		}
	}
	
	for i = 1:1:this.td.defaultList.count() do { quit:isDone
		
		type SchemaColumn cd = Db.getSchemaColumn(this.tableName, this.td.defaultList.elementAt(i))
		
		if 'cd.default.isNull(), cd.computation.isNull() do {
		
			set this.sections = this.sections.add("defaults")
			set isDone = true
		}
	}
	
	type ResultSet rsj = Db.select( "JRNID", "DBTBL9", "%LIBS='SYSDEV' AND PRITABLE=:this.tableName")
	if 'rsj.isEmpty() set this.sections = this.sections.add("journals")
	
	type ResultSet rscd = Db.select("FID", "DBTBL1F", "%LIBS='SYSDEV' AND TBLREF=:this.tableName")
	if 'rscd.isEmpty() set this.sections = this.sections.add("cascadeDelete")
	
	/* Check triggers and set trigger-related properties
	
	   Index to trigger arrays makes use of properties trigBI, trigBU, etc.
	   
	   If all AU or BU triggers only involve keys, won't dispatch from main flow
	   but from key change logic.  Sections AUKO and BUKO indicate that. 
	   
	   Any DBTBL7.IFCOND values are added to the appropriate ifCond() entry, separated
	   by AND to build up a single ifcond.  If any trigger DOES NOT HAVE an ifcond,
	   the ifCond() value is set to "*", and we're done with it.  We only care if
	   ALL the triggers for a specific trigger type have an ifcond.
	*/
	
	for i=1:1:6 set hasTrigger(i) = false		// Any triggers of this type?
	for i=1:1:6 set hasTriggerKO(i) = true		// Only triggers on keys?
	for i=1:1:6 set ifCond(i) = ""			// All conditional code
	
	type ResultSet rst = Db.select("ACTBI,ACTBU,ACTBD,ACTAI,ACTAU,ACTAD,COLUMNS,IFCOND", "DBTBL7", "%LIBS='SYSDEV' AND TABLE=:this.tableName")
	while rst.next() do {
		
		type String ifcond, triggers
		
		set triggers = rst.getCol("ACTBI")_ ","_ rst.getCol("ACTBU")_ ","_ rst.getCol("ACTBD")_ ","_ rst.getCol("ACTAI")_ ","_ rst.getCol("ACTAU")_ ","_ rst.getCol("ACTAD")
		set ifcond = rst.getCol("IFCOND")
		
		for i = 1:1:6 if {Boolean}(triggers.piece(",", i)) do {
			
			set hasTrigger(i) = true
			
			if ifcond.isNull() set ifCond(i) = "*"		// All don't have ifcond
			else  set ifCond(i) = ifCond(i)_ "("_ ifcond_ ") and "
			
			// Check if trigger involves keys only (BU and AU only)
			if ((i = this.trigBU) or (i = this.trigAU)), hasTriggerKO(i) do {
				
				type List columns = {List}(rst.getCol("COLUMNS"))
				type Number j
				
				if (columns.count() = 0) set hasTriggerKO(i) = false		// Applies to all columns
				else  for j = 1:1:columns.count() if 'keys.contains(columns.elementAt(j)) set hasTriggerKO(i) = false quit
			}
		}
	}
	
	if hasTrigger(this.trigBI) set this.sections = this.sections.add("BI")
	if hasTrigger(this.trigBU) set this.sections = this.sections.add("BU")
	if hasTrigger(this.trigBD) set this.sections = this.sections.add("BD")
	if hasTrigger(this.trigAI) set this.sections = this.sections.add("AI")
	if hasTrigger(this.trigAU) set this.sections = this.sections.add("AU")
	if hasTrigger(this.trigAD) set this.sections = this.sections.add("AD")
	
	for i=1:1:6 if hasTrigger(i) set this.sections = this.sections.add("triggers") quit
	
	if hasTrigger(this.trigBU), hasTriggerKO(this.trigBU) set this.sections = this.sections.add("BUKO")
	if hasTrigger(this.trigAU), hasTriggerKO(this.trigAU) set this.sections = this.sections.add("AUKO")
	
	for i=1:1:6 set this.triggerAllIfConds(i) = ""
	for i=1:1:6 if 'ifCond(i).isNull(), (ifCond(i) '= "*") do {
		
		set this.triggerAllIfConds(i) =  ifCond(i).extract(1, ifCond(i).length() - 5)
	}
	
	type ResultSet rslit = Db.select("DISTINCT TABLE", "SYSMAPLITDTA", "TABLE=:this.tableName")
	if 'rslit.isEmpty() set this.sections = this.sections.add("literals")

	quit

	
	// ---------------------------------------------------------------------
private void getTriggerCode(String dispatch(,,),	// Dispatch info array
			    String ifConds(),		// If conditions, by trigger
			    String trgid,		// dbtbl7.trigid
			    Boolean actbi,		// dbtbl7.actbi
			    Boolean actbu,		// dbtbl7.actbu
			    Boolean actbd,		// dbtbl7.actbd
			    Boolean actai,		// dbtbl7.actai
			    Boolean actau,		// dbtbl7.actau
			    Boolean actad,		// dbtbl7.actad
			    List columns,		// dbtbl7.columns
			    String des,			// dbtbl7.des
			    String ifcond,		// dbtbl7.ifcond
			    PSLTokenizer tknzr)		// Tokenizer object
				   
	/* ---------------------------------------------------------------------	
	Get the code for one trigger and add it to the RecordTABLE code being
	built.  Return information on triggers to allow building dispatch code.
	   
	This method is used by method buildtriggers.
	*/
	
	type Boolean hasTrigger()
	type Number i, lastLine, trigSeq
	type String code, trigCode()
	
	set trigSeq = this.triggerSeq
	set this.triggerSeq = trigSeq + 1

	/* First, set up info for dispatch logic */
	set hasTrigger(this.trigBI) = actbi
	set hasTrigger(this.trigBU) = actbu
	set hasTrigger(this.trigBD) = actbd
	set hasTrigger(this.trigAI) = actai
	set hasTrigger(this.trigAU) = actau
	set hasTrigger(this.trigAD) = actad

	/* For dispatch, triggers with no columns come first (dispatch(,1,seq),
	   and others are simply sorted by columns (dispatch(,2,columns).
	   Insert and delete related triggers do not consider columns, so even
	   if the same trigger is used for insert or delete and update, where
	   there are columns, ignore the column info for insert and delete.
	*/
	for i = 1:1:6 if hasTrigger(i) do {
		
		type Boolean isInsOrDel = '((i = this.trigBU) or (i = this.trigAU))
		
		if (columns.isNull() or isInsOrDel) set dispatch(i, 1, trigSeq) = ""
		else  do {
			
			if 'dispatch(i, 2, columns).exists() set dispatch(i, 2, columns) = trigSeq
			else  set dispatch(i, 2, columns) = dispatch(i, 2, columns)_ ","_ trigSeq
		}
	}
	
	if 'ifcond.isNull() set ifConds(trigSeq) = ifcond
	
	/* Now add trigger code to source.
	
	   Because of legacy code in triggers, and use of TABLE.column references
	   instead of this.column, pass the RecordTABLE instance to trigger to
	   allow either type of reference.
	   
	   Note that comment trigger name and description is used by SYSMAPLB^DBSFILB
	   to provide mapping of label name to trigger name.
	*/
	
	do this.addLine(trigCode(), "")
	set code = "private void vRCTrig"_ trigSeq_ "(Record"_ this.tableName_ " "_ this.tableNameLC_ ", String vpar)"
	set code = code_" // Trigger "_ trgid_ " - "_ des_ " - "
	for i = 1:1:6 if hasTrigger(i) set code = code_ this.trigDESC.piece(",", i)_ " "
	do this.addLine(trigCode(), code)
	
	if hasTrigger(this.trigBU) {
		do this.addLine(trigCode(), " do this.setAuditFlag(true)")
		do this.addLine(trigCode(), " do "_ this.tableNameLC_".setAuditFlag(true)")
	}
		
	type ResultSet rs = Db.select("CODE", "DBTBL7D", "TABLE = :this.tableName and TRGID = :trgid")		
	
	while rs.next() do {
		
		/* Because dbtbl7d.code is likely to contain tabs, cannot
		   simply use getCol() reference. */
		type String line = rs.getRow().toString().replace(9.char(), " ")
		
		/* Any methods must be private and they must be all uppercase */
		if (line.extract(1) ? 1AN.E) do {
			
			type String p3 = line.piece(" ", 3).piece("(", 1)
			
			if 'line.beginsWith("private") throw Class.new("Error", "%PSL-E-INVALID,Aborted - method in trigger must be private ("_ trgid_ ")")
			
			if (p3.upperCase() '= p3) throw Class.new("Error", "%PSL-E-INVALID,Aborted - method name "_ p3_ " in trigger must be upper case ("_ trgid_ ")")
		}
		
		do this.addLine(trigCode(), line)
	}
	
	/* Add a quit at the end if there isn't one in the trigger source.
	   Find last non-blank line.
	*/
	set lastLine = trigCode("").order(-1)
	for i = lastLine:-1:1 quit:'trigCode(i).trim().isNull()
	if 'trigCode(i).trim().beginsWith("quit") do this.addLine(trigCode(), " quit")
	
	do tknzr.appendSrc(trigCode())		// Add trigger code
	
	quit
	
	
	// ---------------------------------------------------------------------
private String getWhereKey(String objName,	// Object name
			   Boolean asNATIVE,	// Return key query using native names
			   ret List nattable)	// Native database table name
	/* ---------------------------------------------------------------------		 
	Get appropriate SQL WHERE clause for keys for this table

	Because a non-M database may remap both table and key names to
	protect reserved words, the flag asNATIVE indicates to use the
	remapping scheme.  In that case, the table name may also change,
	so is returned in nattable.
	
	Note that for a non-M database that a table may also be remapped
	into multiple tables, returning nattable as a list.  The caller
	needs to deal with that issue.
	
	If objName is null, use "vkeyn" for variable assignment.  See
	vdelete coding for RBD.
	*/
	
	type public String %DB
	
	type Boolean ER = false
	type List keys = this.td.primaryKeys
	type Number i
	type String col, colLC, ret

	if asNATIVE do {		// Remap table
		
		set nattable = nattable.add(this.tableName, ",", false)
		do MAP^DBMAP(%DB, .nattable)
	}

	if keys.isNull() quit ""

	set ret = ""

	for i = 1:1:keys.count() do {
		
		if (i > 1) set ret = ret_" and "
		set col = keys.elementAt(i)
		
		if this.td.isRdb, asNATIVE do {
			
			do MAP^DBMAP(%DB, this.tableName, .col)
			
			if ER throw Class.new("Error", "%PSL-E-INVALID,Aborted - "_ this.tableName_ "."_ col_ " not in DBMAP")
		}
		
		if 'objName.isNull() set ret = ret_ col_ "=:"_ objName_ "."_ this.colName(col, "LC", true)
		else  set ret = ret_ col_ "=:vkey"_ i
	}
	
	quit ret		
		

	// ---------------------------------------------------------------------
private void setJournalSort(String sort(,,,,,))		// Sort array
	/* ---------------------------------------------------------------------
	Final sort on journal sort array for buildjournals method.
	
	sort() is passed in for a final sort to structure for most efficient
	dispatch logic.
	
	See buildjournals() for structure of sort array.
	*/
	
	type Number i
	type String efdopt, mode, prio, trantype
	
	/* For each of the first three levels (under their current level), if
	   the level doesn't contain all the options, then break any multiple
	   option values into individual options.  E.g., break "I,U" into "I"
	   and "U".
	*/
	
	// Break up modes
	if ((sort("").order() '= "I,U,D") or (sort("").order(-1) '= "I,U,D")) do {
		
		type String modeval
		
		set (efdopt, mode, trantype) = ""
		for  set mode = sort(mode).order() quit:mode.isNull()  if mode.isLike("%,%") do {
			for i = 1:1:mode.length(",") set modeval = mode.piece(",", i) do {
				for  set trantype = sort(mode, trantype).order() quit:trantype.isNull()  do {
					for  set efdopt = sort(mode, trantype, efdopt).order() quit:efdopt.isNull()  do this.setJrnSortSplit(sort(,,,,,), mode, modeval, trantype, trantype, efdopt, efdopt)
				}
			}
			
			kill sort(mode)		// Remove this level, since now broken into components
		}
	}
	
	set (efdopt, mode, prio, trantype) = ""
	for  set mode = sort(mode).order() quit:mode.isNull()  do {
		
		// Break up trantypes
		if ((sort(mode, "").order() '= "F,O,B") or (sort(mode, "").order(-1) '= "F,O,B")) do {
			
			type String trantypeval
			
			set (efdopt, trantype) = ""
			for  set trantype = sort(mode, trantype).order() quit:trantype.isNull()  if trantype.isLike("%,%") do {
				for i = 1:1:trantype.length(",") set trantypeval = trantype.piece(",", i) do {
					for  set efdopt = sort(mode, trantype, efdopt).order() quit:efdopt.isNull()  do this.setJrnSortSplit(sort(,,,,,), mode, mode, trantype, trantypeval, efdopt, efdopt)
				}
			
				kill sort(mode, trantype)
			}
		}
		
		for  set trantype = sort(mode, trantype).order() quit:trantype.isNull()  do {
			
			// Break up efdopts
			if ((sort(mode, trantype, "").order() '= "N,E") or (sort(mode, trantype, "").order(-1) '= "N,E")) do {
				
				type String efdoptval
				
				set efdopt = ""
				for  set efdopt = sort(mode, trantype, efdopt).order() quit:efdopt.isNull()  if efdopt.isLike("%,%") do {
					for i=1:1:efdopt.length(",") set efdoptval = efdopt.piece(",", i) do this.setJrnSortSplit(sort(,,,,,), mode, mode, trantype, trantype, efdopt, efdoptval)
					
					kill sort(mode, trantype, efdopt)
				}
			}
		}
	}
	
	quit
			
	
	// ---------------------------------------------------------------------
private static String translateKeyWords(SchemaTable td,		// RecordTABLE being built
					String input,		// Input value
					String typ,		// Data type
					Boolean addQuotes)	// Add quotes [*4]
	/* ---------------------------------------------------------------------
	Translated keyword phrase to valid PSL construct
	
	Handle various legacy values.
	
	ARGUMENT NOTES:
	
		[*4] If returning input, which has not otherwise been modified,
		     add quotes.
	
	RETURNS:
		. PSL equivalent with keyword replaced
	*/
	
	type Boolean isVarin = false			// Variable insert syntax << >>
	type String return = ""
	
	if input.beginsWith("<<"), input.endsWith(">>") do {
		
		set isVarin = true
		set input = input.extract(3, input.length() - 2)
	}
	
	if input.isNull() quit ""
	if input.isNumber() quit input
	
	if input.beginsWith("$$") do { if 'return.isNull() quit return
		
		if (input = "$$USERNAM^%ZFUNC") set return = "%UserName"
		else  if (input = "$$TLO^UTLO") set return = "%UserStation"
		else  if input.beginsWith("$$^CUVAR(") set return = "CUVAR."_ input.piece("(""",2).piece(""")", 1)
	}
	if input.beginsWith("$$") quit input
	if input.beginsWith("""") quit input
	
	/* Note that while it would be nice (and more efficient) to use caching
	   here, we can't since it depends on the RecordTABLE code already 
	   existing for STBLSYSKEYWD and STBLJRNFUNC. */
	
	// Already a valid keyword
	type ResultSet rskeywrd = Db.select("KEYWORD", "STBLSYSKEYWD", "KEYWORD=:input")
	if 'rskeywrd.isEmpty() quit input
	
	type ResultSet rsjrn = Db.select("PSLEQUIV", "STBLJRNFUNC", "FUNC=:input AND PSLEQUIV IS NOT NULL")
	
	if rsjrn.next() quit rsjrn.getCol("PSLEQUIV")
	
	/* Handle STBLJRNFUNC entries without PSL equivalents in the table.
	   Note that these are only valid entries in a journal related context,
	   not as defaults, etc. */
	set return = ""
		
	if (input = "ColName") set return = "column"
	else  if (input = "FmTable") set return = "vRCaudit(column).piece(""|"", 11)"
	else  if (input = "NewValue") set return = "vRCaudit(column).piece(""|"", 2)"
	else  if (input = "OldValue") set return = "vRCaudit(column).piece(""|"", 1)"
	else  if (input = "TableName") set return = td.table.addQuotes()
	
	if 'return.isNull() quit return
	
	if input.isNumber() quit input
	
	// Handle various legacy values
	if ((input = "%UID") or (input = "$G(%UID)")) quit "%UserID"
	if (input = "TJD") quit "%SystemDate"
	if ((input = "+$H") or (input = "+$P($H,"","",1)")) quit "%CurrentDate"
	if (input = "$P($H,"","",2)") quit "%CurrentTime"
	if (input = "$I") quit "%UserStation"
	
	if (input.beginsWith("CUVAR.")) quit input.upperCase()
	
	if (typ = "D") do {
		
		if (input = "T") set return = "%SystemDate"
		else  if (input = "C") set return = "%CurrentDate"
	}
	else  if (typ = "C") do {
		
		if (input = "C") set return = "%CurrentTime"
	}
	else  if (typ = "L") do {
		
		if (input = "Y") set return = true
		else  set return = false
	}
	
	if 'return.isNull() quit return
	
	if addQuotes quit input.addQuotes()

	quit input
	
	
	// ---------------------------------------------------------------------
private static String colName(String columnName,	// Column name
			      String case,		// "LC" or "UC"
			      Boolean addQ)		// Add quotes for _?
	/* ---------------------------------------------------------------------		
	If column name contains an underscore, make uppercase and add quotes
	if addQ is true, otherwise make lowercase or uppercase based on case
	parameter.
	
	Note that chose case as string versus Boolean to improve readability
	of callers.  And, since this is private, am not checking validity of
	case being either UC or LC (trust the caller).
	*/
	
	if columnName.isLike("%_%") do { quit columnName.upperCase()
		
		if addQ set columnName = columnName.addQuotes()
	}
	
	if (case = "UC") quit columnName.upperCase()
	
	quit columnName.lowerCase()
	

	// ---------------------------------------------------------------------
private static void addLine(String srcarr(),		// Source code array
			    String code,		// Code to add
			    ret Number lineNo)		// Line number added
	/* ---------------------------------------------------------------------	
	Helper method to add code to the end of a source code array.
	*/
	
	set lineNo = srcarr("").order(-1) + 1

	set srcarr(lineNo) = code	

	quit
	
	
	// ---------------------------------------------------------------------
private static void addLine2(String srcarr(),		// Source code array
			     String srcarr2(),		// Secondary source array
			     String code,		// Code to add
			     ret Number lineNo)		// Line number added (primary)
	/* ---------------------------------------------------------------------	
	Helper method to add code to the end of a source code array, and, at
	the same time, to the end of a secondary array.
	*/
	
	set lineNo = srcarr2("").order(-1) + 1
	set srcarr2(lineNo) = code
	
	set lineNo = srcarr("").order(-1) + 1
	set srcarr(lineNo) = code	

	quit
 #OPTION ResultClass ON
public String vSIG()	quit "61523^1911^Dan Russell^192755"	// Signature - LTD^TIME^USER^SIZE
