	/*
	ORIG: Frans S.C. Witte, 2006-04-24
	DESC: PSL ByteString Method library

	---- Comments ----------------------------------------------------------
	This unit implements the methods and properties of class ByteString.
	Many methods are derived from UCSTRING.
	In fact, if the current GT.M version does not support Unicode, then
	the implementation of all methods that have an equivalent method in
	class String will call that method.

	If the current GT.M version does support Unicode, then the code
	generated for ByteString methods will depend on the value of $ZCHSET
	at COMPILETIME (!!). Note that this assumes that a consistant, constant
	value will be used for any given compiler environment.

	In addition, special considerations apply with respect to Upgrade rules.
	See appropriate section below.

	Given the above considerations, most code generating subroutines follow
	the pattern below:

	    xxxxxx // implements ByteString.xxxxxx()
		if $$rtChset()="M" do {	// environment not set up for UTF-8
			do xxxxxx^UCSTRING
		}
		else  do {	/ generate code for UTF-8 support
			(code for Unicode version)
		}

	Note that with the introduction of vRuntime.m the above distinction is
	completely encapsulated in the code generated for Runtime.charsetName.

	Subroutines generated by this unit will use one of the following
	class-specific prefixes:
	- vBts for ByteString methods
	- vStr for String methods

	---- Upgrade Considerations --------------------------------------------
	Since the introduction of the vRuntime.m module, this unit can be placed
	in the Insensitive group.
	To deal with differences between the source environment and the target
	environment, PSLParser.CS("boot","restrictionlevel")<0 (PREPARE mode) is
	used to generate code that defers retrieval of Runtime.charsetName until
	the target environment (by coding a call to $$charsetName^vRuntime).

	So all PSL code, including the compiler code itself can now use the
	Runtime.charsetName property to reference the character set name.

	The current upgrade rules only deal with MDB/RDB distinctions. Character
	set sensitivity will need to consider the following:
	- $ZVERSION mismatches between source and target environment.
		This is currently handled by wrapping the detection in a call
		to $$gtmLevel^UCGM(), which supports the
		PSLParser.getSetting("boot","gtmlevel") override. Due to this
		override, UCBYTSTR (and other units) can generate code for a
		GT.M version that differs from the actual source version,
		assuming that the resulting code is not stored in the standard
		crtns directory.
	- For character set sensitive constructs the code generated for the
		methods String.upperCase() and String.lowerCase() deserves
		special attention: GT.M versions lower than V5.2 will not
		recognize $ZCONVERT(), and GT.M V5.2 and up with $ZCHSET="M"
		can use $ZCONVERT only for 7 bit ASCII values. The code
		generated up to the introduction of UCBYTST has 8 bit
		"characters" in string literals. This will not even compile in
		GT.M V5.2 with $ZCHSET="UTF-8".

	In this particular case, the following observations are made:
	* If the source version does not support Unicode (either due to the
		value of $ZVERSION or due to the value of $ZCHSET), then the .m
		file will
		- contain code that runs on every platform
		- generate incorrect code for ByteStream methods if the target
			environment does support Unicode.
	* If the target version does not support Unicode due to the value of
		$ZVERSION, then the .m file shall not reference $ZCHSET
	* If the target version does not support Unicode due to the value of
		$ZCHSET, then any version of the .m file will run in that target
		environment. However, it will only produce the correct results,
		if the source version is $ZCHSET-aware.
	* If the target environment expects correct treatment of Unicode, and
		the distributed UCBYTSTR.m file does not contain the code that
		can make the disctinction at compile time (i.e. is compiled to
		contain the "IF"-part, not the "ELSE"-part above), then all code
		generated for ByteStream occurrences that are compiled by
		boot^UCGMCU() (i.e. the "phase 1" elements) before the correct
		version of UCBYTSTR.proc is compiled and ZLINKed will
		incorrectly contain the String equivalents.
	The above suggests that there is not a single way to generate the .m
	file that needs to be included in the distribution.

	---- Other Considerations ----------------------------------------------
	Because the implementation of Number.byte() follows the same pattern as
	the ByteString methods, and obeys the same upgrade restrictions, it is
	implemented here instead of in UCNUMBER.

	Similarly, the implementation of String.byteLimitSubstring(),
	String.upperCase() and String.lowerCase( titleCase) will be implemented
	here to reduce the number of units that need to deal with the upgrade
	restrictions and the specifics of pre-Unicode, Unicode, and $ZCHSET.

	---- Revision History --------------------------------------------------
	2009-04-10, Frans S.C. Witte, CR 35741/38852
		* modified chrsetNm to return "charsetName^vRuntime" if in boot
		  preparation mode.

	2009-03-13, Frans S.C. Witte, CR 35741/37572
		psl2m() now calls PSLParser.findPSLMethod() to handle inherited
		methods.

	03/30/07 - Frans S.C. Witte - CR: 27800
		* Replaced calls to UCXOBJ by calls to PSLParser.
		* Replaced commands(,) by pslPrsr(,)
		* Eliminated xecute-statement

	12/19/06 - Frans S.C. Witte - CRs: 25185 / 25186 / 25187
		Added implementation of Runtime.charsetEncoding

	12/01/06 - Frans S.C. Witte - CRs: 22719 / 20613
		Modified upCase, loCase, and rtChset to deal with boot setting
		(PSL.getSetting("boot","charsetlevel"))

	08/14/06 - Frans S.C. Witte - CRs: 22720 / 22274
		* Added case parameter in call to $$omGet^UCXOBJ().
		* Added $$rtChset(), and modified all method generating code to
		 call it (instead of using compile-time #IF).

	04/24/06 - Frans S.C. Witte - CRs: 22060 / 22061
		Initial version.
	*/
	#PACKAGE framework.psl
	#OPTION  ResultClass ON

	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	/* ****************************************************************** */
	/* public and package runtime functions                               */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
public String rtChset()	// Return current character set at runtime
	/* ---------------------------------------------------------------------
	This function returns the runtime value of the current character set.
	This is slightly different from Runtime.charsetName, because that value
	will be evaluated at compile time, and end up as either the literal "M",
	or the svn $ZCHSET.

	NOTES:
	. This function is primarily intended for use by the compiler itself
		during bootstrap processing: The M routine that will be part
		of the distribution must access the Character Set name in the
		target environment. So it cannot use Runtime.charsetName, as
		that references the Character Set in the source environment.
	. The runtime reference for the character set name calls the native
		module vRuntime, which makes this method target language
		insensitive.
	*/
	quit:'PSL.getSetting( "boot", "charsetlevel").isNull() PSL.getSetting( "boot", "charsetlevel")
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	quit:'$$gtmLevel^UCGM(5.2) "M"
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	quit $$charsetName^vRuntime

	/* ****************************************************************** */
	/* ByteString method implementations                                  */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
void ascii	// Method: ByteString.ascii(Number position)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.ascii()
	*/
	type public PSLParser pslPrsr

	type PSLClass dummy = pslPrsr.getPSLClass( "String")

	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do psl2m^UCPRIM(0,1)	// ... so generate $ascii()
	}
	else  do psl2m(0,1)		// Generate code that supports Unicode
	quit

	// ---------------------------------------------------------------------
void extract	// method: String.extract(Number start,Number end)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.extract()
	*/
	type public PSLParser pslPrsr

	type PSLClass dummy = pslPrsr.getPSLClass( "String")

	/* If GT.M version does not support Unicode
	   */
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do extract^UCSTRING
	}
	else  do {	// Generate code that supports Unicode
		if PSL.actual(1).isNull() set PSL.actual(1) = 1			// Default to position 1
		if PSL.actual(2).isNull() set PSL.actual(2) = PSL.actual(1)	// Default to 1st parameter
		
		// Optimize this syntax by replacing with the maximum string length
		else  if PSL.actual(2)=("$ZLENGTH("_PSL.objectName_")") set PSL.actual(2) = PSL.maxStringLength
	
		if PSL.actual(1)=PSL.actual(2) set PSL.return="$ZEXTRACT("_ PSL.objectName_ ","_ PSL.actual(1)_")"
		else  set PSL.return="$ZEXTRACT("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"	
	
		if PSL.objectName.isLiteral() set PSL.return = $$toLit^UCSTRING( PSL.return)
	}
	quit

	// ---------------------------------------------------------------------
void find	// Method: ByteString.find(ByteString string,Number start)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.find()
	*/
	type public PSLParser pslPrsr

	type PSLClass dummy = pslPrsr.getPSLClass( "String")

	/* If GT.M version does not support Unicode
	   */
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		set PSL.actual(3) = "", PSL.actual(4) = ""
		do find^UCSTRING
	}
	else  do psl2m(1,2) 		// Generate code that supports Unicode
	quit

	// ---------------------------------------------------------------------
void justify	// Method: ByteString.justify(Number fieldLength)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.justify()
	*/
	type public PSLParser pslPrsr

	type PSLClass dummy = pslPrsr.getPSLClass( "String")

	/* If GT.M version does not support Unicode
	   */
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		set PSL.actual(2) = "", PSL.actual(3) = "", PSL.actual(4) = ""
		do justify^UCSTRING
	}
	else  do {	// Generate code that supports Unicode
		if PSL.actual(1).isNull(1) set PSL.return = PSL.objectName quit

		do psl2m(1,1)
	}
	quit

	// ---------------------------------------------------------------------
void length	// Method: String.length(String delimiter)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.length()
	*/
	type public PSLParser pslPrsr

	type PSLClass dummy = pslPrsr.getPSLClass( "String")

	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do length^UCSTRING
	}
	else  do {	// Generate code that supports Unicode
		type String char = PSL.actual(1)

		if char.isNull() do {

			set PSL.return="$ZLENGTH("_ PSL.objectName_")"
		}

		else  set PSL.return = "$ZLENGTH("_ PSL.objectName_","_char_")"

		if PSL.objectName.isLiteral() set PSL.return = $$toLit^UCSTRING( PSL.return)
	}
	quit

	// ---------------------------------------------------------------------
void piece	// method: ByteString.piece(ByteString delimiter,Number start,Number end)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.piece()
	*/
	type public PSLParser pslPrsr

	type PSLClass dummy = pslPrsr.getPSLClass( "String")

	/* If GT.M version does not support Unicode
	   */
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		set PSL.actual(4)=""
		do piece^UCSTRING
	}
	else  do psl2m(1,3)	// Generate code that supports Unicode
	quit

	// ---------------------------------------------------------------------
void toPSLExpr	// Method: ByteString.toPSLExpression()
	/* ---------------------------------------------------------------------
	Generate code for ByteString.toPSLExpression()

	NOTES:
	. The subroutine that is constructed for the runtime implementation of
		this method assumes that it can create a single $CHAR(,,,) (or
		$ZCHAR(,,,)) that represents all the characters/bytes in the
		string in case the value contains non-graphics.
		This may be a problem with long strings, especially if they
		contain a significant number of non-ascii characters.
		Furthermore, since the returned value is likely to be used in
		code, the maximum is presumably determined by PSL.maxLineLength
		rather than by PSL.maxStringLength.
	. A more complex algorithm should be able to produce a result that is
		close to the GT.M ZWRITE format (only non-graphics in $ZCHAR()).
	*/
	type literal String label   = "vBtsPslE"

	if 'PSL.subrouExists(label) do {
		type PSLBuffer buf = PSL.openBuffer("(ByteString vVal)","ByteString.toPSLExpression")

		do buf.add("type Boolean bValid = false")
		do buf.add("do {")
		do buf.add("    catch vEx { // catch and ignore %GTM-E-BADCHAR exception")
		do buf.add("    }")
		do buf.add("    set bValid = ({String}vVal)?.ANP")
		do buf.add("}")

		do buf.add("if bValid,({String}vVal).isNumber() quit vVal")
		do buf.add("if bValid quit ({String}vVal).addQuotes()")
		do buf.add("type Number vC")
		
		/* If the character set is M, there is no choice between $C()
		   and $ZCH(), but if the characterset is UTF-8, we can return
		   code that uses $C() if the supplied value contains only ASCII
		   characters.
		   */
		if $$rtChset() = "M" {
			do buf.add("type String vE = ""$C(""_ vVal.ascii()")
		}
		else  do {
			do buf.add("type String vE")
			do buf.add("if vVal.translate($C(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,12,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127))?.ANP set vE = ""$C(""_ vVal.ascii()")
			do buf.add("else set vE = ""$ZCH(""_ vVal.ascii()")
		}
		do buf.add("for vC=2:1:vVal.length() set vE=vE_"",""_vVal.ascii(vC)")
		do buf.add("quit vE_"")""")

		do buf.insert(label, "PSLExpression")
	}

	set PSL.return = "$$"_ label_ "("_ PSL.objectName_ ")"
	quit

	// ---------------------------------------------------------------------
void translate	// Method: ByteString.translate(ByteString expr1,ByteString expr2)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.translate()
	*/
	type public PSLParser pslPrsr

	type PSLClass dummy = pslPrsr.getPSLClass( "String")

	/* If GT.M version does not support Unicode
	   */
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do psl2m^UCPRIM(1,2)	// will generate $TRANSLATE()
	}
	else  do psl2m(1,2)	// Generate code that supports Unicode
	quit

	/* ****************************************************************** */
	/* Number method implementations                                      */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
void byte	// Method: Number.byte()
	/* ---------------------------------------------------------------------
	Generate code for Number.byte()
	*/
	type public PSLParser pslPrsr

	type PSLClass dummy = pslPrsr.getPSLClass( "Number")

	set PSL.method = "char"

	/* GT.M version does not support Unicode
	   */
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do psl2m^UCPRIM(0,0)	// will generate $char()
	}
	else  do psl2m(0,0)	// Generate code that supports Unicode
	quit

	/* ****************************************************************** */
	/* Runtime property implementations                                   */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
void chrsetEnc	// Property: Runtime.charsetEncoding
	/* ---------------------------------------------------------------------
	Generate code for Runtime.charsetEncoding.

	If Runtime.charsetName = "UTF-8", then "UTF-8",
	else if the call to $$ENCODING^%CHARSET succeeds, then whatever that
	returns, else guess from:
	- "ISO-8859-15" (if code point 168 is lowercase),
	- "ISO-8859-2" (if code point 177 is lowercase),
	- "DEC-MULTINATIONAL" (if code point 247 is lowercase),
	- "ISO-8859-1" (all others).
	*/
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do {
			catch vEx {
				// no $$ENCODING^%CHARSET, try to guess one from
				// ISO-8859-1, ISO-8859-2, ISO-8859-15 and
				// DEC-MULTINATIONAL
				#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
				type String lc = $$LC^%CHARSET()
				if lc[168.char()       set PSL.return = "ISO-8859-15"
				else  if lc[177.char() set PSL.return = "ISO-8859-2"
				else  if lc[247.char() set PSL.return = "DEC-MULTINATIONAL"
				else  set PSL.return = "ISO-8859-1"
			}
			#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
			set PSL.return = $$ENCODING^%CHARSET()
		}
	}
	else  set PSL.return = $$rtChset()	// Return whatever is the runtime set
	set PSL.return = PSL.return.addQuotes()
	quit

	// ---------------------------------------------------------------------
void chrsetNm	// Property: Runtime.charsetName
	/* ---------------------------------------------------------------------
	Generate code for Runtime.charsetName.

	If the implementation supports $ZCHSET, return "$ZCHSET", else return
	the literal "M".
	*/
	if PSL.getSetting( "boot", "restrictionlevel")<0 set PSL.return = "$$charsetName^vRuntime"
	#ACCEPT GROUP=ACCESS;CR=27800;DATE=2008-02-27;PGM=Frans S.C. Witte
	else  if $$gtmLevel^UCGM(5.2) set PSL.return = "$ZCHSET"
	else  set PSL.return = "M".addQuotes()
	quit

	/* ****************************************************************** */
	/* String method implementations                                      */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
void bytLimSub	// Method: String.byteLimitSubstring ( start, maxBytes)
	/* ---------------------------------------------------------------------
	Generates $ZSUBSTR() for GT.M versions that support Unicode,
	or $$vStrBLS() for others.

	NOTES:
	. This function has a different code pattern than most of the other
		functions. This stems from the fact that the signatures for
		the unicode and non-unicode runtime functions are identical
		and differ only in function name. So the code that deals with
		generating the value of PSL.return will be common.
	. The code that returns a compile-time literal value when the object
		and all supplied parameters are literal has been disabled.
		This is due to the fact that $$toLit^UCSTRING() cannot be called
		if $$rtChset()="M", and any code generated inside UCBYTSTR will
		be based on the value of Runtime.charset at the SOURCE, not at
		the TARGET.
	*/
	type String ZSUBSTR = $select($$rtChset()="M":$$mSubstr(),1:"$ZSUBSTR(")

	// Generate code for all variations
	type String start = PSL.actual(1)
	type String maxBt = PSL.actual(2)
	type Boolean isLit = 0

	if maxBt.isNull() do {
		//if PSL.objectName.isLiteral(),start.isLiteral() set PSL.return = PSL.objectName.byteLimitSubstring( start.stripQuotes()).addQuotes() quit
		set PSL.return = ZSUBSTR_ PSL.objectName_ ","_ start_ ")"
	}
	else  do {
		//if PSL.objectName.isLiteral(),start.isLiteral(),maxBt.isLiteral() set PSL.return = PSL.objectName.byteLimitSubstring( start.stripQuotes(), maxBt.stripQuotes()).addQuotes() quit
		set PSL.return = ZSUBSTR_ PSL.objectName_ ","_ start_ ","_ maxBt_ ")"
	}
	quit

	// ---------------------------------------------------------------------
void loCase	// Method: String.lowerCase(Boolean capitalizeFirstChar)
	/* ---------------------------------------------------------------------
	Generates $ZCONVERT() for UTF-8, or calls loCase^UCTRING to generate the
	traditional lowercase conversion.

	NOTES:
	. Even though the Unicode GT.M version supports $ZCONVERT() for
		$ZCHSET="M", this subroutine still calls loCase^UCSTRING to
		generate the code, because $ZCONVERT() will only handle 7-bit
		standard ASCII, and the target site may use 8-bit characters.
	*/

	/* If preparing boot version of routine, insert ASCII only conversion
	*/
	type literal String UC = ",""ABCDEFGHIJKLMNOPQRSTUVWXYZ"""
	type literal String LC = ",""abcdefghijklmnopqrstuvwxyz"""

	if PSL.hasSetting( "boot", "charsetlevel"), PSL.getSetting( "boot", "charsetlevel") = "" do {
		set PSL.return = "$TR("_ PSL.objectName_ UC_ LC_ ")"
	}
	/* GT.M version does not support Unicode
	   */
	else  if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do loCase^UCSTRING
	}
	else  do {	// Generate code that supports Unicode
		type String option = PSL.actual(1)
		if option.isNull(1) set option=0	// Default to 0

		if option.isLiteral() set PSL.return = "$ZCONVERT("_ PSL.objectName_ ","_ $select(option:"T",1:"L").addQuotes()_ ")"
		else  set PSL.return = "$ZCONVERT("_ PSL.objectName_ ",$S("_ option_ ":""T"",1:""L""))"
		if PSL.objectName.isLiteral() set PSL.return = $$toLit^UCSTRING( PSL.return)

	}
	quit

	// ---------------------------------------------------------------------
void toByteString	// Method: String.toByteString
	/* ---------------------------------------------------------------------
	This is a no-op method for all implementations.
	The advantage of having is String.toByteString() in addition to type
	casting is that is tends to make the code more readable.
	*/
	set PSL.return = PSL.objectName
	quit

	// ---------------------------------------------------------------------
void upCase // Method: String.upCase	 Returns an upper case string
	/* ---------------------------------------------------------------------
	Generates $ZCONVERT() for UTF-8, or calls upCase^UCTRING to generate the
	traditional uppercase conversion.

	NOTES:
	. Even though the Unicode GT.M version supports $ZCONVERT() for
		$ZCHSET="M", this subroutine still calls upCase^UCSTRING to
		generate the code, because $ZCONVERT() will only handle 7-bit
		standard ASCII, and the target site may use 8-bit characters.
	*/

	/* If preparing boot version of routine, insert ASCII only conversion
	*/
	type literal String UC = ",""ABCDEFGHIJKLMNOPQRSTUVWXYZ"""
	type literal String LC = ",""abcdefghijklmnopqrstuvwxyz"""

	if PSL.hasSetting( "boot", "charsetlevel"), PSL.getSetting( "boot", "charsetlevel") = "" do {
		set PSL.return = "$TR("_ PSL.objectName_ LC_ UC_ ")"
	}
	/* GT.M version does not support Unicode
	   */
	else  if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do upCase^UCSTRING
	}
	else  do {	// Generate code that supports Unicode
		set PSL.return = "$ZCONVERT("_ PSL.objectName_ ",""U"")"
		if PSL.objectName.isLiteral() set PSL.return = $$toLit^UCSTRING( PSL.return)
	}
	quit

	/* ****************************************************************** */
	/* local subroutines                                                  */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
String mSubstr()	// generate M code for String.byteLimitSubstring()
	/* ---------------------------------------------------------------------
	This subroutine generates the "M version" of $ZSUBSTR().
	*/
	type literal String label   = "vStrBLS"
	type literal String ZSUBSTR = "$$"_ label_ "("

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf = PSL.openBuffer("(String vVal, Number vStart, Number vMax)","String.byteLimitSubstring")

		do buf.add("if 'vMax.exists() quit vVal.extract( vStart, PSL.maxStringLength)")
		do buf.add("quit vVal.extract( vStart, vStart+vMax-1)")

		do buf.insert(label, "String")
	}
	quit ZSUBSTR

	// ---------------------------------------------------------------------
void psl2m(	Number minArg,	// minimum number of arguments	/REQ/MECH=VAL
	Number maxArg)	// maximum number of arguments	/REQ/MECH=VAL
	/* ---------------------------------------------------------------------
	Support procedure that calls mtd2m^UCPRIM() with common permutations:
	- mname = "Z"_ method.upperCase()
	- allowLit from pslPrsr.pslMtd( PSL.class_ "."_ PSL.method)

	NOTES:
	. The call to psl2m^UCPRIM() is OK, provided that we trick UCPRIM to
		believe that the current method = zmethod().
		Because psl2m^UCPRIM does look at pslPrsr(class,method), we must
		create that entry, but we do that for this call only, because we
		do not want to allow a ByteString.zmethod() method
	*/
	type public PSLParser pslPrsr
	type public PSLTokenizer tknzr

	type String mid = pslPrsr.findPSLMethod( tknzr, PSL.mclass_ "."_ PSL.method, 0)
	do mtd2m^UCPRIM( "Z"_ PSL.method.upperCase(), pslPrsr.pslMtd( mid).inLiteral, minArg, maxArg)
	quit
 #OPTION ResultClass ON
public String vSIG()	quit "61461^41407^Frans S.C. Witte^25473"	// Signature - LTD^TIME^USER^SIZE
