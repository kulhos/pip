DBARCHIVE	
		 
	/*
	Archive Driver and Functions
	
	This procedure manages archiving of data in tables that have been
	identified as archive enabled tables.  It also contains functions
	associated with archiving for use by SQL and PSL.
	
	Entry at the top will generate a UTLREAD screen to prompt for the
	table to be archived and the date through which to archive.  All
	records in the table that have lower key value (or related serial
	column value) less than or equal to the entered date will be
	archived and deleted from the primary database.
	*/
	
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.  The M routine from the     *
	// * crtns directory should be used for this purpose.                *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other during an upgrade,    *
	// * an mrtns version of this routine should not exist.              *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	
	/*                                               

	---- Revision History -------------------------------------------------
	01/20/2008 - RussellDS - CR30801
		* Eliminate reference to filer program.  This project requires
		  filers for all tables, with names following a convention.
		* Modified getArchiveTable to ignore archiving considerations
		  during bootstrap.
		* Modified getPSLTable methods to use level 0
	
	03/01/07 - RussellDS - CR26386
		   Created.

	-----------------------------------------------------------------------
	*/
	
	/*	
	DBARCHIVE relies on calls to DBARCHIVE2, which is generated by procedure
	DBARCHIVE1 (DBARCHIVE2 Builder).  DBARCHIVE2 contains the calls to
	the ARCHIVE section of filer programs for archived tables.
	   
	The following code ensures that post procedure DBARCHIVE1 has been compiled,
	and then calls it to build DBARCHIVE2.  This code is only executed when
	DBARCHIVE is compiled.
	*/
 
        // Compile procedure DBARCHIVE1 (DBARCHIVE2 Builder)
	#XECUTE do COMPILE^DBSPROC("DBARCHIVE1")
 
        // Generated DBARCHIVE2
        #XECUTE do ^DBARCHIVE1
        
        type public Boolean ER
        type public String RM
        
        type Number cnt, i, keycnt, reccnt
        type String %READ, %TAB(), ARCHTBL, keys, keyvals(), THRUDATE, VFMQ
        
        set %TAB("ARCHTBL") = ".ARCHTABLE/TBL=[DBUTARCHIVE]"
        set %TAB("THRUDATE") = ".ARCHDATE"
        
        set %READ = "@@%FN,,ARCHTBL,THRUDATE"
        
        do ^UTLREAD quit:(VFMQ = "Q")
        
        set RM = $$ARCHIVE(ARCHTBL, THRUDATE, "", "", "")
        
        if 'RM.isNull() set ER = 1
        
        quit
        
	
public ARCHIVE( String ARCHTBL,		// Table to be archived
		Date THRUDATE,		// Archive through date
		String SELECT,		// Top keys [*]
		String FROM,		// Select against [*]
		String WHERE)		// Where clause [*]
		
	/*
	Archive driver - this function selects primary records and calls
	ARCHIVE^DBARCHIVE2 to select and archive journal records.
	
	The SELECT, FROM, and WHERE clauses may be null (if any are null,
	all must be null).  In this case, all records from the table to be
	archived that are less than or equal to the archive through date will
	be archived.

	If not null, the SELECT clause must contain exactly the number of
	columns that make up the top keys (all but the bottom key) of the
	table to be archived, in order matching the archived table keys.
	The combination of these three clauses must make a valid SELECT to be
	used to determine the top level keys for which archiving should occur.

	For example, to archive HIST for deposit product type 405:

		SELECT = "CID"
		FROM = "DEP"
		WHERE = "TYPE=405"

	This allows other functions to be developed to provide the ability to
	archive selections from the table.  For example, history archiving is
	generally done by product type, not on the entire HIST table at once.

	No host variables are allowed in the WHERE clause.
	
	Note that if the SELECT does not begin with DISTINCT, it will be added.
	
	For archibe enabled tables where the first key is the archive key,
	SELECT/FROM/WHERE cannot be used, since all records from the top
	key level will be selected, based on THRUDATE.
	
	ARGUMENT NOTES:
		. SELECT, FROM, WHERE - see comments above
		
	RETURNS:
		. $$	Error message, if any, otherwise null
		
	*/
	
	type public String %INTRPT()
	
	type Boolean stop
	type Number archkey, ARCHNUM, archseq
	type String ARCHDIR, DBARCHIVE(), ERMSG, keys, keyvals()
	
	set stop = false
	
	// If any provided, all must be
	if '(SELECT_FROM_WHERE).isNull(), (SELECT.isNull() ! FROM.isNull() ! WHERE.isNull()) do { quit ERMSG
	
		// Invalid SELECT/FROM/WHERE set
		set ERMSG = $$^MSG(6903)
	}
	
        lock +DBARCHIVE(ARCHTBL):1 else  do { quit ERMSG
        	
        	// Only a single archive process, per table, can be run at a time
        	set ERMSG = $$^MSG(6902)
        }
        
        // Get archive information
        #ACCEPT Date=03/01/07; Pgm=RussellDS; CR=25675; Group=Bypass
	#BYPASS
	set ARCHNUM=$ZTRNLNM("SCAU_ARCHIVE_CURRENT")
	set ARCHDIR=$ZTRNLNM("SCAU_ARCHIVE_"_ARCHNUM)
	#ENDBYPASS
	
	if (ARCHDIR.isNull() ! (ARCHNUM '> 0)) do { quit ERMSG
		
		// Archive directory information missing
		set ERMSG = $$^MSG(6905)
	} 
        
	// Register M process
	do REGISTER^IPCMGR("ARCHIVE", ARCHTBL)
        
        // Select top-level keys and pass to ARCHIVE^filerPGM to archive
        
        type PSLTable tblDes = PSL.getPSLTable(ARCHTBL, 0)
        
        set keys = {String}(tblDes.primaryKeys)
        set archkey = tblDes.getArchiveKey()
        set keys = keys.piece(",", 1, archkey - 1)	// Ignore archive key
        
        // SELECT/FROM/WHERE not valid if archive key is first key
	if (archkey = 1), 'SELECT.isNull() do { quit ERMSG
	
		// Invalid SELECT/FROM/WHERE set
		set ERMSG = $$^MSG(6903)
	}
	
	type ResultSet rsarchist = Db.select("MAX(ARCHSEQ)", "DBARCHIST", "ARCHTBL=:ARCHTBL")
	
	if rsarchist.next() set archseq = rsarchist.getCol(1) + 1
	else  set archseq = 1
	
	type RecordDBARCHIST dbarchist = Class.new("RecordDBARCHIST", "ARCHTBL=:ARCHTBL,ARCHSEQ=:archseq")
	
	set dbarchist.begdat = %CurrentDate
	set dbarchist.begtim = %CurrentTime
	set dbarchist.primcnt = 0
	set dbarchist.reccnt = 0
	set dbarchist.stopped = 0
	set dbarchist.thrudate = THRUDATE
	set dbarchist.sel = SELECT
	set dbarchist.frm = FROM
	set dbarchist.whr = WHERE
	
	do dbarchist.save()
	
	/* If archiving is done on the first key, there is no "pre-selection"
	   of primary table records.  All control happens in ARCHIVE^filerPGM
	   to select the top level key based on the THRUDATE.  In this case,
	   the count of primary records is the same as detail records.
	*/
	if (archkey = 1) do {
		
		type Number reccnt
		
		set reccnt = $$^DBARCHIVE2(ARCHDIR, ARCHNUM, THRUDATE, ARCHTBL, .keyvals())
		
		set dbarchist.primcnt = reccnt
		set dbarchist.reccnt = reccnt
		
		do dbarchist.save()
		
		// If was interrupted, indicate that here
		if '%INTRPT.get().isNull() do {
		
			if %INTRPT = "STOP" set stop = true
			
			// Clear Interrupt indicator
			set %INTRPT = ""
		}
	}
	else  do {
		
		type Number i, primcnt, reccnt
		type String ORDERBY
		
		// If no SELECT/FROM/WHERE, just select top keys from archive table
		if SELECT.isNull() do {
			
			set SELECT = keys
			set FROM = ARCHTBL
		}
		
		// Add DISTINCT to SELECT if it's not there
		if 'SELECT.upperCase().beginsWith("DISTINCT") set SELECT = "DISTINCT "_SELECT
		
		// Strip DISTINCT for order by
		set ORDERBY = SELECT.piece(" ", 2, SELECT.length())
        
        	#ACCEPT Date=03/12/07; Pgm=RussellDS; CR=25675; Group=Dynamic
        	type ResultSet rs = Db.select(SELECT, FROM, WHERE, ORDERBY)
        
        	set (primcnt, reccnt) = 0
        	while rs.next() do { quit:stop
        	
        		for i = 1:1:archkey - 1 set keyvals(i) = rs.getCol(i)
        	
        		set reccnt = reccnt + $$^DBARCHIVE2(ARCHDIR, ARCHNUM, THRUDATE, ARCHTBL, .keyvals())
        		set primcnt = primcnt + 1
        		
        		if (primcnt # 10000 = 0) do {
        			
				set dbarchist.primcnt = primcnt
				set dbarchist.reccnt = reccnt
		
				do dbarchist.save()
        		}
        		
        		// Check Interrupt status for stop
			if %INTRPT.data() > 1 do INTRPT^IPCMGR
			if '%INTRPT.get().isNull() do {
		
				if %INTRPT = "STOP" set stop = true
			
				// Clear Interrupt indicator
				set %INTRPT = ""
			}
        	}
        	
        	// Update final numbers
        	set dbarchist.primcnt = primcnt
		set dbarchist.reccnt = reccnt
		
		do dbarchist.save()
        }
        	
	set dbarchist.enddat = %CurrentDate
	set dbarchist.endtim = %CurrentTime
	
	if stop set dbarchist.stopped = 1
	
	do dbarchist.save()

        lock -DBARCHIVE(ARCHTBL)
        
        // Unregister M Process
	do CLOSE^IPCMGR()
        
	quit ""


public STOP	// Allow stop of running archive process

	// Called by function DBARCHSTOP
	
	type public String ER
        type public String RM
        
        type String %READ, %TAB(), ARCHSTOP, LOOKUP(), VFMQ
        
        type ResultSet rs = Db.select("PID,SUBTYP", "PROCESSID", "PRCTYP='ARCHIVE'")
        
        if rs.isEmpty() do { quit
        	
        	set ER = 1
        	// No archiving processes are currently running
        	set RM = $$^MSG(6904)
        }
        
        while rs.next() set LOOKUP(rs.getCol("SUBTYP")) = rs.getCol("PID")
        
        set %TAB("ARCHSTOP") = ".ARCHSTOP/TBL=LOOKUP("
        
        set %READ = "@@%FN,,ARCHSTOP"
        
        do ^UTLREAD quit:(VFMQ = "Q")
        
        // Signal Interrupt to STOP
	do SIGNAL^IPCMGR(LOOKUP(ARCHSTOP), "STOP")
        
	set ER = "W"
	// Signal sent. May take up to ~p1 seconds for process to stop.
	set RM = $$^MSG(5533, "10+")
        
        quit	
	
	
private getArchiveTable( PSLTable tblDes)	// table descriptor
	/* ---------------------------------------------------------------------
	This function provides the run-time code for the PSLTable.getArchiveTable()
	method.  A table can be archived in four ways:
	
	  - as a primary archive table, with an entry in DBUTARCHIVE.ARCHTBL
	  - as a sub-table of a primary archive table (a sub-table uses the same
	    global and has at least as many keys, and any literal keys in the
	    first keys (number of keys in tblDes table) must match value and
	    position.
	  - as a table listed to be included with the primary table, i.e., is
	    in DBUTARCHIVE.INCLUDED
	  - as a sub-table of a table listed to be included with the primary table
	    
	For primary tables, the primary table name is returned.  For all others,
	the related primary table name is returned, since it is this table's
	filer than manages archiving and archive access.
	
	Returns null if the table is not archive enabled or is not a sub-table,
	related table, or sub-table of a related table.
		
	RETURNS:
	. $$ = String - table name of primary archive table (this table, or, if
	       this table is a sub-table, included table, or sub-table of an
	       included table, the primary table name)
	     = null otherwise
	*/
	
	/* restrictionlevel = -1 indicates that we're building an M copy
	   of this procedure for distribution for bootstrap and upgrades.
	   In that case, we ignore archive handling during the initial phase,
	   until this procedure is recompiled on-site. */
	
	#IF (PSL.getSetting("boot","restrictionlevel") = -1)
	quit ""		// Ignore archive building when building the compiler
	#ELSE
	type String ArchTbl, TBL
	
	set TBL = tblDes.table
	
	if Db.isDefined("DBUTARCHIVE", "ARCHTBL=:TBL") quit TBL
	
	// Check each archive enabled table to see if this is a sub-table of it
	// or is included with it, or is a sub-table of an included table
	type DbSet ds = Db.selectDbSet("DBUTARCHIVE")
	
	set ArchTbl = ""
	while ds.next() do { quit:'ArchTbl.isNull()
		
		type RecordDBUTARCHIVE dbutarchive = ds.getRecord("DBUTARCHIVE")
		
		type PSLTable archDes = PSL.getPSLTable(dbutarchive.archtbl, 0)
		
		// Sub-table
		if ({List}$$getArchiveSubs(archDes)).contains(TBL) set ArchTbl = dbutarchive.archtbl
		else  do {
			
			type List included
			
			set included = {List}(dbutarchive.included)
			
			// Related table
			if included.contains(TBL) set ArchTbl = dbutarchive.archtbl
			else  do {
				
				type Number i
				type String incltbl
				
				for i = 1:1:included.count() do { quit:'ArchTbl.isNull()
					
					set incltbl = included.elementAt(i)
					
					type PSLTable inclDes = PSL.getPSLTable(incltbl, 0)
					
					// Sub-table of related table
					if ({List}$$getArchiveSubs(inclDes)).contains(TBL) set ArchTbl = dbutarchive.archtbl
				}
			}
		}
	}
	
	quit ArchTbl
	#ENDIF
	
	
private getArchivable( PSLTable tblDes)	// Table descriptor of table to check

	/*
	This funtion provides the run-time code for the PSLTable.getArchivable()
	method.  A table is archivable if it is a journal table, i.e., it must
	have a date key as the bottom key, or have a serial column
	(DBTBL1D.SRL = 1).  Archiving is date controlled, therefore, one of
	these conditions must exist.
	
	Additionally, even if a table otherwise qualifies, if it is a sub-table
	of another archivable table, it cannot be archived independently.
	
	This code does not check if the table has a filer, since that can be
	easily modified.  The code in ARCHTBLCHK does that check to support the
	trigger for DBUTARCHIVE.
	
	RETURNS:
	. $$ = Boolean - true if this table can be archived
	     = false if not
	*/
	
	type Boolean isArchivable
	type String ARCHTBL, global
	
	set ARCHTBL = tblDes.table
	
	if ($$getArchiveKey(tblDes, false) = 0) quit false
	
	// Archivable table cannot have a query (DBTBL1.QID1) associated with it
	if 'tblDes.getQuery().isNull() quit false
	
	// Archivable table cannot be a parent table
	if tblDes.isParent() quit false
	
	set isArchivable = true
	
	// Check to see if a sub-table of another archivable table
	set global = tblDes.global.piece("(", 1).replace("^")
		
	type ResultSet rs = Db.select("FID", "DBTBL1", "%LIBS='SYSDEV' AND FID<>:ARCHTBL AND GLOBAL=:global")
	
	while rs.next() do { quit:'isArchivable
		
		type String FID
		
		set FID = rs.getCol("FID")
		
		type PSLTable fidDes = PSL.getPSLTable(rs.getCol("FID"), 0)
		
		if ({List}$$getArchiveSubs(fidDes)).contains(ARCHTBL), $$getArchivable(fidDes) set isArchivable = false
	}
	
	quit isArchivable
	
	
private getArchiveIncluded( PSLTable tblDes)	// Table descriptor of table to check

	/*
	This funtion provides the run-time code for the PSLTable.getArchiveIncluded()
	method.  This returns all the tables that are listed in DBUTARCHIVE.INCLUDED
	to be included with it.
	
	If this table is not in DBUTARCHIVE, return null.
	
	RETURNS:
	. $$ = List - list of table that will be included with this when archived.
	       May be null.
	*/
	
	type String X
	
	type RecordDBUTARCHIVE dbutarchive = Db.getRecord("DBUTARCHIVE", "ARCHTBL=:tblDes.table", 1)
	
	set X = dbutarchive.included
	
	quit X
	
	
private getArchiveKey( PSLTable tblDes,	// Table descriptor of table to check
		    Boolean forArch)	// Get archive key for archive table

	/*
	This funtion provides the run-time code for the PSLTable.getArchiveKey()
	method.  This returns the number of the archive key, based on the primary
	key list, PSLTable.primaryKeys.
	
	If forArch = true, then see if the table pointed to by tblDes has an
	archive table, i.e., tblDes is a subtable or included with table, in which
	case, return archive key for the archive table.
	
	Otherwise, return archive key for tblDes table, regardless of whether or
	not archived.
	
	An archive key is either the first key (from the primary key list) that
	is a date datatype, or, if there is not a date key, if there is a serial
	value column in the table (DBTBL1D.SRL = 1), the archive key is the
	bottom key of the table.
	
	If there is no archive key, it will return 0.
	
	A table may have an archive key but not be archivable, e.g., if it is
	a sub-table of an archivable table.
	
	RETURNS:
	. $$ = Number - archive key for the table
	       0 if there is no archive key
	*/
	
	type List primkeys
	type Number archkey, i
	type String key, table
	
	set archkey = 0
	
	set table = tblDes.table
	
	if (forArch = false) set primkeys = tblDes.primaryKeys
	else  do {
		
		set table = $$getArchiveTable(tblDes)
		
		if 'table.isNull() do {
		
			type PSLTable td = PSL.getPSLTable(table, 0)
			
			set primkeys = td.primaryKeys
		}
	}

	if table.isNull() quit 0

	for i = 1:1:primkeys.count() do { quit:(archkey > 0)
		
		set key = primkeys.elementAt(i)
	
		type SchemaColumn colrec = Db.getSchemaColumn(table, key)
	
		if (colrec.dataType = "D") set archkey = i
	}
	
	// No date key, look for serial
	if (archkey = 0) {
	
		type ResultSet rs = Db.select("DI", "DBTBL1D", "%LIBS='SYSDEV' AND FID=:table AND SRL=1")
		
		if rs.next() set archkey = primkeys.count()	// Use bottom key
	}
	
	quit archkey
	
	
private getArchiveSubs( PSLTable tblDes)	// Table descriptor of table to check

	/*
	This funtion provides the run-time code for the PSLTable.getArchiveSubs()
	method.  It returns a list of sub-tables of the table passed in the
	descriptor.  If there are no sub-tables, it returns null.  It does not
	matter if the table defined by tblDes is archive enabled.  This method
	simply determines what sub-tables it has that would be archived with it.
	
	A sub-table of TBL uses the same global and more keys than TBL, and any
	literal keys in the first keys (number of keys in TBL) must match value
	and position.
	
	If the table has no archive key, there are no sub-tables.
	
	RETURNS:
	. $$ = List - list of sub-tables, based on archiving definition, that
	       would be archived with this.  May be null
	*/
	
	type List ArchSubs, tblkeys
	type String TBL
	
	if ($$getArchiveKey(tblDes, false) = false) quit ""
	
	set ArchSubs = ""
	
	set TBL = tblDes.table
	
	type RecordDBTBL1 tbldbtbl1 = Db.getRecord("DBTBL1", "%LIBS='SYSDEV',FID=:TBL")
	
	set tblkeys = {List}(tbldbtbl1.acckeys)
	
	type ResultSet rs = Db.select("FID", "DBTBL1", "%LIBS='SYSDEV' AND GLOBAL=:tbldbtbl1.global AND FID<>:TBL")	

	while rs.next() do {
		
		type Boolean isSubTbl
		type List psubkeys
		type Number i
		type String PSUBTBL
		
		set PSUBTBL = rs.getCol("FID")
		
		type RecordDBTBL1 psubdbtbl1 = Db.getRecord("DBTBL1", "%LIBS='SYSDEV',FID=:PSUBTBL")
	
		set psubkeys = {List}(psubdbtbl1.acckeys)
		
		if (psubkeys.count() > tblkeys.count()) do {
	
			// Check any literal keys
			set isSubTbl = true
			for i = 1:1:tblkeys.count() do { quit:'isSubTbl
		
				type String P, T
		
				set P = psubkeys.elementAt(i)
				set T = tblkeys.elementAt(i)
		
				if (T.isLiteral() ! P.isLiteral()), (T '= P) set isSubTbl = false
			}
			
			if isSubTbl set ArchSubs = ArchSubs.add(PSUBTBL, ",", 1)
		}
	}
	
	quit ArchSubs
	
	
private ARCHTBLCHK( String ARCHTBL)	// Archive Table Name

	/*
	Check that this table is valid for archiving.
	
	This function is called by the DBUTARCHIVE-BEFORE_INSERT trigger as well
	as the screen post-processor for DBUTARCHIVE.ARCHTBL.
	
	RETURNS:
		$$	Error message, if any, otherwise null
	*/
	
	type public String %DB
	
	type List primkeys
	type String ERRMSG, tmkey, global
	
	set ERRMSG = ""
	
	/* Validate that the environment is using a GT.M database.  Archiving
	   is only available for GT.M.
	*/
	
	// Only valid with a GT.M database
	if '(%DB.isNull() ! (%DB = "GTM")) quit $$^MSG(6900)

	/* Validate that a table being added is able to be archived.  Only journal
	   tables, i.e., tables that have a date key, or have a serial column
	   (DBTBL1D.SRL = true), are valid.  Archiving is date controlled,
	   therefore, one of these conditions must exist.
	*/
	
	type PSLTable tblDes = PSL.getPSLTable(ARCHTBL, 0)
	
	/* Archivable table cannot have a query (DBTBL1.QID1) associated with it
	   Note that this check and the next are here, even though also in the
	   getArchivable code in order to return the specific message.
	*/
	if 'tblDes.getQuery().isNull() quit $$^MSG(6892)
	
	// Archivable table cannot be a parent table
	if tblDes.isParent() quit $$^MSG(6893)
	
	/* Archivable tables must have bottom date key or a serial column and 
	   cannot be a sub-table of another archivable table 
	*/
	if '$$getArchivable(tblDes) quit $$^MSG(6891)
	
	quit ERRMSG
	
	
private INCLUDEDCHK( String ARCHTBL,	// Archive table name
		     List INCLUDED)	// List of included with tables
	
	/*
	Check that all tables in INCLUDED list are valid related tables.
	
	This function is called by the DBUTARCHIVE-BEFORE_INSERT trigger as well
	as the screen post-processor for DBUTARCHIVE.INCLUDED.
	
	RETURNS:
		$$	Error message, if any, otherwise null
	*/
	
	/* Validate that for any table name entered in the Include With column it
	   is a related table, i.e., that it uses a different global, the key
	   structure of both tables match exactly (datatype and length) through
	   the archive key, and it doesn't appear in DBUTARCHIVE as either a
	   primary or included table for any other entries.
	*/
	
	type Boolean ERR
	type List archkeys
	type Number i
	type String archkey, ERRMSG
	
	set ERR = 0
	set ERRMSG = ""
	
	type PSLTable archDes = PSL.getPSLTable(ARCHTBL, 0)
	
	set archkey = $$getArchiveKey(archDes, false)
	set archkeys = {List}(archDes.primaryKeys)
	
	for i = 1:1:INCLUDED.count() do { quit:'ERRMSG.isNull()
		
		type List inclkeys
		type String TBL
		
		set TBL = INCLUDED.elementAt(i)
		
		type PSLTable inclDes = PSL.getPSLTable(TBL, 0)
		
		// Archive Table and Included Table must use different globals
		if archDes.global.piece("(", 1) = inclDes.global.piece("(", 1) set ERRMSG = $$^MSG(6895) quit
			
		set inclkeys = inclDes.primaryKeys
		
		if (inclkeys.count() < archkey) set ERR = 1
		else  for i = 1:1:archkey do { quit:ERR
					
			type SchemaColumn colarch = Db.getSchemaColumn(ARCHTBL, archkeys.elementAt(i))
			type SchemaColumn colincl = Db.getSchemaColumn(TBL, inclkeys.elementAt(i))
					
			if (colarch.dataType '= colincl.dataType) set ERR = 1
			else  if (colarch.length '= colincl.length) set ERR = 1
		}
				
		// Number, type, and length of keys for ~p1 and ~p2 must match
		if ERR set ERRMSG = $$^MSG(6896, TBL, ARCHTBL) quit
	
		type DbSet ds = Db.selectDbSet("DBUTARCHIVE", "ARCHTBL<>:ARCHTBL")
		
		while ds.next() do { quit:ERR
			
			type RecordDBUTARCHIVE dbutarchive = ds.getRecord("DBUTARCHIVE")
			
			if (TBL = dbutarchive.archtbl) do {
				
				set ERR = 1
				// Included table ~p already entered as ARCHTBL in DBUTARCHIVE
				set ERRMSG = $$^MSG(6897, TBL)
			}
			else  if ({List}(dbutarchive.included)).contains(TBL) do {
				
				set ERR = 1
				// Included table ~p already set as included for ~p2
				set ERRMSG = $$^MSG(6898, TBL, dbutarchive.archtbl)
			}
		}
	}

	quit ERRMSG
 #OPTION ResultClass ON
public String vSIG()	quit "61254^68475^Dan Russell^22653"	// Signature - LTD^TIME^USER^SIZE
