//DO NOT MODIFY  Psl compiler - compiler upgrades|UCGMCU|||||||1
public UCGMCU( Boolean file)	//
	/*
	ORIG: Frans S.C. Witte - 2005-04-07
	DESC: PSL compiler, Insensitive Group - compiler upgrade utilities

	*************************************************************************
	* IMPORTANT NOTE:							*
	*	Framework upgrades, and the Framework bootstrap process	require	*
	*	special precautions. Please read the associated (CR) documents,	*
	*	and adhere to the rules and guidelines that are specified in	*
	*	the documents listed below.					*
	*************************************************************************

	---- Relevant Documents ------------------------------------------------
	* FrameworkUpgradeRules.doc
		https://teams.fnfis.com/sites/ProfileFramework/Shared%20Documents/FrameworkUpgradeRules.doc
		This document provides the current rules and guidelines that
		apply to framework upgrades.
	* FrameworkUpgradeDocumentation.doc
		https://teams.fnfis.com/sites/ProfileFramework/Shared%20Documents/FrameworkUpgradeDocumentation.doc
		This document provides the backgrounds of the current rules and
		guidelines that apply to framework upgrades. It also documents
		the classification of all framework elements that are compiled
		phase 1.
	* CR15592CompilerUpgradesDesign.doc
		StarTeam://phlscm01/SSP/Project_Specific/Database Independence III/Requirements/CR15592CompilerUpgradesDesign.doc
		Outlines the original changes to support PSL compiler upgrades.

	---- Comments ----------------------------------------------------------

	This procedure will contain all functions and subroutines that support
	the PSL Compile Upgrade proces.

	Library
	^UCGMCU		Check which PSL compiler elements need to be re-compiled
			or re-compile all elements that need to be re-compiled.
	boot		Bootstrap PSL compiler installation
	bootCmp		Boot compile specified procedure using supplied compiler
			command options
	bootFiler	Compile filer for specified table using the same compiler
			command options that are in effect for the bootstrap of
			the PSL compiler itself.
	bootProc	Compile specified DQ procedure using the same compiler
			command options that are in effect for the bootstrap of
			the PSL compiler itself.
	bootUCOPTS	Generate new version of M routine UCOPTS.
	cascade		Cascade compiler change into dependent compiler procs.
	date		Convert a String to a Date, using features that are
			available during bootstrap phases.
	getCapabilities	Return the capabilities of this version of the compiler
			with respect to the requested capabilites section.
	getGroup	Return group that specified element belongs to
	getList		Return list of elements that belong to specified group
			Is complemented by $$getComList(), $$getDatList(),
			$$getDicList(), $$getInsList(), $$getObjList(), and
			$$getUpgList().
	isGroup		Does specified element belong to specified group
			Is complemented by $$isCompiler(), $$isData(),
			$$isDictionary(), $$isInsensitive(), $$isObject(), and
			$$isUpgrade().
	linkAll		ZLINK all PSL compiler units.
	prep		Prepare framework version for bootstrap in the specified
			target environment.
	prepProc	Prepare a single framework unit for bootstrap in the
			specified target environment.
	time		Convert a String to a time, using features that are
			available during bootstrap phases.

	As part of the PSL compiler bootstrap process, the routine UCOPTS will
	be generated. Generating UCOPTS instead of distribution UCOPTS as part
	of Profile is based on the following considerations:
	* The idea behind UCOPTS is to provide a mechanism to customize
		environment settings for the PSL compiler. However, if UCOPTS
		itself is distributed as part of a Profile release (e.g. as
		UCOPTS.proc), there are conflicting interests when a new version
		of UCOPTS is distributed. The new compiler release requires the
		new version of UCOPTS, which can only be effectuated by
		overwriting the environment specific settings in the target
		environment.
	* Specification of environment sensitive settings shall be separated
		from runtime behavior of the routine. To achieve this, these
		settings will be stored in the file UCOPTS.ini that shall reside
		in the application's "root" directory.
	* The compiler upgrade process will use the UCOPTS.ini file and its own
		knowledge of the current configurable settings to generate the
		UCOPTS routine that provides all functionality expected by the
		current version of the compiler.
	* "new" configurable settings that could also be specified in
		UCOPTS.ini shall take sensible defaults when not found.
	* Sufficient Profile-independent tools are available to support merging
		of the "new" and the "old" UCOPTS.ini if the target environment
		needs non-default settings.

	---- Revision History ------------------------------------------------
	04/10/07 - RussellDS - CR26503
		* Removed DBMAPDFT, which has been removed from the framework
		  view.  It is now incarnated as USTMAPDF in the application
		  views, but is no longer needed to be listed here.
	
	12/21/06 - Frans S.C. Witte - CRs: 24902 / 24903 / 24974
		* calls to getSrc^UCXDT25() now pass level=0 (do not include any
		  leaders).
		* Extension of source files modified from ".proc" to ".psl".
		* DBSDD moved from Data to Upgrade group.

	11/10/06 - Frans S.C. Witte - CRs: 22519 / 20613
		* Added DBMAPDFT (Insensitive), SQLUTL (Upgrade), removed
		  SQLAG, SQLC, SQLEXT, SQLFMT, SQLI, SQLOADER, SQLTESTF,
		  SQLTESTS, and SQLUTIL
		* Added support for commands("boot","charsetlevel")

	09/14/06 - Frans S.C. Witte - CRs: 22719 / 20613
		* Corrected PSL.maxCharValue for UTF-8.
		* Added %DBAPI, %ZM, and %ZOPEN to list of routines that are
		  ZLINKed by linkAll().

	08/30/06 - Frans S.C. Witte - CRs: 22720 / 22274
		* Removed UCTEST and SCAUTL from compiler list.
		* Added code to generate charsetName^UCUPTS() to obtain the
		  name of the character set at runtime (e.g. for M routines).
		* Added keyword 'void" to getCapabilites("KEYWORDS")

	08/08/06 - Pete Chenard - CR 22561 / 22563
		* Added SCAUTL to the Insensitive group since it now gets
		  called during compilation.
		  
	07/13/06 - Frans S.C. Witte - CRs: 22273 / 22274
		* Boot options array is now re-created for each call to "boot"
		  a single unit (in case units contain explicit #OPTION etc.).
		* Moved UCLABEL to Dictionary group (DBTBL33D is considered
		  equivalent to DBTBL25D).
		* Added UCIO0 (Insensitive)

	05/24/06 - Frans S.C. Witte - CRs: 22060 / 22061
		Added UCBYTSTR (Upgrade), UCPSLSR (Insensitive).
		Added prep(), prepCmp(), and prepProc().
		Removed afterDeploy().
		Added DBMAP, DBSDBASE, DBSDDMAP, DBSMACRO, and DBSTBL (all
		Insensitive), and DBSDD, and DBSDI (both Upgrade).
		Added $$getCapabilities() for interaction with Profile Workbench
		Modified getBootOptions().

	05/01/06 - Frans S.C. Witte - CRs: 21394 / 21395
		Added bootUCOPTS() (and call to it from boot()).
		Moved UCTIME from "Upgrade" to "Insensitive" (see UCTIME).
		info() now calls INFO^UCGM("PLSBOOT",msg).
		getBootOptions() now turns all INFO groups off as well.

	03/13/06 - Frans S.C. Witte - CRs: 20280 / 18164
		Added UCPSLLR (Insensitive).
		Added subroutine bootFiler().

	12/27/05 - Frans S.C. Witte - CRs: 18163 / 18164
		Added UCREC4OP (Insensitive), UCPSLST (Insensitive), and
		UCXOBJ (Object).
		getBootOptions() now turns object optimization off.
		boot() now ZLINKs phase 0 files that it needs.

	11/30/05 - Frans S.C. Witte - CRs: 18727 / 18727
		Added subroutine getBootData() to instantiate the RowSets and
		load them with data. Modified get BootOptions accordingly.
		bootProc will delete SCAU_MRTNS version after compile
		boot will recompile all DQ procedures that are not in the Data
		group as well.
		Split linkAll() in linkAll() and linkList().

	11/16/05 - Frans S.C. Witte - CRs: 18247 / 15593
		Added UCXCUVAR to Upgrade.
		Enabled use of vDataDir in boot().

	10/24/05 - Frans S.C. Witte - CRs: 17937 / 15593
		Added UCTIME to Upgrade. Moved UCDATE to Upgrade.

	06/15/05 - Frans S.C. Witte - CRs: 15592 / 15593
		Initial procedure, derived from UCDTAUTL.
		Function $$isCompiler() and subroutine linkAll copied from
		UCDTAUTL.
		Initial implementation of ^UCGMCU(), afterConst(),
		afterDeploy(), boot(), bootCmp(), cascade(), cascInfo(),
		getBootOptions(), getBootRws(), date(), time().
		$$getComList(), $$getDatList(), $$getDicList(), $$getGroup(),
		$$getInsList(),	$$getList(), $$getObjList(), $$getUpgList(),
		info(), $$isCompiler(), $$isData(), $$isDictionary(),
		$$isGroup(), $$isInsensitive(), $$isObject(), $$isUpgrade(),
		$$needCompile().
	*/
	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************

	/* ---------------------------------------------------------------------
	^UCGMCU( Boolean file)
	   ---------------------------------------------------------------------
	Check which PSL compiler elements need to be re-compiled (file = 0), or
	re-compile all PSL compiler elements need to be re-compiled (file = 1).
	The supplied parameter is passed to $$cascade().
	*/
	type literal String SUBROU = "^UCGMCU()"

	do info(SUBROU, "PSL Compiler Upgrade verfication", "start")

	type List units = $$getList("Compiler")
	set units = $$cascade(file, units)
	if units.isNull() do info(SUBROU, "No differences found", "end") quit

	type String src = "These PSL Compiler units "
	if file set src = src_ "have been"
	else  set src = src_ "need to be"
	write !!
	do info(SUBROU, units, src_" re-generated")
	write !!

	quit

	// ---------------------------------------------------------------------
public afterConst()	// To be called after PSL constant has been modified
	/* ---------------------------------------------------------------------
	Cascade modifications to PSL compiler units after a CUVAR constant that
	is used by the compiler or a PSL constant has been changed.

	The afterConst processing will cascade compile all PSL compiler units.

	PRECONDITIONS:
	- Because this subroutine calls the PSL compiler, $P must be writable.
	- The CRTNS directory shall contain the .PROC file of each unit that
	  needs to be validated.
	- Calls to cmpA2A^UCGM(.proc,.m) are valid (i.e. the PSL compiler can
	  be invoked with standard behavior, but without calls to UCLREGEN and
	  UCSYSMAP).

	POSTCONDITIONS:
	- All PSL compiler PROC elements will have been re-compiled if needed.
	- Information about the progress of the compilation process will have
	  been directed to $P (by calls to INFO^UCGM())
	- $I=$P
	*/
	type literal String SUBROU = "afterConst^UCGMCU()"

	do info(SUBROU, "PSL Compiler After Constant Changed Processing", "start")

	type List cascade = $$cascade(1, {List}$$getList("Compiler"))
	write !!
	if cascade.isNull() do info(SUBROU, "No differences found", "end") quit

	do info(SUBROU, cascade, "New versions of these PSL Compiler units have been generated")

	quit

	// ---------------------------------------------------------------------
public boot(	local String vDataDir,	// directory for .DAT files (*1)
		local String %VN)	// Profile Version Number (*2)
	/* ---------------------------------------------------------------------
	This subroutine will bootstrap the PSL compiler in an initial
	environment, or upgrade the PSL compiler in an existing environment.

	According to the rules of PSL Compiler Upgrades (CR15592), all PSL
	compiler element groups require compilation. For elements of the Data
	group this is obvious, but for other elements, the removal of the MRTNS
	version of the routine and the synchronisation of the CRTNS version with
	the MRTNS version can only be guaranteed if all elements are re-compiled
	independent of the M routines that occur in an upgrade.

	Subroutine boot handles the calls to bootCmp(,) in three steps
	1) UCOPTS is generated
		This is achieved by calling bootUCOPTS(), which in turn uses the
		UCOPTS.ini file for environment specific settings.
	2) All elements of the Data group are compiled
		For these elements bootCmp(,) will be called with the following
		compiler options:
		- #WARN XXX OFF for each option returned by $$allWARN^UCGMC()
		- #OPTIMIZE XXX OFF for all options returned by
			$$allOPTIMIZE^UCGMC() except #OPTIMIZE OBJECTS ON
		- ("Options","nolink") will be ON, all other
			("Options",) will be OFF
		- ("boot","restrictionlevel") = 2

	3) All other PROC elements of the compiler/engine/kernel are compiled
		For these elements bootProc() will be called with the following compiler options:
	- #WARN XXX OFF for each option returned by $$allWARN^UCGMC()
	- #OPTIMIZE XXX OFF for all options returned by $$allOPTIMIZE^UCGMC()
		except #OPTIMIZE OBJECTS ON
	- ("Options","nolink") will be ON, all other
		("Options",) will be OFF
	- ("boot","restrictionlevel") = 2

	ARGUMENTS:
	(*1) vDataDir = directory for .DAT files
		This value is required in an empty environment.
		It is also required for an upgrade that contains modifications
		to any of the PSL tables in the System group.
		If the data of the PSL tables in the System group can correctly
		be retrieved from the tables in the underlying data store, then
		the parameter can be omitted.
	(*2) %VN = Profile version number
		This value is required in an empty environment.
		In an existing environment, an absent parameter will default to
		CUVAR.%VN, which is assumed to be accessable.

	NOTES:
	* Compilation order
		The units are compiled in the order in which they occur in the
		list returned by $$getList("Data"). Even though the compiled
		routines will not be ZLINKed automatically, units that are
		compiled later can use classes for which the method generating
		routine has been created earlier in the process. Similarly,
		units compiled earlier cannot use classes for which the method
		generating routine has not yet been created.
	* This procedure ZLINKs the routines that it expects to be present in
		their after-upgrade version, but that may have been called by
		the installation program in phase 0, BEFORE the new routines
		were loaded. This is restricted to OBSOLETIONS in case of an
		Upgrade, but could include most of the SQL engine, and PSL
		runtime routines such as UCXDD. It will also include other
		framework routines such as DBMAP and DBSDBASE.
		In the near future, these elements shall be classified just like
		compiler and engine elements, and they shall be integrated into
		the values returned by $$getList().
		Note that linkAll() cannot be called, because that includes the
		routines from the Data group that may not yet be present at all.
		Note that routines from the Data group may have been called as
		well in their pre-upgrade form, so after calling bootProc, the
		unit must be ZLINKed explicitly.
	*/

	// Update the current image by ZLINKing the routines that may have been
	// called before
	do linkList( $$getList("Insensitive"))
	do linkList( $$getList("Dictionary"))
	do linkList( $$getList("Object"))
	do linkList( $$getList("Upgrade"))

	// Generate routine UCOPTS
	do bootUCOPTS()

	// Boot the remainder of the PSL compiler, SQL engine, and DBS kernel
	type List sysList
	type Number elm
	type String unt

	/* The actual compiler bootstrap */
	set sysList = $$getList("Data")
	for elm=1:1:sysList.count() do {
		set unt = sysList.elementAt(elm)

		if unt = "UCOPTS" quit	// UCOPTS already compiled separately

		type Primitive co(,)	// compiler options (clean set per call)

		if 'vDataDir.get().isNull() set co("boot","datadirectory") = vDataDir

		do getBootOptions( .co(,))

		set co("boot","restrictionlevel") = 2	// force restriction level
	
		do bootCmp( unt, co(,))

		// ZLINK new, environment specific, version (to deal with polluted image)
		do linkList( unt)
	}

	type List comList = $$getList("Compiler")
	for elm=1:1:comList.count() do {
		set unt = comList.elementAt( elm)
		if sysList.contains( unt) quit	// Data group already done
		if '$$isProc^UCXDT25( unt) quit	// not a DQ procedure
		do bootProc( unt)
	}
	quit

	// ---------------------------------------------------------------------
public bootCmp( local String proc,		// procedure to compile
		local Primitive cco(,))		// compiler command options (*2)
	/* ---------------------------------------------------------------------
	This subroutine mimics the behavior of COMPILE^DBSPROC(), with the
	following exceptions:
	- The source will be constructed using $$getSrc^UCXDT25(), that will
		include a copyright notice without calling ^SCACOPYR(), but will
		not include the vSig label used to track source modifications.
	- The version of the routine in SCAU_MRTNS will be deleted.

	This is the simplest set of actual parameters that allows overriding
	compiler default settings.

	NOTES:
	. The SCAU_MRTNS version will only be deleted if
		- $$getSrc^UCXDT25() returned PSL source code.
			This prevents the deletion of M routines.
		- The compilation is successful.
			This ensures that the set of routines will always be
			"complete".
	*/
	type String src(), cfe
	//type String rtn = $$getSrc^UCXDT25( proc, .src(), 2)
	type String rtn = $$getSrc^UCXDT25( proc, .src(), 0)

	quit:rtn=""
	quit:src.data()<10

	/* call compile-arrray-to-file with:
		- src = scr() returned by $$getSrc^UCXDT25()
		- dst = rtn as returned by $$getSrc^UCXDT25()
		- labels = ignored
		- methods = ignored
		- commands = cco(,) as passed in
		- sysmap = ignored
		- cmperr = cfe(), used to check that routine delete is safe
		- PGM = rtn_"~Procedure"
	*/
	do cmpA2F^UCGM( src(), rtn, , ,  cco(,), , .cfe, rtn_"~Procedure")

	/* If the compilation was successful, delete the SCAU_MRTNS version of
	   this element. */
	if cfe.get().toNumber()>0 quit
	do DEL^%ZRTNDEL( rtn, $$SCAU^%TRNLNM("MRTNS"))
	quit

	// ---------------------------------------------------------------------
public bootFiler( local String table)	// table for which to compile filer
	/* ---------------------------------------------------------------------
	This subroutine calls COMPILE^DBSFILB() with the bootoptions that apply
	to boot-restrictionlevel=1.
	It is the caller's responsibility to ensure that the filer meets
	all other requirements that allow compilation with the PSL compiler's
	boot options in effect.

	NOTES:
	. Unlike boot^UCGMCU() this subroutine does not accept additional
		parameters. This implies that access to CUVAR, system tables,
		and other datastructures shall be possible using the underlying
		data store.
	*/
	type Primitive co(,)	// compiler options

	do getBootOptions( .co(,))
	do COMPILE^DBSFILB( table, , co(,))

	quit
	
	// ---------------------------------------------------------------------
public bootProc( local String proc)	// procedure to compile using bootstap settings
	/* ---------------------------------------------------------------------
	This subroutine mimics the behavior of COMPILE^DBSPROC(). However this
	subroutine does not invoke any function or subroutine that might be
	unavailable in an initial environment.
	The boot options will be similar to the boot options used to boot the
	PSL compiler (see subroutine boot() in this unit).
	It is the caller's responsibility to ensure that the DQ procedure meets
	all other requirements that allow compilation with the PSL compiler's
	boot options in effect.

	NOTES:
	. Unlike boot^UCGMCU() this subroutine does not accept additional
		parameters. This implies that access to CUVAR, system tables,
		and other datastructures shall be possible using the underlying
		data store.
	*/
	type Primitive co(,)	// compiler options

	do getBootOptions( .co(,))
	do bootCmp(proc, co(,))

	quit
	
	// ---------------------------------------------------------------------
public bootUCOPTS()	// procedure to generate routine UCOPTS
	/* ---------------------------------------------------------------------
	This subroutine creates a new version of the routine UCOPTS. This call
	is needed after changes have been made to $SCAU_DIR/UCOPTS.ini.

	A call to this subroutine will be automatic for compiler bootstraps.

	OUTPUTS:
	. A new version of routine UCOTPS has been created in $SCAU_CRTNS.

	NOTES:
	. See comment throughout this subroutine, and in the generated code for
		additional explanation.
	*/
	type String siteOpts(,)		// values from UCOPTS.ini
	type String uc()		// UCOPTS source code
	type Number ln = 0		// source line pointer

	do decodeFile^UCGMC( $$SCAU^%TRNLNM("DIR"), "UCOPTS.ini", .siteOpts(,))

	do ca(.uc(), "private UCOPTS( String Options()) // PSL Compiler Environment Options")

	do ca(.uc(), " // *******************************************************************")
	do ca(.uc(), " // * IMPORTANT NOTE:                                                 *")
	do ca(.uc(), " // * According to the rules that apply to PSL compiler upgrades,     *")
	do ca(.uc(), " // * this routine is generated by the compiler from the PSL Compiler *")
	do ca(.uc(), " // * Environemnt Options file $SCAU_DIR/UCOPTS.ini                   *")
	do ca(.uc(), " // *                                                                 *")
	do ca(.uc(), " // * To modify environment settings on a permanent basis:            *")
	do ca(.uc(), " // * 1) change $SCAU_DIR/UCOPT.ini                                   *")
	do ca(.uc(), " // * 2) call bootUCOPTS^UCGMCU() to rebuild UCOPTS.m                 *")
	do ca(.uc(), " // *                                                                 *")
	do ca(.uc(), " // * To modify WARN, OPTIMIZE and Options settings on an incidental  *")
	do ca(.uc(), " // * basis, ensure that the environment variable $SCAU_UCOPTS names  *")
	do ca(.uc(), " // * the file that specifies these overwrites.                       *")
	do ca(.uc(), " // *                                                                 *")
	do ca(.uc(), " // * Note that you cannot specify incidental overwrites for values   *")
	do ca(.uc(), " // * to be returned by $$getPslValue().                              *")
	do ca(.uc(), " // *******************************************************************")

	/* force defaults.
	   Defaults are choosen in such a way that they best fit a production
	   environment. Given that existing production sites per introduction of
	   this feature (JUNE 2006) are all Profile Version 6.4 or lower, an
	   absent UCOPTS.INI file shall correspond to the default settings of a
	   Profile V6.4 production environment.

	   All new installations as of JUNE 2006 will have a UCOPTS.ini, that
	   will be tailored to the Profile Production Environment for that
	   version.

	   Profile Development environments and Profile QA environments will
	   require a UCOPTS.ini file with settings that correspond to the
	   rules and guidelines set for that environment.

	   This leads to the following defaults:
	   - WARN and INFO: all OFF
	   - OPTIMIZE: all ON
	   - Options: $GetEFD, AllowGOTO, and AutoPublicERRM ON, ResultClass OFF
	   */
	type String def()
	type String opt
	type String on
	type String val

	set def("WARN")     = ""
	set def("INFO")     = ""
	set def("OPTIMIZE") = $$allOPTIMIZE^UCGMC()
	set def("Options")  = $$allOptions^UCGMC()
	set def("Options")  = def("Options").replace( ",ResultClass")

	// insert lines that specify settings
	for opt="WARN","INFO","OPTIMIZE","Options" do {
		do ca(.uc(), " //")
		do ca(.uc(), " // ---- "_ (opt_ " settings ").justify( 64, -1, "-"))
		if siteOpts( opt).data() do {
			set (on, val) = ""
			for  set val = siteOpts( opt, val).order() quit:val.isNull()  do {
				if 'siteOpts( opt, val) quit
				if on.isNull() set on = val quit
				set on = on_ ","_ val
			}
		}
		else  do {
			do ca(.uc(), " // None specified, using PSL defaults")
			set on = def( opt)
		}

		do ca(.uc(), " set Options("_ opt.addQuotes()_ ") = "_ on.addQuotes())
	}
	do ca(.uc(), " quit")


	// add $$charsetName()
	do ca(.uc(), "")	
	do ca(.uc(), " // *******************************************************************")
	do ca(.uc(), "private charsetName() // return current character set as runtime value")
	do ca(.uc(), " quit Runtime.charsetName")


	// add $$getPslValue()
	type literal List IMMUTABLE = "maxCharValue,maxLineLength,maxNameLength,maxStringLength"
	type String objdef
	type String prop    = ""
	type Row    propDes = Class.new( "Row", "#$$opRowDef^UCXOBJ()")
	type String pslProp(,)
	type String rtn

	do opAll^UCXOBJ( .pslProp(,), "PSL")

	do ca(.uc(), "")	
	do ca(.uc(), " // *******************************************************************")
	do ca(.uc(), "private getPslValue( String property) // return value of PSL.xxxYyyZzz property")

	/* First add the immutable values
	   */
	do ca(.uc(), " // ---- PSL.maxCharValue ----")
	do ca(.uc(), " // This value indicates the maximum value that is allowed in $CHAR().")
	do ca(.uc(), " // The value depends on the GT.M version and if the GT.M version")
	do ca(.uc(), " // supports Unicode it also depends on the setting of $ZCHSET.")
	do ca(.uc(), " // Note that GT.M treats 0x10FFFF and 0x10FFFE as unmapped characters.")
	do ca(.uc(), " //")
	//do ca(.uc(), " #IF $$gtmLevel^UCGM(5.2)")
	//do ca(.uc(), " #IF $ZCHSET=""UTF-8"" if property = ""maxCharValue"" quit 1114109")
	//do ca(.uc(), " #IF $ZCHSET=""M"" if property = ""maxCharValue"" quit 255")
	//do ca(.uc(), " #ELSE")
	//do ca(.uc(), " if property = ""maxCharValue"" quit 255")
	//do ca(.uc(), " #END")
	do ca(.uc(), " #IF $$rtChset^UCBYTSTR()=""UTF-8""")
	do ca(.uc(), " if property = ""maxCharValue"" quit 1114109")
	do ca(.uc(), " #ELSE")
	do ca(.uc(), " if property = ""maxCharValue"" quit 255")
	do ca(.uc(), " #END")

	do ca(.uc(), " //")
	do ca(.uc(), " // ---- PSL.maxLineLength ----")
	do ca(.uc(), " // This value indicates the split value that will be used to determine")
	do ca(.uc(), " // if a line of M code must be split over multiple lines.")
	do ca(.uc(), " // For example, assigning a constant with a length close to")
	do ca(.uc(), " // PSL.maxStringLength to a variable requires multiple lines:")
	do ca(.uc(), " //     set var = ""FIRST PIECE""")
	do ca(.uc(), " //     set var = var_""SECOND PIECE""")
	do ca(.uc(), " // The value leaves room for additional characters such as the")
	do ca(.uc(), " //     'set var = var_'")
	do ca(.uc(), " // in the example above.")
	do ca(.uc(), " //")
	do ca(.uc(), " #IF $$gtmLevel^UCGM(4)")
	do ca(.uc(), " if property = ""maxLineLength"" quit 1980")
	do ca(.uc(), " #ELSE")
	do ca(.uc(), " if property = ""maxLineLength"" quit 450")
	do ca(.uc(), " #END")

	do ca(.uc(), " //")
	do ca(.uc(), " // ---- PSL.maxLitLength ----")
	do ca(.uc(), " // The PSL compiler will try to generate code that uses literal values")
	do ca(.uc(), " // whenever possible. To prevent the construction of lines that exceed")
	do ca(.uc(), " // PSL.maxLineLength when multiple long literals occur, the maximum")
	do ca(.uc(), " // length of such a literal will be limited to PSL.maxLineLength / 4")
	do ca(.uc(), " //")
	do ca(.uc(), " #IF $$gtmLevel^UCGM(4)")
	do ca(.uc(), " if property = ""maxLitLength"" quit 511")
	do ca(.uc(), " #ELSE")
	do ca(.uc(), " if property = ""maxLitLength"" quit 255")
	do ca(.uc(), " #END")

	do ca(.uc(), " //")
	do ca(.uc(), " // ---- PSL.maxNameLength ----")
	do ca(.uc(), " // This value indicates how many characters are allowed in names.")
	do ca(.uc(), " // The value applies to names of")
	do ca(.uc(), " // - local variables (error)")
	do ca(.uc(), " // - labels (info)")
	do ca(.uc(), " // - routines (info)")
	do ca(.uc(), " // The compiler will issue a LENGTH error or information message")
	do ca(.uc(), " //  when the length of a name exceeds this value")
	do ca(.uc(), " //")
	do ca(.uc(), " #IF $$gtmLevel^UCGM(5)")
	do ca(.uc(), " if property = ""maxNameLength"" quit 31")
	do ca(.uc(), " #ELSE")
	do ca(.uc(), " if property = ""maxNameLength"" quit 8")
	do ca(.uc(), " #END")

	do ca(.uc(), " //")
	do ca(.uc(), " // ---- PSL.maxStringLength ----")
	do ca(.uc(), " // This value indicates the maximum length that is assumed for local")
	do ca(.uc(), " // variables. You can use this constant in constructs like")
	do ca(.uc(), " // String.extract(first,PSL.maxStringLength)")
	do ca(.uc(), " //")
	do ca(.uc(), " #IF $$gtmLevel^UCGM(""4.4-004"")")
	do ca(.uc(), " if property = ""maxStringLength"" quit 1048575")
	do ca(.uc(), " #ELSE")
	do ca(.uc(), " if property = ""maxStringLength"" quit 32767")
	do ca(.uc(), " #END")

	/* Remaining property values
	   */
	do ca(.uc(), " //")
	do ca(.uc(), " // ---- supplied by UCOPTS.ini ----")
	   
	for  set prop = pslProp( "PSL", prop).order() quit:prop.isNull()  do {
		if IMMUTABLE.contains(prop) quit	// not for change

		set propDes = {Row}pslProp( "PSL", prop)
		set rtn = propDes.routine
		if rtn'[ "getPslValue^UCMETHOD(" quit	// not a PSL value

		set objdef = rtn.extract( "getPslValue^UCMETHOD(x".length(), rtn.length()-1)
		set val = siteOpts( "DEFINE", prop).get( objdef)
		if 'val.isNumber() set val = val.addQuotes()
		do ca(.uc(), " //")
		do ca(.uc(), " if property = "_ prop.addQuotes()_ " quit "_val)
	}
	do ca(.uc(), " quit """"")

	// generate M routine, using boot restrictionlevel = 3
	type String bo(),cfe

	do getBootOptions( .bo(,))

	set bo("boot","restrictionlevel") = 3

	do cmpA2F^UCGM( uc(), "UCOPTS", , , bo(,), , .cfe, "UCOPTS.ini~file")

	quit

	// ---------------------------------------------------------------------
local ca( public String src(), local String cod) // Append cod to src()
	/* ---------------------------------------------------------------------
	Support function that adds a line of code to src()
	*/
	set src( src("").order(-1) + 1) = cod
	quit

	// ---------------------------------------------------------------------
public cascade( local Boolean file,	// file changes? (*1)
		local List units)	// list of units (*2)
	/* ---------------------------------------------------------------------
	Cascade modifications of PSL compiler units into all compiler units.

	ARGUMENTS:
	(*1) Indicates if the new version of a unit must be filed if it differs
		from the version stored on disk:
		0 - do not file changes.
			If this value is supplied, then each PSL compiler element
			will be checked at most once.
		1 - do file changes.
			If this value is supplied, new versions of PSL compiler
			elements will be filed until all units recompile equal.
			Note that at each compiler element is recompiled at least
			twice when this value is supplied
	(*2) List of units that shall be validated
		Only units in this list will be checked, and possibly
		re-compiled, even if changes may cascade into other units as
		well. There is no default value.

	OUTPUTS:
	. $$ = List of PSL compiler elements that are either
		- elegable for recompilation, because they compile differently
		  (if file=0)
		- recompiled and overwritten, because they compiled differently
		  (if file=1)
	*/
	type List cascade = Class.new("List", "")	// the return List
	type Boolean changed = 1			// iteration flag
	type Number elm
	type String SCAUCRTNS = $$SCAU^%TRNLNM("CRTNS")	// .proc and .m directory

	while changed do {
		set changed = 0
		for elm = 1:1:units.count() do {
			type String m()			// generated M code
			type String unit = units.elementAt(elm)

			type Boolean bNeed = $$needCompile(unit, SCAUCRTNS, .m())
			do cascInfo(unit, file, bNeed)	// show unit info

			if 'bNeed quit

			set cascade = cascade.add( unit, , 0)
			if 'file quit

			// file the new unit, copy to SCAU_MRTNS, no ZLINK
			do ^%ZRTNCMP(unit, "m", 1)
			set changed = 1
		}
		if changed do linkAll()
	}

	quit cascade

	// ---------------------------------------------------------------------
cascInfo(	local String unit,	// PSL compiler element name (*1)
		local Boolean file,	// file flag (*2)
		local Boolean need)	// need recompile flag (*3)
	/* ---------------------------------------------------------------------
	Subroutine that wraps a call to INFO^UCGM() to hide any side effect
	caused by that call.

	ARGUMENTS:
	(*1) unit name, without extension. The unit need not be a PROC element.
	(*2) Shall be the value of the formal parameter file from $$cascade()
	(*3) Shall be the return value from $$needCompile()
	
	EXAMPLE:
	. do cascInfo^UCGMCU("UCTS",0,1) will produce:
		UCTS // PSL compiler element cascade validation
		PSL-I-cascade: need=1, file=0
		At source code line: 1 in subroutine: UCTS
	*/
	type String txt
	if 'need set txt = "NOT needed"
	else  do {
		set txt = "needed, "
		if 'file set txt = txt_ "NOT "
		set txt = txt_"filed"
	}
	do info(unit, unit_" // PSL compiler element cascade validation", "Regenerate "_ txt)
	quit

	// ---------------------------------------------------------------------
public date(	local String vStr,	// string representation of date (*1)
		local String vMsk)	// date mask (*2)
	/* ---------------------------------------------------------------------
	Convert a String to a Date using the specified mask, without calling
	routines that may not be avaialable.
	See the individual arguments with respect to limitations.

	ARGUMENTS:
	(*1) date = string representation of date
		The supplied value shall unconditionally match the supplied mask
	(*2) mask = date mask
		- shall contain "DD"
		- shall contain "MM"
		- shall contain either "YY" or "YEAR"

	NOTES:
	. If the date does not match the mask, or the mask does not match the
		requirements, the code generated for String.toDate() will call
		^SCAJD, which is not yet present in an initial environment.
	*/
	catch vErr {
		throw Class.new("Error","%PSL-E-CONVERT,,"_vStr_"~"_vMsk)
	}
		
	quit vStr.toDate( vMsk)

	// ---------------------------------------------------------------------
public getBootData( public Primitive bo(,))	// boot option array
	/* ---------------------------------------------------------------------
	This subroutine will instantiate the RowSet objects and load them with
	data, provided that bo("boot","datadirectory") exists.

	ARGUMENTS:
	. bo(,) = boot option array
		bo("boot","datadirectory") will be referenced.
		If this node exists, then TABLE data will be loaded into
		RowSets, and bo("boot",TABLE) will contain the RowSet for TABLE.

	OUTPUTS:
	. bo("boot","CUVAR") = RowSet instance for CUVAR data
		If and only if bo("boot","datadirectory").exists()
		In this case vobj(bo("boot","CUVAR")) will contain the
		RowSet's data.
	. bo("boot","STBLSYSKEYWD") = RowSet instance for STBLSYSKEYWD data
		If and only if bo("boot","datadirectory").exists()
		In this case vobj(bo("boot","STBLSYSKEYWD")) will contain the
		RowSet's data.
	. bo("boot","STBLPSLFUNSUB") = RowSet instance for STBLPSLFUNSUB data
		If and only if bo("boot","datadirectory").exists()
		In this case vobj(bo("boot","STBLPSLFUNSUB")) will contain the
		RowSet's data.

	NOTES:
	. This subroutine must instantiate all RowSets that are ACCESSED in
		phase 1 (compiler completion) of the bootstrap.
	. The PSL compiler will COMPILE the correct database access to EVERY
		table, regardless of the values in bo(,).
	. Based on the above observations, creation of the STBLJRNFUNC RowSet is
		not needed, because it will not be accessed by the compiler
		itself or by the SQL engine.
	*/

	if 'bo("boot","datadirectory").exists() quit

	/* First retrieve the contents of CUVAR.
	   According to the rules established for initial environment creation,
	   and upgrades, this file is not located in the data directory, but in
	   the "environment root" directory. */
	type String tbl = "CUVAR"
	type Number ptr = $$getBootRws( $$SCAU^%TRNLNM("DIR"), tbl_".DAT")
	if 'ptr.isNull() set bo("boot",tbl) = ptr

	for tbl = "STBLSYSKEYWD", "STBLPSLFUNSUB" do {
		type Number ptr = $$getBootRws( bo("boot","datadirectory"), tbl_".DAT")
		if 'ptr.isNull() set bo("boot",tbl) = ptr
	}
	quit

	// ---------------------------------------------------------------------
local getBootOptions( public Primitive bo(,))	// boot option array
	/* ---------------------------------------------------------------------
	This subroutine returns the array of boot options that are used to
	bootstrap the PSL compiler.

	Only the required overrides are initialized here. All other settings will
	be obtainted by main^UCGM(), which in turn calls UCINIT^UCDTAUTL().
	
	Note that this may result in different settings for different boot
	restriction level values:
	- If boot restriction level = 3, only the settings from the file named
		by SCAU_UCOPTS will be in effect. All settings that are not
		supplied explicitly by that file will be treated as OFF.
	- If boot restriction level < 3, the "standard" UCOPTS handling is in
		effect, and the resulting settings will apply to code generated
		through calls to bootProc() and prepProc().

	OUTPUTS:
	. bo("boot","restrictionlevel") = 1
	. bo("Options","nolink") = 1
	. bo("OPTIMIZE","FUNCTIONS") = 0

	NOTES:
	. Because UCGM NEWs vobj(), the RowSets cannot be instantiated as part
		of the compiler set-up. The RowSet objects will be hidden by the
		compiler even though the bo("boot",TABLE) entries suggest that
		the RowSets shall be used.
	. The setting of OPTIMIZE OBJECT depends on the UCOPTS settings that are
		in effect (SCAU_UCOPTS and routine UCOPTS). The advantage of
		this is that the units will be compiled using the same settings
		that apply to non-Framework units. The risk of this behavior is
		that problems with object optimization will affect the framework
		units themselves, which is likely to result in a very corrupt
		system. For this reason, if changes are made to the
		implementation of object optimization, framework units shall be
		compiled with OPTIMIZE OBJECTS OFF until the change is known to
		be reliable.
		Point SCAU_UCOPTS to an appropriate overwrite to achieve this.
	*/
	set bo( "boot", "restrictionlevel") = 1
	set bo( "Options", "nolink") = 1
	set bo( "OPTIMIZE", "FUNCTIONS") = 0

	/* ---------------- old code that forced overwrites for all settings
	// Done if explicit UCOPTS settings file is present
	if '$$SCAU^%TRNLNM("UCOPTS").isNull() quit

	// Use standard values: all OFF
	type String g
	type List ol
	type Number elm

	set ol = {List}$$allWARN^UCGMC()
	for elm = 1:1:ol.count() set g = ol.elementAt(elm), (bo( "WARN", g), bo( "INFO", g)) = 0

	set ol = {List}$$allOPTIMIZE^UCGMC()
	for elm = 1:1:ol.count() set bo( "OPTIMIZE", ol.elementAt(elm)) = 0
	set bo( "OPTIMIZE", "OBJECTS") = 1

	set ol = {List}$$allOptions^UCGMC()
	for elm = 1:1:ol.count() set bo( "Options", ol.elementAt(elm)) = 0
	---------------- end old code ---------------- */

	quit

	// ---------------------------------------------------------------------
local getBootRws( local String dir, local String file)
	/* ---------------------------------------------------------------------
	Local support funtion that instantiates the RowSet, and loads the data.
	If the RowSet is empty, it will return "", otherwise it will return the
	RowSet object instance.
	*/
	type RowSet rws = Class.new( "RowSet")
	do {
		catch loadExep {	// ignore rws.loadFromFile() exception
		}
		do rws.loadFromFile( dir, file, 1)
	}
	if rws.isEmpty() quit ""
	quit rws

	// ---------------------------------------------------------------------
public getGroup( String sRtn)	// the routine for which the grooup is requested
	/* ---------------------------------------------------------------------
	Return the PSL compiler group to which the routine belongs.

	OUTPUTS:
	$$	"Insensitive" if the routine belongs to the Insensitive group
		"Object" if the routine belongs to the Object group
		"Dictionary" if the routine belongs to the Dictionary group
		"Upgrade" if the routine belongs to the Upgrade group
		"Data" if the routine belongs to the Application group, or the
			System group, but not to the Upgrade group

	NOTE:
	. The implementation is not very efficient. It calls $$getGroup() for
		each of the pre-defined groups, until a match is found.
	. Because the Upgrade group is a subset of the Data group, it must be
		tested first.
	*/
	type String sGrp
	for sGrp = "Insensitive","Dictionary","Upgrade","Data","Object" if ({List}$$getList(sGrp)).contains(sRtn) quit
	else  set sGrp = ""
	quit sGrp

	// ---------------------------------------------------------------------
public getCapabilities( local String sSec)	// section (*1)
	/* ---------------------------------------------------------------------
	Return the List of capabilities that is supported by the current version
	of the compiler.

	ARGUMENTS:
	(*1) sSec = sectionname
		The name of the section in the (Profile Workbench) file
		pslKeywords.ini. Currently the following sections are supported:
		- "KEYWORDS"
			Returns the List of all PSL command names, compile time
			commands, and other keywords (like "public"). Because
			the compiler is case insensitive with respect to these
			keywords, all elements are returned using lowercase
			spelling.
		- "FUNCTIONS"
			Returns the List all M functions that are still valid
			in PSL.

	NOTES:
	. pslKeywords.ini keeps the entries in a specific order. To prevent
		mixing responsibilites, this function provides the List in an
		"arbitrary" order (newer features occur at higher positions).
		Thus it is the responsibility of the caller to sort the values
		if needed.
	. Keywords in PSL are case insensitive (like in SQL, but unlike C, Java,
		or Pascal). The function will always return them using lowercase
		characters only.
	. Like $$getList(), the implementation of this function uses a bunch of
		literals to construct the return value.
	*/
	if sSec = "FUNCTIONS" quit $$initFcts^UCGM()
	if sSec '= "KEYWORDS" quit ""

	/* KEYWORDS: ----------------
	   - All commands as obtained from initCmds^UCGM(), converted to
		lowercase
	   - access keywords ( literal, local, private, public)
	   - compiler commands
	*/
	/* Initial PSL keywords (per AMR05) */
	type literal List KWD05  = "literal,private,public"

	/* Additional PSL keywords per AMR06 */
	type literal List KWD06  = KWD05_ ",local,void"
	
	/* Total PSL keywords per latest CR */
	type literal List KWD = KWD06

	/* Initial PSL compile time commands (per AMR05) */
	type literal List CTC05A = "#accept,#break,#bypass,#else,#end,#endif"
	type literal List CTC05  = CTC05A_ ",#if,#optimize,#warn,#while,#xecute"

	/* Additional PSL compile time commands per AMR06 */
	type literal List CTC06  = CTC05_ ",#info,#option"

	/* Total PSL compile time commands per latest CR */
	type literal List CTC = CTC06

	type String acmd()
	type String cmd = ""
	type List   cmdl = ""
	do initCmds^UCGM(.acmd())

	for  set cmd = acmd( cmd).order() quit:cmd.isNull()  set cmdl = cmdl.add( cmd.lowerCase())
	quit cmdl_ ","_ KWD_ ","_ CTC

	// ---------------------------------------------------------------------
public getList( String sGrp)	// 
	/* ---------------------------------------------------------------------
	Return List of all PSL compiler routines.
	This function returns a List of all routines that are part of the PSL
	compiler, the SQL engine, or the DATA-QWIK runtime system. This function
	provides an unordered List that is used by all other functions and
	subroutines.

	The functions and subroutines that use this List rely on the fact that
	the DQ procedure name and the M routinename are equal.

	OUTPUTS:
	$$	A List instance containing all PSL compiler routines per latest
		release of this unit.

	NOTES:
	* All routines that are considered part of the PSL compiler are included
	  in the list even if there (current) use is questionable such as:
	  - UCERROR.m	All code has been copied and redirected to UCRUNTIM.m
	  - UCMEMO.m	Does not implement any existing method.
	  - UCSTAT.m	This is a utility routine that analyzes and provides
			SYSMAP info for M routines. It is not called by the
			compiler, but MASS^UCSTAT will indirectly invoke the
			compiler for PSL sources such as Batches and Procedures.
	* When the order of the units is irrelevant, the list is constructed
		using one or more literals that reflect the historic grows of
		the compiler.
	* When the (compilation) order of the units does matter, the comment
		preceeding the definition explains the order.
	*/
	/* Initial PSL INSENSITIVE elements (per AMR05) */
	type literal List INS05A = "UCDBSET,UCERROR,UCGMR,UCIO,UCLIST,UCMEMO"
	type literal List INS05B = INS05A_ ",UCMETHOD,UCNUMBER,UCPATCH"
	type literal List INS05C = INS05B_ ",UCRECCIF,UCRECDEP,UCRECLN,UCREF"
	type literal List INS05D = INS05C_ ",UCRESULT,UCROW,UCRUNTIM,UCSCHEMA"
	type literal List INS05E = INS05D_ ",UCSTAT,UCSTRING,UCTS,UCUTILN"

	/* Initial SQL INSENSITIVE elements (per AMR05) */
	type literal List INS05S = INS05E_ ",SQLA,SQLAGFUN,SQLBLOB,SQLF"
	type literal List INS05  = INS05S_ ",SQLFILER,SQLFUNCS,SQLG,SQLQ"

	/* Additional PSL and SQL INSENSITIVE elements per AMR06 */
	type literal List INS06A = INS05_  ",UCCOLSF,UCDBR,UCGMCU,UCIO0,UCPSLLR"
	type literal List INS06B = INS06A_ ",UCPSLSR,UCPSLST,UCREC4OP,UCROWSET"
	type literal List INS06  = INS06B_ ",UCTIME"

	/* Total PSL and SQL INSENSITIVE elements per latest CR */
	type literal List INS    = INS06

	/* Initial PSL DICTIONARY elements (per AMR05) */
	type literal List DIC05A = "UCCLASS,UCCOLUMN,UCDB,UCGM,UCGMC,UCHTML"
	type literal List DIC05B = DIC05A_ ",UCLABEL,UCOBJECT,UCQRYBLD,UCRECACN"
	type literal List DIC05C = DIC05B_ ",UCRECORD,UCUTIL"

	/* Initial SQL DICTIONARY elements (per AMR05) */
	type literal List DIC05S = DIC05C_ ",SQL,SQLBUF,SQLCACHE,SQLCMP,SQLCOL"
	type literal List DIC05T = DIC05S_ ",SQLCONV,SQLCRE,SQLDD,SQLJ,SQLM"
	type literal List DIC05  = DIC05T_ ",SQLO,SQLODBC,SQLPROT,SQLTBL"


	/* Additional PSL, SQL and DQR DICTIONARY elements AMR06 */
	type literal List DIC06A = DIC05_ ",UCDBRT,UCXDD,UCXDT25"
	type literal List DIC06B = DIC06A_ ",DBMAP,DBSDBASE,DBSDDMAP,DBSDYNRA"
	type literal List DIC06  = DIC06B_ ",DBSMACRO,DBSTBL"

	/* Total PSL and SQL DICTIONARY elements per latest CR */
	type literal List DIC    = DIC06

	/* Initial PSL OBJECT elements (per AMR05) */
	type literal List OBJ05  = "UCGMCONV,UCPRIM"

	/* Additional PSL OBJECT elements AMR06 */
	type literal List OBJ06  = OBJ05_ ",UCXOBJ"

	/* Total PSL OBJECT elements per latest CR */
	type literal List OBJ    = OBJ06

	/* PSL, SQL AND DQR DATA elements will need to be compiled at the
	   beginning of the compiler bootstrap. Units that provide method 
	   generating code shall preceed other units in the list.
	   The compilation order also imposes limits on what classes can be
	   used by units in the group. The compilation order also prevents
	   separating SYSTEM and APPLICATION elements.
	   - UCOPTS must be compiled early to provide the correct values for
	   	calls to $$getPslValue^UCOPTS(). Whereas the compilation of some
	   	units may succeed using conservative defaults, procedures that
	   	store data in the database will call
	   	$$getPslValue^UCOPTS("batchCommitCount") to generate code for
	   	Runtime.commit(). Note that this call may be implied e.g. by a
	   	Record.save() call.
	   	UCOPTS.proc will be constructed and compiled as a separate step
	   	in the bootstrap process (see subroutine bootUCOPTS()).
	   - UCBYTSTR implements class ByteString and must be compiled "early"
	   	In addition to the ByteString Methods, it implements the
	   	methods String.upperCase() and String.lowerCase(). This unit
	   	can be placed in the UPGRADE group, provided that the supplied
	   	M routine does not contain references to possibly unsupported
	   	GT.M constructs.
	   - SQLUTL provides a number of utilities that use the ByteString
		class. It is treated as an UPGRADABLE module (see UCBYTSTR), and
		will be compiled "early" to ensure that if it is called during
		bootstrap, it will use the target environment's character set.
	   - UCDATE implements class Date and must be compiled "early"
	   	Even though this unit contains Cache.getRecord("UTBLNBD"), it
	   	can be treated as an UPGRADABLE module, because no calls to
	   	Date.isBusDate are expected during bootstrap processing. In
	   	addition the unit shall be treated as UPGRADABLE because the
	   	method generating code is self-referencing with respect to code
	   	generated for literal values. So the module must be present in
	   	an initial environment in order to compile itself.
	   - UCDTAUTL and UCXCUVAR are both updatable, so the associated M
	   	routine will already be available at bootstrap time. This makes
	   	their position in the list less relevant.
	   - DBSDD is updatable, like UCDTAUTL, and will be compiled "close to"
		UCDTAUTL. This unit accesses STBLSYSKEYWD, but the subroutine
		that contains the Db.select() will never be called during phase1
		or phase2 of a bootstrap. Having DBSDD.m around during bootstrap
		ensures that other calles to this routine will work even if they
		occur very early in the bootstrap.
	   - DBSDI is strictly speaking not updatable, because it contains
		occurrences of Db.getRecord() for the non-framework tables XBAD,
		STBLXBAD, and STBLRER. Unfortunately, there seem to be "early"
		calls to DBSDI in phase 1 (and may be even in phase 0), so it
		will be compiled "close to" DBSDD.
	   - UCDTASYS, UCLREGEN, and UCSYSMAP will (shall)
	   	not be called during bootstrap and can be compiled "later".
	   	Note tha UCOPTS is needed to generate code for UCLREGEN and
	   	UCSYSMAP.
	   - SQLEFT references an application table.
	*/
	type literal List DAT01  = "UCOPTS,UCBYTSTR,SQLUTL,UCDATE"
	type literal List DAT02  = DAT01_ ",UCDTAUTL,DBSDD,DBSDI,UCXCUVAR"
	type literal List DAT03  = DAT02_ ",UCDTASYS,UCLREGEN,UCSYSMAP,SQLEFD"

	/* Total PSL and SQL DATA elements per latest CR */
	type literal List DAT    = DAT03

	/* Initial PSL and SQL UPGRADABLE elements (per AMR05)
	   PSL AND SQL UPGRADABLE elements are an (unordered) subset of the DATA
	   elements (more accurately of the SYSTEM elements). The discriminating
	   characteristics of UPGRADABLE elements are that they are included in
	   an upgrade as M routine, but they still need to be compiled at the
	   target site to ensure that they contain the proper target dependent
	   code to access the data when called outside the upgrade process, or
	   the correct defaults for CUVAR properties or other environment
	   sensitive values.
	   Based on this definition, UCOPTS will never belong to the UPGRADABLE
	   group, because it is customizable by nature. */
	type literal List UPG05  = "UCBYTSTR,UCDATE,UCDTAUTL"

	/* Additional PSL and SQL UPGRADABLE elements AMR06 */
	type literal List UPG06  = UPG05_ ",UCTIME,UCXCUVAR,SQLUTL,DBSDD"

	/* Total PSL and SQL UPGRADABLE elements per latest CR */
	type literal List UPG    = UPG06

	/* Total PSL and SQL COMPILER elements per latest CR */
	type literal List COM    = INS_","_OBJ_","_DIC_","_DAT

	if sGrp = "Compiler"    quit COM
	if sGrp = "Data"        quit DAT
	if sGrp = "Dictionary"  quit DIC
	if sGrp = "Insensitive" quit INS
	if sGrp = "Object"      quit OBJ
	if sGrp = "Upgrade"     quit UPG
	quit ""

	// ---------------------------------------------------------------------
	/* Shorthand calls for each of the groups
	*/
public getComList() quit $$getList("Compiler")
public getDatList() quit $$getList("Data")
public getDicList() quit $$getList("Dictionary")
public getInsList() quit $$getList("Insensitive")
public getObjList() quit $$getList("Object")
public getUpgList() quit $$getList("Upgrade")

	// ---------------------------------------------------------------------
info(	local String subRou,	// "subroutine" name (*1)
	local String line,	// "source line" (*2)
	local String info)	// info text (*3)
	/* ---------------------------------------------------------------------
	Subroutine that wraps a call to INFO^UCGM() to hide any side effect
	caused by that call.

	ARGUMENTS:
	(*1) name to be passed as subroutine name
	(*2) text to represent the "source line" that triggered the INFO message
	(*3) informative text (will occur %PSL-I-...)

	EXAMPLE:
	. do cascInfo^UCGMCU("^UCGMCU(1)","Units recompiled:","UCLIST,UCSTRING")
		will produce:
		Units recompiled:
		PSL-I-PSLBOOT: UCLIST,UCSTRING
		At source code line: 1 in subroutine: ^UCGMCU(1)
	*/
	type String cmperr(),commands(,),m2src()
	type Number lptr = 1
	set m2src(1) = line
	set commands( "INFO", "PSLBOOT") = 1
	do INFO^UCGM( "PSLBOOT", info)
	quit

	// ---------------------------------------------------------------------
public isGroup( local String grp,	// name of group
		local String rtn)	// name of routine
	/* ---------------------------------------------------------------------
	Return whether the named routine is part of the specified PSL Compiler
	group.

	OUTPUTS:
	. $$ =	1 if and only if the routine is part of that PSL compiler group
		0 otherwise

	NOTES:
	. Because the Upgrade group is a proper subset of the Data group, units
		that are in the $$isUpgrade() and $$isData() will both return 1.
		On the other hand $$getGroup() will return a single group for
		its argument.
		So for units in the Upgrade group
			$$isGroup( "Data", unit) ==> 1
		but
			$$getGroup( unit) = "Data" ==> 0
	*/
	quit ({List}$$getList(grp)).contains(rtn)

	// ---------------------------------------------------------------------
	/* Shorthand calls for each of the groups
	*/
public isCompiler( local String rtn) quit $$isGroup("Compiler", rtn)
public isData( local String rtn) quit $$isGroup("Data", rtn)
public isDictionary( local String rtn) quit $$isGroup("Dictionary", rtn)
public isInsensitive( local String rtn) quit $$isGroup("Insensitive", rtn)
public isObject( local String rtn) quit $$isGroup("Object", rtn)
public isUpgrade( local String rtn) quit $$isGroup("Upgrade", rtn)

	// ---------------------------------------------------------------------
public linkAll()
	/* ---------------------------------------------------------------------
	ZLINK all M routines that are part of the PSL compiler.
	This subroutine shall be called by installation programs that are about
	to install PSL compiler elements. Calling this subroutine ensures that
	the installation will use a single, consistent version of the PSL
	compiler to perform the installation.

	This subroutine will also ZLINK a selected list of non-compiler routines
	that are known to be called by the compiler, and that might already have
	been called by the installation process.

	OUTPUTS:
	. All routines that are part of the PSL compiler and the set of routines
		called in phase 1 or later that may already have been called in
		phase 0 are ZLINKed into the current process image.

	NOTES:
	* The following "phase 0" routines are ZLINKed:
		%DBAPI, %ZM, %ZOPEN
	* The current literal PHASE0RELINK list implies a hard-coded list of
		routines, known to be called by TBX. A more caller agnostic
		mechanism would be to add a formal parameter to linkAll that
		specifies the list of routines that the installation process
		has called.
	* Alternatively, an "M only" subroutine could check which non-compiler
		routines that are known to be called do already occur in the
		current image, and need to be ZLINKed. 
	*/
	type literal List PHASE0RELINK = "_DBAPI,_ZM,_ZOPEN"

	do linkList( $$getComList()),linkList( PHASE0RELINK)
	quit

	// ---------------------------------------------------------------------
linkList( local List link)
	/* ---------------------------------------------------------------------
	ZLINK all M routines in the specified list.

	OUTPUTS:
	. All routines in the specified list, excpt the current routine,
		are ZLINKed into the current process image.
	*/
	type Number i

	for i = 1:1:link.count() do {
		type String rtn = link.elementAt(i)
		#ACCEPT CR=11441; DATE=11/23/04; PGM=FSCW
		#BYPASS
		if rtn'=$TEXT(+0) ZLINK rtn
		#ENDBYPASS
	}
	quit

	// ---------------------------------------------------------------------
private needCompile( local String unit,		// name of PSL compiler element
		local  String dir,		// directory (*2)
		public String newCode())	// new M code (*3)
	/* ---------------------------------------------------------------------
	Return if the specified unit in the specified directory needs to be
	recompiled.

	ARGUMENTS:
	(*2) The directory where the .psl file and the .m file reside
		This parameter is currently ignored.
	(*3) The result of the call to the compiler will be available in this
		array, even if the return value = 0. However, if the return value
		equals "", then newCode() will not be defined.

	OUTPUT:
	. $$ = 1 if the compilation was successfull, and the result differs from
		the version stored on disk
	     = 0 if the compilation was successfull, and the result equals the
		version stored on disk
	     = "" if the compilation did not complete (e.g. not .psl file)

	NOTES:
	. Due to some peculiarities of %ZRTNCMP and UCGM, this function needs to
		"normalize" the contents of the stored file and the supplied M
		code before is can be compared. This includes removing trailing
		empty lines, and trailing whitespace.
	*/

	type String oldCode()
	type Number nlp,olp

	/* Use stored .psl as input. If m() does not exist at return, there was
	   no .psl file. Most likely this implies that the unit is still M
	   based.
	   NOTE: This version reads the .psl file here and calls cmpA2A^UCGM.
	   This is done because the AMR05 version of UCGM leaves an empty line at
	   the end of the source code. This shows up as an extra comment line
	   between the original PSL source code, and the v* labels added by the
	   compiler. This will lead to unequal files in all cases. */
	type String proc()
	do cmpF2X^UCGM( unit_ ".psl", .proc)
	if proc.data()=0 quit ""
	for proc=proc("").order(-1):-1 quit:'proc(proc).isNull()  kill proc(proc)
	do cmpA2A^UCGM( .proc, .newCode)

	/* do cmpF2A^UCGM( unit_ ".psl", .newCode) */
	
	if newCode.data()=0 quit ""

	/* read stored .m file into oldCode() */
	do cmpF2X^UCGM(unit_".m", .oldCode())

	/* Start normalization */
	type Number omax = oldCode("").order(-1)

	/* Replace TAB by SPACE and strip trailing SPACE */
	for olp=1:1:omax set oldCode(olp) = oldCode(olp).translate($CHAR(9)," ").trim(1)
	set nlp=""
	for  set nlp=$o(newCode(nlp)) q:nlp=""  set newCode(nlp) = newCode(nlp).translate($CHAR(9)," ").trim(1)

	/* Discard empty lines at the end of both files */
	for omax = omax:-1:1 quit:'oldCode(omax).isNull()
	set nlp=""
	for  set nlp=newCode(nlp).order(-1) do { quit:nlp.isNull()
		if newCode(nlp).isNull() kill newCode(nlp) quit
		if newCode(nlp) = " ;"  kill newCode(nlp) quit
		set nlp=""
	}

	/* Compare */
	set nlp=""
	for olp = 1:1:omax do {
		set nlp=newCode(nlp).order()
		if nlp="" set olp = omax quit
		if oldCode(olp) = newCode(nlp) quit
		if oldCode(olp)["Copyright",newCode(nlp)["Copyright" quit
		set olp = omax, nlp =""
	}
	quit newCode(nlp).order() '= ""

	// ---------------------------------------------------------------------
public prep(	local String vRtnDir,	// output directory for routines (*1)
		local String %VN,	// Profile Version Number (*2)
		local String vGtmLvl,	// Target GT.M version (*3)
		local String vChrLvl)	// Target charset value (*4)
	/* ---------------------------------------------------------------------
	This subroutine will generate all routines that are needed to bootstrap
	the PSL compiler in an initial environment, or upgrade the PSL compiler
	in an existing environment. To that extend, this subroutine complements
	subroutine boot(): While boot() is used in the target environment, this
	subroutine is used in the originating environment.

	ARGUMENTS:
	(*1) vRtnDir = directory for generated (or copied) routines
		This value is required, but not validated. It is stored in the
		compiler options array that is passed to prepCmp().
	(*2) %VN = Profile version number
		This value is required in an empty environment.
		In an existing environment, an absent parameter will default to
		CUVAR.%VN, which is assumed to be accessable.
	(*3) vGtmLvl = target GT.M version
		This value is optional. If supplied, and non-empty it will be
		stored in the compiler options array that is passed to prepCmp()
	(*4) vChrLvl = target Runtime.charset value
		This value is optional. If supplied, it will be stored in the
		compiler options array that is passed to prepCmp().
		If not supplied, then a value of "" will be stored.

	NOTES:
	. This subroutine calls linkAll() before it prepares any element. This
		ensures a consistent, and recent PSL compiler.
	. This subroutine calls getBootOptions() just like boot(). This ensures
		that the M routine that is included in the distribution will be
		compiled with the same settings as the M routine that will be
		compiled in the bootstrap phase.
	. This subroutine includes TBXDQINT in the list of elements to prepare.
		By including this unit in the preparation, it will show up in
		directory compares. This may help Framework developers to take
		this unit into consideration when Framework related upgrades are
		prepared.
	. The vChrLvl parameter is treated differnetly from the other optional
		parameters. This is due to the fact that boot versions of a
		compiler routine MUST be "charset neutral" with respect to
		case conversions. See UCBYTSTR for details.
	*/
	type literal String SUBROU = "prep^UCGMCU()"

	do linkAll()			// Ensure an up-to-date image

	// Boot the remainder of the PSL compiler, SQL engine, and DBS kernel
	type List comList = $$getList("Compiler")
	type Number elm
	type String unt

	set comList = comList.add( "TBXDQINT", , 0)	// force TBXDQINT

	for elm=1:1:comList.count() do {
		type Primitive co(,)	// compiler options (clean set per call)

		if 'vRtnDir.get().isNull() set co("boot","rtndirectory") = vRtnDir
		if 'vGtmLvl.get().isNull() set co("boot","gtmlevel") = vGtmLvl
		set co("boot","charsetlevel") = vChrLvl.get()	// unconditionally!

		do getBootOptions( .co(,))

		set co("boot","restrictionlevel") = -1	// force restriction level

		set unt = comList.elementAt( elm)
		if $$getGroup(unt) = "Data" quit	// Data not distributed

		catch vEx {
			do info( SUBROU, vEx.toString(), "failed to prepare "_unt)
		}
		do prepCmp( unt, co(,))
		do info( SUBROU, "", "prepared "_unt)
	}
	quit

	// ---------------------------------------------------------------------
public prepCmp( local String unit,		// unit to prepare (*1)
		local Primitive cco(,))		// compiler command options (*2)
	/* ---------------------------------------------------------------------
	If the unit is an M routine, then this subroutine obtains the source by
	reading from an Class IO instance.
	If the unit is a DQ procedure, this subroutine calls $$getSrc^UCXDT25()
	to obtain the PSL source code, and cmpA2A^UCGM() to produce the M code.
	In both cases it writes the returned array to the output directory.

	ARGUMENTS:
	(*1) unit = PSL phase0 or phase1 unit
		The name can either represent a DQ procedure, or an M routine.
	(*2) cco(,) = compiler options
		This array is passed to cmpA2A^UCGM().
		This subroutine checks that cco("boot","rtndirectory") exists,
		and that its value is different from SCAU_CRTNS, SCAU_MRTNS, and
		SCAU_PRTNS.
	THROWS:
	. %PSL-E-PREPARE
		If the subroutine cannot complete the prepare because of reasons
		that it controls (e.g. PRE-condition not met)
	. Any unexpected exception encountered during the preparation
		Exceptions that are expected, such as %PSL-E-IO exceptions, are
		handled internally. All other exceptions are re-thrown.

	*/
	type String dir

	if 'cco("boot","rtndirectory").exists() throw Class.new("Error","%PSL-E-PREPARE,missing output directory")
	for dir = "CRTNS","MRTNS","PRTNS" if cco("boot","rtndirectory") = $$SCAU^%TRNLNM(dir) throw Class.new("Error","%PSE-E-PREPARE,cannot use reserved directory,$SCAU_"_ dir)

	type String dst(), src(), cfe

	if $$isProc^UCXDT25( unit) do {		// DQ Procedure

		//type String rtn = $$getSrc^UCXDT25( unit, .src(), 2)
		type String rtn = $$getSrc^UCXDT25( unit, .src(), 0)

		if rtn.isNull()!(src.data()<10) throw Class.new("Error","%PSL-E-PREPARE,DQ procedure source not found")
		if rtn'=unit throw Class.new("Error","%PSL-E-PREPARE,different names,"_unit_"->"_rtn)

		/* call compile-array-to-file with:
			- src = scr() returned by $$getSrc^UCXDT25()
			- dst = dst() to be written on return
			- labels = ignored
			- methods = ignored
			- commands = cco(,) as passed in and adapted
			- sysmap = ignored
			- cmperr = cfe(), used to check that routine delete is safe
		*/
		do cmpA2A^UCGM( src(), .dst(), , ,  cco(,), , .cfe)

		/* If the compilation was not successful, delete the dst() array
		   */
		if cfe.get().toNumber()>0 throw Class.new("Error","%PSL-E-PREPARE,compilation failure(s)")
	}
	else  do {				// M Routine
		type IO rIo = Class.new( "IO")
		type String %ZI(), %ZR()
		type Number ln

		set %ZI(unit) = ""
		do INT^%RSEL
		if '%ZR(unit).exists() throw Class.new("Error","%PSL-E-PREPARE,routine not found")

		set rIo.directory = %ZR(unit)
		set rIo.fileName  = unit_".m"
		set rIo.openParams = "READ"
		set rIo.recordSize = 32767

		/* The DO-block below is needed to deal with a memory leak issue
		   of PSL. Even though the catch-block can exit the entire ELSE-
		   block, it only cleans up objects that are instantiated AFTER
		   the catch statement. Objects instantatiated BEFORE the catch
		   statement will not be cleaned out, even though the catch
		   statement will "pop" that DO-level. In this case rIo will not
		   be finalized: it is declared inside the block but it is
		   instantiated before the catch statement.
		   */
		do {
			catch rEx {
				do rIo.close()
				if rEx.type'["PSL-E-IO" throw rEx
			}
			do rIo.open()
			for ln=1:1 set dst(ln) = rIo.read()
		}
	}
		
	if dst("").order()="" quit	// nothing to write

	type IO rOutFile = Class.new( "IO")
	set rOutFile.directory = cco("boot","rtndirectory")
	set rOutFile.fileName  = unit_".m"
	set rOutFile.openParams = "WRITE/NEWV"
	set rOutFile.recordSize = 32767

	catch rEx {
		do rOutFile.close()
		throw rEx
	}

	do rOutFile.open()
	type Number lnr = "", pos
	type String txt
	for  set lnr = dst(lnr).order()  quit:lnr=""  do {
		set txt = dst(lnr).translate( 9.char(), " ").trim(1," ")
		if txt.isNull() quit
		set pos = txt.find(" ")
		if pos=0 set txt = txt_" ", pos = txt.length()+1
		if pos<9 set txt = txt.extract(1,pos-2)_ 9.char()_ dst(lnr).extract(pos,txt.length())
		
		do rOutFile.write( txt)
	}
	do rOutFile.close()
	quit

	// ---------------------------------------------------------------------
public prepProc( local String vUnit,	// Unit name
		local String vRtnDir,	// output directory for routines (*2)
		local String %VN,	// Profile Version Number (*2)
		local String vGtmLvl,	// Target GT.M version (*2)
		local String vChrLvl)	// Target Runtime.charset value (*2)
	/* ---------------------------------------------------------------------
	This subroutine is primiarily included to maintain symmetry between the
	boot/bootCmp/bootProc and prep/prepCmp/prepProc entrypoints.
	Instead of calling prepProc() on individual elements, framework
	developers are encouraged to call prep() in order to create a consistent
	set of bootable framework routines.

	ARGUMENTS:
	(*1) vProc = name of unit to prepare
		Can be a procedure or a routine
	(*2) vRtnDir, %VN, vGtmLvl, vChrLvl
		Same as parameters to prep()
	*/
	type literal String SUBROU = "prepProc^UCGMCU()"

	do linkAll()			// Ensure an up-to-date image

	// Set up for perpare of single unit
	type Primitive co(,)	// compiler options

	if 'vRtnDir.get().isNull() set co("boot","rtndirectory") = vRtnDir
	if 'vGtmLvl.get().isNull() set co("boot","gtmlevel") = vGtmLvl
	set co("boot","charsetlevel") = vChrLvl.get()	// unconditionally!

	do getBootOptions( .co(,))

	set co("boot","restrictionlevel") = -1	// force restriction level
	
	do {
		catch vEx {
			do info( SUBROU, vEx.toString(), "failed to prepare "_vUnit)
		}
		do prepCmp( vUnit, co(,))
		do info( SUBROU, "", "prepared "_vUnit)
	}
	quit

	// ---------------------------------------------------------------------
public time( local String vStr)	// string representation of time
	/* ---------------------------------------------------------------------
	Convert String to Time. This function uses String.toTime() to return the
	time. It can be called by the installation routines that would otherwise
	need to call a utility that may not yet be available.
	
	Because all time conversions are in-line, and there are no provisions
	for a time mask, there are no limitiations to the supplied value that
	would yield a result that differs from a call to the time conversion
	utility.
	*/
	quit vStr.toTime()
