//DO NOT MODIFY  PSL ByteString Method library|UCBYTSTR|||||||1
	/*
	ORIG: Frans S.C. Witte, 2006-04-24
	DESC: PSL ByteString Method library

	---- Comments ----------------------------------------------------------
	This unit implements the methods and properties of class ByteString.
	Many methods are derived from UCSTRING.
	In fact, if the current GT.M version does not support Unicode, then
	the implementation of all methods that have an equivalent method in
	class String will call that method.

	If the current GT.M version does support Unicode, then the code
	generated for ByteString methods will depend on the value of $ZCHSET
	at COMPILETIME (!!). Note that this assumes that a consistant, constant
	value will be used for any given compiler environment.

	In addition, special considerations apply with respect to Upgrade rules.
	See appropriate section below.

	Given the above considerations, most code generating subroutines follow
	the pattern below:

	    xxxxxx // implements ByteString.xxxxxx()
		if $$rtChset()="M" do {	// environment not set up for UTF-8
			do xxxxxx^UCSTRING
		}
		else  do {	/ generate code for UTF-8 support
			(code for Unicode version)
		}

	Subroutines generated by this unit will use one of the following
	class-specific prefixes:
	- vBts for ByteString methods
	- vStr for String methods

	---- Upgrade Considerations --------------------------------------------
	Ideally, this unit would belong to the Insensitive group. However, due
	to the potential impact of incorrect code generated by the compiler in
	phase 1, the unit is currenlty placed in the Upgrade group, until we
	have a complete picture of the bootstrap implications.

	The current upgrade rules only deal with MDB/RDB distinctions. We will
	need to define the additional rules for
	- $ZVERSION mismatches between source and target environment.
		This is currently handled by wrapping the detection in a call
		to $$gtmLevel^UCGM(), which supports the
		commands("boot","gtmlevel") override. Due to this override,
		UCBYTSTR (and other units) can generate code for a GT.M version
		that differs from the actual source version, assuming that the
		resulting code is not stored in the standard crtns directory.
	- Once the Framework has its own view, we may also need to deal with
		%VersionID mismatches between source and target.
	- For character set sensitive constructs the code generated for the
		methods String.upperCase() and String.lowerCase() deserves
		special attention: GT.M versions lower than V5.2 will not
		recognize $ZCONVERT(), and GT.M V5.2 and up with $ZCHSET="M"
		can use $ZCONVERT only for 7 bit ASCII values. The code
		generated up to the introduction of UCBYTST has 8 bit
		"characters" in string literals. This will not even compile in
		GT.M V5.2 with $ZCHSET="UTF-8".

	In this particular case, the following observations are made:
	* If the source version does not support Unicode (either due to the
		value of $ZVERSION or due to the value of $ZCHSET), then the .m
		file will
		- contain code that runs on every platform
		- generate incorrect code for ByteStream methods if the target
			environment does support Unicode.
	* If the target version does not support Unicode due to the value of
		$ZVERSION, then the .m file shall not reference $ZCHSET
	* If the target version does not support Unicode due to the value of
		$ZCHSET, then any version of the .m file will run in that target
		environment. However, it will only produce the correct results,
		if the source version is $ZCHSET-aware.
	* If the target environment expects correct treatment of Unicode, and
		the distributed UCBYTSTR.m file does not contain the code that
		can make the disctinction at compile time (i.e. is compiled to
		contain the "IF"-part, not the "ELSE"-part above), then all code
		generated for ByteStream occurrences that are compiled by
		boot^UCGMCU() (i.e. the "phase 1" elements) before the correct
		version of UCBYTSTR.proc is compiled and ZLINKed will
		incorrectly contain the String equivalents.
	The above suggests that there is not a single way to generate the .m
	file that needs to be included in the distribution.

	---- Other Considerations ----------------------------------------------
	Because the implementation of Number.byte() follows the same pattern as
	the ByteString methods, and obeys the same upgrade restrictions, it is
	implemented here instead of in UCNUMBER.

	Similarly, the implementation of String.byteLimitSubstring(),
	String.upperCase() and String.lowerCase( titleCase) will be implemented
	here to reduce the number of units that need to deal with the upgrade
	restrictions and the specifics of pre-Unicode, Unicode, and $ZCHSET.

	---- Revision History --------------------------------------------------
	12/19/06 -Frans S.C. Witte - CRs: 25185 / 25186 / 25187
		Added implementation of Runtime.charsetEncoding

	12/01/06 - Frans S.C. Witte - CRs: 22719 / 20613
		Modified upCase, loCase, and rtChset to deal with boot setting
		(PSL.getSetting("boot","charsetlevel"))

	08/14/06 - Frans S.C. Witte - CRs: 22720 / 22274
		* Added case parameter in call to $$omGet^UCXOBJ().
		* Added $$rtChset(), and modified all method generating code to
		 call it (instead of using compile-time #IF).

	04/24/06 - Frans S.C. Witte - CRs: 22060 / 22061
		Initial version.
	*/
	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	/* ****************************************************************** */
	/* public and private runtime functions                               */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
public rtChset()	// Return current character set at runtime
	/* ---------------------------------------------------------------------
	This function returns the runtime value of the current character set.
	This is slightly different from Runtime.charsetName, because that value
	will be evaluated at compile time, and end up as either the literal "M",
	or the svn $ZCHSET.

	NOTES:
	. This function is primarily intended for use by the compiler itself
		during bootstrap processing: The M routine that will be part
		of the distribution must access the Character Set name in the
		target environment. So it cannot use Runtime.charsetName, as
		that references the Character Set in the source environment.
	. The runtime reference to $ZCHSET is hidden in an M XECUTE command to
		prevent %GTM-E- messages when the routine is ZLINKed in an
		environment based on GT.M V5.1 or below.
	*/
	if 'PSL.getSetting( "boot", "charsetlevel").isNull() quit PSL.getSetting( "boot", "charsetlevel")

	if '$$gtmLevel^UCGM(5.2) quit "M"

	type String chset

	#ACCEPT CR=22270; DATE=2006-07-28; PGM=Frans S.C. Witte; GROUP=XECUTE
	xecute "SET chset=$ZCHSET"

	quit chset

	/* ****************************************************************** */
	/* ByteString method implementations                                  */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
private ascii	// Method: ByteString.ascii(Number position)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.ascii()
	*/
	type public String pslMtd(,)

	type String dummy = $$omGet^UCXOBJ( .pslMtd(,), "String", "ascii", 0)

	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do psl2m^UCPRIM(0,1)	// ... so generate $ascii()
	}
	else  do psl2m(0,1)		// Generate code that supports Unicode
	quit

	// ---------------------------------------------------------------------
private extract	// method: String.extract(Number start,Number end)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.extract()
	*/
	type public String pslMtd(,)

	type String dummy = $$omGet^UCXOBJ( .pslMtd(,), "String", "extract", 0)

	/* If GT.M version does not support Unicode
	   */
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do extract^UCSTRING
	}
	else  do {	// Generate code that supports Unicode
		if PSL.actual(1).isNull() set PSL.actual(1) = 1			// Default to position 1
		if PSL.actual(2).isNull() set PSL.actual(2) = PSL.actual(1)	// Default to 1st parameter
		
		// Optimize this syntax by replacing with the maximum string length
		else  if PSL.actual(2)=("$ZLENGTH("_PSL.objectName_")") set PSL.actual(2) = PSL.maxStringLength
	
		if PSL.actual(1)=PSL.actual(2) set PSL.return="$ZEXTRACT("_ PSL.objectName_ ","_ PSL.actual(1)_")"
		else  set PSL.return="$ZEXTRACT("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"	
	
		if PSL.objectName.isLiteral() set PSL.return = $$toLit^UCSTRING( PSL.return)
	}
	quit

	// ---------------------------------------------------------------------
private find	// Method: ByteString.find(ByteString string,Number start)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.find()
	*/
	type public String pslMtd(,)

	type String dummy = $$omGet^UCXOBJ( .pslMtd(,), "String", "find", 0)

	/* If GT.M version does not support Unicode
	   */
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		set PSL.actual(3) = "", PSL.actual(4) = ""
		do find^UCSTRING
	}
	else  do psl2m(1,2) 		// Generate code that supports Unicode
	quit

	// ---------------------------------------------------------------------
private justify	// Method: ByteString.justify(Number fieldLength)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.justify()
	*/
	type public String pslMtd(,)

	type String dummy = $$omGet^UCXOBJ( .pslMtd(,), "String", "justify", 0)

	/* If GT.M version does not support Unicode
	   */
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		set PSL.actual(2) = "", PSL.actual(3) = "", PSL.actual(4) = ""
		do justify^UCSTRING
	}
	else  do {	// Generate code that supports Unicode
		if PSL.actual(1).isNull(1) set PSL.return = PSL.objectName quit

		do psl2m(1,1)
	}
	quit

	// ---------------------------------------------------------------------
private length	// Method: String.length(String delimiter)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.length()
	*/
	type public String pslMtd(,)

	type String dummy = $$omGet^UCXOBJ( .pslMtd(,), "String", "length", 0)

	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do length^UCSTRING
	}
	else  do {	// Generate code that supports Unicode
		type String char = PSL.actual(1)

		if char.isNull() do {

			set PSL.return="$ZLENGTH("_ PSL.objectName_")"
		}

		else  set PSL.return = "$ZLENGTH("_ PSL.objectName_","_char_")"

		if PSL.objectName.isLiteral() set PSL.return = $$toLit^UCSTRING( PSL.return)
	}
	quit

	// ---------------------------------------------------------------------
private piece	// method: ByteString.piece(ByteString delimiter,Number start,Number end)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.piece()
	*/
	type public String pslMtd(,)

	type String dummy = $$omGet^UCXOBJ( .pslMtd(), "String", "piece", 0)

	/* If GT.M version does not support Unicode
	   */
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		set PSL.actual(4)=""
		do piece^UCSTRING
	}
	else  do psl2m(1,3)	// Generate code that supports Unicode
	quit

	// ---------------------------------------------------------------------
private toPSLExpr	// Method: ByteString.toPSLExpression()
	/* ---------------------------------------------------------------------
	Generate code for ByteString.toPSLExpression()

	NOTES:
	. The subroutine that is constructed for the runtime implementation of
		this method assumes that it can create a single $CHAR(,,,) (or
		$ZCHAR(,,,)) that represents all the characters/bytes in the
		string in case the value contains non-graphics.
		This may be a problem with long strings, especially if they
		contain a significant number of non-ascii characters.
		Furthermore, since the returned value is likely to be used in
		code, the maximum is presumably determined by PSL.maxLineLength
		rather than by PSL.maxStringLength.
	. A more complex algorithm should be able to produce a result that is
		close to the GT.M ZWRITE format (only non-graphics in $ZCHAR()).
	*/
	type literal String label   = "vBtsPslE"

	type String CHAR = $S($$rtChset()="M":"C",1:"ZCH")

	if 'PSL.subrouExists(label) do {
		type PSLBuffer buf = PSL.openBuffer("(ByteString vVal)","ByteString.toPSLExpression")

		do buf.add("type Boolean bValid = 0")
		do buf.add("do {")
		do buf.add("    catch vEx { // catch and ignore %GTM-E-BADCHAR exception")
		do buf.add("    }")
		do buf.add("    set bValid = ({String}vVal)?.ANP")
		do buf.add("}")

		do buf.add("if bValid,({String}vVal).isNumber() quit vVal")
		do buf.add("if bValid quit ({String}vVal).addQuotes()")

		do buf.add("type Number vC")
		do buf.add("type Number vE = ""$"_ CHAR_ "(""_ vVal.ascii()")
		do buf.add("for vC=2:1:vVal.length() set vE=vE_"",""_vVal.ascii(vC)")
		do buf.add("quit vE_"")""")

		do buf.insert(label)
	}

	set PSL.return = "$$"_ label_ "("_ PSL.objectName_ ")"
	quit

	// ---------------------------------------------------------------------
private translate	// Method: ByteString.translate(ByteString expr1,ByteString expr2)
	/* ---------------------------------------------------------------------
	Generate code for ByteString.translate()
	*/
	type public String pslMtd(,)

	type String dummy = $$omGet^UCXOBJ( .pslMtd(), "String", "translate", 0)

	/* If GT.M version does not support Unicode
	   */
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do psl2m^UCPRIM(1,2)	// will generate $TRANSLATE()
	}
	else  do psl2m(1,2)	// Generate code that supports Unicode
	quit

	/* ****************************************************************** */
	/* Number method implementations                                      */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
private byte	// Method: Number.byte()
	/* ---------------------------------------------------------------------
	Generate code for Number.byte()
	*/
	type public String pslMtd(,)

	type String dummy = $$omGet^UCXOBJ( .pslMtd(), "Number", "char", 0)

	set PSL.method = "char"

	/* GT.M version does not support Unicode
	   */
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do psl2m^UCPRIM(0,0)	// will generate $char()
	}
	else  do psl2m(0,0)	// Generate code that supports Unicode
	quit

	/* ****************************************************************** */
	/* Runtime property implementations                                   */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
private chrsetEnc	// Property: Runtime.charsetEncoding
	/* ---------------------------------------------------------------------
	Generate code for Runtime.charsetEncoding.

	If Runtime.charsetName = "UTF-8", then "UTF-8",
	else if the call to $$ENCODING^%CHARSET succeeds, then whatever that
	returns, else guess from:
	- "ISO-8859-15" (if code point 168 is lowercase),
	- "ISO-8859-2" (if code point 177 is lowercase),
	- "DEC-MULTINATIONAL" (if code point 247 is lowercase),
	- "ISO-8859-1" (all others).
	*/
	if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do {
			catch vEx {
				// no $$ENCODING^%CHARSET, try to guess one from
				// ISO-8859-1, ISO-8859-2, ISO-8859-15 and
				// DEC-MULTINATIONAL
				type String lc = $$LC^%CHARSET()
				if lc[168.char()       set PSL.return = "ISO-8859-15"
				else  if lc[177.char() set PSL.return = "ISO-8859-2"
				else  if lc[247.char() set PSL.return = "DEC-MULTINATIONAL"
				else  set PSL.return = "ISO-8859-1"
			}
			set PSL.return = $$ENCODING^%CHARSET()
		}
	}
	else  set PSL.return = $$rtChset()	// Return whatever is the runtime set
	set PSL.return = PSL.return.addQuotes()
	quit

	// ---------------------------------------------------------------------
private chrsetNm	// Property: Runtime.charsetName
	/* ---------------------------------------------------------------------
	Generate code for Runtime.charsetName.

	If the implementation supports $ZCHSET, return "$ZCHSET", else return
	the literal "M".
	*/
	if $$gtmLevel^UCGM(5.2) set PSL.return = "$ZCHSET"
	else  set PSL.return = "M".addQuotes()
	quit

	/* ****************************************************************** */
	/* String method implementations                                      */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
private bytLimSub	// Method: String.byteLimitSubstring ( start, maxBytes)
	/* ---------------------------------------------------------------------
	Generates $ZSUBSTR() for GT.M versions that support Unicode,
	or $$vStrBLS() for others.

	NOTES:
	. This function has a different code pattern than most of the other
		functions. This stems from the fact that the signatures for
		the unicode and non-unicode runtime functions are identical
		and differ only in function name. So the code that deals with
		generating the value of PSL.return will be common.
	. The code that returns a compile-time literal value when the object
		and all supplied parameters are literal has been disabled.
		This is due to the fact that $$toLit^UCSTRING() cannot be called
		if $$rtChset()="M", and any code generated inside UCBYTSTR will
		be based on the value of Runtime.charset at the SOURCE, not at
		the TARGET.
	*/
	type String ZSUBSTR = $S($$rtChset()="M":$$mSubstr(),1:"$ZSUBSTR(")

	// Generate code for all variations
	type PSLExpression start = PSL.actual(1)
	type PSLExpression maxBt = PSL.actual(2)
	type Boolean isLit = 0

	if maxBt.isNull() do {
		//if PSL.objectName.isLiteral(),start.isLiteral() set PSL.return = PSL.objectName.byteLimitSubstring( start.stripQuotes()).addQuotes() quit
		set PSL.return = ZSUBSTR_ PSL.objectName_ ","_ start_ ")"
	}
	else  do {
		//if PSL.objectName.isLiteral(),start.isLiteral(),maxBt.isLiteral() set PSL.return = PSL.objectName.byteLimitSubstring( start.stripQuotes(), maxBt.stripQuotes()).addQuotes() quit
		set PSL.return = ZSUBSTR_ PSL.objectName_ ","_ start_ ","_ maxBt_ ")"
	}

	quit

	// ---------------------------------------------------------------------
private loCase	// Method: String.lowerCase(Boolean capitalizeFirstChar)
	/* ---------------------------------------------------------------------
	Generates $ZCONVERT() for UTF-8, or calls loCase^UCTRING to generate the
	traditional lowercase conversion.

	NOTES:
	. Even though the Unicode GT.M version supports $ZCONVERT() for
		$ZCHSET="M", this subroutine still calls loCase^UCSTRING to
		generate the code, because $ZCONVERT() will only handle 7-bit
		standard ASCII, and the target site may use 8-bit characters.
	*/

	/* If preparing boot version of routine, insert ASCII only conversion
	*/
	type literal String UC = ",""ABCDEFGHIJKLMNOPQRSTUVWXYZ"""
	type literal String LC = ",""abcdefghijklmnopqrstuvwxyz"""

	if PSL.hasSetting( "boot", "charsetlevel"), PSL.getSetting( "boot", "charsetlevel") = "" do {
		set PSL.return = "$TR("_ PSL.objectName_ UC_ LC_ ")"
	}
	/* GT.M version does not support Unicode
	   */
	else  if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do loCase^UCSTRING
	}
	else  do {	// Generate code that supports Unicode
		type String option = PSL.actual(1)
		if option.isNull(1) set option=0	// Default to 0

		if option.isLiteral() set PSL.return = "$ZCONVERT("_ PSL.objectName_ ","_ $S(option:"T",1:"L").addQuotes()_ ")"
		else  set PSL.return = "$ZCONVERT("_ PSL.objectName_ ",$S("_ option_ ":""T"",1:""L""))"
		if PSL.objectName.isLiteral() set PSL.return = $$toLit^UCSTRING( PSL.return)

	}
	quit

	// ---------------------------------------------------------------------
private toByteString	// Method: String.toByteString
	/* ---------------------------------------------------------------------
	This is a no-op method for all implementations.
	The advantage of having is String.toByteString() in addition to type
	casting is that is tends to make the code more readable.
	*/
	set PSL.return = PSL.objectName
	quit

	// ---------------------------------------------------------------------
private upCase // Method: String.upCase	 Returns an upper case string
	/* ---------------------------------------------------------------------
	Generates $ZCONVERT() for UTF-8, or calls upCase^UCTRING to generate the
	traditional uppercase conversion.

	NOTES:
	. Even though the Unicode GT.M version supports $ZCONVERT() for
		$ZCHSET="M", this subroutine still calls upCase^UCSTRING to
		generate the code, because $ZCONVERT() will only handle 7-bit
		standard ASCII, and the target site may use 8-bit characters.
	*/

	/* If preparing boot version of routine, insert ASCII only conversion
	*/
	type literal String UC = ",""ABCDEFGHIJKLMNOPQRSTUVWXYZ"""
	type literal String LC = ",""abcdefghijklmnopqrstuvwxyz"""

	if PSL.hasSetting( "boot", "charsetlevel"), PSL.getSetting( "boot", "charsetlevel") = "" do {
		set PSL.return = "$TR("_ PSL.objectName_ LC_ UC_ ")"
	}
	/* GT.M version does not support Unicode
	   */
	else  if $$rtChset()="M" do {		// Environment does not use Unicode, ...
		do upCase^UCSTRING
	}
	else  do {	// Generate code that supports Unicode
		set PSL.return = "$ZCONVERT("_ PSL.objectName_ ",""U"")"
		if PSL.objectName.isLiteral() set PSL.return = $$toLit^UCSTRING( PSL.return)
	}
	quit

	/* ****************************************************************** */
	/* local subroutines                                                  */
	/* ****************************************************************** */

	// ---------------------------------------------------------------------
mSubstr()	// generate M code for String.byteLimitSubstring()
	/* ---------------------------------------------------------------------
	This subroutine generates the "M version" of $ZSUBSTR().
	*/
	type literal String label   = "vStrBLS"
	type literal String ZSUBSTR = "$$"_ label_ "("

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf = PSL.openBuffer("(String vVal, Number vStart, Number vMax)","String.byteLimitSubstring")

		do buf.add("if 'vMax.exists() quit vVal.extract( vStart, PSL.maxStringLength)")
		do buf.add("quit vVal.extract( vStart, vStart+vMax-1)")

		do buf.insert(label)
	}
	quit ZSUBSTR

	// ---------------------------------------------------------------------
psl2m(	Number minArg,	// minimum number of arguments	/REQ/MECH=VAL
	Number maxArg)	// maximum number of arguments	/REQ/MECH=VAL
	/* ---------------------------------------------------------------------
	Support procedure that calls psl2m^UCPRIM() with common permutations:
	- zmethod = "Z"_ method.upperCase()
	- pslMtd( PSL.class. zmethod) = pslMtd( PSL.class, method)

	NOTES:
	. The call to psl2m^UCPRIM() is OK, provided that we trick UCPRIM to
		believe that the current method = zmethod().
		Because psl2m^UCPRIM does look at pslMtd(class,method), we must
		create that entry, but we do that for this call only, because we
		do not want to allow a ByteString.zmethod() method
	*/
	type public String pslMtd(,)	// pslMtd(class,method) = data

	type String zmethod = "Z"_ PSL.method.upperCase()

	set pslMtd( PSL.mclass, zmethod) = pslMtd( PSL.mclass, PSL.method)
	set PSL.method = zmethod
	do psl2m^UCPRIM( minArg, maxArg)
	kill pslMtd( PSL.mclass, zmethod)
	quit
