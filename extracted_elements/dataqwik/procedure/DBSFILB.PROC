//DO NOT MODIFY  Filer code generator|DBSFILB|||||||1
DBSFILB	/* Utility to generate DATA-QWIK filer code
	Copyright(c)2003 Sanchez Computer Associates, Inc.  All Rights Reserved - 10/01/03 13:40:04 - GIRIDHARANB

	ORIG: FSANCHEZ - 11/11/2003
	DESC: Filer code generator

	---- Comments --------------------------------------------------------

	This routine is a rewrite of the pre-existing DATA-QWIK filer DBSFILB
	converted to PSL and with numerous performance optimizations.

	---- Revision History ------------------------------------------------
	
	07/30/07 - RussellDS - CR28507
		   Added code to save label to trigger map in table DBLABELMAP.
		   
		   Modified LOG section to only set user info for DBS elements
		   if the user column was not changed by the client.  This
		   allows external interfaces, such as Profile Application
		   Workbench to send the user info.
	
	03/01/07 - RussellDS - CR26386
		   Introduce archiving support - calls DBFILARCH for tables
		   that are archive enabled to generate archive support
		   code.
		   
		   Eliminate remapping of large filers.  Generate to a single
		   procedure.
		   
		   Removed ADDSRC and modified calls to ADD, ADDDOC, and TAG
		   to eliminate public scope variables.
		   
		   Remove old revision history.
		   
	04/06/07 - Giridharanb - CR 26108
		   Modified section compile to correct the description of PSL
		   error thrown where the Record being modified does not exist.
	
	08/17/06 - RussellDS - CRs: 22719 /20613
		   Modify handling of call to initPar^UCUTILN in generated code
		   to provide input parameter that indicates parameters are
		   already normalized and no call is needed.
		   
		   Remove check for %O="" from generated code since all code
		   now generated by PSL will ensure that vobj(,-2) is set.
		   
		   Remove all skip warning code.  Allow this to all be handled
		   at this point by UCOPTS.
		   
		   Replace references to OBJGBL^UCUTIL with getGbl^UCXDD.
		   
		   Modified code generated to call VOBJ^DBSDBASE to handle
		   new parameters.
		   
		   Correct format of vlist for passing to EXECUTE^%DBAPI and
		   checking of return value.
		   
		   Modified code generated for vlegacy section to fix problem
		   when %ProcessMode = 0 not creating indexes.
	
	06/15/06 - RussellDS - CR21912
		   Modify generation of M database save code to use new PSL
		   getSaveCode method to correct problems with saving of
		   memo/blob fields and clean up code.
		   
		   Modify code to generate cascade delete for RDB since cannot
		   just depend on RDB cascade delete logic because there may be
		   delete related triggers that need to be fired.
		   	
		   Added coding to deal with negative node subscripts, like in
		   table DBTBL2.
		   
		   Removed old revision history.
		   
	05/19/06 - RussellDS - CR21340
		   Modified vdelete section to honor filer parameters.
	
	05/17/06 - RussellDS - CR21382
		   Modify to recognize /NOLOG qualifier to avoid calls to
		   ^DBSLOGIT.
	
	05/11/06 - RussellDS - CR21235
		   Error in syntax for VCASDEL comment that made remapping
		   not work.
	
	05/05/06 - RussellDS - CR21137
		   Correct error in remapping logic for VIDXPGM tag.  Was not
		   getting built if not remapped.
	
	04/06/06 - RussellDS - CR20602
		   Set skipwarn in BUILDALL section to avoid undefined.  Extend
		   skipwarn comment.
		   
		   Modify remapping logic to avoid issues when line is not
		   tracked correctly since all code is not added to SOURCE.
		   
		   Add CR to generated ACCEPT statements.
	
	02/25/06 - RussellDS - CR19065
		   Modify COMPILE section to return PGM.
	
	02/22/06 - RussellDS - CR19723
		   Modified generated code to update to always call vregu.
		   Previously was using vreqn section, but change in logic
		   will now only check required fields on update if they
		   have been modified.
	
	02/15/06 - RussellDS - CR19556
		   Use SchemaColumn instead of DBTBL1D references.
	
	01/12/06 - RussellDS - CR18994
		   Add call to AUDIT^UCUTILN for %O = 0 mode since need the
		   information to pass to ^DBSLOGIT.  Use vxins array instead
		   vx to avoid issues with checks on vx.
	*/
	
	//I18N=OFF

	quit

	
COPY(	String from(),	 	// Append from array
	String to(),		// Append to array
	String commands(,),	// PSL commands array
	String PGMS)		// Generated program name(s)	/MECH=REFNAM:W
	
	/*
	Append from() to to()
	*/
	
	if from("").order().isNull() quit		// Nothing to append

	type public String PSFILE

	type Number n = ""
	type Number line = to("").order(-1)

	set line = line+1,to(line) = "",line = line+1
	for  set n = from(n).order() quit:n.isNull()  set to(line) = from(n),line = line+1
	quit
	
	
BUILDALL	 // Build All Run-Time Filer Routines
  
	type ResultSet rs = Db.select("FID","DBTBL1","UDFILE IS NOT NULL")
	while rs.next() do COMPILE(rs.getCol("FID"))
	quit


BUILD	 // Build Run-Time Filer Routine

	type Number COUNT
	type String fid, RM
	
	set COUNT = $$LIST^DBSGETID("DBTBL1")			// Interactive select
	quit:'COUNT
	
	type ResultSet tmpdqrs=Db.select("ELEMENT","TMPDQ","PID=:%ProcessID")
	
	while tmpdqrs.next() do {
        	
        	set fid=tmpdqrs.getCol("ELEMENT")
	
		type SchemaTable tblrec = Db.getSchemaTable(fid)
		
		// Error message only if selected a single table
		if tblrec.filerPGM.isNull() do { quit
			if COUNT=1 set RM = $$^MSG(3056,fid) write !,$$MSG^%TRMVT(RM)
		}
		
		do COMPILE(fid)
	}
	
	do Db.delete("TMPDQ", "PID=:%ProcessID")

	quit


public COMPILE(String PSFILE,	 	// Table name
	       Boolean NLU,		// No longer used [*]
	       String commands(,),	// PSL commands array		/NOREQ/MECH=REFARR:R
	       String PGMS)		// Generated program name(s)	/NOREQ/MECH=REFNAM:W
	       
	/*
	Compile code
	
	ARGUMENT NOTES:
	
		. NLU		Parameter retained for backward compatibility
	*/
	
	catch ERROR {
		
		type Number ER=0
		type Number %ZTDY=0	// Scrolled display of error
		type Boolean %ZTHANG=0	// Don't wait for <CR> request
		
		write ?10," *** Compile error - see following error log entry",!
		
		do ZE^UTLERR
		
		write !
	}

	if 'Db.isDefined("DBTBL1","%LIBS='SYSDEV',FID=:PSFILE") write " Aborted - Table does not exist: ",PSFILE quit
	write !,PSFILE

	type public Number ER = 0
	type public String RM

	type String %LIBS = "SYSDEV"
	type String cmperr
	
	type Boolean hasLits, hasNegNd, vreqsec

	type Number i,del,n,sourceH

	type String code,delstr,di,gbl,key,keys,keywhr,lvn,partbl,rectyp,tag,z
	type String arch(),archtbl, casdel(),ctl(),dft(),jrn(),keytrgs(),labelmap()
	type String sections(),vddver(),vkchg(),vreq(),vsts(),vtrg(),zfkys(),zindx()
	type String SOURCE()

	type String file = PSFILE
	type SchemaTable tblrec = Db.getSchemaTable(file)

	type String INDEXPGM = tblrec.filerPGM
	if INDEXPGM.isNull() write " Aborted - filer program is NULL" quit
	
	set PGMS = INDEXPGM

	type Boolean isRDB = $$rdb^UCDB(file)

	type String objName = file.translate("_").lowerCase()
	
	type ResultSet rs = Db.select("DISTINCT TABLE", "SYSMAPLITDTA", "TABLE=:file")
	if rs.isEmpty() set hasLits = 0
	else  set hasLits = 1

	do ADD(.SOURCE(), INDEXPGM_"(Record"_file_" "_objName_", String vpar, Boolean vparNorm) // "_file_" - "_tblrec.description_" Filer")
	do ^SCACOPYR(.z)
	do ADD(.SOURCE(), " // "_z.piece(";;",2,z.length()))
	do ADD(.SOURCE(), " // Generated from DATA-QWIK schema in: "_$$CURR^%DIR_"  by: "_$$PGMDIR($T(+0)))
	do ADD(.SOURCE(), "")

	set sourceH = SOURCE("").order(-1)		// Mark location
	
	/* Note FRMFILER is only used when trigger code in one filer needs to signal to
	   another filer, where that filer will base what it does on the flag.  It is
	   not set automatically, but is available for use by developers.
	*/	

	do ADD(.SOURCE(), " /*")
	do ADD(.SOURCE(), "  vpar      Runtime qualifiers:      /NOREQ/MECH=REFARR:R")
	do ADD(.SOURCE(), "")
	do ADD(.SOURCE(), "  /[NO]CASDEL   - Cascade delete")
	do ADD(.SOURCE(), "  /[NO]FRMFILER - Called from another filer")
	do ADD(.SOURCE(), "  /[NO]INDEX    - Update Indexes")
	do ADD(.SOURCE(), "  /[NO]JOURNAL  - Journal update")
	do ADD(.SOURCE(), "  /[NO]TRIGAFT  - After update triggers")
	do ADD(.SOURCE(), "  /[NO]TRIGBEF  - Before update triggers")
	do ADD(.SOURCE(), "  /[NO]UPDATE   - Update primary table")
	do ADD(.SOURCE(), "  /[NO]VALDD    - Validate column values")
	do ADD(.SOURCE(), "  /[NO]VALFK    - Validate foreign keys")
	do ADD(.SOURCE(), "  /[NO]VALREQ   - Validate not null values")
	do ADD(.SOURCE(), "  /[NO]VALRI    - Validate transaction integrity")
	do ADD(.SOURCE(), "  /[NO]VALST    - Validate database state")
	do ADD(.SOURCE(), " */")
	do ADD(.SOURCE(), "")
	
	#IF %VersionID<7
	// P01 still depends on ER and RM from the filers
	do ADD(.SOURCE(), " type Public Number ER = 0")
	do ADD(.SOURCE(), " type Public String RM")
	do ADD(.SOURCE(), "")
	#ENDIF
	
	do ADD(.SOURCE(), " type public String verrors()")
	do ADD(.SOURCE(), "")
	
	#IF %VersionID<7
	// Add catch block for P01 error handling of DBFILER errors - rethrow GT.M errors
	do ADD(.SOURCE(), " catch fERROR {")
	do ADD(.SOURCE(), "  if fERROR.type=""%PSL-E-DBFILER"" do {")
	do ADD(.SOURCE(), "   set ER = 1")
	do ADD(.SOURCE(), "   set RM = fERROR.description")
	do ADD(.SOURCE(), "  }")
	do ADD(.SOURCE(), "  else  throw fERROR")
	do ADD(.SOURCE(), " }")
	#ENDIF
	
	set gbl = tblrec.global
	set keys = tblrec.primaryKeys
	set rectyp = tblrec.recordType
	set del = tblrec.columnDelimiter
	if 'isRDB set archtbl = tblrec.getArchiveTable()
	else  set archtbl = ""
	
	// If table has negative nodes (like DBTBL2), need to remap "v" node
	// when going between vobj and global
	if tblrec.nodeQuotedList.isLike("%""v%") set hasNegNd = 1
	else  set hasNegNd = 0

	if 'del.isNull() do {
	
		if (del < 32) ! (del > 127) set delstr = "$C("_del_")"
		else  set delstr = del.char().addQuotes()
	}
	
	if isRDB set rectyp=$$RDBRCTYP(file)

	set gbl = $$getGbl^UCXDD(tblrec,objName)
	// If has archive reference, remove it.  Filer does not use it and
	// vobj(,-99) is not always passed in, e.g., on a Class.new
	if gbl.extract(1, 2) = "^|" set gbl = "^"_gbl.piece("|", 3, gbl.length())
	if gbl.endsWith(",") set gbl = gbl.extract(1, gbl.length() - 1)
	set keywhr = $$KEYWHR(file,keys,objName,isRDB,0)

	// Find the parent table of this table to support Db.isDefined() method
	// properly.  This should be fixed in isDefined itself.
	set partbl = $$PARTBL(file,tblrec)		// Top of hierarchy

	do ADD(.SOURCE(), " type String vx(), vxins()","audit column array")
	do ADD(.SOURCE(), " type Number %O = "_objName_".getMode()","Processing mode")
	do ADD(.SOURCE(), " set vpar = vpar.get()", "Initialize vpar")
	
	do ADD(.SOURCE(), "", "")
	if 'archtbl.isNull() do {
	
		do ADD(.SOURCE(), "", "Cannot modify records in archive file")
	
		set code = " if (%O '= 2), (vpar '[ ""NOUPDATE""), "
		set code = code_$$getCHECK^DBSFILARCH(file, archtbl, objName)
		// fix this once get error #
		set code = code_" throw Class.new(""Error"",""%PSL-E-DBFILER,""_$$^MSG(6906).replace("","",""~""))"
		
		do ADD(.SOURCE(), code)
		do ADD(.SOURCE(), "", "")
	}

	/* Need to call AUDIT^UCUTILN even in insert mode to make sure that vobj
	   -100 level is updated correctly.  Use different vx array for insert vs.
	   update so that can pass to DBSLOGIT, but don't mess with other vx
	   checking that is related only to update mode.
	*/
	do ADD(.SOURCE(), " if %O = 0 do AUDIT^UCUTILN("_objName_",.vxins(),"_rectyp_","_delstr_")")
	set z = " if %O = 1"
	if rectyp>1 set z = z_" quit:'"_objName_".isChanged() "
	set z = z_" do AUDIT^UCUTILN("_objName_",.vx(),"_rectyp_","_delstr_")"
	do ADD(.SOURCE(), z)
	do ADD(.SOURCE(), "")
	
	// Index code
	if 'isRDB  do {	quit:ER					// Skip for RDB
		type ResultSet rs = Db.select("FID","DBTBL8","FID = :file")
		if 'rs.isEmpty() do ^DBSINDXB(file,.zindx())	 // Index file logic
	}

	do DEFTBL^DBSTRG(PSFILE,.dft(),tblrec)			// Default logic
	if dft set sections("vinit")=""
	
	if 'isRDB do {
		do REQUIRD^DBSTRG(PSFILE,.vreq(),tblrec)	// Required logic (if GT.M)
		if 'vreq("").order().isNull() set sections("vreq")=""
	}
	
	do VDD^DBSTRG(PSFILE,.vddver(),tblrec,isRDB) quit:ER	// Validate data types
	if 'vddver("").order().isNull() set sections("vddver")=""

	do ^DBSJRNC(file,.jrn())				// Journal file logic
	if ER write " Aborted - journal error - ",RM,! quit
	
	// Archive code
	if 'archtbl.isNull() do { quit:ER

		if 'archtbl.isNull() do ^DBSFILARCH(file, archtbl, .arch())
		if ER write " Aborted - archive error - ", RM, !
	}

	// Trigger definitions
	do COMPILE^DBSTRG(file,.vtrg(),.vsts(),.keytrgs(),isRDB,tblrec,.labelmap())

	if 'isRDB do FKEYS^DBSTRG(file,.zfkys(),tblrec)		// Foreign key logic	
	
	do CASDEL^DBSTRG(file,.casdel(),tblrec)			// Cascade delete logic

	// Add statistical documentation
	do ADDDOC(.SOURCE(), .sourceH, .vddver, "1D")
	do ADDDOC(.SOURCE(), .sourceH, .vtrg, 7)
	do ADDDOC(.SOURCE(), .sourceH, .zindx, 8)
	do ADDDOC(.SOURCE(), .sourceH, .jrn, 9)

	do ADD(.SOURCE(), " if 'vparNorm.get() set vpar = $$initPar^UCUTILN(vpar)","Run-time qualifiers")

	// Define access keys as local variables to support legacy	
	if 'keys.isNull(),'vsts("").order().isNull() do {
	
		do ADD(.SOURCE(), "")
		do ADD(.SOURCE(), " // Define local variables for access keys for legacy triggers")
		for i = 1:1:keys.length(",") do {

			type String di = keys.piece(",",i)
			type String var = di.translate("_").upperCase()

			do ADD(.SOURCE(), " type String "_var_" = "_objName_"."_di.lowerCase())
		}
	}

	do ADD(.SOURCE(), "")

	type Number savLine = SOURCE("").order(-1)
	set SOURCE(savLine+100) = ""			// Save 100 lines for control block
	do ADD(.SOURCE(), " quit")
	
	/* Code to support legacy calls from ^DBSFILER for integrity checks and ^DBSDF9
	   to rebuild DQ control filers -- note that this can be removed once no longer
	   needed by legacy code.  These are the only callers expected.  Do not add
	   any others without a careful review of this code.  Note that DBSDF9 in P04
	   and beyond no longer calls vlegacy.
	*/
	do {
		type String keylist = ""
		
		do TAG(.SOURCE(), "vlegacy(Number %ProcessMode,String vpar) // Legacy interface (^DBSDF9 for %O=0, EXT^DBSFILER for %O = 2)")

		// Define keys -- they will be public
		if 'keys.isNull() do {
			for i = 1:1:keys.length(",") do {
				type String di = keys.piece(",",i)
				type String var = di.translate("_").upperCase()
				do ADD(.SOURCE(), " type public String "_var)
				set keylist=keylist_var_"=:"_var_","
			}
		}
		
		set keylist=keylist.extract(1,keylist.length()-1)
		do ADD(.SOURCE(), "")
		do ADD(.SOURCE(), " type Record"_file_" "_objName_" = Db.getRecord("""_file_""","""_keylist_""")")
		do ADD(.SOURCE(), " if (%ProcessMode = 2) do {")
		do ADD(.SOURCE(), "  do "_objName_".setMode(2)")
		do ADD(.SOURCE(), "")
		do ADD(.SOURCE(), "  do "_INDEXPGM_"("_objName_",vpar)")
		do ADD(.SOURCE(), " }")
		if 'zindx("").order().isNull() do ADD(.SOURCE(), " else  do VINDEX("_objName_")")
		do ADD(.SOURCE(), "")
		do ADD(.SOURCE(), " quit")
	}
	
	// Add function to return indicator if table involved in literals or not
	if hasLits do {
		do TAG(.SOURCE(), "vLITCHK() quit 1 // Table has columns involved in literals")
	}
	else  do TAG(.SOURCE(), "vLITCHK() quit 0 // Table does not have columns involved in literals")

	do TAG(.SOURCE(), "vexec // Execute transaction")

	do ADD(.SOURCE(), " type public Number %O")
	do ADD(.SOURCE(), " type public String vpar,vobj(),vx(),vxins()")
	do ADD(.SOURCE(), "")
	do ADD(.SOURCE(), " type public Record"_file_" "_objName)
	do ADD(.SOURCE(), "")
	do ADD(.SOURCE(), " type String vERRMSG")
	do ADD(.SOURCE(), "")
	
	// 7932 = Record Not Defined; 2327 = Record already exists
	do ADD(.SOURCE(), " if vpar[""/VALST/"" if '(''Db.isDefined("""_partbl_""","""_keywhr_""") = ''%O) set vERRMSG = $$^MSG($select(%O:7932,1:2327)) throw Class.new(""Error"",""%PSL-E-DBFILER,""_vERRMSG.replace("","",""~""))")

	if 'zfkys("").order().isNull() do {
		do ADD(.SOURCE(), " if vpar[""/VALFK/"" do CHKFKS","Check foreign keys")
		do ADD(.SOURCE(), " if vpar[""/VALRI/"" do VFKEYS","Foreign key definition")
	}
	
	do ADD(.SOURCE(), "")
	do ADD(.SOURCE(), " if vpar'[""/NOUPDATE/"" do {")
	
	do MAIN(file,tblrec)	// Build main update code

	if 'jrn("").order().isNull() do {
		type Number saveline
		do ADD(.SOURCE(), "")
		do ADD(.SOURCE(), "  if vpar[""/JOURNAL/"" do VJOURNAL(."_objName_")","Create journal files",.saveline)
	}
	
	do ADD(.SOURCE(), " }")
	
	// Always update index if requested, regardless of state of UPDATE flag
	if 'zindx("").order().isNull() do {
		type Number saveline
		do ADD(.SOURCE(), "")
		do ADD(.SOURCE(), " if vpar[""/INDEX/"",'(%O = 1)!'vx("""").order().isNull() do VINDEX(."_objName_")","Update Index files",.saveline)
	}
	
	do ADD(.SOURCE(), "")
	do ADD(.SOURCE(), " quit")
	
	// Add procedures to load complete record and create -100 index

	if rectyp>1 do {
		
		/* Need to ensure all data is loaded, so force incremental loading
		   of any remaining data.  Do this directly with globals.  For RDB
		   generate code to load a column from each split table.
		*/
		
		do TAG(.SOURCE(), "vload // Record Load - force loading of unloaded data")
		do ADD(.SOURCE(), " type public Record"_file_" "_objName)
		
		if 'isRDB do {
			type String code, gblref
	
			if gbl.extract(gbl.length())="(" set gblref=gbl_"n)"	// CUVAR style
			else  set gblref=gbl_",n)"
			
			do ADD(.SOURCE(), " type String n = """"")
			if hasNegNd do ADD(.SOURCE(), " type String vn")
			do ADD(.SOURCE(), "")
			do ADD(.SOURCE(), " // Allow global reference")
			do ADD(.SOURCE(), " #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS")
			do ADD(.SOURCE(), " #BYPASS")
			set code = " for  set n=$order("_gblref_") quit:n=""""  "
			if hasNegNd set code = code_"s vn=$S(n<0:""v""_-n,1:n) if '$D(vobj("_objName_",vn)),$D("_gblref_")#2 set vobj("_objName_",vn)=^(n)"
			else  set code = code_"if '$D(vobj("_objName_",n)),$D("_gblref_")#2 set vobj("_objName_",n)=^(n)"
			do ADD(.SOURCE(), code)
			do ADD(.SOURCE(), " #ENDBYPASS")
			do ADD(.SOURCE(), " quit")
		}
		
		else  do {
			
			do ADD(.SOURCE(), " type String X")
			do ADD(.SOURCE(), "")
			
			type ResultSet rs = Db.select("DISTINCT RTBL", "DBMAP", "DB=:%DB AND TBL=:file", "RTBL ASC")
			while rs.next() do {
				type String rtbl = rs.getCol("RTBL")
				
				type ResultSet rs2 = Db.select("COL", "DBMAP", "DB=:%DB AND TBL=:file AND RTBL=:rtbl")
				
				if rs2.next() do {
					
					type String column = rs2.getCol("COL")
					
					do ADD(.SOURCE(), " set X = "_objName_"."_column)
				}
			}
			
			do ADD(.SOURCE(), " quit")
		}
	}

	do TAG(.SOURCE(), "vdelete(Boolean vkeychg) // Record Delete")
	do ADD(.SOURCE(), " type public String vobj(),vpar")
	if isRDB do ADD(.SOURCE(), " type String vlist")
	do ADD(.SOURCE(), " type public Record"_file_" "_objName)
	do ADD(.SOURCE(), "")
		
	if isRDB do {
		do ADD(.SOURCE(), " type Boolean vER")
		do ADD(.SOURCE(), " type String vRM")
		if 'keys.isNull() do {
			type Number i
			type String code = ""
			for i = 1:1:keys.length(",") set code = code_"vkey"_i_","
			set code = " type String "_code.extract(1, code.length() - 1)
			do ADD(.SOURCE(), code)
		}
	}
	
	if rectyp>1 do {
		do ADD(.SOURCE(), " if 'vkeychg.get(),"_objName_".isChanged() throw Class.new(""Error"",""%PSL-E-DBFILER,Deleted object cannot be modified"")")
		do ADD(.SOURCE(), "")
	}

	#IF CUVAR.PUBLISH
	if 'tblrec.publishPGM.isNull() do ADD(.SOURCE(), " if '(%SVCHNID.get() = 5) do "_tblrec.publishPGM)
	#END

	if 'casdel("").order().isNull() do {
		type Number saveline
		do ADD(.SOURCE(), " if vpar[""/CASDEL/"" do VCASDEL","Cascade delete",.saveline)
	}
	if 'zindx("").order().isNull() do {
		type Number saveline
		do ADD(.SOURCE(), " if vpar[""/INDEX/"" do VINDEX(."_objName_")","Delete index entries",.saveline)
	}
	if 'jrn("").order().isNull() do {
		type Number saveline
		do ADD(.SOURCE(), " if vpar[""/JOURNAL/"" do VJOURNAL(."_objName_")","Create journal entries",.saveline)
	}
	if tblrec.isAutoLog do ADD(.SOURCE(), " if vpar'[""/NOLOG/"" do ^DBSLOGIT("_objName_",3)")

	if 'isRDB do {

		set z=" kill " 
		if rectyp<10,'(tblrec.hasMemo!tblrec.hasBlob) set z = " ZWI "
		if 'tblrec.primaryKeys.isNull() do {
			do ADD(.SOURCE(), "")
			do ADD(.SOURCE(), " // Allow global reference - Delete record")
			do ADD(.SOURCE(), " #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; Group=BYPASS")
			do ADD(.SOURCE(), " #BYPASS")
			do ADD(.SOURCE(), z_gbl_")")
			do ADD(.SOURCE(), " #ENDBYPASS")
		}
	}

	else  do { quit:ER

		type Number cnt
		type String sql()
		
		if keys.isNull() do {
			do ADD(.SOURCE(), " set vlist=""""")
		}
		else  do {
			type String code = ""
			for i = 1:1:keys.length(",") do {
				
				type Boolean isNum = 0
				type String di = keys.piece(",",i)
				
				type SchemaColumn rec = Db.getSchemaColumn(file, di)
				
				if 'rec.dataType.isNull(),"N$L"[rec.dataType set isNum = 1
				
				if 'code.isNull() set code=code_"_"_delstr_"_"
				set code=code_objName_"."_di.lowerCase()
				do ADD(.SOURCE(), " set vkey"_i_"="_objName_"."_di.lowerCase())
			}

			do ADD(.SOURCE(), " set vlist="_code_"_"_delstr)
		}
		
		if keywhr.isNull() set sql(1) = "DELETE FROM "_file
		else  if 'isRDB set sql(1) = "DELETE FROM "_file_" WHERE "_keywhr
		else  do { quit:ER
			
			type String keywhrn, nattable
			
			set keywhrn = $$KEYWHR(file, keys, "", 1, 1, .nattable)
			
			// Handle wide tables (one table split into multiple)
			for cnt = 1:1:nattable.length(",") set sql(cnt) = "DELETE FROM "_nattable.piece(",", cnt)_" WHERE "_keywhrn
		}
		
		set cnt = ""
		for  set cnt = sql(cnt).order() quit:cnt.isNull()  do {
			do ADD(.SOURCE(), " set vER = $$EXECUTE^%DBAPI("""","_sql(cnt).addQuotes()_","_delstr_",vlist,.vRM)")
			do ADD(.SOURCE(), " if (vER<0) throw Class.new(""Error"",""%PSL-E-DBFILER,""_vRM.get().replace("","",""~""))")
		}
	}

	do ADD(.SOURCE(), " quit")
	

	if dft do COPY(.dft(), .SOURCE(), , .PGMS)	// Default section
	do COPY(.vreq(), .SOURCE(), , .PGMS)		// Required items
	do COPY(.zfkys(),.SOURCE(), , .PGMS)		// Foreign key definition
	
	do COPY(.vtrg(), .SOURCE(), .commands(,), .PGMS)		// Trigger definition
	do COPY(.vddver(), .SOURCE(), .commands(,), .PGMS)	// Column validation
	do COPY(.jrn(), .SOURCE(), .commands(,), .PGMS)	// Journal definitions	
	do COPY(.zindx(), .SOURCE(), .commands(,), .PGMS)	// Index definitions
	do COPY(.arch(), .SOURCE(), .commands(,), .PGMS)	// Archive code

	/*
	The key change logic code must be generated after the trigger code is copied,
	because the before update and after update triggers are called by the key
	change logic and the proper address is needed.
	*/

	set vreqsec = sections("vreq").exists()
	// Key changed logic
	do KEYCHG^DBSTRG(file,.vkchg(),tblrec,.vsts(),.keytrgs(),vreqsec,.sections(),rectyp,isRDB)

	do COPY(.vkchg(), .SOURCE(), , .PGMS)

	/*
	The casade delete is not skipped on a relational database. although 
	the "on cascade delete" clause on the foreign key definition at 
	schema creation time will manage it.  That does not, however deal
	with triggers or journals that may be set up for the child table.
	The Db.delete method includes optimizations that will avoid calls
	to the filers if not necessary.
	*/

	if 'casdel("").order().isNull() do {

		set casdel(.1) = "VCASDEL // Cascade delete logic"
		set casdel(.2) = ""
		set casdel(casdel("").order(-1)+1) = $C(9)_"quit"
		do COPY(.casdel, .SOURCE, .commands(,), .PGMS)
	}

	// Generate & insert control blocks
	do CONTROL(file,.ctl(),.sections(),.vsts(),tblrec,isRDB,partbl,keywhr,hasLits)

	set n = ""
	for  set n = ctl(n).order() quit:n.isNull()  set savLine = savLine+1,SOURCE(savLine) = ctl(n)
	
	// Add VIDXPGM function
	if 'zindx("").order().isNull() do TAG(.SOURCE(), "VIDXPGM()"_$C(9)_"quit """_INDEXPGM_""""_$C(9)_"// Location of index program")

	// Call PSL compiler
	do cmpA2F^UCGM(.SOURCE,INDEXPGM,,,.commands(,),,.cmperr,file_"~Filer")

	if +cmperr.get() set ER = 1
	else  do {				// Save label map
		
		type String label
		
		do Db.delete("DBLABELMAP", "TARGET=:INDEXPGM")
		
		set label = ""
		for  set label = labelmap(label).order() quit:label.isNull()  do {
			
			type RecordDBLABELMAP dblm = Class.new("RecordDBLABELMAP", "TARGET=:INDEXPGM,LABEL=:label")
			
			set dblm.elemtype = labelmap(label).piece("|", 1)
			set dblm.elemname = labelmap(label).piece("|", 2)
			
			do dblm.save()
		}
	}
	
	quit


CONTROL(String fid,	// Return procedural code to process required data items
	String code(),
	String sections(),
	String vsts(),
	SchemaTable tblrec,
	Boolean isRDB,
	String partbl,
	String keywhr,
	Boolean hasLits) 

	type Boolean vreqsec = sections("vreq").exists()
	type Number saveline
	type String keys = tblrec.primaryKeys

	// Insert program control logic into saved position for all %O
	
	do ADD(.code(), " if %O = 0 do { quit","Create record control block")
	if sections("vinit").exists() do ADD(.code(), "  do vinit","Initialize column values")
	if vsts("BI").exists() do ADD(.code(), "  if vpar[""/TRIGBEF/"" do "_vsts("BI"),"Before insert triggers")
	if 'isRDB,vreqsec do ADD(.code(), "  if vpar[""/VALREQ/"" do vreqn","Check required")
	if sections("vddver").exists() do ADD(.code(), "  if vpar[""/VALDD/"" do vddver","Check values",.saveline)
	do ADD(.code(), "  do vexec")
	if vsts("AI").exists() do ADD(.code(), "  if vpar[""/TRIGAFT/"" do "_vsts("AI"),"After insert triggers")
	if hasLits do ADD(.code(), "  do SET^UCLREGEN("""_fid_""",""*"")", "Literal references to "_fid_" exist")
	do ADD(.code(), " }")
	do ADD(.code(), "")

	do ADD(.code(), " if %O = 1 do { quit","Update record control block")

	// Check for key change, add call to key change logic
	if 'keys.isNull() do {

		type Number i
		type String z
		
		set z = "  if vx("_keys.piece(",",1).addQuotes()_").exists()"
		for i = 2:1:keys.length(",") set z = z_"!vx("_keys.piece(",",i).addQuotes()_").exists()"
		set z = z_" do vkchged quit"

		do ADD(.code(), z,"Primary key changed")
	}

	if vsts("BU").exists() do ADD(.code(), "  if vpar[""/TRIGBEF/"" do "_vsts("BU"),"Before update triggers")
	if 'isRDB,vreqsec do ADD(.code(), "  if vpar[""/VALREQ/"" do vrequ", "Check required")
		
	do ADD(.code(), "  if vpar[""/VALDD/"" do VDDUX^DBSFILER("""_fid_""",.vx)")
	do ADD(.code(), "  set %O = 1 do vexec")
	if vsts("AU").exists() do ADD(.code(), "  if vpar[""/TRIGAFT/"" do "_vsts("AU"),"After update triggers")
	
	/* Note that checking of SYSMAPLITDTA is done at run-time to simplify overall processing.
	   No need to make sure that if literal is used that the code already exists in the filer
	   to check it, since just need to make sure the filer has the runtime code to check any
	   literals for this table.  This shouldn't be a performance issue since tables that are
	   used with literals have low change rates.  If it turns out to be a problem, could change
	   logic to generate column specific checking. 
	*/
	if hasLits do {
		do ADD(.code(), "  do {", "Check to see if updated columns involved in literal references")
		do ADD(.code(), "   type String vcol, vlitcols()")
		do ADD(.code(), "")
		do ADD(.code(), "   type ResultSet rslits = Db.select(""DISTINCT COLUMN"", ""SYSMAPLITDTA"", ""TABLE='"_fid_"'"")")
		do ADD(.code(), "   while rslits.next()  set vlitcols(rslits.getCol(""COLUMN"")) = """"")
		do ADD(.code(), "")
		do ADD(.code(), "   set vcol = """"")
		do ADD(.code(), "   for  set vcol = vlitcols(vcol).order() quit:vcol.isNull()  if vx(vcol).exists() do SET^UCLREGEN("""_fid_""",vcol)")
		do ADD(.code(), "  }")
	}
	do ADD(.code(), " }")
	do ADD(.code(), "")

	do ADD(.code(), " if %O = 2 do { quit","Verify record control block")
	if 'isRDB,vreqsec do ADD(.code(), "  if vpar[""/VALREQ/"" do vreqn","Check required")
	if sections("vddver").exists() do ADD(.code(), "  if vpar[""/VALDD/"" do vddver","Check values",.saveline)
	do ADD(.code(), "  set vpar = $$setPar^UCUTILN(vpar,""NOJOURNAL/NOUPDATE"")")
	do ADD(.code(), "  do vexec")
	if vsts("AI").exists() do ADD(.code(), "  if vpar[""/TRIGAFT/"" do "_vsts("AI"),"After insert triggers")
	do ADD(.code(), " }")
	do ADD(.code(), "")
	
	do ADD(.code(), " if %O = 3 do { quit","Delete record control block")
	do ADD(.code(), "  quit:'Db.isDefined("""_partbl_""","""_keywhr_""")","No record exists")
	if vsts("BD").exists() do ADD(.code(), "  if vpar[""/TRIGBEF/"" do "_vsts("BD"),"Before delete triggers")
	do ADD(.code(), "  do vdelete(0)")
	if vsts("AD").exists() do ADD(.code(), "  if vpar[""/TRIGAFT/"" do "_vsts("AD"),"After delete triggers")
	if hasLits do ADD(.code(), "  do SET^UCLREGEN("""_fid_""",""*"")", "Literal references to "_fid_" exist")
	do ADD(.code(), " }")

	quit


MAIN(	String file,	 // Build Main Filer Section
	SchemaTable tblrec)
	
	type public Number ER
	type public String PSFILE, RM, SOURCE()

	type Boolean hasNegNd = tblrec.nodeQuotedList.isLike("%""v%")
	type String gblref, gblref1, gblref2, z
	type String keys = tblrec.primaryKeys
	type List MBNodes, NegNodes
	type Number rectyp = tblrec.recordType
	type Number del = tblrec.columnDelimiter

	type String objName = PSFILE.translate("_").lowerCase()
	type String gbl = $$getGbl^UCXDD(tblrec,objName)
	
	// If has archive reference, remove it.  Filer does not use it and
	// vobj(,-99) is not always passed in, e.g., on a Class.new
	if gbl.extract(1, 2) = "^|" set gbl = "^"_gbl.piece("|", 3, gbl.length())
	
	if tblrec.primaryKeys.isNull() do {	// CUVAR style
		
		if hasNegNd set gblref = gbl_"vn)"
		else  set gblref = gbl_"n)"
		set gblref1 = gbl.piece("(",1)
		set gblref2 = gbl
	}
	else  do {
		
		if hasNegNd set gblref = gbl_"vn)"
		else  set gblref = gbl_"n)"
		set gblref1 = gbl.extract(1, gbl.length() - 1)_")"
		set gblref2 = gbl
	}

	type String sn = "vobj("_objName_")"

	type Boolean isRDB = $$rdb^UCDB(PSFILE)
	type Boolean hasMB = (tblrec.hasMemo!tblrec.hasBlob)
	
	// Memos, blobs, and negative nodes have special handling
	set (MBNodes, NegNodes) = ""
	if hasMB do {
		
		type ResultSet rs = Db.select("DI","DBTBL1D","FID = :file and TYP ='B' or TYP = 'M'")

		while rs.next() set MBNodes = MBNodes.add(rs.getCol("DI"), , 0)
	}
	
	// Get list of negative nodes - only need one column per node
	if hasNegNd do {
		
		/* Note - need to use <'0' instead of LIKE '-%' since the M SQL optimizer
		   has problems with that.  Need '0' to avoid possible future problems on
		   the Oracle side since NOD is a text field.  Since this may also get
		   nodes that aren't negative, filter those.
		*/
		type ResultSet rs = Db.select("NOD,DI","DBTBL1D","FID = :file and NOD<'0'")

		while rs.next() do {
		
			if rs.getCol("NOD").beginsWith("-") do {
		
				type PSLColumn colrec = PSL.getPSLColumn(file, rs.getCol("DI"))
		
				set NegNodes = NegNodes.add(colrec.getCurrentNode(1), , 0)
			}
		}
	}
		
	type String sys = tblrec.systemName
	type String cdate = $$LOG(tblrec.dateCreated,sys,"D",objName)
	type String ctime = $$LOG(tblrec.timeCreated,sys,"T",objName)
	type String cuser = $$LOG(tblrec.userCreated,sys,"U",objName)
	type String udate = $$LOG(tblrec.dateUpdated,sys,"D",objName)
	type String utime = $$LOG(tblrec.timeUpdated,sys,"T",objName)
	type String uuser = $$LOG(tblrec.userUpdated,sys,"U",objName)
	
	do ADD(.SOURCE(), "")

	// If the same column us updates for new and update, promote logic
	if 'cdate.isNull(),cdate = udate do ADD(.SOURCE(), " "_cdate) set (cdate,udate) = ""
	if 'ctime.isNull(),ctime = utime do ADD(.SOURCE(), " "_ctime) set (ctime,utime) = ""
	if 'cuser.isNull(),cuser = uuser do ADD(.SOURCE(), " "_cuser) set (cuser,uuser) = ""

	if 'cdate.isNull() do ADD(.SOURCE(), "  if %O = 0 "_cdate)
	if 'ctime.isNull() do ADD(.SOURCE(), "  if %O = 0 "_ctime)
	if 'cuser.isNull() do ADD(.SOURCE(), "  if %O = 0 "_cuser)
	if 'udate.isNull() do ADD(.SOURCE(), "  if %O = 1 "_udate)
	if 'utime.isNull() do ADD(.SOURCE(), "  if %O = 1 "_utime)
	if 'uuser.isNull() do ADD(.SOURCE(), "  if %O = 1 "_uuser)

	if tblrec.isAutoLog do {

		do ADD(.SOURCE(), "  if %O = 0, vpar'[""/NOLOG/"" do ^DBSLOGIT("_objName_",%O,.vxins())")
		do ADD(.SOURCE(), "  if %O = 1, vpar'[""/NOLOG/"" do ^DBSLOGIT("_objName_",%O,.vx())")
		do ADD(.SOURCE(), "")
	}

	if isRDB do { quit

		do ADD(.SOURCE(), "  type String del")
		do ADD(.SOURCE(), "  set del = "_del_".char()")
	 	do ADD(.SOURCE(), "  do VOBJ^DBSDBASE("_objName_",del)")

		#IF CUVAR.PUBLISH
		if 'tblrec.publishPGM.isNull() do ADD(.SOURCE(), "  if '(%SVCHNID.get() = 5)  do "_tblrec.publishPGM)
		#END

	}
	
	// ----- Remaining code is for M database updates ---------------------

	if rectyp>1 do {
		
		do ADD(.SOURCE(), "  type String n = -1")
		do ADD(.SOURCE(), "  type String x")
		if hasNegNd do ADD(.SOURCE(), "  type String vn")
 		do ADD(.SOURCE(), "")
 		
 		do MSAVE(0, tblrec, objName, MBNodes, NegNodes)
 		do MSAVE(1, tblrec, objName, MBNodes, NegNodes)

		
		// Top level for type 11
		if (rectyp = 11) do {
			
			do ADD(.SOURCE(), "  // Allow global reference and M source code")
			do ADD(.SOURCE(), "  #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
			do ADD(.SOURCE(), "  #BYPASS")
			do ADD(.SOURCE(), "  if $D(vobj("_objName_"))"_tblrec.getSaveCode(objName, "", -1))
			do ADD(.SOURCE(), "  #ENDBYPASS")
		}
	}

	if (rectyp = 1) do {
		
		do ADD(.SOURCE(), "  // Allow global reference and M source code")
		do ADD(.SOURCE(), "  #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
		do ADD(.SOURCE(), "  #BYPASS")
		do ADD(.SOURCE(), "  if $D(vobj("_objName_"))"_tblrec.getSaveCode(objName, "", -1))
		do ADD(.SOURCE(), "  #ENDBYPASS")
		
		if hasMB do {
			
			type String nodeRef
			
			// Will only be a single column
			type SchemaColumn colrec = Db.getSchemaColumn(file, MBNodes.elementAt(1))
			
			set nodeRef = colrec.getCurrentNode(1)
			
			do ADD(.SOURCE(), "   // Allow global reference and M source code")
			do ADD(.SOURCE(), "   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
			do ADD(.SOURCE(), "   #BYPASS")
			do ADD(.SOURCE(), "   if $D(vobj("_objName_","_nodeRef_"))"_tblrec.getSaveCode(objName, "*"_MBNodes.elementAt(1), -1))
			do ADD(.SOURCE(), "   #ENDBYPASS")
		}
	}
	
	#IF CUVAR.PUBLISH
	if 'tblrec.publishPGM.isNull() do ADD(.SOURCE(), "  if '(%SVCHNID.get() = 5)  do "_tblrec.publishPGM)
	#END
	
	quit
	
	
MSAVE(Number MODE,		// Record mode (0 or 1)
      SchemaTable tblrec,
      String objName,		// Object name
      List MBNodes,		// Memo/blob nodes
      List NegNodes)		// Negative nodes
      
	type public String SOURCE()
	
	type Number I
	type String col
	
	// Code to file new type 10 or 11 record
	if (MODE = 0) do ADD(.SOURCE(), "  if %O = 0 for  set n = vobj("_objName_",n).order() quit:n.isNull()  do {")
	if (MODE = 1) do ADD(.SOURCE(), "  else  for  set n = vobj("_objName_",-100,n).order() quit:n.isNull()  do {")

	// Handle memos and blobs
	for I = 1:1:MBNodes.count() do {
	
		type String nodeRef
				
		set col = MBNodes.elementAt(I)
				
		type SchemaColumn colrec = Db.getSchemaColumn(tblrec.table, col)
		
		// Strip ,1 from CurrentNode
		if (MODE = 0) do {
			
			set nodeRef = colrec.getCurrentNode(1)
			set nodeRef = nodeRef.extract(1, nodeRef.length() - 2)
		}
		else  set nodeRef = colrec.getOldNode(1)		
		
		do ADD(.SOURCE(), "   if n = "_nodeRef_" do { quit")
		do ADD(.SOURCE(), "    // Allow global reference and M source code")
		do ADD(.SOURCE(), "    #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
		do ADD(.SOURCE(), "    #BYPASS")
		do ADD(.SOURCE(), "    "_tblrec.getSaveCode(objName, "*"_col, MODE))
		do ADD(.SOURCE(), "    #ENDBYPASS")
		do ADD(.SOURCE(), "   }")
	}
	
	// Handle negative nodes
	for I = 1:1:NegNodes.count() do {
		
		type String nodeRef = NegNodes.elementAt(I)
		
		do ADD(.SOURCE(), "   if n = "_nodeRef_" do { quit")
		do ADD(.SOURCE(), "   // Allow global reference and M source code")
		do ADD(.SOURCE(), "   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
		do ADD(.SOURCE(), "   #BYPASS")
		do ADD(.SOURCE(), "    "_tblrec.getSaveCode(objName, nodeRef, MODE))
		do ADD(.SOURCE(), "   #ENDBYPASS")
		do ADD(.SOURCE(), "   }")
	}
	
	// Top level or key - only need to deal with this on update when using -100
	if (MODE = 1) do ADD(.SOURCE(), "   quit:'$D(vobj("_objName_",n))")

	// Handle "non-special" nodes
	do ADD(.SOURCE(), "   // Allow global reference and M source code")
	do ADD(.SOURCE(), "   #ACCEPT DATE=04/22/04; PGM=Dan Russell; CR=20602; GROUP=BYPASS")
	do ADD(.SOURCE(), "   #BYPASS")
	do ADD(.SOURCE(), "   "_tblrec.getSaveCode(objName, "n", MODE))
	do ADD(.SOURCE(), "   #ENDBYPASS")
	do ADD(.SOURCE(), "  }")
	
	do ADD(.SOURCE(), "")
	
	quit


LOG(	String column,	// Procedure to generate PSL code for log columns
	String system,
	String typ,
	String objName)

	if column.isNull() quit ""

	type String return = " set "_objName_"."_column_" = "
	if typ = "D" set return = return_$select(system = "PBS":"%SystemDate",1:"%CurrentDate")
	if typ = "T" set return = return_"%CurrentTime"
	if typ = "U" do {
		
		set return = return_$select(system = "DBS":"%UserName",1:"%UserID")
		
		// For DBS, allow change from external interfaces
		if (system = "DBS") set return = " if '"_objName_".isChanged("""_column_""", ""USER"")"_return
	}

	quit return


PARTBL(	String table,		// Return top of Recordclass hierarchy
	SchemaTable tblrec)

	if tblrec.parentTable.isNull() quit table
	for  set table = tblrec.parentTable,tblrec = Db.getSchemaTable(table) quit:tblrec.parentTable.isNull()
	quit table


KEYWHR(	String table,		// Table name
	String keys,		// Keys
	String objName,		// Object name
	Boolean isRDB,		// Is this a non-M database?
	Boolean asNATIVE,	// Return key query using native names
	String nattable)	// Native database table name
	
	/*
	Return SQL key query
	
	Because a non-M database may remap both table and key names to
	protect reserved words, the flag asNATIVE indicates to use the
	remapping scheme.  In that case, the table name may also change,
	so is returned in nattable.
	
	Note that for a non-M database that a table may also be remapped
	into multiple tables, returning nattable as a list.  The caller
	needs to deal with that issue.
	
	If objName is null, use "vkeyn" for variable assignment.  See
	vdelete coding for RBD.
	*/
	
	type public Boolean ER = 0
	type public String %DB
	
	type Number i
	type String col, di, ret

	if asNATIVE do {		// Remap table
		
		set nattable = table
		do MAP^DBMAP(%DB, .nattable)
	}

	if keys.get().isNull() quit ""

	set ret = ""

	for i = 1:1:keys.length(",") do { quit:ER

		if i>1 set ret = ret_" and "
		set di = keys.piece(",",i).lowerCase()
		set col = di.upperCase()
		
		if isRDB, asNATIVE do {
			
			do MAP^DBMAP(%DB, table, .col)
			
			if ER write " Aborted - ",table,".",col," not in DBMAP", !
		}
		
		if 'ER do {
			if 'objName.isNull() set ret = ret_col_" = :"_objName_"."_di
			else  set ret = ret_col_" =:vkey"_i
		}
	}
	
	quit ret
	

private TAG( String SOURCE(),	// Source code array
	     String pslcode)	// Code to add
	     
	// Inset program line tags
	
	do ADD(.SOURCE(), "")
	do ADD(.SOURCE(), pslcode)
	do ADD(.SOURCE(), "")
	
	quit


ADDDOC(	String SOURCE(),	// Source code array
	Number sourceH,		// Counter
	String record,		// Count and date
	Number element)		// Element to document
	
	if record.get().isNull() quit

	type Number count = record.piece($C(9),1)
	type Date tld = record.piece($C(9),2)
	
	if 'count quit

	set element = "DBTBL"_element

	type RecordDBTBL1 rec = Db.getRecord("DBTBL1","%LIBS='SYSDEV',FID=:element")

	type String cmt = rec.des.extract(1,35)
	set cmt = cmt_" ("_count_") "
	set cmt = cmt.insert(tld.toString(),45)

	set sourceH = sourceH+.1
	set SOURCE(sourceH) = $C(9)_"// "_cmt
	
	quit


private ADD( String code(),		// Code array	/MECH=REFARR:RW
	     String pslcode,		// Code to add
	     String comment,		// Comment	/NOREQ
	     Number line)		// Line number	/NOREQ/MECH=REFVAL:RW
		
	// Add procedural code in the output array

	if 'line.get() set line = code("").order(-1)+1		// Next sequence 

	if 'comment.get().isNull() set pslcode = pslcode_"".justify(55-pslcode.length())_" // "_comment
	
	// Replace leading spaces with tabs if not preformatted
	if pslcode'[$C(9),pslcode.beginsWith(" ") do {
		type Number n
		
		for n=1:1:pslcode.length() quit:pslcode.extract(n)'=" "
		set pslcode=pslcode.replace(" ",$C(9),n-1)
	}	
	
	set code(line) = pslcode
	quit
	
	
private RDBRCTYP(String file)	// Reset record type for RDB

	type Number rectyp = 1

	if $$wide^DBSDBASE(file) set rectyp = 11
	
	quit rectyp


ERR(	String RM,		// Manage error display
	String expr)
	
	//       Tag+Line^Routine, SCA_[System_Name], msg: RM
	
	type public Number ER
	type public String %SN
	
	type String msg()
	
	ZSH "S":msg
	
	set ER=1,RM=msg("S",2)_", SCA_"_%SN.get()_", "_RM.get()
	
	if expr.exists() set expr=" // *ERR* "_RM
	use $P write !,$$MSG^%TRMVT(RM,,1)
	quit
	

PGMDIR(pgm)	// Return the directory location of the object file

	type String %ZE,%ZI(),%ZR()
	set %ZI(pgm) = "",%ZE = ".obj"
 
	do INT^%RSEL
 	quit %ZR(pgm).get()_pgm_".obj"
 	
 	
public SYSMAPLB(String tag,		// Line tag
		String comment)		// Comment on the line
		
	/*
	Used by UCSYSMAP to return the appropriate label reference for
	triggers from filer code being generated.  This information is
	used for storage in the SYSMAP* tables.
	*/
	
	type String RETURN = tag
	
	if tag.extract(1) = "v", comment.isLike("%Trigger%") do {
			
		set RETURN = comment.piece("Trigger", 2).piece("-", 1)
		set RETURN = tag_" (Trigger - "_RETURN.trim(0)_")"
	}
	
	quit RETURN
