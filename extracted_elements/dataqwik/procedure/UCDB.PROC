//DO NOT MODIFY  Class Db methods - DD Group|UCDB|||||||1
	/*
	ORIG: FSANCHEZ - 01/15/98
	DESC: Library of Db methods

	KEYWORDS:

	========================================================================
	Because a separate project to migrate the PSL compiler itself from a set
	of "M routines" to "PSL	procedurer", is not expected to start in the near
	future, but the growing complixity of the MDB/RDB support can be much
	better handled by "PSL" than by "M", this PSL compiler element will be
	migrated on a per-subroutine basis. The code that has not yet been
	migrated is embedded in #BYPASS - #ENDBYPASS blocks. The only purpose
	and justification for these unusally large chunks of #BYPASSed code is
	this slow migration.
	========================================================================

	---- Comments ----------------------------------------------------------
	This unit implements the methods and properties of class Db and class
	Cache.

	Subroutines generated by this unit will use the class-specific
	prefixes "vCa" (Cache) and "vDb" (Db).

	In addition the following non-standard prefixes are used:
	vExNNaYY	labes jumped to in code generated for "advance to next
			row" of Db.isDefined()
	vFetchNN	Fetch result code for Db.select() and Db.selectDbset()
	vLNNaYY		labels jumped to in code generated for "advance to next
			result" of Db.select() and Db.selectDbSet()
	vOpenNN		Open cursor code for Db.select() and Db.selectDbset()

	---- Revision History --------------------------------------------------
	05/16/07 - Frans S.C. Witte - CR: 27486
		* RECNOFL exceptions now put table name in Error.context
		* Removed dead (M) code from previous version of keyVal().
		* Converted getRecPr to PSL.
		* Added support for Cache.getRecord(,,classNew) and
		  Cache.isDefined(,)
		* Added support for pslPrsr("DEBUG","DBIOCOUNT") in getRecSr()
		* Corrected sql2akey() to deal with SQL strlits in whereclause

	04/17/07 - Frans S.C. Witte - CR: 26334
		* Corrected code that uses addm2^UCGM
		* Removed quit after throw to prevent warning

	03/23/07 - RussellDS - CR26386
		* Changes to support archiving
		   - Modified getRecSr to add consideration for purpose node -99,
		     archive directory.
		   - Modified cacheSr to consider archive on incremental loading.
	
	07/02/05 - Frans S.C. Witte - CRs: 25185 / 25186 / 25187
		* Corrected code generated for Db.isDefined when count>1
		* Added code to find more in-line optimizations for Db.isDefined
		  in MDB.
		* Added lvn 'mode' to list of lvns NEWed in vOpen0 for MDB (this
		  lvn is referenced by FLT^SQLCACHE).

	07/27/06 - Frans S.C. Witte - CRs: 22719 / 20613
		* Corrected problem in select when data item protection was used
		  and in call to selSrOpen^UCDBR() for dynamic select with data
		  item protection.
		* Added third parameter in code generated for filer calls, and
		  modified fileQual to call initPar^UCUTILN().
		* delRdb now uses $C(9) in call to $$EXECUTE^%DBAPI()
		* All %PSL-E-SQLFAIL exceptions now include the error message
		  returned by the API, with newline translated into space, and
		  comma into tilde.
		* Rewrote keyVal(), removed RKeyVal() and all code no longer
		  called.
		* Converted procPar() to PSL
		* getRecSr() now uses PSLTable.getUpdateKey() to construct the
		  -151 node.
		* calls to %DBAPI now pass 0 (zero) instead of "" for vIndex.
		* Corrected problem in CacheSr() for tables without primary key.

	07/21/06 - Frans S.C. Witte - CRs: 22273 / 22274
		* Modified isDefined and select to support Unicode change to
		  SQLM for >= and <=.

	06/01/06 - Frans S.C. Witte - CRs: 21397 / 21937
		* Corrected $$hasQual()
		* Rewrote $$filequal() and renamed to $$fileQual().
		* Added support for dynamic qualifier in Db.delete(),
		  Db.insert() and Db.update().
		* Replaced '255' by PSL.maxLitLength (and converted M to PSL).
		* Rewrote select and isDefined to PSL, using new PSLSubrou
		  capabilities. Removed subVar and tagcheck because this code
		  now resides in addExe^UCPSLLR().

	05/24/06 - Frans S.C. Witte - CRs: 21394 / 21395
		* Warnings now reported through warnGroup^UCGM()
		* Added extra check to $$sql2akey()

	05/09/06 - Frans S.C. Witte - CRs: 21101 / 18164
		* Implemented support for /LOG (and /NOLOG) for both MDB and RDB
		* modified Db.fastDelete so it no longer includes the qualifiers
		  /NOINDEX/NOVALFK, and corrected code to deal with non-literal
		  access key specification.
		* SELECT * is now replaced by SELECT $$COLLIST^DBSDD before
		  passing the query to either MDB or RDB. This ensures that the
		  select-list and struct() will all have the same idea about the
		  columns and their order.

	03/21/06 - Frans S.C. Witte - CRs: 20280 / 18164
		* Added access for all private subroutines and functions.
		* Added GROUP to all ACCEPT compiler commands.
		* Corrected MDB delete (table has no primary key, where-clause
		  references undefined row).
		* Implemented $$sql2akey().
		* Corrected RKeyVal() for Db.currVal()
		* Corrected CacheSr()

	11/09/05 - Frans S.C. Witte - CRs: 18163 / 18164
		* The source code is "converted" to PSL. Most subroutines and
		  functions are still #BYPASSed M code.
		* removed history older than 2004-01-01
		* Replaced setScop^UCGM + setType^UCGM by setScope^UCGM
		* Added support for /PSLBOOT qualifier in dynamic select
		* Modified Db.isDefined (for RDB).
		* Rewrote getRecord and LitInst to use functions in UCXDD, which
		  makes them DBI in all aspects.
		* Rewrote Cache to have vobj and voxn code in same place

	08/31/05 - Frans S.C. Witte - CRs: 15592, 17056 / 15593, 17057
		* Replaced literal 1900 by $$getPslVal^UCOPT("maxLineLength")
		  (4 occurrences).
		* Documented subroutine tagcheck, and cleaned variable usage.
		* Subroutine select: support for /PSLBOOT
		* replaced call to TYP^DBSDD with TYP^SQLDD
		* Replaced SchemaTable by PSLTable (comment only)

	06/14/05 - Frans S.C. Witte / RussellDS - CR16346
		* Modified subroutine VIEW() to support parent/child on RDB
		* Modified function $$getGbl()
		* Commented out subroutine getRow (method Db.getRow not defined,
		  and not called from within UC* or ^OBJECT.
		* Commented out function $$query() (only called by getRow)
		* Commented out subroutine BLDRETURN (only called by $$query())
		* Commented out function $$pos() (only called by getList code
		  that has been commented out)
		* Commneted out ET (not called / no trap set)
		* Added $$RgetDef() and $$RgetKey()
		* Commented out subroutine RisDefined (merged with isDefined)
		* Commented out subroutine RgetRecord (merged with getRecord)
		* Commented out BMsel and hasBMtyp (only called by RgetRecord)
		* Eliminate RfastDel section
		* Modify fastDel to call delete for RDB and pass parameters
		  to delete for both RDB and MDB
		* Modify Rdelete to implement TRUNCATE command and direct
		  delete calls, versus filer, when appropriate
		* Modify handling of vEr after calls to %DBAPI to conform to
		  values returned
		* Rework Rdelete section to eliminate unnecessary code
		* Eliminate WHR section - no longer used
		* Subroutine Cache: correct assignment to patch(-6,,,) for type
		  1 tables.
		* Subroutine LitInst moved code that checks M_global
		* Subroutine filequal now calls setPar^UCUTILN(,) to insert
		  defaults or debug related parameters (to handle conflicts)
		* subroutine RkeyVal now generates code that adds SQL quotes for
		  non-numeric literals.

	06/14/05 - GIRIDHARANB / RussellDS - CR16287
		* Modified section RgetRecord to use sql select statements to 
		  load the large object columns.Added sections hasBMTYp,BMsel to 
		  support the above changes.
		* Replaced references to parameter() with sysmap()(2 occurences)
		* Patched section RisDefined to check for CLS for an isDefined
		  on DEP/LN

	03/15/05 - CHENARDP/RussellDS/F.S.C. Witte - CRs 15379, 14919 / 14920
		* Modified isDefined and RisDefined sections to update
		  parameters(#IF" based on isDirctv flag
		* Modified select section to eliminate conditional check on
		  paramters before updating SYSMAP data since it is now always
		  collected.
		* Patch - Modified WHR section to strip outer layer of
		  parens from the value.
		* Modified $$hv() section to handle a list of vsql()
		  entries.
		* Modified selectDyn to call $$RsRdb^UCDBRT(), $$RsDyRT^UCDBRT()
		  and the structures provides by that function in the generated
		  code. Also added code to throw an exception when the cursor
		  open returns a non-zero ER (same behavior as MDB).
		* Removed assignment to struct("open",,,) (not used).
		* Introduced node vobj(rs,-4) to contain the equivalent of
		  vsql("D") at runtime.
		* Subroutines RSelect, OPENLBL, FETCHLBL, map, typmap, and
		  RselDyRT removed (that functionality is now handled by
		  UCDBR.proc and UCDBRT.proc).
		* Changed ERROR^UCGM(.RM) to ERROR^UCGM($G(RM)) (4 occurrences)
		* Subroutine procPar: removed redundant $G() (2 occurrences)
		* Corrected subroutines gblRef and LitInst to handle the literal
		  keys, and to retrieve the (Record) instance at compile time.
		  NOTE that LitInst will not work for Rdb!
		* Db.getList now always produces an error (not documented, no
		  longer supported).
		* ER/RM replaced by vEr/vRm (all RDB code).
		* Subroutine Rdelete: added code line to NEW vEr,vRm
		* splitExpr() now uses a 1900 byte chunk size.
		* subroutines select and selectDyn: added ";=noOpti" marker for
		  lines that shall not be removed by UCPATCH.

	02/16/05 - Frans S.C. Witte - CRs 14185 / 14186
		* Subroutine select: modified code generated for vOpen and vFetch
		  to fetch row only when it is requested (fetch before
		  construct), except for fetch of first row to be able to satisfy
		  ResultSet.isEmpty().
		* Subroutine mapPSLvar: added SQL binary operators (+ - * / > <)
		  as token delimiters when looking for hostvar.
		* Added accessibility of private/public subroutines

	02/15/05 - GIRIDHARANB - CR14419
		* Modified sections Rselect and RselDyRt to include support for
		  the DQMODE parameter (par("DQMODE")=1).
		* Modified section map to correct parsing errors when the columns
		  selected contained a DISTINCT clause.

	02/11/05 - GIRIDHARANB - CR14407
		* Modifed section Rselect to correct errors with column order in 
		  Input select list.
		* Modified section Rdelete to pass the correct where clause to
		  the key select logic.

	01/19/05 - GIRIDHARANB - CR 13233
		* Miscellaneous fixes to section map() to correct reserved check
		  in the 'order by' clause.
		* Modified RisDefined section to correct the sql string 
		  for the isDefined method.
		* Newed Variable 'array' in section Rdelete.
		* Modifed section typmap() to check for "." in column name.
		* Modified section Rkeyval to do a DBMAP check for inc=1.

	01/05/05 - Frans S.C. Witte - CRs 12313 / 12314
		* Subroutines BLDRETURN, map(), rdb(), Rfrmcls(), typmap(),
		  WHR(): Added SPACE before ";" to conform to M standard.
		* Inserted QUIT before first subroutine of this routine.
		* Replaced ^SQLQ(,,,,.0,,.vdd,.vdd) by ^SQLQ(,,,,0,,.fsn,.vdd)
		  (ie ".0" by "0", and first occurrence of "vdd" by "fsn")
		  (4 occurrences).
		* Subroutine selectDyn: fixed code generated for return value of
		  vOpen0() for RDB (object instead of vobj(object)), and value
		  assigned to vobj(object,0) after opening the cursor
		  (vsql instead of 1). Fixed code generated to set
		  vobj(object,-2) ($$vFetch0 instead of $$vOpen0).

	12/16/04 - Frans S.C. Witte - CRs 11445 / 11446
		* Changed $D(commands("WARN",)) to $G(commands("WARN",)
		  (2 occurrences).
		* Subroutine selectDyn(): the lvns used by dynamic select are now
		  checked against and added to type().
		* Function $$ISSFD(): will now quit on ER from ^SQLxxx.

	11/16/04 - Frans S.C. Witte - CRs 11441, 12564 / 11442, 12565
		* Fixed problem in subroutine getList (when pos=0).
		* Fixed problem in subroutine WHR() ('> shall translate to less
		  or equal)
		* Subroutine Get1Row (code for Db.getOneRow) moved from UCDBTX
		  to this routine (and renamed get1Row). Added deprecation
		  warning for this method.
		* Subroutine getSchTab (code for Db.getSchemaTable) copied from
		  subroutine getTable in UCSCHEMA.proc.
		* Added deprecation warnings for Db.insert, Db.nextKey,
		  Db.prevKey, and Db.prevVal.
		* subroutine getLock commented out. (method Db.getLock not defined)
		* Subroutines insert and update: remove new of variable X from
		  the generated code.
		* subroutine Cache: REPLACED if ftype#2 BY if ftype#2 do
		* Subroutine filequal(): filer qualifiers in commands("SQLPARS")
		  are used again when present. Since no part of the compiler will
		  set this node, the net effect will be a no-op in these versions.
		  The presence of this statement ensures compatibility with
		  p01rel03_01 (where the compiler does set this node).
		* Subroutine isDefined: Moved code that decomposes accesskey to
		  separate function (akey2sql()). Requirement that all keys are
		  supplied is now restricted to two-argument form.
		* Subroutine akey2sql(): modified $TR(val,"""","'") to
		  $$QADD^%ZS($$QSUB^%ZS(val,""""),"'") (in case constant includes
		  one of the quote characters).
		* Subroutine mapPSLvar(): removed "fif" parameter from call to
		  $$valExpr^UCGM().
		* Multiple subroutines: code that generates runtime exception now
		  conforms to new Error.type layout: %PSL-E-error.

	11/11/04 - RussellDS - CR13190 (P04) / CR13911 (P01)
		     Corrected additional issue related to return on dynamic
		     select from vOpen0 for RDB.

		     Fix problem in fastDel related to literal keys.

	09/20/04 - RussellDS - CR12259 (P04) / CR12526 (P01)
		     Corrected problem in selectDyn to change to return
		     result of first fetch from vOpen0.

		     Corrected error in update section - removed reference
		     to $g(par), replaced with actual(4).

		     Removed unnecessary $D(actual()) and $G(actual()) tests
		     in update section.

	09/06/04 - GIRDHARANB - CR8533
		     Cleaned out dead code warnings in section Rdelete.

	09/01/04 - RussellDS - CR11515
		     Added code to handle dynamic selects from RDBs.

	06/15/04 - Giridharanb - CR9217
		     Misc Bug fixes in sections RfastDel,Rkeyval. Also added 
		     section typmap to support optimization of the select method.

	03/29/04 - RussellDS - CR9172
		     Integrate changes as part of move of filers to PSL.

		     Added code to isDefined section to handle CUVAR and similar
		     globals, which use "*" as a key.

		     Change vExist generated label name to vExst to shorten to
		     avoid conflict problems.

		     Remove use of SQLPARS - obsoleted with changes for filers.

		     Added code to handle automatically treating ER and RM as
		     public scope for versions prior to Profile04.

	02/02/04 - FSANCHEZ/KELLYP - 7813
		     Fixed loading error in Db.getRecord if nested property
		     syntax is used (e.g.,  Db.getRecord("DEP",1).bal).

	01/08/04 - GIRIDHARANB - 7811
		     Minor fixes and code optimizations to RfastDel,Rdelete
		     WHR,RgetRecord section
	*/
	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.  The M routine from the     *
	// * crtns directory should be used for this purpose.                *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	// ---------------------------------------------------------------------
private akey2apl( PSLTable td,		// table descriptor
		PSLIdentifier var,	// object variable (*2)
		String akeys,		// access key expression (*3)
		Number sparse,		// sparse indicator (*4)
		String lvpm())		// purpose mapping (*5)	  /MECH=REFARR:W
	/* ---------------------------------------------------------------------
	Transform access key expression into actual parameter list and local
	variable purpose mapping.

	ARGUMENTS:
	(*2) var = object variable
		When a variable name is supplied (unsubscripted!), then each
		key value expression that reduces to a single variable name
		(again unsubscripted) will be recorded in
			patch(-3,PSL.subRou,var,,)=hostvarname
		It denotes a potential variable name to reference the key.
	(*3) akeys = access key expression
		the function supports both the deprecated positional list and
		the NAME=value syntax. Furthermore it supports a SQL conforming
		specification of the primary key (i.e keyword AND instead of
		comma to separate key column comparison predicates)
	(*4) sparse = indicates how missing keys (sparse expression) are treated
		 0 - report an error
		 1 - accept and insert "" in the returned list
		-1 - accept and ignore in the returned list
	(*5) lvpm() = local variable purpose mapping
		This (optional) output array will contain the key purpose
		mapping using the -keynum-2 convention.

	OUTPUTS:
	. $$ = positional list of primary key values
		This value can be used as the actual list to a subroutine that
		has a formallist speficying the primary key, such as the vDbN()
		method generated for Db.getRecord().
	. lvpm(keynum_"*") = key expression
		For each key supplied in akeys

	NOTES:
	. Variable PSL.tok must be used (instead of declaring a local) because:
		- $$valExpr^UCGM() uses 'tok' as a public variable (!!)
		- (double) quoted strings inside the access key must be added
		  to the existing list of tokens, because they will be
		  untokenized outside this subroutine.
	*/
	type public PSLTable pslTbl()
	type public String patch(,,,,)
	type public String tok

	type List fkeys = td.primaryKeys

	if fkeys.isNull() quit ""

	type String expr	// akeys expression element
	type Number i		// iterator
	type Number ptr = 0	// char pointer in akeys
	type String keyNam	// name of key
	type Number keyNum = 0	// key ordinal position
	type String xref()	// key column cross references

	if akeys.extract()="""" set akeys = akeys.stripQuotes()
	set akeys = $$TOKEN^%ZS(akeys,.tok)	// APPEND to existing !!

	for i=1:1:fkeys.count() set xref(fkeys.elementAt( i)) = i

	for  set expr = $$nextExpr^UCGM( akeys, .ptr, tok, 1) do { if ptr=0 quit

		if expr="",sparse quit			// missing key
		if expr="," quit
		if expr.upperCase()="AND" quit		// delimiter
		if expr["=" do {			// key=value

			set keyNam = expr.piece("=",1).upperCase()
			set expr   = expr.extract( keyNam.length() + 2, expr.length())
			set keyNum = xref( keyNam).get()
			if keyNum.isNull() throw Class.new( "Error", "%PSL-E-INVALIDREF, Invalid key column: "_keyNam)
		}
		else  do {

			set keyNum = keyNum + 1
			set keyNam = fkeys.elementAt( keyNum)
			if keyNam.isNull() throw Class.new( "Error", "%PSL-E-INVALIDREF, Too many access keys")
		}

		/* now keyNam contains the name, keyNum the ordinal position,
		   and expr the value.
		   */
		if lvpm(-keyNum-2).exists() do PSL.error("Duplicate access key: "_keyNam)

		kill xref(keyNam)	// drop name that has been used

		/* First case supports SQL 'literal' syntax
		   */
		if expr.extract()="'",expr.extract( expr.length())="'",expr.length("'")=3 set expr = expr.translate("'", """")
		
		/* TAB xxx TAB (patched reference) */
		else  if expr.extract() = PSL.tab, expr.extract(expr.length()) = PSL.tab, expr.length( PSL.tab)=3

		/* wrapped column reference */
		else  if $$hasWrap^UCREC4OP(expr)

		/* [FRS] This is not a strict sytax, currently ':' host
		   variable prefix is not required.  Everything is treated
		   as a host expression.
		   FSCW CR18163: NOTE valExpr uses 'tok' as public variable !!!
		   */
		else  do {
			if expr.extract()=":" set expr = expr.extract( 2,expr.length())
			if expr[(PSL.oLvn_"(") quit
			set expr = $$valExpr^UCGM( expr) if PSL.ER set ptr=0
		}

		set lvpm(-keyNum-2) = expr
		if $$isVar^UCGM(expr),$$isVar^UCGM(var) do {
			type Number newPtr = $$getNew^UCGM(var)
			set patch( -3, PSL.subRou, var, newPtr, -2 - keyNum) = expr
		}
	}

	/* Construct the return value: an ordered list of xref(keyNum) values,
	   using the value of sparse to decide what to do with missing values
	   */
	type String return = ""
	type String zerror = ""

	for i=1:1:fkeys.count() do {
		if lvpm(-i-2).exists() set return = return_ lvpm(-i-2)_ "," quit
		if sparse = 0 set zerror = zerror_ fkeys.elementAt(i)_ "," quit
		if sparse > 0 set return = return_""""""
		set return = return_ ","
	}

	if 'zerror.isNull() do PSL.error("Missing actual keys: "_ zerror.extract( 1, zerror.length() - 1))

	/* Remove ALL trailing commas from return value
	   */
	// quit $$UNTOK^%ZS( return.extract( 1, return.length() - 1), tok)
	quit $$UNTOK^%ZS( return.trim( 1, ","), tok)

	// ---------------------------------------------------------------------
private Cache	// method Cache.getRecord ; Returns Record<Class> object
	/* ---------------------------------------------------------------------
	This subroutine generates a vCaX() subroutine that returns the
	top/default node of the requested Record from the Cache (as supplied in
	objectName), and loads it into the Cache (using Db.getRecord()) when the
	Cache does not yet contain that node.

	If the table's recordType is greater than 9, then it will also generate
	a subrutine vCaNL() to incrementally load a node through the Cache.

	2007-05-16: Added support for 3rd parameter in Cache.getRecord(), with
	the same meaning as the 3rd parameter of Db.getRecord(). This impacts
	generated code as follows:
	- The vDbN() call will now always be a Db.getRecord(,,1)
	- The node returned by vDbN() will be stored as before
	- The record mode returned by vDbN() will be stored in
		cache(table,k,e,y,-2)
	- For a Cache.getRecord(,,0) the exception will be thrown inside the
		generated vCaN() function instead of by the vDbN() function.
		This will be based exclusively on the value of the record mode
		found in the cache.
	- Because the execption must also be thrown for records that are already
		in the cache, the code that throws the exception will occur
		in a block that is independent of the call to vDbN().

	INPUTS:
	. PSL.actual(1) = table name (literal String)
	. PSL.actual(2) = access key expression (literal String)

	. PSL.pslTbl()
		The table descriptor cache
	. PSL.reClass
		The literal "Record"
	. PSL.var
		The target variable to receive the cached RecordTABLE instance
		Note also that this implies that "nested calls" must allocate
		and supply a scratch variable to use as assignment target.

	OUTPUTS:
	. PSL.actual(3) = record mode
		Assigned before calling getRecord
	. PSL.class = RecordTABLE
		where TABLE = PSL.actual(1).stripquotes()
	. PSL.return
		Extref to be called for this method

	NOTES:
	. The cache structure stores data nodes, mirroring the vobj(,) structure
		The code generated here uses the return value from $$vDbN() as
		the subscript in vobj() to access the initial node, and copy it
		in the cache.
	*/
	type public PSLTable  pslTbl()

	type String table = PSL.actual(1)
	if table.extract() = """" set table = table.stripQuotes()

	/* Make sure the Db.getRecord() that must be called if the record is not
	   found in the Cache is defined.
	   After the call, PSL.return will contain the call to $$vDbN() that
	   shall be used inside vCaN(). 
	   To keep the count of references to vDbN() correct, increment it here
	   (as used by vCaN()).
	   Note that Cache.getRecord(,,0) and Cache.getRecord(,,1) will need
	   separate subroutines, so this distinction must be reflected in the
	   comment.
	   */
	set PSL.class = PSL.reClass_ table
	//set PSL.actual(3) = 0
	type Number clsNew = PSL.actual(3).toNumber()
	set PSL.actual(3) = 1
	do getRecord

	type PSLTable td    = PSL.cachePSLTable( .pslTbl, table)
	type String   akeys = $$akey2apl( td, PSL.var, PSL.actual(2), 0)
	type String   cmmnt = "vobj()=({Cache}"_ PSL.objectName_ ".getRecord("_ table_ ","_ clsNew_ ")"
	type String   label = $$findSubr^UCGM( "vCa", cmmnt)

	/* Increment reference count for lblGetRec */
	type String lbGetRec = PSL.return.piece( "(")
	do incrLabel^UCGM( lbGetRec)

	/* Mark the record-mode purpose variable as being used.
	   THIS IS TEMPORARY CODE, BECAUSE IT UNCONDITIONALLY CREATES THE ENTRY
	   WHEREAS THE ENTRY MAY ONLY BE NEEDED INSIDE vCaN() TO SET THE -2 NODE
	   OF THE CACHE. HOWEVER, TO DO THE LATTER, vCaN() MUST BE GENERATED AS
	   PSL CODE, NOT AS M CODE
	   */
	type Number dummy = $$purByOvs^UCREC4OP( PSL.subRou, PSL.var, -2)

	if 'PSL.subrouExists( label) do CacheSr( td, 1, label, cmmnt, PSL.objectName, clsNew, lbGetRec)
	set PSL.return = "$$"_ label_ "("_ akeys_ ")"

	if PSL.var.optimize()

	quit

	// ---------------------------------------------------------------------
private CacheDef	// method Cache.isDefined
	/* ---------------------------------------------------------------------
	This subroutine generates the code for Cache.isDefined() as a simple
	PSL wrapper:
	
	vCaExN() //
		type public Cache cacheNm
		type RecordTABLE vRec = cacheRef.getRecord(table,accKeys,1)
		quit vRec.getMode()=1
	
	INPUTS:
	. PSL.actual(1) = table name (literal String)
	. PSL.actual(2) = access key expression (literal String)

	NOTES:
	. This code shall be adapted to generate a separate subroutine in the
		target language.
	*/
	type String tbl = PSL.actual(1)
	if tbl.extract() = """" set tbl = tbl.stripQuotes()

	type String cmt = "{Cache}"_ PSL.objectName_ ".isDefined("_ PSL.actual(1)_ ","_ PSL.actual(2)_ ")"

	type String lbl = $$findSubr^UCGM( "vCaEx", cmt)

	set PSL.return = "$$"_ lbl_ "()"

	if 'PSL.subrouExists( lbl) {
		type PSLBuffer buf = PSL.openBuffer( "()", cmt)
		type String ucn = PSL.objectName.piece( "(")
		do buf.add(" type public Cache "_ ucn_ "()")
		do buf.add(" type Record"_ tbl_ " vRec = "_ PSL.objectName_ ".getRecord("_ PSL.actual(1)_ ","_ PSL.actual(2)_ ",1)")
		do buf.add(" quit vRec.getMode() = 1")

		do buf.insert( lbl)
	}

	quit

	// ---------------------------------------------------------------------
private CacheSr( PSLTable td,		// table descriptor
		Boolean useVobj,
		String label,
		String comment,
		PSLIdentifier cacheNm,	// instantiator (cache instance)
		Number clsNew,		// value of ClassNew parameter (0, 1)
		String lbGetRec)	// label to use for getRecord
	/* ---------------------------------------------------------------------
	This subroutine generates 2 labels in a single subroutine:
	- vCaN() to load and cache the initial node
	- vCaNL() to load and cache the incrementally loaded nodes.

	The code generated by this subroutine has only minimal differences due
	to vobj() versus voxn. To load the initial node from the database, the
	supplied $$vDbN() will be called (if needed). This leads to the
	following  matrix for vCaN():
	cached?	vobj model			voxn model
	NO	1) purge cache			1) purge cache
		2) call $$vDbN()		2) call $$vDbN()
		3) copy init node from vobj()	3) copy init node from vOid
		   into cache			   into cache
		4) return result from $$vDbN()	4) return result from $$vDbN()
	YES	1) instantiate new Record
		   object,
		2) copy init node from cache	1) return init node from cache
		3) copy/set special purpose
		   nodes
		4) return vOid

	Because Cache access is supposed to deal with read-only cases, and
	because caching of blob/memo columns is not supported at all, the
	incremental load code for both MDB and RDB can use the actual key values
	from vobj(,-key-2)

	Some special care should be exercised with respect to incremental loads
	when Cache objects are involved. Because the Cache structure mirrors the
	vobj() structure, the existance of a Cache entry for a node must be
	deterministic:
	For recordType 11 tables, additional nodes in the Cache structure shall
	only exist if the top node exists.
	For recordType 1 tables and recordType 10 tables, the Cache is always
	consistent. For recordType 10 the consistency is a side-effect of the
	initial record loading of the associated $$vDb() function:
	- If there is an existsNode, $$vDb() will return the existsNode, and
		that node will always end up in the Cache (in the existsNode).
	- If there is no existsNode, $$vDb() will return "", and all nodes are
		loaded through incremental loading. The "" returned by $$vDb()
		will be stored in the top node, and be returned consistently for
		every Cache.getRecord() that uses this Cache.

	Furthermore, incremental loads through Cache use a separate subroutine,
	whereas for other incremental loads the retrieval code is generated
	"in line". When incremental loads are needed for an object, that object
	may have multiple, different instantiation expressions. In particular
	combinations of Cache.getRecord and calls that pass the object as an
	actual parameter are reasonable combinations.
	To allow the compiler to generate code that uses the Cache structure as
	much as possible while still maintaining the consistency of the Cache,
	the code generated for incremetal loads through Cache uses the following
	algorithm:
	- If the requested node is present in the Cache, it is returned
		immediately.
	- Else the node is loaded into a local variable.
	- If this is a recordType 10 table, the node is added to the Cache
		unconditionally, else it is a recordType 11 table, and the node
		will only be added to the Cache if "top" node exists in the
		Cache
	- In either case, the value of the local variable is returned.

	The subroutine generated for incremental node loading through Cache
	objects is limited to cases where the vobj node is equal to the MDB
	node. Incremental loading of nodes that do not preserve this mapping
	will always bypass the Cache object. This involves:
	- Blob and Memo columns in MDB and RDB
	- MDB negative nodes (where the MDB ^G(,,-N) maps to vobj(,"vN"))
	- RDB wide table nodes (because the table name would not be known until
		runtime)

	NOTES:
	. Cache entries for recordType 10 of optimized objects may need
		additional attention.
	*/
	type public PSLColumn pslCln()

	type String  code			// code construction
	type String  fpl = ""			// formal parameter list
	type Number  ftype = td.recordType	// record type
	type Boolean isArchived = false
	type Number  k				// key iterator
	type String  lvn			// cacheNm(v1,v2,v3)
	type String  lvn1			// cacheNm(v1,v2,v3,
	type String  lvnInit			// cache node for initial load
	type String  lvpm()			// map passed to getRecCode^UCXDD()
	type String  nodExis = td.existsNode	// exists node
	type String  nodInit = $$getRecPur^UCXDD( td)	// initial node
	type List    pkl = td.primaryKeys	// primary key columns
	type String  ucn = cacheNm.piece( "(")	// unsubscripted cache name
	type String  vobjHead			// "vobj(vOid"
	type String  vobjInit			// vDbN var that holds init node
	
	if 'td.getArchiveTable().isNull() set isArchived = true

	for k=1:1:pkl.count() do {
		if k>1 set fpl = fpl_ ","
		set fpl = fpl_ "v"_ k
		set lvpm( k_"*") = "v"_ k
	}

	if useVobj set vobjHead = PSL.oLvn_ "(vOid"

	if cacheNm.endsWith( ")") set lvn = cacheNm.extract( 1, cacheNm.length() - 1)_ ","
	else  set lvn = cacheNm_ "("

	set lvn = lvn_ fpl_ ")"
	if lvn.endsWith( "()") set lvn = lvn.extract( 1, lvn.length() - 2)
	if lvn.endsWith( ",)") set lvn = lvn.extract( 1, lvn.length() - 2)_")"

	set lvn1 = lvn

	if lvn1.extract(lvn1.length()) = ")" set lvn1 = lvn1.extract(1, lvn1.length()-1)_","
	else  set lvn1=lvn1_"("
	
	if (nodInit = "0*") ! nodInit.isNull() do {
		/* unsubscripted node is used.
		   target = cache lvn + formals
		   origin = vobj(recInst) (or vOid if optimized) */
		set lvnInit  = lvn
		set vobjInit = $SELECT(useVobj:vobjHead_")",1:lbGetRec)
	}
	else  if 'nodInit.isNull() do {
		/* exists node is used.
		   target = cache lvn + formals + existsNode
		   origin = vobj(recInst,nodExis) (or vOid if optimized) */
		set lvnInit  = lvn1_ nodExis_ ")"
		set vobjInit = $SELECT(useVobj:vobjHead_","_nodExis_")",1:"vOid")
	}

	set code = fpl
	if clsNew=1,'useVobj set code = ({List}code).add("v2out")
	type PSLSubrou sr = PSL.addSubrou( label, "("_ code_ ")", comment, 0)

	if useVobj do sr.addCode(" N vOid")

	// Add the code to load the record from the db if not in cache
	do sr.addCode(" I '$D("_ lvn_ ") D")
	if 'useVobj {
		set code = ""
		set:clsNew=0 code = "v2out"
		set:isArchived code = ({List}code).add("vArch")
		do:'code.isNull() sr.addCode(" .  N "_ code)
	}
	do sr.addCode(" .  I $G("_ cacheNm_ ")>"_ PSL.maxCacheSize_ " S "_ ucn_ "="_ ucn_ "-"_ cacheNm_ " KILL "_ cacheNm)
	do sr.addCode(" .  S "_ cacheNm_ "=$G("_ cacheNm_ ")+1,"_ ucn_ "=$G("_ ucn_ ")+1")
	if useVobj do {
		do sr.addCode(" .  S vOid="_ lbGetRec_ "("_ fpl_ ")")
		if isArchived do sr.addCode(" .  S "_ lvn1_"-99)="_ vobjHead_ ",-99)")
		do sr.addCode(" .  S "_ lvn1_"-2)="_ vobjHead_ ",-2)")
		if 'nodInit.isNull() do sr.addCode(" .  S "_ lvnInit_ "="_ vobjInit)
	}
	else  do {
		
		set code = " .  S "_lvnInit_ "="_ lbGetRec_ "("_ ({List}fpl).add(".v2out")
		if isArchived set code = code_ ",.vArch),"_ lvn1_ "-99)=vArch,"_ lvn1_ "-2)=v2out"
		else  set code = code_ "),"_ lvn1_ "-2)=v2out"
		do sr.addCode(code)
	}

	do sr.addCode(" ;")

	// Add the code that creates the object to be returned
	if useVobj do {
		/* vobj mode: instantiate new record,
		   set mode to whatever was returned by Db.getRecord,
		   set keys. Do not set -151 (not yet supported). */
		do sr.addCode(" E  D")
		do sr.addCode(" . "_ $$cdNewObj^UCCLASS( "vOid", """Record"_ td.table_ """"))
		do sr.addCode(" .  S "_ vobjHead_ ",-2)="_ lvn1_ "-2)")
		if 'pkl.isNull() for k=1:1:pkl.count() do sr.addCode(" .  S "_ vobjHead_ ","_ (-2-k)_ ")=v"_ k)

		if 'nodInit.isNull() do sr.addCode(" .  S "_ vobjInit_ "="_ lvnInit)
	}

	do sr.addCode(" ;")

	// If not Cache.getRecord(,,1), add code that throws %PSL-E-RECNOFL
	// Else add the code that sets v2out when entry found in cache
	if clsNew = 0 {
		do sr.addCode(" I "_ lvn1_"-2)=0 S $ZS=""-1,""_$ZPOS_"",%PSL-E-RECNOFL,,"_ td.table_ """ X $ZT")
	}
	else  if 'useVobj do sr.addCode(" E  S v2out="_ lvn1_"-2)")

	do sr.addCode(" Q "_$SELECT(useVobj:"vOid",nodInit.isNull():"""""",1:lvnInit))

	/* For MDB tables with recordType > 1, add code to load nodes
	   incrementally. This code will not apply to RDB tables (hard to stay
	   independent of implementation of wide tables), and it does not work
	   for incremental loads of MDB and RDB blob/memo columns.
	   Note that the code below does not call $$getLodCode^UCXDD() */
	if ftype>1 do {
		if td.isRdb do warnGroup^UCGM("INTERNAL","Incremental loads will bypass Cache for : "_cacheNm_".getRecord("_td.table_")") quit

		if isArchived set lvpm(-99) = lvn1_"-99)"

		type String gbl = $$getDataNode^UCXDD( td, "vOid", "vn", 0, .lvpm(), .pslCln())

		if 'fpl.isNull() set fpl = fpl_ ","

	 	do sr.addCode( label_ "L("_fpl_"vn) ; Incremental Load "_ td.table_ " Cache into "_cacheNm)

	 	if ftype = 10 do {
	 		do sr.addCode( " I '$D("_ lvn1_ "vn)) S "_ lvn1_ "vn)="_ gbl)
	 		do sr.addCode( " Q "_ lvn1_ "vn)")
	 	}
	 	else  do {	// recordType = 11
		 	do sr.addCode( " I $D("_ lvn1_ "vn)) Q "_ lvn1_ "vn)") 
		 	do sr.addCode( " N vData S vData="_ gbl)
		 	do sr.addCode( " I $D("_ lvn_ ") S "_ lvn1_ "vn)=vData")
			do sr.addCode( " Q vData")
	 	}
	}
	quit

	// --------------------------------------------------------------------
private delete	// Db.delete(table_name,where_clause,filer_qualifier)
	/* --------------------------------------------------------------------
	For MDB tables and RDB tables, if there is a filer, and we need to call
	it, generate a subroutine that uses Db.selecteDbSet() and iterates over
	the matching rows to call the filer with %O=3 for each row.

	Otherwise, the MDB case and the RDB case differ.

	INPUTS:
	. actual(1) = tablename (literal)
	. actual(2) = where clause (literal)
	. actual(3) = filer qualifiers (literal)

	NOTES:
	. Even though the MDB code and the RDB code may differ, they behave
		"functionally equivalent".
		In particular, if there is no filer, the deletes will not be
		logged, regardless of the value of SchemaTable.isAutoLog !!
	*/
	type public PSLTable pslTbl()

	type String table = PSL.actual(1).stripQuotes().upperCase()
	type String where = PSL.actual(2).stripQuotes()
	type String qual  = $$fileQual( "Db.delete", PSL.actual(3))

	type PSLTable td = PSL.cachePSLTable( .pslTbl(), table)

	/* Call mapPSLvar to handle case of :record.column as host variable
	   to map to variable prior to call to delete sub-routine */
	if where[":" set where=$$mapPSLvar(where)
	
	/* See if the where-clause references a single row by primary key */
	type String akey = $$sql2akey( td, where)

	/* If RDB wide table with WHERE-clause, call DelByFiler(), because the
	   WHERE-clause may span multiple tables.
	   NOTE that the call to delByFiler() is based on the assumption that
	   wide tables will always have a filer.
	   */
	if td.isRdb,td.recordType>1,'where.isNull() do delByFiler( td, where, akey, qual) quit

	/* Check no filer present, or not needed.
	   Check filer logic that is reported as being required, but that is not
	   supported by inline PSL code. If the filer qualifier is not literal,
	   then $$getFlrLgc(,,"") will not be called. As a result, $$getFlrLgc()
	   will return the maximum list, which will ensure that a call to the
	   filer will be generated for this occurrence to deal with the dynamic
	   parameters. The only case that a dynamic value will not lead to code
	   that calls the filer is the case where the filer can always be
	   bypassed (no journals, no triggers). */
	type List flrLgc = $$getFlrLgc^UCXDD(td, "DELETE", qual, 1)
	if 'td.filerPGM.isNull(),'flrLgc.isNull() do delByFiler( td, where, akey, qual) quit
	if 'flrLgc.isNull(),flrLgc'="LOG" do PSL.error("Cannot generate inline DELETE code for /"_flrLgc.translate(",","/")) quit

	if td.isRdb do delRdb( td, where, akey) quit

	/* MDB delete one or more rows when there is no (need to call the)
	   filer.
	   If delete-by-accesskey, then replace DO:postCond by KILL:postCond
	   else generate subroutine.
	   To ensure that the DELETE is treated as an atomic operation, the
	   multi-row loop is enclosed by Runtime.start() and Runtime.commit()
	   */
	type PSLIdentifier lvpm()

	if 'akey.isNull()!td.primaryKeys.isNull(),flrLgc.isNull() do {
		type String dummy = $$akey2apl(td, "", akey, 0, .lvpm())
		type Number k

		/* Copy from lvpm( -k-2) to lvpm( k_"*") */
		for k=1:1:td.primaryKeys.count() set lvpm( k_"*") = lvpm( -k-2)

		set PSL.mcode  = $$backup^UCGM( PSL.mcode)
		set PSL.return = $$delMcode( td, .lvpm(), PSL.postCond)
	}
	else  do {
		type String comment = "DELETE FROM "_td.table
		if 'where.isNull() set comment = comment_ " WHERE "_ where

		type String label = $$findSubr^UCGM( "vDbDe", "")	// generate new label

		set PSL.return = label_ "()"

		if PSL.subrouExists( label) quit

		/* Need to generate the subroutine */
		type PSLBuffer buf = PSL.openBuffer( "()", comment)
		type Number k
		type List   pkeys = td.primaryKeys
		type String line = " type Primitive "
		type String getKeys = "set "
		type String setKeys = "set "
		for k=1:1:pkeys.count() do {
			set lvpm( k_"*") = "v"_k
			if k>1 set line = line_ ",", getKeys = getKeys_ ",", setKeys = setKeys_","
			set line = line _"v"_k
			set getKeys = getKeys_ "v"_ k_ "=vRs.getCol("_k_")"
			set setKeys = setKeys_ "vRec."_ pkeys.elementAt(k)_ "=v"_ k
		}
		do buf.add( line)
		do buf.add( " do Runtime.start(""CS"")")

		if 'flrLgc.isNull() do {
			do buf.add(" type Record"_ td.table_ " vRec=Class.new(""Record"_ td.table_ """)")
			do buf.add(" do vRec.setMode(3)")
		}

		do buf.add( " type ResultSet vRs=Db.select("""_ pkeys_ ""","""_td.table_""","""_where_""")")
		do buf.add( " while vRs.next() do {")
		do buf.add( "   "_ getKeys)

		if 'flrLgc.isNull() do {
			do buf.add( "   "_ setKeys)
			do buf.add( "   #ACCEPT CR=21101;DATE=2006-05-11;PGM=FSCW;GROUP=DEPRECATED")
			do buf.add( "   do ^DBSLOGIT(vRec.getPointer(),3)")
		}

		do buf.add( "   #ACCEPT CR=18163;DATE=2006-01-09;PGM=FSCW;GROUP=BYPASS")
		do buf.add( "   #BYPASS")
		do buf.add( $$delMcode( td, lvpm(), ""))
		do buf.add( "   #ENDBYPASS")
		do buf.add( " }")
		do buf.add( " do Runtime.commit()")
		do buf.add( " quit")

		do buf.insert( label)
	}
	quit

	// --------------------------------------------------------------------
delByFiler( PSLTable td,	// table descriptor
	String where,		// WHERE-clause
	String acckey,		// access key (or "" if not applicable)
	PSLExpression qual)	// filer qualifiers ("normalized")
	/* --------------------------------------------------------------------
	MDB and RDB DELETE code when the filer needs to be called is identical

	The generated subroutine will ensure that the entire DELETE is treated
	as a single transaction by including Runtime.start() before the delete,
	and Runtime.commit() after the delete. This is independent of the number
	of rows to delete, because even a single row delete may cascade into
	other deletes or db modifications, that all shall be treated as an
	atomic operation.
	*/
	type String comment = "DELETE FROM "_td.table
	if 'where.isNull() set comment = comment_ " WHERE "_ where

	type String label = $$findSubr^UCGM( "vDbDe", "")	// generate new label

	set PSL.return = label_ "()"

	if PSL.subrouExists( label) quit

	type PSLBuffer buf = PSL.openBuffer( "()", comment)

	do buf.add(" do Runtime.start(""CS"")")
	if acckey.isNull() do {
		do buf.add(" type DbSet vDs=Db.selectDbSet("""_ td.table_ ""","_ where.addQuotes() _")")
		do buf.add(" while vDs.next() do {")
		do buf.add("   type Record"_ td.table_ " vRec = vDs.getRecord("""_td.table_""")")
		do buf.add("   do vRec.setMode(3)")
		do buf.add("   do ^"_ td.filerPGM_ "(vRec,"_ qual_ ",1)")
		do buf.add(" }")
	}
	else  do {
		/* Single Row.
		   Call filer only if the row exists. Note that this code
		   executes under TP and cannot QUIT if "not found". It has to
		   go through the commit even if there is nothing to commit
		   */
		do buf.add(" type Record"_ td.table_ " vRec = Db.getRecord("""_td.table_""","_acckey.addQuotes()_",1)")
		do buf.add(" if vRec.getMode()=1 do vRec.setMode(3),^"_ td.filerPGM_ "(vRec,"_ qual_ ",1)")
	}
	do buf.add(" do Runtime.commit()")
	do buf.add(" quit")
	do buf.insert( label)

	quit

	// --------------------------------------------------------------------
delMcode( PSLTable td,		// table descriptor
	String lvpm(),		// keys
	String mpc)		// M_postcond (incl ":", or "")
	/* --------------------------------------------------------------------
	Support function that returns the KILL or ZWITHDRAW statement for a
	singe row MDB delete.
	ZWITHDRAW will be used when the row is guaranteed to reside in a single
	global node (recordType = 1 and no blobs or memos)
	Otherwise KILL will be used.
	*/
	type String code = $$getGvn^UCXDD( td, "", .lvpm())

	if td.isOneNode() quit " ZWI"_mpc_" "_code

	quit " K"_mpc_" "_ code

	// ---------------------------------------------------------------------
delRcode( PSLTable td, String where, Boolean doTrunct, PSLBuffer delBuf)
	/* ---------------------------------------------------------------------
	Code that inserts M code with call to RDB API to perform the DELETE.

	The code will add the #ACCEPT and #BYPASS at the beginning,
	but will NOT add the #ENDBYPASS at the end.
	The reason for this is that the caller may need to add TRAILING M code,
	but is not expected to have added LEADING M code.
	*/
	do delBuf.add("#ACCEPT CR=21101;DATE=2006-05-11;PGM=FSCW;GROUP=BYPASS")
	do delBuf.add("#BYPASS")

	if doTrunct do {			// Use truncate, if possible
		type Number i
		type List tables = td.internalNames

		do delBuf.add( "N vEr,vRm")

		// do delBuf.add( "I 0,$TLEVEL=0 D  Q  ; TRUNCATE requires $TLEVEL=0")
		// do delBuf.add( ". ; Note - this code will not yet execute")
		// for i=1:1:tables.count() do delBuf.add( "."_$s(i>1:" I vEr'<0",1:"")_" S vEr=$$EXECUTE^%DBAPI(0,""TRUNCATE TABLE "_tables.elementAt(i)_""","""","""",.vRm)")
		// do delBuf.add( ". I vEr<0 S $ZS=""-1,""_$ZPOS_"",%PSL-E-SQLDELFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)) X $ZT")
		// do delBuf.add( ". ; Note - no commit here, since if $Tlevel=0, we do truncate")

		for i=1:1:tables.count() do delBuf.add( $s(i>1:"I vEr'<0",1:"")_" S vEr=$$EXECUTE^%DBAPI(0,""DELETE FROM "_tables.elementAt(i)_""","""","""",.vRm)")

		do delBuf.add( "I vEr<0 S $ZS=""-1,""_$ZPOS_"",%PSL-E-SQLDELFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)) X $ZT")
	}
	else  do {
		type String hvMap()
		type String vListCd
		type String sql = "DELETE FROM "_ td.internalNames

		do delBuf.add( "N vEr,vRm")

		if 'where.isNull() do {
			set where    = $$where^UCDBR( td.table, where, .hvMap())
			set vListCd = $$RsMsXV^UCDBRT( hvMap(),.where))
			set sql = sql_ " WHERE "_where
		}
		else  set vListCd = """"""

		do delBuf.add(" S vEr=$$EXECUTE^%DBAPI(0,"""_ sql_ """,$C(9),"_ vListCd_ ",.vRm)")
		do delBuf.add(" I vEr<0 S $ZS=""-1,""_$ZPOS_"",%PSL-E-SQLDELFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)) X $ZT")
	}
	quit

	// ---------------------------------------------------------------------
delRdb( PSLTable td,		// table descriptor
	String where,		// where clause (*2)
	String akeys)		// access key (*3)
	/* ---------------------------------------------------------------------
	SQL DELETE statement for RDB table, when we don't have a filer or we do
	have parameters that would make no reason to call the filer.
	
	If in addition we don't have a WHERE clause, then we can use
	TRUNCATE or a direct delete call to the RDB, since we're deleting the
	entire table. The use of TRUNCATE is further limited by constraints on
	the table (e.g. foreign key). Until all these conditions are known,
	and used by the compiler, the doTrunct-flag is only used to indicate
	the absence of a WHERE clause, but the generated code will never use
	the TRUNCATE statement.

	If we do have a WHERE clause then use a direct delete call to the RDB.
	(Will not do this for wide tables since WHERE clause may involve more
	than just keys, and they do have a filer anyway).

	Note that because TRUNCATE does it's own commit automatically, we don't
	want to use it if already under TP at runtime.

	A complicating factor is the PSLTable.isAutoLog property. A table can
	have this flag set, even if there is no filer. In that case, the call to
	the LOG processor must be generated here. Because the LOG processor
	expects a single object per call, a separate ResultSet is used to deal
	with LOG. To mimimize the number of calls to the RDB, a single DELETE
	will be passed to delete all rows after they have been logged.
	To ensure that LOGging and DELETE will be part of the same transaction,
	the generated code uses Runtime.start() and Runtime.commit().
	This leads to the following cases:
	A) td.isAutoLog & 'akeys.isNull()
		Single row delete with log. Use akeys to construct the Record
		object to pass to DBSLOGIT. Include Runtime.start(), singel call
		to DBSLOGIT, call to RDB API and Runtime.commit()
	B) td.isAutoLog & akeys.isNull()
		Multiple row delete with log. Use ResultSet to obtain rows that
		need to be LOGged. Include Runtime.start(), Db.select(),
		ResutlSet.next()/ DBSLOGIT per row, call to RDB API and
		Runtime.commit()
	C) 'td.isAutoLog
		The number of rows to delete is irrelevant. Generate calls to
		RDB API for delete and for commit.

	ARGUMENTS:
	(*2) where = WHERE-clause
		This function relies on the fact that the caller has already
		transformed the clause into a SQL compliant expression (e.g.
		by calling $$mapPSLvar())
	(*3) akeys = access key
		If non-empty, then the delete is a single row delete.
		This will be used only if td.isAutoLog.

	NOTES:
	. Because there will be no call to a filer, there is no need to deal
		with filerqualifiers.
	. This subroutine unconditionally codes a DELETE table WHERE where
		Since this cannot be applied to wide table deletes, the caller
		must handle that case.
		Because DELETE table or TRUNCATE table can be applied to wide
		tables, this is the only case that is acceptable.
	*/
	type String sqlcmt = "DELETE FROM "_td.table		// SQL delete for comment uses DQ name

	if 'where.isNull() set sqlcmt=sqlcmt_" WHERE "_where

	type String label = $$findSubr^UCGM( "vDbDe", "")	// generate new label

	set PSL.return = label_ "()"

	if PSL.subrouExists( label) quit

	/* Need to generate the subroutine */
	type PSLBuffer buf = PSL.openBuffer( "()", sqlcmt)

	// Case A) Delete single row with LOG ----------------
	if td.isAutoLog, 'akeys.isNull() do {
		do buf.add( "do Runtime.start(""CS"")")
		do buf.add( "type Record"_ td.table_ " vRec=Class.new(""Record"_ td.table_""","_ akeys.addQuotes()_")")
		do buf.add( "do vRec.setMode(3)")
		do buf.add( "#ACCEPT CR=21101;DATE=2006-05-11;PGM=FSCW;GROUP=DEPRECATED")
		do buf.add( "do ^DBSLOGIT(vRec.getPointer(),3)")
	
		do delRcode( td, where, 0, buf)

		do buf.add( "#ENDBYPASS")
		do buf.add( "do Runtime.commit()")
	}

	// Case B) Delete multiple rows with LOG ----------------
	if td.isAutoLog, akeys.isNull() do {

		type Number k
		type List   pkeys = td.primaryKeys
		type String setKeys = "set "

		for k=1:1:pkeys.count() do {
			if k>1 set setKeys = setKeys_","
			set setKeys = setKeys_ "vRec."_ pkeys.elementAt(k)_ "=vRs.getCol("_k_")"
		}

		do buf.add( "do Runtime.start(""CS"")")
		do buf.add( "type Record"_ td.table_ " vRec=Class.new(""Record"_ td.table_""","_ akeys.addQuotes()_")")
		do buf.add( "do vRec.setMode(3)")
		do buf.add( "type ResultSet vRs=Db.select("""_ pkeys_ ""","""_td.table_""","_where.addQuotes()_")")
		do buf.add( "while vRs.next() do {")
		do buf.add( "   "_ setKeys)
		do buf.add( "   #ACCEPT CR=21101;DATE=2006-05-11;PGM=FSCW;GROUP=DEPRECATED")
		do buf.add( "   do ^DBSLOGIT(vRec.getPointer(),3)")
		do buf.add( "}")

		do delRcode( td, where, 0, buf)

		do buf.add( "#ENDBYPASS")
		do buf.add( "do Runtime.commit()")
	}

	// Case C) Delete without LOG ----------------
	if 'td.isAutoLog do {
		// NOTE: doTrunct is only used to indicate "no WHERE clause" (see intro)
		type Boolean doTrunct = ( where.isNull())

		/* Both code variations need to include a call to RunTime.commit()
		   */
		type String labelc
		do CommitC^UCRUNTIM(.labelc)	// need to commit explicitly
		
		do delRcode( td, where, doTrunct, buf)

		do buf.add( "I ($Tlevel=0) D "_ labelc)
		do buf.add( "#ENDBYPASS")
	}

	// common exit
	do buf.add( "quit")

	do buf.insert( label)
	quit

	// ---------------------------------------------------------------------
private fastDel	// void; method Db.fastDelete
	/* ---------------------------------------------------------------------
	Db.fastDelete() is considered a special case of db.delete(), just like
	Record.bypassSave() is considered a special case of Record.save().
	The applicable filerqualifiers are:
		/NOJOURNAL/NOTRIGBEF/NOTRIGAFT

	As off CR18163 Db.fastDelete() for an MDB table and for a RDB table
	behave identical. In particular, referential integrity will be observed,
	and index tables will be maintained.

	The necessity to call the filer is determined by a call to
	$$statusd^SQLCMP() in which the above parameters are supplied

	NOTES:
	. Before CR18163, Db.fastDelete() of an MDB table would result in an
		M kill command regardless of the presence of indexes or foreign
		keys. This could result in an inconsistent database if
		surrounding code did not explicitly re-establish the referential
		integrity (by cascading the delete) and delete all indexes.
		Because that kind of behavior cannot be ported to SQL compliant
		RDB environments, the MDB version of fastDelete shall obey the
		same rules that apply to the RDB version.
	*/
	type public PSLTable  pslTbl()

	type String akeys
	type String gbl
	type Number i
	type String map()
	type PSLTable td = PSL.cachePSLTable( .pslTbl(), PSL.actual(1).stripQuotes())

	set akeys = $$akey2apl( td, "", PSL.actual(2), -1, .map())

	/* Copy map( -2-key) to map( key_"*" for call to $$getGvn^UCXDD.
	   Remove trailing keys that are missing. Note that missing intermediate
	   keys will end up in map() as "", so will show up as missing subscript
	   in the global. */
	for i = 1:1:td.primaryKeys.count() set map( i_"*") = map( -2-i).get()
	for i = td.primaryKeys.count():-1:1 quit:'map( i_"*").isNull()  kill map(i_"*")
	set gbl = $$getGvn^UCXDD( td, "", .map())

	if gbl["()" set gbl = gbl.piece( "()")

	// If there were literal keys (that are now missing), do regular delete
	if (gbl["(,")!(gbl[",,")!td.isRdb do {
		set PSL.actual(2) = $$akey2sql( PSL.actual(2).stripQuotes(), td.primaryKeys)
		set PSL.actual(3) = """/NOJOURNAL/NOTRIGAFT/NOTRIGBEF"""
		do delete
	}
	else  do {
	
		/* Strip missing subscripts at the end */
		if gbl [ ",)" set gbl = gbl.piece( ",)")_ ")"
	
		set PSL.mcode = $$backup^UCGM( PSL.mcode)
		set PSL.return =" K"_ PSL.postCond_ " "_ gbl
	}
	quit

	// ---------------------------------------------------------------------
private fileQual( local String method,		// calling method (*1)
		local PSLExpression qualarg)	// applicable qualifiers (*2)
	/* ---------------------------------------------------------------------
	Filer qualifier passing logic.
	Determine the filer qualifiers to use when calling a filer routine

	ARGUMENTS:
	(*1) method = calling method
		This value is not interpreted here, but the value will be
		compared to commands("DEBUG") to determine if it needs to force
		/VALDD/VALRI for this call
	(*2) qualarg = qualifier argument as modified by pass 1 of the PSL
		compiler. So a literal value will have quotes, but the value
		may contain a simple expression such as a variable name or even
		a complete expression with binary operators or function calls.

	INPUTS:
	. commands("SQLPARS")
		If this entry exists at compiletime, and contains a non-empty
		value, then these values will be PREPENDED to qualarg.
	. commands("DEBUG")
		This entry will either contain "*" or it will contain the name
		of a single method. If commands("DEBUG")="*", then the
		qualifiers /VALDD/VALRI will be APPENDED to qualarg for all
		methods. If commands("DEBUG") has a different value, then these
		qualifiers will only be appended if the value passed as the
		method parameter matches the value of commands("DEBUG")

	OUTPUT:
	. $$ = qualifier string as it shall be inserted in the code that calls
		the filer.
		- If qualarg.isLiteral(), then $$setPar^UCUTLN("",modQualarg)
			will have been called to deal with duplicates and
			conflicts.
		- Else if commands() settings force compile time modifications,
			then the return value will be a call to
			$$setPar^UCUTILN() that includes qualarg and the forced
			settings.
		In either case, the returned value will have been "normalized"
		by the time the value ends up in the filer.

	NOTES:
	. Looking at commands("SQLPARS") for specific standard values is a left-
		over from p01_rel03_01. method^UCGM would fill this node from
		OBJECTMET.QUALIFIERS, that has meanwhile been obsoleted. 
	. The batch compiler DBSBCH has provisions that will result in the
		setting of commands("DEBUG").
	. The value of the method parameter is hard-coded in the callers:
		delete^UCDB passes "Db.delete"
		insert^UCDB and update^UCDB pass "Db.update"
		save^UCRECORD passes "Record.save"
	. The history of OBJECTMET.QUALIFIERS has not been documented, so it is
		unknown what the original intend was, as is the reason to
		obsolete. Presumably OBJECTMET was not the best place to put
		default quailifiers, given that only very few methods use them.
		On the other hand, the idea of environment specific default
		qualifiers makes sense. If this is to be (re)introduced, it will
		most likely be through the UCOPTS.ini file.	
	*/
	type public String commands()

	type String par = qualarg

	// standardize if literal
	if par.isLiteral() set par = $$setPar^UCUTILN( "", par.stripQuotes().upperCase()).addQuotes()

	// PREPEND command("SQLPARS") defaults (backward comp. w. p01_rel03_01)
	if 'commands("SQLPARS").get().isNull() set par = "$$setPar^UCUTILN("""_ commands("SQLPARS")_ """,par)"

	// APPEND debug settings if applicable
	type String  debug = commands("DEBUG").get()

	if debug = "*" ! (debug = method) set par = "$$setPar^UCUTILN("_ par_ ",""/VALDD/VALRI"")"

	set par = "$$initPar^UCUTILN("_ par_ ")"
	#ACCEPT CR=22719; DATE=2006-06-23; PGM=FSCW; GROUP=XECUTE
	if qualarg.isLiteral()!qualarg.isNull() xecute "set par=$$QADD^%ZS("_ par_ ")"

	quit par

	// ---------------------------------------------------------------------
private getList // method Db.getList returns String (comma separated list of matches)
	/* ---------------------------------------------------------------------
	Method not supported.

	NOTES:
	. This subroutine performed a general SELECT, and returned the result as
		a single, comma separated list of column values. Because none of
		the supplied arguments was validated, the subroutine produced a
		compile time literal for almost everything
		(provided actual(5) = 0).
	. The description of this method never occurred in any PSL Help document
		and no calls to this mathods have been found in Profile01 and
		Profile04.
	*/
	do PSL.error( "Invalid method: Db.getList") quit

	// ---------------------------------------------------------------------
private getRecCN( String df)	// value of ClassNew parameter
	/* ---------------------------------------------------------------------
	Helper function to provide a consistent value for the ClassNew parameter
	on Db.getRecord(,,df).
	- quotes are stripped
	- an empty value is translated into zero
	- a non-empty value is translated into one
	*/
	set df = df.stripQuotes()
	quit ''df

	// ---------------------------------------------------------------------
private getRecord	// method Db.getRecord; returns RecordTABLE
	/* ---------------------------------------------------------------------
	INPUTS:
	. PSL.actual(1) = table name (literal String)
	. PSL.actual(2) = access key expression (literal String)
	. PSL.actual(3) = record not fond mode

	. PSL.pslTbl()
		The table descriptor cache
	. PSL.ptr
		If the value of this variable is greater than zero, parsing of
		the expression is not yet complete, and we are dealing with a
		"nested property reference": Db.getRecord(t,k,m).column
	. PSL.var
		The target variable to receive the new RecordTABLE instance
		Note that objectName="Db", and cannot be used.
		Note also that this implies that "nested calls" must allocate
		and supply a scratch variable to use as assignment target.
	*/
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	if PSL.ptr do getRecPr quit	// 7813 - Handle nested property syntax

	type PSLTable td  = PSL.cachePSLTable( .pslTbl(), PSL.actual(1).stripQuotes())
	type Number deflt = $$getRecCN( PSL.actual(3))

	set PSL.return = $$akey2apl( td, PSL.var, PSL.actual(2), 0)

	/* FSCW CR18163: Original code used deflt=-1 to kill vobj() on RECNOFL,
	   and quit "" without throwing an exception. Any occurrence of this
	   undocumented behavior is flagged here: */
	if deflt<0 do warnGroup^UCGM("INTERNAL","Db.getRecord( "_ PSL.actual(1)_ ", "_ PSL.actual(2)_ ", "_ PSL.actual(3)_ ")")


	set PSL.class = PSL.reClass_ td.table
	type String scope = PSL.var.scope

	if scope="LITERAL" do LitInst( PSL.var, td.table, PSL.return, deflt, .PSL.level) quit

	/* ================================
	   The code in this block is questionable for more than one reason:
	   1) UCGM will modify the scope of a FORMAL parameter to "vosc"
		This will occur BEFORE this subroutine is called, so the
		condition will never occur.
	   2) If this code were to be inserted, it may end up at an
		incorrect M line level: The line is inserted AFTER the
		line that contains the instantiation, but the line
		following the instantiation will have a different line
		level if a DO { occurs to the left of the instantiation.
		Furthermore, the instantiation itself may be in
		conditional code, so there is no guarantee that the
		execution of the inserted line will be appropriate
	   Given the above, the code block is commented out.
	if scope="FORMAL",td.recordType>1 do {			// Runtime test
		type String code = "$G("_ var_ ")"
		if PSL.mcode[("'"_code) quit
		set code="I "_code_" S $ZS=""-1,""_$ZPOS_"",%PSL-E-RECEXISTS"" X $ZT"
		do ADD^UCGM($$initLine^UCGM(.level)_code,msrc+.001)
		if $G(commands("WARN","RECEXISTS")) do WARN^UCGM("Possible runtime error RECEXISTS")
	}
	================================ */
	
	// find a matching vDbN() subroutine (or create a new one).
	type String comment = PSL.oLvn_ "()=Db.getRecord("_ td.table_ ",,"_ deflt_ ")"
	type String label = $$findSubr^UCGM( "vDb", comment)
	set PSL.return = "$$"_ label_ "("_ PSL.return_ ")"

	if 'PSL.subrouExists( label) do getRecSr( td, "vOid", label, comment, deflt)

	quit

	// ---------------------------------------------------------------------
local getRecPr	// Db.getRecord has properties
	/* ---------------------------------------------------------------------
	This subroutine deals with contraucts such as:

	type Number mm = Db.getRecord("CIF", "ACN=":ACN").dob.monthOfYear() + 1

	Because $$nextExpr() will not treat the dot as a separator, the entire
	code between the first equal-sign and the plus-operator will be treated
	as a single expratom (inside $$valExpr()). This is then decomposed by
	$$valObj(), which will first see the method, and call $$method() to
	obtain the translation (of the entire code sequence). It in turn will
	call getRecord^UCDB, which calls getRecPr.

	At the time of the call, the entire expratom is available in the lvn
	PSL.atom.

	NOTES:
	. This is VERY tricky code !!!!
		It uses the lvn atom, which is assigned by $$valExpr^UCGM before
		it calls $$valObj(), which calls $$valObj^UCGM(), which calls
		$$method^UCGM(), which calls getRecord^UCDB which calls this
		subroutine ...
		If any of these levels NEWs atom, this subroutine will generate
		incorrect code.
	. PSL.ptr must be set to zero at the end of the subroutine, because it
		is needed to construct the quit-argument.
	. This subroutine will use the key variables as public variables,
		without declaring them public. This relies on the suppression of
		warnings by PSLBuffer.insert().
	*/
	type public String atom

	if PSL.fset do ERROR^UCGM("Expression is not updateable") quit

	type String table = PSL.actual(1).stripQuotes()

	/* Append code to PSL source and create a unique label */
	type String var=$$nxtSym^UCGM
	type String label="vDbGr"_$P(var,"vo",2)	// Create unique label

	/* Always need to generate the subroutine */
	type PSLBuffer buf = PSL.openBuffer( "()", "nested Db.getRecord() using "_ var)
	do buf.add(" type "_ PSL.reClass_ table_ " "_ var_ "=Db.getRecord("_ PSL.actual(1)_ ","_ PSL.actual(2)_ ","_ PSL.actual(3)_ ")")
	do buf.add(" quit "_ var_ $$UNTOK^%ZS(atom.extract( PSL.ptr + 1, atom.length()), PSL.tok))

	do buf.insert( label)

	set PSL.return = label_ "()"
	set PSL.class  = "String"
	set PSL.ptr    = 0

	quit

	// ---------------------------------------------------------------------
private getRecSr( PSLTable td,	// table descriptor
	String recInst,		// record variable or declaration position (*2)
	String label,		// name of subroutine to generate
	String comment,		// comment line of subroutine
	Number clsNew)		// value of ClassNew parameter (0, 1, "")
	/* ---------------------------------------------------------------------
	This subroutine generates the subroutine that implements the
	Db.getRecord method for the specified table and ClassNew combination.

	The generated subroutine can have one of seven signatures (assuming a
	table with 2 key columns):
	- label(v1,v2)
		This signature will be used when vobj() is used, or when
		none of the -2, -99, nor -151 purpose nodes are needed.
	- The following combinations, based on which of the purpose nodes are
	  needed:
	  	- label(v1,v2,v2out)
	  	- label(v1,,v2,v99out)
	  	- label(v1,,v2,v151out)
	  	- label(v1,,v2,v2out,v99out)
	  	- label(v1,,v2,v2out,v151out)
	  	- label(v1,,v2,v99out,v151out)
	  	- label(v1,,v2,v2out,v99out,v151out)

	Because the signatures will be different, the caller must be aware of
	the signature that is associated with the call to the supplied label.

	ARGUMENTS:
	(*2) recInst = record variable or declaration position
		If a record variable is supplied, the generated code will use
		vobj(recInst), and all assignments to negative nodes (key, -1,
		-2, -150, -151) will be included.
		If a declaration position is supplied, the generated code will
		assume the voxn mode. In this case, the code returned by
		getRecCode^UCXDD() will always be included. Assignements to
		variables that represent key columns will never be made because
		the subroutine may be called from different places that use
		different key pupose variables. Assignments to the special
		purpose nodes -2 and -151 will only be included if the
		associated purpose ID is defined ($$lvpm^UCREC4OP() not empty).
		The values will be passes out of the subroutine using additional
		formal parameters.

	NOTES:
	. lvpm() = local variable purpose map
		For all modes, this subroutine will force the mappings for
		keyOrdinal_"*" (primary keys in retrieval).
		For vobj mode, the subroutine forces the entries for
		-keyOrdinal - 2 (primary key in assignment), and for the special
		purpose nodes -2, -99, and -151 (even if on MDB)
		For voxn mode, nodes will only be copied from $$lvpm^UCREC4OP(),
		if they exist.
	. The code that determines whether to generate assignments to (default)
		key / special purpose nodes in located in the first part of the
		subroutine, by setting lvmp(). Code in the second part of the
		subroutine will just generate what it is told to do based on the
		nodes present in lvpm().
	*/
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	type String  archRef = ""	// archive reference
	type String  archTbl = td.getArchiveTable()
	type String  code
	type List    fkeys = td.primaryKeys
	type List    fpl = ""		// formal parameter list
	type Number  i			// iterator
	type String  load()		// load code by getRecCode^UCXDD
	type String  loadNod = ""	// node corresponding to the lvn
	type String  lvn		// scratch local var name
	type String  lvpm()		// map passed to getRecCode^UCXDD()
	type Boolean useVobj = 'recInst.isNumber()
	type String  retVal

	if 'fkeys.isNull() do {
		for i=1:1:fkeys.count() do {
			if i>1 set fpl = fpl_ ","
			set fpl = fpl_ "v"_i, lvpm( i_"*") = "v"_i
			if useVobj set lvpm( -2-i) = PSL.oLvn_ "("_ recInst_ ","_ (-2-i)_ ")"
			//else  set lvn=$$lvpm^UCREC4OP( recInst,-2-i, 0) if 'lvn.isNull() set lvpm(-2-i) = lvn
		}
	}

	if useVobj do {
		/* lvpm(-1) is needed for parent/child recordMode updates */
		set lvpm(-1) = PSL.oLvn_ "("_ recInst_ ",-1)"
		set lvpm(-2) = PSL.oLvn_ "("_ recInst_ ",-2)"
		if td.isRdb set lvpm(-151) = PSL.oLvn_ "("_ recInst_ ",-151)"
	}
	else  for i = -2,-99,-151 do {
		if $$lvpm^UCREC4OP( recInst, i, 0).isNull() quit
		set lvpm(i) = "v"_ (-i)_ "out", fpl = fpl.add( lvpm(i))
	}

	type PSLSubrou sr = PSL.addSubrou( label, "("_ fpl_ ")", comment, 0)

	/* code to NEW local vars, and to create new object:
	   If vobj mode use RecInst, else get the node that will receive the
	   initial retrieval. Use this node locally as well, but NEW it (because
	   that variable will also receive the return from the function call).
	   We must use the same variable(s) as mapped by $$lvpm^UCREC4OP(),
	   because the code generated by getRecCode^UCXDD() may use these nodes
	   to deal with DBTBL1.QID1 !!
	   */
	if useVobj set retVal = recInst, code = " N "_retVal
	else  do {
		set loadNod = $$getRecPur^UCXDD( td)
		if loadNod.isNull() set retVal = """""", code =""
		else  set (lvpm( loadNod), retVal) = $$lvpm^UCREC4OP( recInst, loadNod), code = " N "_retVal
	}

	if td.isRdb set code = code_ " N vData,vEr,vRm"
	do sr.addCode( code)
	if useVobj do sr.addCode( $$cdNewObj^UCCLASS( recInst, """Record"_ td.table_ """"))

	/* If database IO counts are requested, insert code here, so we count
	   unsuccessful calls as well */
	if PSL.hasSetting("DEBUG","DBIOCOUNT") do sr.addCode(" D "_ PSL.getSetting("DEBUG","DBIOCOUNT")_"("""_td.table_""",""READ"")")

	// Initialize archive directory purpose node, get archive key
	if 'archTbl.isNull() do {

		if 'lvpm(-99).exists() set lvpm(-99) = "vobj(vOid,-99)"
		set archRef = lvpm(-99)
	
		set code = " S "_ archRef_ "="""""

		do sr.addCode( code)
	}

	// add initial load code - strip any archive reference
	do getRecCode^UCXDD( td, recInst, .lvpm(), .load(), .pslCln())
	for i = 1:1:load("").order(-1) do sr.addCode( load(i).replace("|"_archRef_"|", ""))
	
	if lvpm(-2).exists() do sr.addCode( " S "_ lvpm(-2)_ "="_ $SELECT(clsNew:"'$T",1:"1"))

	// Append RECNOFL exception, and record mode assignment
	if archTbl.isNull() do {
		if clsNew = 1 set code=" ;"
		else  do {
			set code = " I $T "
			if useVobj set code = code_ "K "_ PSL.oLvn_ "("_ recInst_ ") "
			if clsNew=-1 set code = code_ "Q """""
			else  set code = code_ "S $ZS=""-1,""_$ZPOS_"",%PSL-E-RECNOFL,,"_ td.table_ """ X $ZT"
		}
		do sr.addCode( code)
	}
	else  do {
		
		type Number archKey = td.getArchiveKey(true)
		type PSLTable tdarch = PSL.getPSLTable(archTbl)
		
		do sr.addCode(" I $T D  ; Try archive")
		do sr.addCode(" .  N vArch")
		set code = " .  S vArch=$$ARCHFILE^"_tdarch.filerPGM_"("""_td.table_""",1,"
		if archKey > 1 set code = code_ fpl.piece(",", 1, archKey - 1)_","
		set code = code_ fpl.piece(",", archKey)_"-1E-10)"
		do sr.addCode( code)
		set code = " .  I vArch="""""
		
		// If not in archive, OK to create new
		if clsNew = 1 set code = code_ " Q"
		do sr.addCode( code)
		
		// Try to load from archive
		for i = 1:1:load("").order(-1) do {
			
			if clsNew = 1 set code = " . "
			else  set code = " .  E "
			
			// Load code will have ^|vobj(vOid,-99| - replace
			set code = code_ load(i).replace(archRef, "vArch")
			do sr.addCode( code)
		}
		
		// Ignore possibility of clsNew = -1 (check with Frans if OK)
		if clsNew = 1 set code = " .  ;"
		else  set code = " .  I $T K vobj(vOid) S $ZS=""-1,""_$ZPOS_"",%PSL-E-RECNOFL,,"_ td.table_ """ X $ZT"
		do sr.addCode( code)
		
		// Update archive directory purpose node even if clsNew=1 and
		// no record since this record would have been in archive range
		set code = " .  S "_ archRef_ "=vArch"
		do sr.addCode( code)
		
		// Done earlier and won't change if clsNew = 0
		if clsNew = 1, lvpm(-2).exists() do sr.addCode( " .  S "_ lvpm(-2)_ "="_ $SELECT(clsNew:"'$T",1:"1"))
	}

	// code to assign keys, and -150/-151 for Rdb
	type PSLColumn cd
	type String set150 = ""
	//type String set151 = ""
	type String typ
	for i=1:1:fkeys.count() do {
		if lvpm(-2-i).exists() do sr.addCode( " S "_ lvpm(-2-i)_ "=v"_ i)

		if 'td.isRdb quit
			
		if i>1 /* set set151 = set151_ "_"" AND " */ if useVobj set set150 = set150_ ","

		set cd = PSL.cachePSLColumn( pslCln(), td.table_"."_ fkeys.elementAt(i), pslTbl())
		set typ =cd.dataType

		// B, and M do not occur in key
		// F, U, and T map to character type
		// $, C, D, L, and N map to numeric type
		//if "FUT"[typ set typ = "$$QADD^%ZS(v"_ i_ ",""'"")"
		//else  set typ = "(+v"_ i_ ")"
			
		//set set151 = set151_ cd.internalColumn_ "=""_"_ typ

		// -150 maintained only if using vobj()
		if useVobj set set150 = set150_ $$getRdbAsn^UCXDD(cd, retVal)
	}

	/* Note that vEr at this point can only be 0 (success) or 100
	   (no record found), and that a non-empty value of set150 implies a
	   non-empty value of set151. However, even if vobj() is not used,
	   set151 will be non-empty if incremental loading or bypassSave
	   apply to this declaration. */
	if clsNew, 'set150.isNull() do {
		do sr.addCode( " I vEr=100 S "_set150)
		set code = " E "
	}
	else  set code = ""

	//if 'set151.isNull(),lvpm(-151).exists() do sr.addCode( code_ " S "_ lvpm(-151)_ "="" WHERE "_ set151)
	if lvpm(-151).exists(),'fkeys.isNull() do sr.addCode( code_ td.getUpdateKey( recInst, lvpm()))

	do sr.addCode(" Q "_retVal)
	quit

	// ---------------------------------------------------------------------
private getSchTab	// method Db.getSchemaTable(String tablename)
	/* ---------------------------------------------------------------------
	INPUTS:
	. actual(1) = name of table (dynamic value allowed)
	*/
	set PSL.return = "$$getSchema^UCSCHEMA("_ PSL.actual(1)_ ")"
	quit

	// ---------------------------------------------------------------------
private hasQual( public PSLExpression expr,	// expression to be checked (*1)
		local String val)		// qualifiers that shall occur (*2)
	/* ---------------------------------------------------------------------
	Does expr contain all qualifiers in val?

	This function checks if expr contains the supplied value according to
	the following rules:
	- If expr = "" it returns 0 (zero)
	- Else, if expr is not a literal, it returns 0 (zero)
	- Else it returns {List}(expr.StripQuotes()).contains(val,"/") for
		ALL qualifiers in val.

	If expr is passed by reference, and the value is a literal, its value
	will be standardized for qualifier use ("/" in the first position)

	ARGUMENTS:
	(*1) expr = qualifier exrpession to be checked.
		This is a PSLExpression: A literal value shall be properly
		quoted.
		This function assumes that qualifiers contain boolean qualifiers
		only, that values are specified as either /QUAL or /NOQUAL, and
		that conflicts have been resolved by the caller (eg both /QUAL
		and /NOQUAL).
		A supplied literal value need not start with a slash.
	(*2) val = qualifiers that shall occur
		This is a String parameter, that specifies the qualifier values
		to look for. Each slash-separated value is treated as a literal
		that shall occur in expr.
		The supplied value shall not be quoted, and shall start with a
		"/".

	OUTPUTS:
	. $$ = 1 if and only if expr contains ALL qualifiers listed in val.
	*/
	if expr.isNull() quit 0
	if 'expr.isLiteral() quit 0
	set expr = expr.stripQuotes()
	if expr = "" quit 0
	if expr.extract() '= "/" set expr = "/"_ expr

	type String qual = expr_"/"	// standardized with trailing "/"
	set expr = expr.addQuotes()	// standardized quoted literal

	if val_"/" = qual quit 1

	type Boolean ret = 1
	type Number  i

	for i=2:1:val.length("/") if qual'[("/"_ val.piece( "/", i)_ "/") set ret=0 quit

	quit ret

	// ---------------------------------------------------------------------
private isDefined	// void; method Db.isDefined
	/* ---------------------------------------------------------------------
	*/
	type public Boolean  isDirctv
	type public PSLTable pslTbl()
	type public String   sysmap(,,)

	type String expr
	type String from  = PSL.actual(1)
	type String where = PSL.actual(2)
	type Number count = PSL.actual(3).stripQuotes()

	// Determine if dynamic
	for expr=from,where,count if 'expr.isNull(),'expr.isLiteral() quit
	if  do isDefDyn(from,where,count) quit

	set from = from.stripQuotes()
	set where = where.stripQuotes()
	if 'count.isNull(),'({String}count).isNumber() do PSL.error("matchCount must be Number") quit

	type String   table = from.piece(",")
	type PSLTable td    = PSL.cachePSLTable( pslTbl(), table, 1)
	type List     fkeys = td.primaryKeys

	if isDirctv.get() set sysmap("#IF","Db.isDefined",table) = fkeys.elementAt( fkeys.count())

	// CUVAR etc. on MBD
	if fkeys.isNull(),'td.isRdb set PSL.return = "$D("_ td.global.piece("(")_ ")" quit

	if where'[" " set where = $$akey2sql( where, fkeys)	// Support legacy key syntax

	type String atom, saveatom, tkeys = ","_ fkeys_ ","
	type Number found, ptr = 0
	for  set atom = $$ATOM^%ZS( where, .ptr, "=") do { quit:ptr=0
		if atom'="=" set saveatom = atom.stripQuotes()_ "," quit
		set found = tkeys.find( saveatom)

		/* isDefined may be used without some keys, if a column does not
		   match then that is the case so we can not warn about it. */
		if found=0 set tkeys = "" quit	
		set tkeys.extract( found-saveatom.length(),found-2) = ""
	}

	// In two-argument form (count not supplied), all keys must be supplied
	if count.isNull(),tkeys.translate(",")'="" do PSL.error("Incorrect number of keys; missing "_tkeys.translate(","," ")) quit
	if where[":" set where = $$mapPSLvar(where)

	/* For the remainder of the code an absent/empty count is equivalent to
	   count = 1 */
	if count.isNull() set count = 1

	/* From here the RDB code and the MDB code are different. The major
	   reason for the distinction is that FSCW is not sure why the statement
	   for the MDB version ends up as:
		SELECT DISTINCT key1 FROM table WHERE whereclause
	   The reason for this may be that the code returned in vsql can easily
	   be used to derive the correct MDB behavior.
	   For RDB tables, the SQL statement will be:
		SELECT COUNT(*) FROM table WHERE whereclause
	   The returned "row" will be compared to 'matchcount' (default: 1) to
	   construct the return value of the Db.isDefined() function call.
	   */
	if td.isRdb set PSL.return = $$isDefined^UCDBR( td, where, count) quit

	// MDB code
	type public String ER,RM

	/* If count=1, it might be sufficient to know if there is a match, and
	   the exact SELECT-clause does not really matter. However, if count>1,
	   then we need to count every possible matching row, and the
	   SELECT-clause must include the complete primary key.

	   The original M version of UCDB used the above difference. Furthermore
	   it inferred that any "jump forward" was a sufficient indication to
	   decide that no matching rows were to be found, and a "QUIT 0" was
	   appropriate. After a Unicode related change to the SQL engine, a
	   "jump forward" is no longer an indication of "no match".
	   In order to ensure behavior that stays close to the behavior of
	   Db.select(), all cases now use the complete primary key in the
	   SELECT-clause.
	================ old code begin ================
	if count = 1 set expr = "DISTINCT "_ fkeys.elementAt(1)_ " FROM "_ from
	else  set expr = "DISTINCT "_ fkeys_ " FROM "_ from
	================ old code end ================ */

	set expr = "DISTINCT "_ fkeys_ " FROM "_ from

	if 'where.isNull() set expr = expr_ " WHERE "_ where

	type String    code, exe(), vsql()
	type List      decl   = ""	// vsqlN vars that need to be declared
	type String    dline  = ""	// line that contains M $DATA()
	type PSLSubrou label  = PSL.addSubrou( "DbEx", "()", "min("_ count_ "): "_ expr, 1)

	/* Set prefix that will be used for labels that are jumped to (cf fetch
	   code). These labels will use at least 2 additional characters (aN,
	   where N is the subscript in the exe() array).
	   Iteration labels for Db.isDefined() start with vEx
	    */
	do label.setTagPrefix( "vEx"_ label.toString().piece("DbEx",2))

	/* Reserve a line that can be used for the declarations, and remember
	   its location. */
	do label.addCode(" ; No vsql* lvns needed")
	type Number declLine = label.getLine()

	if count>1 set dline = 0 do label.addCode(" N vCnt S vCnt=0")

	do SELECT^SQL(expr,"/NOCACHE",,,,,,-1) if ER quit

	type Number codPtr = vsql("P").get()
	type Number i

	if codPtr do {
		do label.addTag( 0, "Q 0")

		/* If count>1, then the "repeated fetch" will "jump" to the line
		   indicated by vsql(0). Make sure that line will receive a
		   label. This is needed because the jump to that line will
		   not be added by addExe() but by addLine(). Note that if
		   count=1, there will be no repeated calls and there is no need
		   to force the label. */
		if count>1,vsql(0).get() do label.addTag( vsql(0))
	}

	for i=1:1:codPtr do {
		set code = exe(i)
		if code["'?.N",code["$$FDAT^%ZM" do label.addExe( ";") quit
		if code?.E1"$G("1U.E do { quit		// Sub host var
			type String lvn = code.piece("$G(",2).piece(" ")
			type Number n   = code.piece("vsql(",2).piece(")")
			do label.addExe( ";") 
			do label.addLvn( n, lvn.extract( 1, lvn.length()-1))
		}

		// Line below must be synced with code generated by SQL engine
		if dline="",(code["I '($D(^")!(code["I '$D(^") set dline = label.getLine()+1
		else  set dline=0

		if code["S vd" set i = codPtr quit	// FSCW: questionable ??

		do label.addExe( code)
	}

	// derive List of lvns to NEW
	type PSLExpression ex
	for i=1:1:label.getLvnMax() do {
		set ex = label.getLvn( i)
		if ex?1"vsql"1.N set decl=decl.add(ex)
	}

	// Cannot optimize archive enabled table
	if 'td.getArchiveTable().isNull() set dline = 0

	/* Only relevant line is the line that contains the IF '$DATA(). Return
	   as inline code. */
	if dline>0,decl.isNull() do { quit
		set PSL.return = label.getCode(dline)
		set PSL.return = PSL.return.piece("I '",2).piece(" Q 0")
		do decrLabel^UCGM( label.toString())
	}

	/* count specified, but no labels (= no iteration) ==> at most one row
	   */
	type Number tag = label.getTagMax()
	if count>1,tag=0 do { quit
		set PSL.return = "0"
		do INFO^UCGM("DEAD","Db.isDefined() always 0; MatchCount '"_count_"' exceeds possible matches ")
	}

	if 'decl.isNull() do label.insCode(declLine, " N "_decl)

	/* code line constructed here will be passed to PSLSourou.addExe(), that
	   expects code that does not start wit a space or tab. */
	set code="Q 1"
	if count>1 set code = "S vCnt=vCnt+1 I vCnt="_ count_ " "_ code

	/* Add code using PSLSubrou.addExe() to deal with jump around deepest
	   $ORDER(). See select for explanation etc.
	   */
	do label.addExe( code)

	if count>1 do label.addCode(" G "_ label.getTag( $SELECT(vsql(0).get():vsql(0),1:codPtr)))

	set PSL.return="$$"_ label.toString()_ "()"

	quit

	// ---------------------------------------------------------------------
isDefDyn( String from,
	String where,
	Number count)
	/* ---------------------------------------------------------------------
	method Db.isDefined - Dynamic from or where

	Build this capability out later as needed
	*/
	do PSL.error("Dynamic Db.isDefined() is not supported") 
	quit

	// ---------------------------------------------------------------------
private LitInst( PSLIdentifier var,	// target variable
		String table,		// source table
		List akeys,		// access keys, literal values only
		String deflt,		// instantiate NEW flag
		String level)		// current DO level
	/* ---------------------------------------------------------------------
	OUTPUTS:
	. PSL.class  = class name of instance.
	. PSL.return = objectID of Record instance.
	. type(level,var)
		If level<0, then the instExpr piece of this node will have been
		filled with the object ID of instantiated Record.
	. vobj(return) or vobj(return,node)
		The initial load node will have been created. In addition, the
		special purpose nodes -1, and -2 will have been created.
	NOTES:
	. Also called by main^UCGM() to instantiate var CUVAR as a LITERAL
		RecordCUVAR instance
	*/
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()
	type public String    type(,)

	type String keys, load(), tok, v
	type Number i
	type PSLTable td = PSL.cachePSLTable( pslTbl(), table)

	set PSL.class = PSL.reClass_ table

	set akeys = $$TOKEN^%ZS( akeys, .tok)

	/* Use Dynamic Record Access interface to instantiate a new record.
	   Do NOT try Class.new("Record", table), because PSL's object scoping
	   will add a KILL of the Record instance prior to return from the
	   subroutine */
	set PSL.return = $$new^DBSDYNRA( table)

	if '(akeys="") for i=1:1:akeys.count() do {
		set v = $$UNTOK^%ZS( akeys.piece( ",", i), .tok)
		if 'v.isLiteral() do PSL.error( "Literal parameter required: "_ v) quit
		set vobj( PSL.return, -2-i) = v.stripQuotes()
	}

	do get^DBSDYNRA( PSL.return, deflt)

	if level<0 do {					; Pre-code

		do setScope^UCGM( var, "", "", "LITERAL", PSL.class)

		set type(level,var).piece( PSL.tab, 4) = -1	// Runtime code line
		set type(level,var).piece( PSL.tab,5) = PSL.return
	}
	quit

	// ------------------------------------------------------------------
LitOpen( String expr,		// complete SQL SELECT statement
	String qual)		// qualifiers
	/* ------------------------------------------------------------------
	Target variable of ResultSet (PSL.var) has LITERAL scope.
	Open the cursor now.
        */
        type String apar()		// OPEN^SQL expects array, not list
	type String sqlsta,sqldta,sqlcnt,sqlind		// passed to OPEN^SQL

	set expr = PSL.var_ " AS SELECT "_ expr

	do PARSPAR^%ZS( qual, .apar())
	do OPEN^SQL( expr, apar(), .sqlsta, .sqldta, .sqlcnt, .sqlind)

	set PSL.return = sqlsta.get()

	quit

	// ---------------------------------------------------------------------
private keyVal(inc)	// void; Method Db.nextVal, currVal, nextKey, prevKey, and prevVal
	/* ---------------------------------------------------------------------
	One subroutine for five methods. The inc parameter determines the
	method that is requested.
	Generate code for the methods Db.currVal(), Db.nextVal(), Db.nextKey(),
	and Db.prevKey()

	For table tbl with primary key key1,keyLast,keyTarget, the method call
	Db.method( "tbl","key1=:val1,keyLast=:valLast") is equivalent to the
	following SQL statement and M expression:

	ARGUMENTS:
	. inc = method to be generated:
		 0 = Db.currVal
		 	SELECT MAX(keyTarget) FROM table WHERE key1=:val1 AND keyLast=:valLast
		 	$ORDER(^TABLE(val1,valLast,""),-1)
		 1 = Db.nextVal
		 	SELECT MAX(keyTarget)+1 FROM table WHERE key1=:val1 AND keyLast=:valLast
		 	$ORDER(^TABLE(val1,valLast,""),-1)+1
		 2 = Db.nextKey (deprecated)
		 	SELECT MIN(keyLast) FROM table WHERE key1=:val1 AND keyLast>:valLast
		 	$ORDER(^TABLE(val1,valLast))
		 3 = Db.prevKey (deprecated) and Db.prevVal (deprecated)
		 	SELECT MAX(keyLast) FROM table WHERE key1=:val1 AND keyLast<:valLast
		 	$ORDER(^TABLE(val1,valLast),-1)

	INPUTS:
	. actual(1) = table
	. actual(2) = (partial) access key

	NOTES:
	. There are a couple of special cases in the RDB code:
		- for Db.currVal() and Db.nextVal(), the WHERE clause will be
			empty if the first key column is used for the increment.
			In this case, the call to $$where^UCDBR must be
			suppressed.
		- for Db.nextVal, if there are no matching rows (i.e. this will
			be the first values), then the ResultSet will be empty.
			So SELECT MAX(col)+1 will not return a value. This is
			handled by using the same SELECT clause for Db.currVal
			and Db.nextVal (MAX(col)), and adding one in the quit-
			argument that terminates the function.
	. Db.prevVal() and Db.prevKey() are now equivalent.
		The value inc=-1 that used to be associated with Db.prevVal()
		shall no longer be used. To be sure the correct code is
		generated, this subroutine changes inc=-1 into inc=3
	. For MDB, there is the special case of Db.currVal on a table with
		DBTBL1.QID1 IS NOT NULL. In that case, the last (constant) value
		of the $ORDER() may be other than "" (eg if QID1 has a KEY<max
		condition).
	. For MDB, if the table is archived, it is possible that all records will
	  be in archive files, so need to locate 
	*/
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	if (inc=0)'!(inc=1) do WARNDEP^UCGM("Db."_$piece("prevVal;nextKey;prevKey",";",$tr(inc,"-")))

	if inc = -1 set inc = 3	// Force equivalence of Db.prevVal() and Db.prevKey()

	type String table = PSL.actual(1).stripQuotes()
	type PSLTable td  = PSL.cachePSLTable( pslTbl(), table, 1)
	type PSLExpression map()
	type String akeys = $$akey2apl( td, "", PSL.actual(2), -1, map())

	type List fkeys = td.primaryKeys
	if fkeys.isNull() do ERROR^UCGM("Invalid method for table: "_table) quit

	type Number acnt = -map("").order()-2		// ord of last keyvalue
	type Boolean useRdb = false			// use RDB method for prevKey
	type Number k					// key iterator

	/* If Db.currVal() supplies all keys, then the "result" is the value
	   supplied for the last key (Goofy but OK according to Frank)
	   */
	if acnt<1 set acnt=0 if inc=2!(inc=3) throw Class.new("Error", "%PSL-E-INVALIDREF: missing accessKey for Db."_ PSL.method)
	if acnt=fkeys.count(), inc=0 set PSL.return = map( -acnt-2) do warnGroup^UCGM( "DEAD", "Db.currVal() with all keys - will assign "_ PSL.return) quit
	if acnt=fkeys.count(), inc=1 do {
		/* if Db.nextVal() supplies all keys, drop last key from map()
		   and from akeys */
		do warnGroup^UCGM( "DEAD", "Db.nextVal() with all keys - dropped "_ td.primaryKeys.elementAt( acnt)_ "="_ map( -acnt-2))
		kill map( -acnt-2) set acnt = acnt - 1
		if acnt = 0 set akeys ="" quit
		set akeys = map(-3)
		for k=2:1:acnt set akeys = akeys_","_map( -k-2)
	}

	/* For prevKey, if table is archived and we are at the archive key
	   level or below, then need to use SELECT, like RDB does, in order
	   to consider archive code.
	*/
	if (inc = 3),'td.getArchiveTable().isNull() do {

		type PSLTable tdarch = PSL.getPSLTable(td.getArchiveTable())

		type Number archkey = tdarch.getArchiveKey()

		// Not getting to archive key level
		if (acnt '< archkey) set useRdb = true
	}

	if td.isRdb ! useRdb do { quit
		/* RDB code for Db.currVal, Db.nextVal, Db.nextKey, Db.prevKey

		   MDB code for Db.prevKey if archived table, since need to
		   consider archive files for this one on backward collation.

		   The call will translate into a function call. The function
		   will have one formal parameter for each key that occurs in
		   accKey.
		   The formal parameters will be named V1, V2, etc. (note the
		   uppercase spelling), so the names can be used as SQL hostvar
		   without re-assignment.

		   For RDB, each method generates a call to $$SELECT^%DBAPI() with
		   the SQL SELECT statement listed for the method in the ARGUMENTS
		   section.

		   The construction of the WHERE clauses relies on the fact that
		   $$RsMsXV^UCDBRT() will ensure proper hostvar values (eg +Num)

		   For MDB, the call is to SELECT^SQL.
		   */
		type String sel		// select clause (with INTERNAL names)
		type String whr		// where clause (with DQ names)
		type PSLColumn cd	// column descriptor

		if inc = 0 ! (inc = 1) do {	// Db.currVal and Db.nextVal
			set cd = PSL.cachePSLColumn( pslCln(), table_"."_fkeys.elementAt( acnt+1), pslTbl())
			set sel = "MAX("_ cd.internalColumn_ ")"
			if inc = 1, "TUFL"[cd.dataType do PSL.error("Db.nextVal() invalid for data type "_cd.dataType)
			set whr = ""
		}
		if inc = 2 do {			// Db.nextKey
			set cd = PSL.cachePSLColumn( pslCln(), table_"."_fkeys.elementAt( acnt), pslTbl())
			set sel = "MIN("_ cd.internalColumn_ ")"
			set whr = cd.column _ ">:V"_acnt
			set acnt = acnt - 1
		}
		if inc = 3 do {			// Db.prevKey and Db.prevVal
			set cd = PSL.cachePSLColumn( pslCln(), table_"."_fkeys.elementAt( acnt), pslTbl())
			set sel = "MAX("_ cd.internalColumn_ ")"
			set whr = cd.column _ "<:V"_acnt
			set acnt = acnt - 1
		}

		/* Construct the (remaining) primary key, and transform the
		   where clause into an RDB where clause
		   */
		type String fpl = ""		// formal parameter list for sr
		type String hvmap()		// hostvar mapping

		for k = 1:1:acnt do {
			if 'whr.isNull() set whr = whr_ " AND "
			set whr = whr_ fkeys.elementAt( k)_ "=:V"_ k
			set fpl = fpl_",V"_k
		}
		if 'whr.isNull() do {
			if td.isRdb set whr = " WHERE "_ $$where^UCDBR( td.table, whr, .hvmap())
			else  set whr = " WHERE "_whr
		}

		/* Use a unique comment string to locate the subroutine:
		   table + method + number of keys */
		type String cmt = td.table _ "."_ PSL.method_"#"_ acnt
		type String label = $$findSubr^UCGM( "vDb", cmt)

		set PSL.return = "$$"_ label_ "("_ akeys_ ")"
		if PSL.subrouExists( label) quit

		if inc=2!(inc=3) set fpl = fpl_",V"_(acnt+1)

		type PSLSubrou sr = PSL.addSubrou( label, "("_ fpl.extract(2, fpl.length())_ ")", cmt, 0)

		if td.isRdb do {
			type String vListCd = $$RsMsXV^UCDBRT(hvmap(,),.whr))
			do sr.addCode( " N vData,vEr,vRm")
			do sr.addCode( " S vEr=$$SELECT^%DBAPI(0,""SELECT "_sel_" FROM "_ td.internalNames.elementAt(1)_whr_""",$C(9),"_vListCd_",.vData,.vRm)")
			do sr.addCode( " I vEr<0 S $ZS=""-1,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(vRm),$C(10,44),$C(32,126)) X $ZT")
		}
		else  do {
			do sr.addCode( " N ER,RM,vData")
			do sr.addCode( " D SELECT^SQL("""_sel_" FROM "_ td.internalNames.elementAt(1)_whr_""",,,.vData)")
			do sr.addCode( " I $G(ER) S $ZS=""-1,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(RM),$C(10,44),$C(32,126)) X $ZT")
		}
		if inc=1 do {
			do sr.addCode( " Q vData+1")
			}
		else  do sr.addCode( " Q vData")
	}	// end if RDB

	// MDB code
	type String ordExt		// $ORDER() extension
	if inc=1 do {		
		set ordExt = "),-1)+1"	// nextVal uses backward $order() + 1
		type PSLColumn cd = PSL.cachePSLColumn( pslCln(), table_"."_fkeys.elementAt( acnt+1), pslTbl())
		if "TUFL"[cd.dataType do PSL.error("Db.nextVal() invalid for data type "_cd.dataType)
	}
	else  if inc=2 set ordExt="))"	// nextKey uses forward $order()
	else  set ordExt = "),-1)"	// all others use backward $order()

	// $$getGbl^UCXDD() requires map(keynum_"*")
	for k=1:1:acnt set map(k_"*") = map( -k-2).get() if 'map( -k-2).exists() throw Class.new("Error","%PSL-E-INVALIDREF: missing accessKey for Db."_ PSL.method)

	// Db.currVal on table with view restriction is handled separately
	if inc=0,'$$RsMsQID1^UCDBRT( td.table).isNull() set PSL.return = $$keyValCurr(td, acnt, map()) quit

	// Add extra key for currVal and nextVal
	if inc=0!(inc=1) set map( acnt+1_"*") = """"""

	if 'td.getArchiveTable().isNull() do {
	
		type PSLTable tdarch = PSL.getPSLTable(td.getArchiveTable())

		type Number archkey = tdarch.getArchiveKey()
		
		// Not getting to archive key level
		if (acnt < (archkey - 1)) quit
		
		// If archkey does not exist or is null, we will use primary
		// archive directory, and don't need map(-99)
		quit:'map( archkey_ "*").exists()
		quit:map( archkey_ "*") = """"""
		
		set map(-99) = "$$ARCHFILE^"_ tdarch.filerPGM_ "("
		set map(-99) = map(-99)_ """"_ td.table_ """,0,"
			
		for k = 1:1:archkey set map(-99) = map(-99)_map( k_ "*")_ ","
		set map(-99) = map(-99).extract(1, map(-99).length() - 1)_")"
	}

	set PSL.return = $$getGbl^UCXDD( td, "", map())
	set PSL.return = "$O(" _ PSL.return.extract( 1, PSL.return.length()-1)_ ordExt
	
	quit

	// ---------------------------------------------------------------------
keyValCurr( PSLTable td,
	Number acnt,		// number of access keys supplied
	PSLExpression map())	// key value exppresions
	/* ---------------------------------------------------------------------
	Support function for Db.currVal when table has VIEW restriction.
	This function mimics the "old" UCDB code that calls SELECT^SQL and
	interprets the result.
	*/
	type String exe(),ER,fsn,RM,vsql(),vsub()	// used by SQL engine

	type Number k
	type String whr = $SELECT(acnt>0:td.primaryKeys.elementAt(1)_"=:V1",1:"")
	for k=2:1:acnt set whr = whr_ " AND "_ td.primaryKeys.elementAt(k)_ "=:V"_k

	type String sql = "DISTINCT "_td.primaryKeys.elementAt(acnt+1)_ " FROM "_td.table
	if 'whr.isNull() set sql = sql_ " WHERE "_whr
	set sql = sql_ " ORDER BY "_ td.primaryKeys.elementAt(acnt+1)_ " DESC"
	do SELECT^SQL(sql,,,,,,,-2) if ER.get() do PSL.error( RM.get()) quit ""

	/* Interpret the exe() array (ugh!)
	   - assignments of the form
			S vsql(n)=$G(Vk)
		map key number k to vsql(n)
	   - replace archive file variable with archive file reference
	   - the line that contains the $O() is the line that we want
	   - if that line still contains vsql(n) occurrences, then we cannot
		use the code (and give up)
	   */
	type Number i,ii,keyNum
	type String code,vsqlN,keyVar

	for i=1:1:exe do {
		set code=exe(i)
		if code'["S vsql(" quit

		set vsqlN  = code.piece( "="), vsqlN = "vsql("_ vsqlN.piece( "S vsql(",2)
		set keyVar = code.piece( "=",2).piece( " ")
		if keyVar = vsqlN quit
		if keyVar.beginsWith( "$G(V") do {
			set keyNum = keyVar.piece("V",2).toNumber()
			if keyNum<1!(keyNum>acnt) quit
			set keyVar = map( keyNum_ "*")
		}

		for ii=i+1:1:exe do {
			if keyVar["$$ARCHFILE", exe(ii)[vsqlN set exe(ii) = exe(ii).replace(vsqlN, keyVar)
			if exe(ii)[vsqlN  set exe(ii) = $$varSub^UCPATCH( exe(ii), vsqlN, keyVar)
		}
	}
	set code = exe( vsql("P"))

	if code'["=$O("  do PSL.error( "Compiler cannot interpret SQL") quit ""
	if code ["vsql(" do PSL.error( "Compiler cannot interpret SQL") quit ""

	type String tok
	set code = $$TOKEN^%ZS( code, .tok)
	quit "$O("_ $$UNTOK^%ZS( code.piece("$O(",2).piece( ") "), .tok)_ ")"

	// ---------------------------------------------------------------------
private procPar( public String fsn(),
		local Boolean sparse)
	/* ---------------------------------------------------------------------
	Process input parameters
	
	NOTES:
	. Only called by msg^UCRUNTIM and xbad^UCRUNTIM !!
	*/
	type public PSLTable pslTbl()

	type String table = PSL.actual(1).get()
	type String akeys = PSL.actual(2).get()

	if table.extract() = """" set table = table.stripQuotes( """")
	if akeys.extract() = """" set akeys = akeys.stripQuotes( """")

	type PSLTable td = PSL.cachePSLTable( pslTbl(), table, 1)

	set PSL.actual(1) = table
	set PSL.actual(2) = $$akey2apl( td, PSL.var.get(), akeys, sparse)

	if PSL.return'="" set PSL.return = PSL.return_"("_ PSL.actual(2)_")"

	if 'fsn(table).exists() do fsn^SQLDD( fsn(), table)

	quit

	// ---------------------------------------------------------------------
private rdb( String table)  // deprecated Boolean
	/* ---------------------------------------------------------------------
	Is table stored in relational database?
	This function returns $$rtIsRdb^UCXDD(), because UCXDD contains all
	DQ Dictionary related code.

	If you "own" a code element that calls this function, please rewrite
	them to call $$rtIsRdb^UCXDD.
	*/
        quit $$rtIsRdb^UCXDD(table.get())

	// ---------------------------------------------------------------------
private select	// method Db.select; returns ResultSet
	/* ---------------------------------------------------------------------

	OUTPUTS:
	. struct("s",subRou,declaredAt,rsobj) = ResultSet data, tab separated
		1) line where rsobj is instantiated
		2) sequence number
		3) ftemp flag (is ^DBTMP($J) used?)
		4) select list
		5) sequence number (if p2="", and set to 1 by Record.compare code)
		6) type/decimals list per column (for class Row)
		7) $$getScope^UCGM(rsobj)
		8) "" if selecting from M tables, 1 if selecting from RDB tables
	*/
	type String expr,RM,tok
	type Number ER=0
	type String select  = PSL.actual(1)
	type String from    = PSL.actual(2)
	type String where   = PSL.actual(3)
	type String orderby = PSL.actual(4)
	type String groupby = PSL.actual(5)
	type String parlist = PSL.actual(6)

	/* FSCW, CR15592: special code when PSLBOOT qualifier is included.
	   */
	if $$hasQual( .parlist, "/PSLBOOT") do selBoot^UCDBR( select, from, where, orderby, groupby, parlist) quit

	type Number varPtr = PSL.var.scopeLine

	/* Determine if data select is dynamic select, exclude variables setup
	   within the procedure. */
	for expr=select,from,where,orderby,groupby,parlist if 'expr.isNull(),'expr.isLiteral() quit
	if  do selectDyn( select, from, where, orderby, groupby, parlist) quit

	set select = select.stripQuotes()
	set from   = from.stripQuotes()
	if 'where.isNull()   set where   = where.stripQuotes()
	if 'orderby.isNull() set orderby = orderby.stripQuotes()
	if 'groupby.isNull() set groupby = groupby.stripQuotes()
	if 'parlist.isNull() set parlist = parlist.stripQuotes() if parlist.extract()'="/" set parlist="/"_parlist

	if select.isNull()!from.isNull() do PSL.error("Expression expected") quit
	if where[":" set where=$$mapPSLvar(where) if ER quit

	/*  Replace SELECT * by SELECT $$COLLIST^DBSDD before passing the query
	    to either MDB or RDB. This ensures that the select-list and struct()
	    will all have the same idea about the columns and their order.
	    The replacement will be skipped if FROM contains an explict JOIN or
	    table alias. */
	if select="*", from.translate("()","  ")'[" JOIN ",from'[" AS " set select=$$RsSelAll^UCDBRT(from)

	set expr = select_ " FROM "_ from
	if 'where.isNull()   set expr = expr_ " WHERE "_ where
	if 'orderby.isNull() set expr = expr_ " ORDER BY "_ orderby
	if 'groupby.isNull() set expr = expr_ " GROUP BY "_ groupby

	set expr = $$SQL^%ZS( expr, .tok)
	type String untokExp = $$UNTOK^%ZS( expr, .tok)
	if ER do PSL.error( "Invalid SQL Syntax ("_ untokExp_ "), "_ RM.get()) quit

	/* update sysmap data.
	   Note that this is not the best way to do it. There are serious
	   limitations:
	   - only the first table in the FROM-clause is considered.
	   - a FROM-clause with comma-separated names (and /DQMODE) will be
	   	treated as a single table name
	   - all SELECT-clause elements are tied to the same table
	   - all SELECT-clause elements are treated as if they are columns (not
	   	expressions)
	   */
	do {
		type String select,from,ref
		type Number i
		set select = expr.piece(" FROM ",1)
		set from   = expr.piece(" FROM ",2).piece(" ",1)
		set from   = $$UNTOK^%ZS(from,.tok)
		if from["""" set from = from.stripQuotes()

		for i=1:1:select.length(",") do {
			set ref = select.piece(",",i)
			if ref[" " set ref = ref.piece(" ",1)
			set ref = $$UNTOK^%ZS(ref,.tok)
			if ref["""" set ref = ref.stripQuotes()
			if ref["."
			else  set ref=from_"."_ref
			do addXref^UCGM("P0",ref,"")
		}
	}

	if PSL.var.scope = "LITERAL" do LitOpen( untokExp, parlist) quit

	/* The FROM-clause may contain keywords like JOIN, AS etc.
	   Call $$RsRdb^UCDBRT() because it takes that into account to determine
	   if this is an RDB select. */
	if $$RsRdb^UCDBRT(from) do select^UCDBR( select, from, where, orderby, groupby, parlist) quit

	// MDB only --------------------------------
	/* variables used / returned by SELECT^SQL() */
	type String exe(), vsql(), vsub()

	/* Split the SQL statement in case it is very long.
	   Use the first (and usually only part) as the comment when creating
	   the new vOpen() subroutine.
	   Add the remaining lines immediately after the subroutine declaration.
	   */
	type Number i
	type String split()

	if untokExp["""" set untokExp = untokExp.stripQuotes()
	do splitCode^UCGMC( untokExp, 0, " ,", .split())
	type PSLSubrou openLbl = PSL.addSubrou( "Open","()", split(1), 1)
	for i=2:1:split("").order(-1) do openLbl.addCode( " ; "_ split(i))

	set PSL.return = "$$"_ openLbl.toString()_ "()"

	type Number seq      = PSL.return.extract( 8, PSL.return.length()).translate("()")
	type String fetchLbl = "vFetch"_ seq

	// iteration labels for Db.select() start with vL
	do openLbl.setTagPrefix( "vL"_ seq)

	set select = $$RsSelList^UCDBRT( select)		// remainder can use standard version

	/* FSCW CR14185: add trap, that only applies to call to SELECT^SQL() */
	do {
		catch vSQLex {
			set ER = 1, RM = vSQLex.toString()
		}
		do SELECT^SQL( expr, "/NOCACHE"_ parlist, , , , , .tok, -1) 
	}
	if ER do PSL.error( "Invalid SQL Expression ("_ untokExp_ "), "_ RM.get()) quit

	type Number  ftemp   = vsql("T").get()
	type Number  keyPtr  = vsql("K").get()
	type Number  codPtr  = vsql("P").get()

	/* Protection resides in vsql("prot",), so the vsql array is not a
	   proper PSL array. Use ACCEPT DEPRECATED to deal with the .data()
	   method. */
	#ACCEPT CR=22719;DATE=2006-07-27;PGM=Frans S.C. Witte;GROUP=DEPRECATED
	type Boolean protect = vsql("prot").data()>0	// Protection enabled

	/* GROUP BY will always cause a sort, it also indicates that codePtr
	   is not correct.

	   FSCW CR14185:
	   In case of GROUP BY, the last line contains the assignment to vd. So
	   codPtr shall point to the last-but-one-th line in this case.
	   Protection handling is added AFTER that.
	   NOTE: The above is based on observation of exe(), not on evidence
	   found in design docs. If problems are reported, the validity of the
	   above assumptions shall be verified. */
	if vsql("GB").exists() set ftemp = 1, codPtr = exe("").order(-1) - 1 - protect

	// determine if aggregate functions are used	;6/12/03
        type literal List AGGFUNC = "MIN,MAX,COUNT,AVG,SUM"
        type literal String TAB = 9.char()

        type public String struct(,,,)

	type Boolean isAgFunc = 0

        for i=1:1:select.length(",") if select.piece(",",i)["(", AGGFUNC.contains( select.piece( ",",i).piece( "(")) set isAgFunc = 1

	/* Save info for fetch optimization and column name support
	   If this identifier is already instantiated, check the statement
	   and null out if they are different. */
	type String z = ( PSL.msrc+1)_ TAB_ seq_ TAB_ ftemp_ TAB_ select

	/* [FRS] Added to support the Row class
	   02/09/04 - Piece #7 added to fix fetch label problem */
	set z.piece( TAB, 6) = vsql("D").get()
	set z.piece( TAB, 7) = PSL.var.scope

	if struct("s", PSL.subRou, varPtr, PSL.var).exists() do {
		set z.piece( TAB, 2) = ""
		set z.piece( TAB, 5) = seq

		/*  FSCW CR14919: store (standardized) SELECT-clause only
		    The piece is used by Row classes (together with piece 6),
		    and it is probably not needed to set it to "".
		    In all cases it seems appropriate to "sync" pieces 4 and 6.
		    */
		if struct( "s", PSL.subRou, varPtr, PSL.var).piece( TAB, 4) '= select set z.piece( TAB, 4) = ""
	}
	set struct( "s", PSL.subRou, varPtr, PSL.var) = z

	do openLbl.addCode( " N vOid")

	/* Reserve a line for the declaration of local variables in OPEN
	   section, and remember its value. */
	do openLbl.addCode( " ;")
	type Number newPtrO = openLbl.getLine()

	do openLbl.addCode( " S vOid=$O("_ PSL.oLvn_ "(""""),-1)+1")
	if ftemp do openLbl.addCode( " K ^DBTMP($J,vOid)")

	do openLbl.addCode( " S "_ PSL.oLvn_ "(vOid,0)=2")
	do openLbl.addCode( " S "_ PSL.oLvn_ "(vOid,-1)=""ResultSet""")
	do openLbl.addCode( " S "_ PSL.oLvn_ "(vOid,-2)=""$$"_ fetchLbl_ "^""_$T(+0)")

	kill split
	do splitCode^UCGMC( select, 0, "", .split())
	do openLbl.addCode( " S "_PSL.oLvn_"(vOid,-3)="_ split(1).addQuotes())
	for i=2:2:split("").order(-1) do openLbl.addCode( " S "_ PSL.oLvn_ "(vOid,-3)="_ PSL.oLvn_ "(vOid,-3)_"_ split(i).addQuotes())

	do openLbl.addCode( " S "_PSL.oLvn_"(vOid,-4)="_ vsql("D").get().addQuotes())

	/* the $P(^) references DBTBL1.ACCKEY.
	   The combination of conditions will result in the suppression of the
	   line that ensures the first fetch, that is part of the OPEN CURSOR.
	   The reason for this code (and the way it is formulated) is unknown.

	if keyPtr.isNull(),$P($G(^DBTBL("SYSDEV",1,from,16)),"|",1)["*"
	else  do openLbl.addCode( " D "_ openLbl.getTag(1))
	================ */

	if codPtr do {
		/* There is initialization code or iteration code.
		   Include a call to this code from vOpen(), and ensure that the
		   line that corresponds to exe(1) will get a label. */
		do openLbl.addCode( " D "_ openLbl.getTag(1))
		do openLbl.addTag(1)
		if vsql(0).get() do openLbl.addTag( vsql(0))
	}

	do openLbl.addCode( " Q vOid")
	do openLbl.addCode( " ;")

	/* add vsql() replacements for first keyPtr nodes. These variables need
	   to "survive" after vOpen() and between vFetch(), so they are kept as
	   part of the object */
	for i=0:1:keyPtr do openLbl.addLvn( i, PSL.oLvn_ "(vOid,"_ i_ ")")

	// Add line that announces end-of-result (using tag 0)
	do openLbl.addTag(0)
	do openLbl.addCode( openLbl.getTag(0)_" S "_ PSL.oLvn_ "(vOid,0)=0 Q")

	type String x
	for i=1:1:codPtr do {
		set x=exe(i)

		if ftemp do {
			if x["sqlcur" set x=$$varSub^UCPATCH(x,"sqlcur","vOid")
			if x["^DBTMP(%TOKEN" set x=$$varSub^UCPATCH(x,"^DBTMP(%TOKEN","^DBTMP($J")
		}

		// Strip the following host variable tests (assumes $G() is at the end !!!!)
		if x["S ER=1" do {
			set x = x.piece(" ",1,2)
			if x [ "$G(" set x =x.piece("$G(",1)_ x.piece("$G(",2,999), x = x.extract( 1, x.length()-1)
		}
		else  if x["'?.N" set x=";"

		do openLbl.addExe( x)
	}

	/* Add the QUIT from subroutine through PSLSubrou.addExe().
	   This is done because SQL compare-greater-than-or-equal will generate
	   a jump-forward in case the "equals" does exist. If this occurs at
	   deepest iteration level, the code will "jump out of" the vOpen() code
	   "into" the vFetch() code (to the first line of the code that
	   constructs the result row). Unfortuantely the vL* labels are called
	   with DO vLNa1, whereas vFetchN() is a function that quits 0 or 1.
	   By adding the QUIT through addExe(), the label will occur at the line
	   that contains the QUIT.

	   Note that this implies that exe() code added as part of vFetchN() can
	   only deal with scrartch variable replacement, and with calls to
	   already generated labels. It cannot add new labels, neither by
	   back-patching, not by prepending "forward" references.
	   */
	do openLbl.addExe( "Q")

	type Number hvO = openLbl.getLvnMax()

	do openLbl.addCode( " ;")
	do openLbl.addCode(fetchLbl_"(vOid) ;")
	do openLbl.addCode( " ;")
	if protect do openLbl.addCode( " N vd,vi ;=noOpti")

	/* Reserve a line for the declaration of local variables in FETCH
	   section, and remember its value. */
	do openLbl.addCode( " ;")
	type Number newPtrF = openLbl.getLine()

	if vsql(0).get(),'vsql("O").get() do {
		do openLbl.addCode( " I "_ PSL.oLvn_ "(vOid,0)=1 D "_ openLbl.getTag( vsql(0)))
		do openLbl.addCode( " I "_ PSL.oLvn_ "(vOid,0)=2 S "_ PSL.oLvn_ "(vOid,0)=1")
	}
	do openLbl.addCode( " ;")
	do openLbl.addCode( " I "_ PSL.oLvn_ "(vOid,0)=0"_ $S(ftemp:" K ^DBTMP($J,vOid)",1:"")_ " Q 0")
	do openLbl.addCode( " ;")

	for i=codPtr+1:1:exe do {
		set x=exe(i)
		if ftemp do {
			if x["sqlcur" set x=$$varSub^UCPATCH( x, "sqlcur", "vOid")
			if x["^DBTMP(%TOKEN" set x=$$varSub^UCPATCH( x, "^DBTMP(%TOKEN", "^DBTMP($J")
		}
		if x["vd", 'protect set x = $$varSub^UCPATCH( x,"vd", PSL.oLvn_ "(vOid)")
		do openLbl.addExe( x)
	}
	if protect do openLbl.addCode( " S "_ PSL.oLvn_ "(vOid)=vd S "_ PSL.oLvn_ "(vOid,.1)=vi")

	if vsql("O").get() do openLbl.addCode( " S "_ PSL.oLvn_ "(vOid,0)=0")

	/* Insert declarations for temporary vsqlN variables used in the OPEN
	   section ( keyPtr+1 .. hvO) */
	if hvO>keyPtr,'isAgFunc do {
		new i,z
		set z="vsql"_(keyPtr+1)
		for i=keyPtr+2:1:hvO S z=z_",vsql"_i

		do openLbl.insCode( newPtrO, " N "_z)
	}

	/* Insert declarations for temporary vsqlN variables used in the FETCH
	   section ( keyPtr+1 .. hvF) */
	type Number hvF = openLbl.getLvnMax()
	if 'ftemp,hvF>keyPtr,'isAgFunc do {
		new i,z
		set z="vsql"_(keyPtr+1)
		for i=keyPtr+2:1:hvF S z=z_",vsql"_i

		do openLbl.insCode( newPtrF, " N "_z)
	}

	do openLbl.addCode( " ;")
	do openLbl.addCode( " Q 1")
	quit

	// ---------------------------------------------------------------------
selectDyn(select,from,where,orderby,groupby,parlist)	;local void; Dynamic SQL statement runtime
	/* ---------------------------------------------------------------------
	Notes on dynamic select in relation to RDB:

	If the environment is not an RDB, the dynamic select code for M will be
	generated.  However, if the environment is an RDB, that means that there
	is the possibility that the select could be against either table(s) mapped
	to M or table(s) mapped to the RDB. If the from-clause is literal, the
	compiler can derive whether the query deals with MDB or RDB.
	If the from-clause is dynamic, code for both cases must be included, and
	the correct path is determined at runtime.

	An additional complication is the dataitem protection (DP) logic. For
	MDB queries (dynamic or not), the DP code is included in the exe()
	array, and will be executed automatically. However for RDB queries, the
	DP logic must be handled on the PSL side. This includes a call to
	getExe^SQLPROT to obtain the code to execute at runtime, and above all
	it includes a FOR-loop to XECUTE these strings.
	
	Because the majority of the Db.select() occurrences will not include
	DPn, this subroutine will not only separate MDB code from RDB code, but
	will also try to separate RDB code that needs DP from RDB code that does
	not need DP.

	This leads to the following subroutines:
	vOpen0R/vFetch0R
		For RDB select without DP
	vOpen0P/vFetch0P
		For RDB select with DP
	vOpen0M/vFetch0M
		For MDB access in RDB environment
	vOpen0/vFetch0
		For (MDB access in) MDB environment, or as general
		dispatcher in case the code needs to defer until runtime
	*/

	type literal String COMMONFPL = "vSelect,vFrom,vWhere,vOrderby,vGroupby,vParlist)"
	type literal Number SEQ = 0
	type literal String FETCHLBL = "vFetch"_ SEQ
	type literal String OPENLBL  = "vOpen"_ SEQ
	type literal String TAB = 9.char()

	type public String mcode, struct(,,,), type(,)
	type public Number msrc

	/* Make sure scope of var is NEW */
	if $$getScope^UCGM( PSL.var, PSL.varLevel)'="NEW" do PSL.error( "SCOPE: Identifier must be local scope for dynamic SQL:"_ PSL.var) quit
	type Number varPtr = PSL.var.scopeLine

	do warnGroup^UCGM( "DYNAMIC", "SQL SELECT statement")

	if where="" set where=""""""
	if orderby="" set orderby=""""""
	if groupby="" set groupby=""""""
	if parlist="" set parlist=""""""

	/* Try to derive as much knowledge as possible about the query.
	   In particular:
	   - If it is an MDB query, and RDB query, or unknown
	   - If it uses dataprotection (RDB only)
	   */
	type Boolean isRdb  = $$rtIsRdb^UCXDD()
	type Boolean needM  = 1		// assume dynamic MDB code is needed
	type Boolean needP  = isRdb	// is dynamic RDB code with DIP needed?
	type Boolean needR  = isRdb	// is dynamic RDB code needed?
	type String  suffix = ""

	if isRdb do {
		do XvClose^UCDBR()	// always need close cursor code

		/* If literal from not for MDB, don't need to include */
		if from.isLiteral(),$$RsRdb^UCDBRT( from.stripQuotes()) set needM = 0

		/* If literal parlist does not specify /PROT, don't need to
		   include */
		if parlist.isLiteral(),("/"_parlist.stripQuotes())'["/PROT" set needP = 0

		/* Derive subroutine suffix of this call:
		   - if not RDB, the suffix will be empty
		   - else if more than one type of subroutine needed, the suffix will be ""
		   - else the suffix will be as needed.
		   */
		/* Note: with stronger datatyping rules, and proper
		   Boolean.toNumber() and Boolean.toString() methods this will
		   be reformulated using the .toNumber() methods */
		if needM + needR + needP > 1 quit

		if needR set suffix = "R" quit
		set suffix = "P" quit
	}

	if needM do {
		/* Make sure exe and vsql aren't in scope yet.
		   New exe & vsql at the line that var was scoped */
		type String mlvns = ",exe,sqlcur,vd,vi,vsql,vsub"
		type Number pce

		/* Check if any of the variables needed for dynamic select are already
		   in scope. If so, generate an error. Else add to type() */
		for pce = 2:1:mlvns.length(",") do {
			type PSLIdentifier lvn = mlvns.piece( ",", pce)
			if $$getInst^UCGM( lvn) set pce = mlvns.length( ",") do PSL.error("SCOPE: Dynamic SQL variable already used: "_lvn)
			do typeCrea^UCGM( lvn, "String", varPtr, "NEW", msrc+1, "")
		}
		if varPtr=(msrc+1) do {			// var is instantiated here
			type String f = "N "_ PSL.var
			if mcode[f set mcode = mcode.piece(f)_ f_ mlvns_ mcode.piece(f,2,999)
		}
		else  do patchNew^UCPATCH( PSL.var, mlvns, varPtr)
	}

	type String z = (msrc+1)_ TAB_ SEQ_ suffix_ TAB
	type String selExpr

	if $$isLit^UCGM(select) do {
		// select is literal (good!). Able to resolve columns
		set selExpr = $$RsSelList^UCDBRT( select)
		set z = z_ TAB_ selExpr

		if selExpr.length() > PSL.maxLitLength do {

			// Use local var if posible
			new expr,lvn
			set lvn = "", expr= selExpr.addQuotes()
			for  set lvn = type( PSL.level,lvn).order() quit:lvn=""  if expr=$$getExpr^UCGM( lvn, PSL.level) quit
			if '(lvn=""),'($$getScope^UCGM( lvn)="LITERAL") set select = lvn
		}
	}
	else  set selExpr=""

	if struct("s", PSL.subRou, varPtr, PSL.var).exists() do {
		set z.piece( TAB, 2) = ""
		set z.piece( TAB, 5) = SEQ_suffix
		if struct("s", PSL.subRou, varPtr, PSL.var).piece( TAB, 4) '= selExpr set z.piece( TAB, 4) = ""
	}
	set struct("s", PSL.subRou, varPtr, PSL.var) = z

	set PSL.return = "$$"_ OPENLBL_ suffix_ "("_ $SELECT("M"[suffix:".exe,.vsql,",1:"")_select_","_from_","_where_","_orderby_","_groupby_","_parlist_")"

	if isRdb, suffix = "" do {
		// Generate general dispatcher
		if PSL.subrouExists( OPENLBL) quit

		type PSLSubrou sr = PSL.addSubrou( OPENLBL, "(exe,vsql,"_ COMMONFPL, "RDB dynamic OPEN CURSOR dispatcher", 0)

		do sr.addCode( " I '$$RsRdb^UCDBRT(vFrom) Q $$"_ OPENLBL_ "M(.exe,.vsql,"_ COMMONFPL)
		do sr.addCode( " I ""/""_vParlist[""/PROT"" Q $$"_ OPENLBL_ "P("_ COMMONFPL)
		do sr.addCode( " Q $$"_ OPENLBL_ "R("_ COMMONFPL)
		do sr.addCode( " ;")
		do sr.addCode( FETCHLBL_"(vOid) ; RDB dynamic FETCH dispatcher")
		do sr.addCode( " I vobj(vOid,-5)=0 Q $$"_ FETCHLBL_ "M(vOid)")
		do sr.addCode( " I $D(vobj(vOid,.1))>1 Q $$"_ FETCHLBL_ "P(vOid)")
		do sr.addCode( " Q $$"_ FETCHLBL_ "R(vOid)")
	}
	if needM do {
		// generate MDB dynamic select as vOpen0/vFetch0 (MDB) or vOpen0M/vFetch0M (RDB)
		if isRdb set suffix ="M"

		if PSL.subrouExists( OPENLBL_ suffix) quit

		type PSLSubrou sr = PSL.addSubrou( OPENLBL_ suffix, "(exe,vsql,"_ COMMONFPL, "Dynamic MDB ResultSet", 0)

		do sr.addCode( " N vOid")
		do sr.addCode( " N ER,vExpr,mode,RM,vTok S ER=0 ;=noOpti")
		do sr.addCode( " ;")
		do sr.addCode( " S vExpr=""SELECT ""_vSelect_"" FROM ""_vFrom")
		do sr.addCode( " I vWhere'="""" S vExpr=vExpr_"" WHERE ""_vWhere")
		do sr.addCode( " I vOrderby'="""" S vExpr=vExpr_"" ORDER BY ""_vOrderby")
		do sr.addCode( " I vGroupby'="""" S vExpr=vExpr_"" GROUP BY ""_vGroupby")
		do sr.addCode( " S vExpr=$$UNTOK^%ZS($$SQL^%ZS(vExpr,.vTok),vTok)")
		do sr.addCode( " ;")
		do sr.addCode( " S sqlcur=$O("_ PSL.oLvn_"(""""),-1)+1")
		do sr.addCode( " ;")
		do sr.addCode( " I $$FLT^SQLCACHE(vExpr,vTok,.vParlist)")

		type String code = " E  S vsql=$$OPEN^SQLM(.exe,vFrom,vSelect,vWhere,vOrderby,vGroupby,"
		set code = code_ "vParlist,"
		set code = code_ ","		// tok
		set code = code_ "1,"		// mode
		set code = code_ ","		// vdd
		set code = code_ "sqlcur)"	// cursor id
		set code = code_ " I 'ER D SAV^SQLCACHE(vExpr,.vParlist)"
		do sr.addCode( code)

		do sr.addCode(" I ER S $ZS=""-1,""_$ZPOS_"",%PSL-E-SQLFAIL,""_$TR($G(RM),$C(10,44),$C(32,126)) X $ZT")
		do sr.addCode( " ;")
		do sr.addCode( " S vOid=sqlcur")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,0)=vsql")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,-1)=""ResultSet""")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,-2)=""$$"_ FETCHLBL_ suffix_ "^""_$T(+0)")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,-3)=$$RsSelList^UCDBRT(vSelect)")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,-4)=$G(vsql(""D""))")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,-5)=0")
		do sr.addCode( " Q vOid")

		do sr.addCode( " ;")

		do sr.addCode( FETCHLBL_ suffix_ "(vOid) ; MDB dynamic FETCH")

		do sr.addCode( " ;")
		do sr.addCode( " ; type public String exe(),sqlcur,vd,vi,vsql()")
		do sr.addCode( " ;")
		do sr.addCode( " I vsql=0 Q 0")
		do sr.addCode( " S vsql=$$^SQLF(.exe,.vd,.vi,.sqlcur)")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid)=vd")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,0)=vsql")
		do sr.addCode( " S "_ PSL.oLvn_"(vOid,.1)=$G(vi)")
		do sr.addCode( " Q vsql")
	}

	if needP do selectPR("P")	// RDB select with dataprotection
	if needR do selectPR("R")	// RDB select without dataprotection
	quit

	// ---------------------------------------------------------------------
selectPR( local String suffix)	// "P" for RS with dp, "R" for RS without DP
	/* ---------------------------------------------------------------------
	Support subroutine that generates the vOpen0P and vOpen0R subroutines
	
	This subroutine essentially uses the value "P" to include or exclude
	code for data protection.
	*/
	type literal String COMMONFPL = "vSelect,vFrom,vWhere,vOrderby,vGroupby,vParlist)"
	type literal String FETCHLBL  = "vFetch0"
	type literal String OPENLBL   = "vOpen0"

	if PSL.subrouExists( OPENLBL_ suffix) quit

	type PSLSubrou sr = PSL.addSubrou( OPENLBL_ suffix, "("_ COMMONFPL, "Dynamic RDB ResultSet with"_ ("out".piece(";",suffix'="P"))_ " dataprotection", 0)
	type String dpi()

	do sr.addCode( " N vExpr,vMap ;=noOpti")

	if suffix = "P" do {
		do sr.addCode(" N vDipx I (""/""_vParlist)[""/PROT"" N vQual D PARSPAR^%ZS(vParlist,.vQual),getExe^SQLPROT(vFrom,.vSelect,.vDipx,.vQual) ;=noOpti")
		set dpi(1) = "; need data protection"
	}

	/* Insert call to convert DQ query toRDB query */
	do sr.addCode( " S vExpr=$$RsDyRT^UCDBRT(vSelect,vFrom,vWhere,vOrderby,vGroupby,vParlist,.vMap)")


	do selSrOpen^UCDBR(  sr, FETCHLBL_ suffix, "@,vExpr,vMap,vDipx", dpi())
	do selSrFetch^UCDBR( sr, FETCHLBL_ suffix, 10, dpi())
	quit

	// ---------------------------------------------------------------------
private selectRecords	// method Db.selectDbSet; returns DbSet
	/* ---------------------------------------------------------------------
	Transform into Db.select() and process it through select^UCDB
	*/
	type public PSLTable pslTbl()

	if PSL.actual(1).isNull() do PSL.error("Table Parameter Required") quit

	type PSLTable td = PSL.cachePSLTable(.pslTbl(), PSL.actual(1).stripQuotes(), 0)
	type List   keys = td.primaryKeys

	if keys.isNull() do PSL.error("Unsupported table in DbSet class: "_ td.table) quit

	/* Convert parameters in PSL.actual() to match parameters expected by
	   select^UCDB */
	set PSL.actual(6) = ""			// no qualifiers
	set PSL.actual(5) = ""			// no GROUP BY
	set PSL.actual(4) = PSL.actual(3)	// ORDER BY from 3 to 4
	set PSL.actual(3) = PSL.actual(2)	// WHERE from 2 to 3
	set PSL.actual(2) = PSL.actual(1)	// FROM form 1 to 2
	set PSL.actual(1) = keys.addQuotes()	// SELECT from primaryKeys

	do select
	set PSL.class = "DbSet"

	quit

	/* ================================
	The following section was designed to optimize processing by
	replacing the record building logic with references to the 
	keys directly.  It pushed the result one row ahead and needs work.
	Related subroutine is getRecord^UCRESULT

	set z=$G(type(varLevel,var,"fetch")),sub=$P(z,tab,1)
	if sub="" do ERROR^UCGM("Method compile error: "_$ZPOS) quit
	set f=tab_"S "_oLvn_"(vOid)=",d="_$C(9)_"

	set n=""
	for  set n=$O(append(sub,n),-1) quit:n=""  if append(sub,n)[f quit
	if n="" do ERROR^UCGM("Method compile error: "_$ZPOS) quit

	set z=append(sub,n),append(sub,n)=tab_";"

	set z=$E(z,$F(z,f),$L(z))
	for i=1:1:$L(z,d) set type(varLevel,var,"fetch",$P(keys,",",i))=$P(z,d,i)
	quit
	*/

	// ---------------------------------------------------------------------
sql2akey( PSLTable td,		// table descriptor
	String where)		// where clause
	/* ---------------------------------------------------------------------
	Support function that translates the supplied where-clause into an
	accesskey (or into "", when the where-clause does not match the primary
	key of the table).
	
	OUTPUTS:
	. $$ = If the where-clause identifies the primary key, then the access
		key specification
		Else ""

	NOTES:
	. This function has the following limitations:
		- It expects boolean expressions that follow the pattern
			COLNAME = valexpr
		- It uses $$nextExpr^UCGM() to deal with the valexpr.
		  Unfortunately nextExpr^UCGM expects a PSL expression, whereas
		  valexpr is a SQL value expression. As usual the strlits are a
		  problem in this context.
		To deal with this, the following is used:
		- it calls $$TOKEN^%ZS(,,"'") to indicate SQL strlits
		- it calls $$nextExpr^UCGM(,,"",1) to prevent untokenizing
		- it calls $$sql2psl(SQLstrlits) to convert SQL strlits to PSL
		- it returns the untokenized value (after SQL-to-PSL convert)
	*/
	//type String exe(),hostvar(),subkey(),vdd()	// exported by $$WHERE
	//type String ER="",RM				// still uses ER/RM
	//type public String tok
	type String strlits

	type String akey

	if where.isNull() quit ""
	do {
		catch xcpt {
			set akey = ""
		}
		type String col
		type String key()
		type List   pkl = td.primaryKeys
		type String pred
		type Number prnr

		set akey = ""
		set where = $$TOKEN^%ZS( where, .strlits, "'")

		for prnr=1:1:where.length(" AND ") do {
			set pred = where.piece(" AND ",prnr)
			set col = pred.piece("=").trim(0)
			set pred = pred.extract( pred.find( "="), pred.length()).trim(0)

			if 'pkl.contains( col) throw Class.new( "Error", "%PSL-E-INTERNAL,not a keycolumn")
			if $$nextExpr^UCGM( pred, 0, "", 1) '= pred throw Class.new( "Error", "%PSL-E-INTERNAL,not a simple predicate")

			set key(col) = ""
			if 'akey.isNull() set akey = akey_ ","
			set akey = akey_  col_ "="_ pred
		}
	
		/* Note that condition below catches pkl.isNull() as well */
		if prnr'=pkl.count() throw Class.new( "Error", "%PSL-E-INTERNAL,invalid number of predicates")
		for prnr=1:1:pkl.count() if 'key( pkl.elementAt(prnr)).exists() throw Class.new( "Error", "%PSL-E-INTERNAL,missing keycolumn")

		set akey = $$UNTOK^%ZS(akey, $$sql2psl( strlits))
	}
	quit akey

	// ---------------------------------------------------------------------
sql2psl( String lits)	// strlit tokens as produced by $$TOKEN^%ZS()
	/* ---------------------------------------------------------------------
	Support function that translates the single-quote delimited SQL strlits
	in lits to double-quote delimited PSL strlits.
	
	OUTPUTS:
	. $$ = The PSL version of all the strlits in lits
	*/
	type Number elm
	type String lit

	for elm=1:1:lits.length( 1.char()) {
		set lit = lits.piece( 1.char(), elm)
		quit:lit.extract() '= "'"
		set lits.piece( 1.char(), elm) = lit.stripQuotes("'").addQuotes()
	}
	quit lits

	/* ****************************************************************** */
	/* CODE BELOW HAS NOT YET BEEN CONVERTED TO PSL			      */
	/* ****************************************************************** */

        ;-----------------------------------------------------------------------
akey2sql(akey,fkeys,knum)	;private void; access key to SQL whereclause
        ;-----------------------------------------------------------------------
	; ARGUMENTS:
	; . akey = the access key
	;	This function supports the following styles:
	;	* COLUMNNAME=:HOSTVAR
	;	* COLUMNNAME=:HOSTVAR simpleExprTail
	;	* COLUMNNAME='literal'
	;	* COLUMNNAME="literal" (discouraged)
	;	* COLUMNNAME=HOSTVAR (deprecated)
	;	* HOSTVAR (deprecated)
	; . fkeys = ordered list of key columns
	; . knum = optional variable that will receive the number of keys in
	;	akey. The caller can use this variable to detect if all keys
	;	were included.
	;
	; OUTPUTS:
	; . $$ = the SQL whereclause that corresponds to the access key.
	; . knum = number of keys in akey
	;
	new atom,expr,ptr,tok,val,where
	;
	#ACCEPT CR=18163; DATE=2005-11-24; PGM=FSCW; GROUP=BYPASS
	#BYPASS
	set knum=0,ptr=0
	set expr=$tr($$TOKEN^%ZS(akey,.tok)," "),where=""
	;
	for  set atom=$$ATOM^%ZS(expr,.ptr,",",tok,1) do  if ptr=0 quit
	.	;
	.	if atom="," quit
	.	set knum=knum+1
	.	if atom="" quit
	.	if where'="" set where=where_" AND "
	.	;
	.	; FSCW CR11441
	.	; In case the list contains other SQL compare operator, and no
	.	; spaces (eg single condition COLNAME>value)
	.	if $tr(atom,"<>")'=atom set where=where_atom quit
	.	;
	.	if atom'["=" set atom=$P(fkeys,",",knum)_"="_atom
	.	set val=$P(atom,"=",2),val=$$UNTOK^%ZS(val,tok)
	.	; for backward compatibility on hostvars
	.	if $E(val)'=":",'("'"[$E(val)),'$$isLit^UCGM(val) set val=":"_val
	.	if $E(val)="""" set val=$$QADD^%ZS($$QSUB^%ZS(val,""""),"'")
	.	set where=where_$P(atom,"=",1)_"="_val
	#ENDBYPASS
	quit $$UNTOK^%ZS(where,tok)

	// ---------------------------------------------------------------------
private get1Row // void; method Db.getOneRow ; returns single row
        /* ---------------------------------------------------------------------
	Syntax: Db.getOneRow(select_list,Table_name,Access_keys,delimiter)

	. select_list	A list of column names
	. table_name	DQ table name (support single table only)
	. access_keys	Primary access keys
	. delimiter	Field delimiter (not required, default to Tab)

	Example:
		S data=Db.getOneRow("TJD","CUVAR")
		S data=Db.getOneRow("CID,BAL,LNM,BOO,IRN","DEP","XCID")
		S data=Db.getOneRow("ACN,TAXID,AGE","CIF","XACN")
		S data=Db.getOneRow("TAMT","HIST","xcid,tseq",124)
	*/
	new del,fkeys,fset,keys,i,list,objectName,objectLevel,table
	#ACCEPT CR=18163; DATE=2005-11-24; PGM=FSCW; GROUP=BYPASS
	#BYPASS
	;
        I '$D(actual(1))!'$D(actual(2)) D ERROR^UCGM("Expression expected") Q
        do WARNDEP^UCGM("Db.getOneRow")
	set list=$$QSUB^%ZS(actual(1))			; column list
	set table=$$QSUB^%ZS(actual(2)) 		; table name
	set keys=$$QSUB^%ZS(actual(3))			; access keys
	set delim=$S($tr($G(actual(4))," ",""):actual(4),1:9)		; Delimiter
	;
	new seq
	;;do addM2src^UCGM(" #ACCEPT DATE=6/23/03; PGM=Mark Spier; CR=Frank Sanchez")
	;;do addM2src^UCGM(" quit")
	set label=$$newLabel^UCGM("Row",.labels)	; Get next label
	do addM2src^UCGM(" #OPTION ResultClass 0")
	do addM2src^UCGM("v"_label_"()")
	do addM2src^UCGM(" #WARN SCOPE 0")
	set expr=" type Record"_table_" getRow=Db.getRecord("""_table_""","""_keys_""",1)"
	do addM2src^UCGM(expr)
	
	do addM2src^UCGM(" type String data=""""")
	;
	; select DISTINCT columns
	if $P(list," ",1)="DISTINCT" S list=$P(list,"DISTINCT ",2),distinct=1
	set list=$$UPPER^%ZFUNC(list)			
	;
	for I=1:1:$L(list,",") do
	.	set prop=$p(list,",",I)
	.	if prop="" do addM2src^UCGM(" set data=data_$C("_delim_")") quit
	.	if prop'["." set prop="getRow."_$$LOWER^%ZFUNC(prop)
	.	set expr=" set data=data_$C("_delim_")_"_prop
	.	do addM2src^UCGM(expr)
	D addM2src^UCGM(" quit data.extract(2,data.length())")
	; function call
        S return="$$v"_label_"()"
	;
	do autoERRM^UCGM()
	;
	#ENDBYPASS
	quit

	// ---------------------------------------------------------------------
private getGbl(gblref,keyvars)	// void; Return Global reference
	/* ---------------------------------------------------------------------
	ARGUMENTS:
	. gblref = global reference as stored in DBTBL1
		E.g. $PIECE(fsn(table),"|",2)
	. keyvars = list of primary key variables
		A comma separated list of key values to be used in the
		construction of the reference. Literals shall be tokenized by the
		caller.
		The number of primary key variables determines how much of the
		total global reference is constructed and returned.

	OUTPUTS:
	. $$ = global reference with all supplied keyvars inserted, and
		remaining key levels dropped.

	NOTES:
	. The only call to this subroutine comes from toString^UCRECORD.
	*/
	new gkey,gkeys,i,keyNum,ptr,ref,return,tok
	#ACCEPT CR=18163; DATE=2005-11-24; PGM=FSCW; GROUP=BYPASS
	#BYPASS
	;
	set gkeys=$$TOKEN^%ZS($P(gblref,"(",2,999),.tok)
	set return=$P(gblref,"(",1)
	;
	; ptr is used as character pointer in keyvars.
	set keyNum=0,ptr=0
	if gkeys'="" set return=return_"(" for i=1:1:$L(gkeys,",") do
	.	;
	.	set gkey=$$UNTOK^%ZS($P(gkeys,",",i),.tok)
	.	if $$isLit^UCGM(gkey) set return=return_gkey_"," quit
	.	;
	.	if keyNum,ptr=0 set i=$L(gkeys,",") quit  ; Partial
	.	;
	.	set keyNum=keyNum+1
	.	;;if lvn'="" S ref=lvn_keyNum
	.	;;;
	.	;;; FSCW CR14919: need to untokenize literal keys!
	.	;;;;E  S ref=$$ATOM^%ZS(akeys,.ptr,",",tok,1) I ptr S ptr=ptr+1
	.	;;E  S ref=$$ATOM^%ZS(akeys,.ptr,",",tok,0) I ptr S ptr=ptr+1
	.	;
	.	; extract next keyvar, which may be subscripted
	.	; if not yet at end-of-string, skip comma
	.	set ref=$$ATOM^%ZS(keyvars,.ptr,",",,1) if ptr set ptr=ptr+1
	.	;;if $E(ref)="'" S ref=""""_$P(ref,"'",2)_""""
	.	set return=return_ref_","
	;
	if $E(return,$L(return))="," set return=$E(return,1,$L(return)-1)_")"
	#ENDBYPASS
	quit return

	// ---------------------------------------------------------------------
append( String code,
	String label)
	/* ---------------------------------------------------------------------
	*/
	do append^UCGM(code,label)
	quit

	// ---------------------------------------------------------------------
mapPSLvar(expr)	;local String; Map PSL variables into SQL variables
	/* ---------------------------------------------------------------------
	*/
	new atom,code,class,i,lvn,new,set,tok,y
	#ACCEPT CR=18163; DATE=2005-11-24; PGM=FSCW; GROUP=BYPASS
	#BYPASS
	;
	set expr=$$TOKEN^%ZS(expr,.tok,"'")
	set expr=$$TOKEN^%ZS(expr,.tok,"""")
	set y=0,new="",set=""
	;
	for  set y=$F(expr,":",y) quit:y=0  do
	.	;
	.	; FSCW CR14185: All SQL binary operators shall delimit token
	.	;;set atom=$$ATOM^%ZS($E(expr,y,$L(expr)),0,",",tok,1)
	.	set atom=$$ATOM^%ZS($E(expr,y,$L(expr)),0,"+-*/|<>=,",tok,1)
	.	if $E(atom,$L(atom))=")" for  quit:$L(atom,"(")=$L(atom,")")  set atom=$E(atom,1,$L(atom)-1)
	.	if $$isVar^UCGM(atom),'(atom?.e1L.e) quit
	.	;
	.	;;set code=$$valExpr^UCGM(atom,.class,,0)
	.	set code=$$valExpr^UCGM(atom,.class)
	.	;
	.	; FRS - 07/01/03 - Add Support for Literal
	.	if $$isLit^UCGM(code) do  quit		; Literal type
	..		set expr=$E(expr,1,y-2)_$$QSWP^%ZS(code,"""","'")_$E(expr,y+$L(atom),$L(expr))
	..		set y=y+$L(atom)-$L(code)
	.	;
	.	if $$isVar^UCGM(code)&'(code?.e1L.e) do  quit
	..		set expr=$E(expr,1,y-1)_code_$E(expr,y+$L(atom),$L(expr))
	..		set y=y+$L(atom)-$L(code)
	.	;
	.	for i=1:1 set lvn="V"_i  quit:$$getNew^UCGM(lvn)=""
	.	;;do setScop^UCGM(lvn,level,msrc,"NEW")
	.	do setScope^UCGM(lvn,"","","NEW","Primitive")
	.	do setInst^UCGM(lvn,$$getDcLnr^UCGM,"")
	.	;
	.	set expr=$E(expr,1,y-1)_lvn_$E(expr,y+$L(atom),$L(expr))
	.	set y=y-$L(atom)+$L(lvn)
	.	;
	.	if new="" set new=lvn,set=lvn_"="_code
	.	else  set new=new_","_lvn,set=set_","_lvn_"="_code
	;
	if '(new="") d
	.	if $e(mcode,$L(mcode))="," S mcode=$e(mcode,1,$l(mcode)-1)_"   "
	.	if $e(mcode,$L(mcode)-1)="."!(mcode=$C(9)) S mcode=mcode_"   "
	.	set mcode=$E(mcode,1,$L(mcode)-2)_" N "_new_" S "_set_" "_$S(cmd="QUIT":"",1:$E(cmd)_" ")
	;
	set expr=$$UNTOK^%ZS(expr,.tok)
	#ENDBYPASS
	quit expr

	// ---------------------------------------------------------------------
private insert	// void; Db.insert(Table_name,column_list,colum_value,filer_qualifier)
	/* ---------------------------------------------------------------------
	This subroutine implements a deprecated method.

	 INPUTS:
	. actual(1) = table name (literal)
	. actual(2) = column name list (literal)
	. actual(3) = column value list (literal)
	. actual(4) = filer qualifiers (dynamic allowed)

	NOTES:
	. This subroutine calls $$fileQual("Db.update",) and inserts the result
		in the generated call to Record.save(). Because save^UCRECORD
		will also call $$fileQual(), two different set of values may be
		added. This leads to the following processing order (i.e. low to
		high in terms of precedence):
		1) commands("SQLPARS") for Record.save()
		2) commands("SQLPARS") for Db.insert()
		3) parameters in source code
		4) parameters added due to commands("DEBUG")="Db.update"
		5) parameters added due to commands("DEBUG")="Record.save"
		If commands("DEBUG")="*" 4) and 5) will set the same values, but
		both will occur in the code.
		If the PSL source code contains a non-literal, the generated M
		code will contain 5 nested calls to $$setPar^UCUTILN(). Happy
		readings!
	*/
	#ACCEPT CR=18163; DATE=2005-11-24; PGM=FSCW; GROUP=BYPASS
	#BYPASS
	new columns,expr,I,label,par,table,value,values,z,zpar
	;;if '$d(actual(1))!('$d(actual(2)))!('$D(actual(3))) D error^UCDB Q
	do WARNDEP^UCGM("Db.insert() - use Db.getRecord(,,1) or Class.new() and Record.save()")
	;
	; Filer run-time qualifier
	set par=$$fileQual("Db.update",actual(4))
	;
	set table=$$QSUB^%ZS(actual(1))				; Table name
	set columns=$$QSUB^%ZS(actual(2))			; Column list
	set values=$$QSUB^%ZS(actual(3))			; Column values
	;
	if values[":" set values=$$mapPSLvar^UCDB(values)
	;
	; get next label and insert into code
	set label=$$newLabel^UCGM("Ins",.labels)		; Get next tag name
	set label="vvIns"_$E(label,5,8)
	set return=label
	do addM2src^UCGM(" #OPTION ResultClass 0")
	do addM2src^UCGM(label_"  //INSERT")
	do addM2src^UCGM(" #WARN SCOPE 0")
	;;do addM2src^UCGM(" new X")	;FSCW CR12564: removed again (see CR7240)
	;
	; Instantiate a new record
	set expr=" type Record"_table_" insRow=Class.new(""Record"_table_""")"
	do addM2src^UCGM(expr)
	;
	; set all columns into the new record as defined by columns and values
	; parameters of the method
	new nextval,currval
	set (currval,nextval)=""
	if '$D(fsn(table)) do fsn^SQLDD(.fsn,table)
	for I=1:1:$L(columns,",") do
	.	set prop=$p(columns,",",I)
	.	if prop["." set prop=$p(prop,".",2)
	.	;values needs to be tokenized
	.	set value=$p(values,",",I)
	.	if $$UPPER^%ZFUNC(value)["NEXTVAL" set nextval=prop quit
	.	if $$UPPER^%ZFUNC(value)["CURRVAL" set currval=prop quit
	.	if $p(fsn(table),"|",3)[prop set nextval(prop)=value
	.	if $E(value)=":" set value=$e(value,2,100)
	.	if $E(value)="'" set value=""""_$e(value,2,$l(value)-1)_""""
	.	else  if value?.P set value=""""_value_""""
	.	new expr
	.	set expr=prop
	.	if '$$ISSFD(table,.expr,value,"insRow") set expr=" set insRow."_$$LOWER^%ZFUNC(prop)_"="_value
	.	do addM2src^UCGM(expr)
	; 
	if nextval'=""!(currval'="") do
	.	new where,i
	.	set (where,i)=""
	.	for  set i=$O(nextval(i)) quit:i=""  set where=where_","_i_"="_nextval(i)
	.	if nextval'="" do addM2src^UCGM(" set insRow."_$$LOWER^%ZFUNC(nextval)_"=Db.nextVal("""_table_""","""_$e(where,2,100)_""")") quit
	.	do addM2src^UCGM(" set insRow."_$$LOWER^%ZFUNC(currval)_"=Db.currVal("""_table_""","""_$e(where,2,100)_""")")
	; save the data using the filer if one exists in order to use all
	; triggers and journals
	do addM2src^UCGM(" do insRow.save("_par_")")
	do addM2src^UCGM(" quit ")
	;
	do autoERRM^UCGM()
	;
	#ENDBYPASS
	quit

	// ---------------------------------------------------------------------
private update	// void; Db.update(Table_name,column_expr,where_clause,filer_qualifier)
	/* ---------------------------------------------------------------------
	INPUTS:
	. actual(1) = table name (literal)
	. actual(2) = column expression (literal)
	. actual(3) = whereclause (literal)
	. actual(4) = filer qualifiers (literal)

	NOTES:
	. This subroutine calls $$fileQual("Db.update",) and inserts the result
		in the generated call to Record.save(). Because save^UCRECORD
		will also call $$fileQual(), two different set of values may be
		added. This leads to the following processing order (i.e. low to
		high in terms of precedence):
		1) commands("SQLPARS") for Record.save()
		2) commands("SQLPARS") for Db.insert()
		3) parameters in source code
		4) parameters added due to commands("DEBUG")="Db.update"
		5) parameters added due to commands("DEBUG")="Record.save"
		If commands("DEBUG")="*" 4) and 5) will set the same values, but
		both with occur in the code.
		If the PSL source code contains a non-literal, the generated M
		code will contain 5 nested calls to $$setPar^UCUTILN(). Happy
		readings!
	*/
	#ACCEPT CR=18163; DATE=2005-11-24; PGM=FSCW; GROUP=BYPASS
	#BYPASS
	new expr,I,label,par,setexpr,sql,src,table,where
	;
	set par=$$fileQual("Db.update",actual(4))	; Run-time qualifier
	;
	set table=$$QSUB^%ZS(actual(1))			; Table name
	set setexpr=$$QSUB^%ZS(actual(2))		; Column expression
	set where=$$QSUB^%ZS(actual(3))			; where clause
	;
	new fsn
	do fsn^SQLDD(.fsn,table) if ER do ERROR^UCGM($G(RM)) quit
	;
	; create label
	set label=$$newLabel^UCGM("Sql",.labels)	; Get next tag name
	set label="vUpd"_$E(label,5,8)
	set return=label
	do addM2src^UCGM(" #OPTION ResultClass 0")
	do addM2src^UCGM(label)
	do addM2src^UCGM(" #WARN SCOPE 0")
	;;do addM2src^UCGM(" new X")	;FSCW CR12564: removed again (see CR7240)
	;
	; Build database set resultset
	set expr=" type DbSet updset=Db.selectDbSet("""_table_""","""_where_""")"
	do addM2src^UCGM(expr)
	;
	do addM2src^UCGM(" while updset.next() do {")
	set expr=" type Record"_table_"  updRow=updset.getRecord("""_table_""")"
	do addM2src^UCGM(expr)
	do addM2src^UCGM(" do updRow.setAuditFlag(1)")
	;
	; Build code to deal with individual columns being updated
	new expr,value
	for I=1:1:$L(setexpr,",") do
	.	set expr=$p(setexpr,",",I)
	.	set value=$TR($p(expr,"=",2),":","")
	.	if $E(value)="'" set value=""""_$e(value,2,$l(value)-1)_""""
	.	else  if value?.P set value=""""_value_""""
	.	set expr=$p(expr,"=",1)
	.	if $p(expr,"=",1)["." set expr=$p($p(expr,"=",1),".",2)_$p(expr,"=",2)
        .       if value?.E1P.E,value'["%",value'["""" do
        ..              new ptr,temp
        ..              set temp=value
	..              set ptr=$f(temp,expr)
        ..              set value=$s(ptr-$l(expr)=1:"",1:$e(temp,1,ptr-$l(expr)-1))_"updRow."_$e(temp,ptr-$l(expr),1000)
	.	set $p(expr,"=",1)=$$LOWER^%ZFUNC($P(expr,"=",1))
	.	if $e($p(expr,"=",2),1)="'" set $p(expr,"=",2)=""""_$e($p(expr,"=",2),2,$l($p(expr,"=",2))-1)_""""
	.	if '$$ISSFD(table,.expr,value,"updRow") set expr=" set updRow."_expr_"="_value
	.	do addM2src^UCGM(expr)
	;
	; save the data and end the subroutine 
	do addM2src^UCGM(" do updRow.save("_par_")")
	do addM2src^UCGM(" }")
	do addM2src^UCGM(" quit ")
	;
	do autoERRM^UCGM()
	#ENDBYPASS
	quit

	// ---------------------------------------------------------------------
ISSFD(table,expr,value,mode)	;local Boolean;
	/* ---------------------------------------------------------------------
	*/
	#ACCEPT CR=18163; DATE=2005-11-24; PGM=FSCW; GROUP=BYPASS
	#BYPASS
	new ddpexpr,frm,fsn,sfd,vdd,x
	set ddexpr=$$UPPER^%ZFUNC(table_"."_expr)
	set table=$$UPPER^%ZFUNC(table)
	set X=$$DI^SQLDD(ddexpr,.frm,.vdd,.fsn)
	if ER quit 0
	set sfd=$$SFD^SQLDD("",.X)
	if sfd="" quit 0
	new di,node,pos,quit
	set node=$$NOD^SQLDD(ddexpr,.X)
	set pos=$$POS^SQLDD(ddexpr,.X)
	set di=""
	set quit=0
        F  S di=$O(^DBINDX("SYSDEV","STR",table,node,pos,di)) Q:di=""  D  Q:quit
        .	if $P(^DBTBL("SYSDEV",1,table,9,di),"|",18)'="" Q
	.	set quit=1
	if di="" quit 0
	set di=$$LOWER^%ZFUNC(di)
	set expr=" set X="_mode_"."_di
	set expr=expr_",$P(X,"""_$C($P(sfd,"~",2))_""","_$p(sfd,"~",4)_")"_"="_value
	set expr=expr_","_mode_"."_di_"=X"
	#ENDBYPASS
	quit 1
