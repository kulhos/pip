//DO NOT MODIFY  Column class - DD Group|UCCOLUMN|||||||1
	/*
	DESC: Library of Column methods - DD Group
 
	KEYWORDS:     DATABASE 

	---- Comments ----------------------------------------------------------
	This unit implements the methods and properties of class Column,
	including references and assignments to Record.column.

	Subroutines generated by this unit will use the class-specific prefix
	"vCo".

	---------- Revision History --------------------------------------------
	05/03/07 - Frans S.C. Witte - CRs: 26334
		Curval(): lvn table is now initialized before calling $$colProp
		because the individual column properties need the table name,
		and no other code provides that.

	01/08/07 - Frans S.C. Witte - CRs: 24800 / 24803
		Method dynSet(): Corrected code that generates -150 assignment
		of key columns for vCoIndN.

	10/19/06 - Frans S.C. Witte - CRs: 23841 / 23842
		Added InstMode parameter in call to $$insByOvs^UCREC4OP

	09/15/06 - Frans S.C. Witte - CRs 22719 / 20613
		* Modified dynKey and DynSet to deal with new -150 layout
		* Modified colProp to recognize record assign mode = 1
		* All calls to %DBAPI now pass 0 (zero) instead of "" for vIndex

	07/11/06 - Frans S.C. Witte - CRs: 22720 / 22274
		* Added nCase parameter in calls to $$opGet^UCXOBJ()
		* Removed comment about use of #BYPASS in this unit. All
		  (remaining) code is now PSL.

	06/12/06 - Frans S.C. Witte - CRs: 22060 / 22061
		* Replaced $C(255) by LEFTEXMARK
		* replaced calls to $$bldgbl() by calls to $$getGbl^UCXDD() and
		  removed function $$bldgbl().
		* Replaced PSL.maxLineLength by PSLExpression.fitsLineLength()

	06/07/06 - Frans S.C. Witte - CRs: 21394 / 21395
		* dynLd: Added code to load negative nodes

	03/30/06 - Frans S.C. Witte - CRs: 20280 / 18164
		* Added $$longGet() and $$longSet() to deal with "long"
		  retrievals and assignments.
		* Modified dynamic() to consider PSLTable.indexList to force
		  bAudit
		* Modified curVal to turn optimize off for RDB and MDB because
		  -100 tree exhibits same behavior as -150 tree.

	03/07/06 - Frans S.C. Witte - CRs: 19821 / 18164
		* Dynamic column access is now noted as an instantiation by
		  parameter passing.
		* scope warning now uses SCOPE: as recognizable prefix.
		* %PSL-E-ABSTRACT changed to %PSL-E-DYNAMIC ("dynamic" record vs
		  "abstract" record).

	02/04/06 - Frans S.C. Witte - CRs: 18163 / 18164
		* Added support for dbAcc() structure
		* Added $$litVal() to deal with literal column retrievals that
		  are DBI for all tables (not just for CUVAR).
		* Subroutine colProp: removed .type() as actual parameter in
		  call to $$property^UCGM().
		* All subroutines that are no longer called have been moved to
		  ZUCDBLOAD.proc
		* Code that referenced ^OBJECT moved to UCXOBJ.

	02/03/06 - Pete Chenard - CR19388
		* Modified Dynamic section to put quotes around vOid
		  reference.

	01/20/06 - Frans S.C. Witte - CRs: 19157 / 19158
		* dynamic(): PSLTable cache entry no longer required (was not
		  available when called from overlay^UCRECORD), and added
		  support for Dynamic Record instance (through ^DBSDYNRA).
		* dynGet(): Code generated for computed column retrieval now
		  passes "vOid" to ^UCXDD (numeric value has special meaning!)

	12/23/05 - Frans S.C. Witte - CRs: 18727 / 18728
		* Column indirection now also accepts uppercase name
		* Added vobj(rec,-100,"0*")="" for recordType=11
		* All setOpti^UCGM() calls set value to -1 to prevent optimize
		  after re-instantiation

	10/07/05 - Frans S.C. Witte - CRs: 15592 / 15593
		* Corrected code used in -100 tree for keys
		* Synchronized use of PSLColumn.getOldNode() with correction in
		  UCXDD.
		* Replaced thi. by PSL., and removed #XECUTE
		* Replaced pslSchCln() by pslCln(), and pslSchTbl() by pslTbl().

	06/24/05 - Frans S.C. Witte - CR16346
		* Fixed computed column retrieval in indirection for RDB. Both
		  MDB and RDB now recursively call the indirect column retrieval
		  subroutine.
		* Fixed optimize problem of MDB masterfields, and of MDB
		  subfield assignments.
		* Subroutine GETCMP "#IF"-ed out (no longer called).
		* Added $$getPslCln() to cache PSLColumn in pslSchCln()
		* Corrected error in dynLd.
		* Corrected $$bldgbl (when table has no keys)
		* Corrected dynamic to include assignment of vTyp if fset
		  (independent of bAudit)
		* modified dynLdBM/dynSet to use vobj(vOid,1,1) for type 1 table
		* modified dynSet to use new structure of -100 tree

	05/16/05 - Frans S.C. Witte - CRs: 15028 / 16039
		* Started migration to PSL. Subroutines ET, des, len, typ, req,
		  key, journal, and getKey() "converted" to PSL.
		* Code for curVal(), dbHist, dynamic(), and setProperty()
		  completely rewritten.
		* $$rdb^UCDB() changed to $$rdb^UCDBRT() (5 occurrences)
		* Changed ERROR^UCGM(.RM) to ERROR^UCGM($G(RM))
		* Removed code commented out for earlier CRs.
		* Removed append(), computed(), getBmType(), master()
		* PSLTable pslSchTbl() and PSLColumn pslSchCln() are now
		  used for table / column properties.

	03/07/05 - Pete Chenard - CR15314
		* Modified Dynamic section to only generate code for subfields
		  if on an M environment.  Because there are no subfields
		  in relational databases, this code should treat those columns
		  like normal non-subfields.

		* Also in the dynamic section, modified code to set variable 'nul'
		  to prevent undefined errors when running on relational database.

	02/10/05 - Pete Chenard - 14457
		* Modified Dynamic section to correctly set level -100
		  when on an RDB.  Prior to this change the code was setting
		  up level -100 with the name of the columns on Oracle, not
		  the DQ name.

	02/01/05 - GIRIDHARANB - CR13233
		* Modified section oldval to setup the rdb position and nod.

	01/13/05 - Pete Chenard - CR13233
		* Modified Dynamic section to always define variable typ at runtime
		  and to not New column sine it is passes in as a parameter.

	01/05/05 - Frans S.C. Witte - CRs: 13403 / 13404
		* Modified "INVALIDREF" to "%PSL-E-INVALIDREF" (2 occurrences).
		* Modified subroutines dynamic(), oldVal, readCol, and setSfd to
		  correct and standardize the handling of subfield columns.
		* Inserted QUIT before first subroutine of this routine.
		* Inserted function $$getBmType()
		* Subroutine dynamic(): renamed isTYP to bBM, and redefined its
		  use to contain the value of $$getBmType(). Eliminated variable
		  'znode'.
		* Subroutine setCol: replaced isTYP by bBM and eliminated all
		  references to 'znode' (which would be undefined at runtime).
		* Replaced append^UCCOLUMN() by append().

	11/02/04 - Frans S.C. Witte - CRs: 12994 / 12995
		Modified subroutine curVal() to add additional parameter in call
		to $$GETSUB^UCSTRING(). This is only a "partial fix". The code
		generated to handle subfields is inconsistent and limited. This
		CR ensures that "direct retrievals" (i.e. without column
		indirection) will work for all possible subfield definitions.
		The change to UCSTRING also ensures that "direct assignment" will
		generate the correct code. However, auditing changes to subfields
		(including access to subfiled.oldval) is still a problem.

	10/12/04 - GiridharanB - CR12092
		Modified section curVal to retain the rdb position for Memos and
		Blobs. Also modified section Dbhist to alter the nod value being 
		set if on a rdb.

	09/02/04 - Frans S.C. Witte - CRs: 10622 11702 11717 / 10575 11703
		Subroutine setDb(): Added formal parameter that indicates
		whether load shall occur after or before the "current line".
		Subroutine curVal(): added additional parameter to setDb() call.
		Subroutine dynamic(): turn off object optimization when column
		indirection is detected. Ensure that generated code NEWs all its
		local variables. Added code to skip loading when node has already
		been loaded. Variable 'rdb' is NEWed and initialized inside this
		subroutine because the subroutine is called by UCRECORD as well.
		Subroutine dbHist(): include generating code that sets node
		vobj(oid,-100,sub) (in addition to vobj(oid,-100,sub,colname)).

	06/04/04 - CHENARDP/GIRIDHARANB - CR9217
		     Fixed section curVal to set level -150 at the 
		     beginning of the line and section setCol to correct 
		     errors with Indirection support for rdb

	05/12/04 - RussellDS - CR9676
		     Move Profile04 version to Profile01 to support single code
		     base for PSL.

	03/29/04 - RussellDS - CR9172
		     Integrate changes as part of move of filers to PSL.

		     Added coding to support Profile01 CR1390.  This modifies
		     the dbHist section.

		     NOTE that support for CR1390 is not yet fully implemented.
		     This change just brings PSL in line across the versions.

	02/02/04 - FSANCHEZ/KELLYP - 7813
		     Fixed database loading error caused by numeric bottom key
		     and error in setDb which caused database loading code to 
		     precede object instantiation in some nested blocks.  Also 
		     changed structure of dbLoad for for Memo and Blob to better
		     comply with dataflow optimization in UCRECORD.  Also removed
		     pre-2003 history.
 
	01/14/03 - SPIER 7240
		     Fixed code review items:
			1) nul newed twice in dynamic section
			2) dynamic misspelled in previous revision notes

	12/11/03 - Spier 7240
		     Modification to dynamic and setCol section to deal with memo/blobs 
		     when a literal key is part of the key structure on rec type 11's
	
	11/03/03 - Spier 51640
		     Corrected coding related to memo and blobs for indirection
		     as well as normal sets. If the node is null, the node could
		     not be two levels deep in the db because of existing data.

	10/29/03 - GIRIDHARANB - 51637
		     Made minor fixes to correct -150 level setup for rdb .also
		     nulled the value of sfd for rdb

	09/05/03 - Spier - 6031,6032,6034 arq 51640
		     Retrofitted v7.0 version back to Profile01 one more time

	09/04/03 - Spier 51640
		     Correct auditflag check for indirection calls

	08/18/03 - Spier 51423
		     Modifications to handle sub-fields properly.

	07/30/03 - GIRIDHARANB - 45497
		     Minor fixes to pass a table parameter into the rdb check. 
		     Also modified dbHist section to set return variable with 
		     -150 level for the relational database.

	07/08/03 - SPIER - 51423
	            Change in SETDB section to correct node loading error
		     Node was being loaded prior to creation of object.

	06/06/03 - CHENARDP - 45497
		     Modified dynamic section to add support for data item
		     indirection for Oracle.

	04/29/03 - GIRIDHARANB - 45497
		     Added an additional parameter, the null indicator flag
		     at the -150 level. Fixes to also handle Memo and blob 
		     fields in the rdb

	03/20/03 - CHENARDP/GIRIDHARANB
		     Corrected the logic to build the -150 level of vobj array
		     in section fset. Also altered curVal section to correct
		     compile errors

	03/14/03 - SPIER - 51423
	            Added $G to 3/11/03 change, level of type
		     may not always be setup ( overlay method)

	03/11/03 - SPIER - 51423
	            Corrected several locations to look at the proper
		     location for the indictor that the auditflag is turned on.

	02/14/03 - SPIER - 51423
	            Bug fixes

	02/10/03 - GIRIDHARANB - 45497
		    Modified the curVal section to obtain the column positions	
		    from the DBMAP global instead of calling the RDB.
	*/
	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	// ---------------------------------------------------------------------
private curVal( PSLIdentifier  oid,	// object variable instance
		String  property,	// column name
		Boolean fset,		// set (1) or get (0)
		PSLExpression objExpr,	// oid.property[.xyz] (*4)
		Number  ptr,		// char pointer	(*5)	/MECH=REF:RW
		Boolean nest)		// nested?		/NOREC
	/* ---------------------------------------------------------------------
	Return the leftexpr (fset=1) or rightexpr (fset=0) that represents the
	column's current value.

	ARGUMENTS:
	(*4) objExpr = object expression (oid.property[.nestedproperty])
		This is the complete expression element that may include the
		additional Property of the Column class.
	(*5) ptr = character pointer
		"points" into objExpr.
		If ptr=0, the caller expects this function to ignore objExpr.
		If ptr>0, then the caller expects this function to deal with the
		nested Column class property.
	*/
	type literal String LEFTEXMARK = 31.char()

	type public Boolean   commands(,)	// uses commands("WARN","SCOPE")
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	type PSLExpression return		// function return value

	/* the Column properties need the table name too */
	type String table = $$getReTable^UCGM( oid.class)

	if ptr quit $$colProp( oid, property, fset, objExpr, .ptr)

	/* handle indirection before checking the table name, to allow column
	   indirection on dynamic instances */
	if property.extract()="@"  quit $$dynamic(0, oid, table, property, fset)

	/* if table.isNull(), then we have a reference to a Record instance */
	if table.isNull() throw Class.new( "Error", "%PSL-E-DYNAMIC,Dynamic record not supported")

	/* ensure PSLTable instance for this table exists.
	   This will throw an exception when the tablename is invalid.
	   Ensure that information level is 1, to be able to use all properties.
	   Note that this must be enforced for ALL instances, not just the new
	   instances. */
	type PSLTable td = {PSLTable}$$getPslTbl( table)

	set property = $$getColNm(property)
	if property.isNull() throw Class.new( "Error", "%PSL-E-REQUIRED,Missing property name")

	type String ref    = table_ "."_ property

	do addXref^UCGM("P"_ fset, ref, oid)

	/* Initiate the PSLColumn instance for this column
	   The PSLColumn properties are filled with RDB values if applicable
	   */
	type PSLColumn cd = {PSLColumn}$$getPslCln(table, property)
	set PSL.class = cd.getClass()

	/* If retrieving column value from literal record instance, retrieve and
	   return the value at compile time */	
	if oid.scope = "LITERAL" quit $$litVal(oid, property, fset)

	/* scope is not literal, so create an access entry.
	   If this column reference does not have a root instance, report a
	   warning */
	type Boolean bHasRoot
	type Boolean bAudit = ''$$getAtt^UCGM( oid, oid.scopeLevel, 12)

	/* Force bAudit for this column if the column is used in an index (and
	   not already part of the primary key) */
	if 'bAudit, pslTbl( table).indexList.contains(property), 'pslTbl( table).primaryKeys.contains(property) set bAudit = 1

	type Number  accPos = $$clnByOvs^UCREC4OP( PSL.subRou, oid, cd, bAudit, fset, .bHasRoot)
	if 'bHasRoot,commands("WARN","SCOPE").get() do PSL.warn( "SCOPE: Variable "_ oid_ " may not have been instantiated")

	/* Construct the return code based on the PSLColumn methods.
	   - For subscripted variables don't try anything fancy, just return
	     the M code
	   - For unsubscripted variables generate placeholder code
	   */
	if oid["(" do {
		if fset set return = cd.getUpdateCode(oid, LEFTEXMARK, bAudit)
		else  set return = cd.getCurrentExpr(oid, 0)
	}
	else  do {
		type Number decPos = $$getDec^UCREC4OP( PSL.subRou, oid, accPos)

		if 'fset set return = cd.getCurrentExpr( decPos, 0) quit
		set return = $$clnAsn1^UCREC4OP( decPos, accPos, LEFTEXMARK)

		/* Some PSL source code contains assignments to columns of a
		   locally declared record, without ever calling Record.save().
		   This will lead to code that uses voxn for nodes, but still
		   includes -150 assignments. To ensure that the record is
		   marked as assigned as well, set assign as if
		   Record.bypassSave is detected (assign=1). This will allow
		   voXN use and suppress -150 assignments.

		   Similar observations apply for the assignment of
		   vobj(oid,-100,nod)="" to indicate a node that changed (both
		   MDB and RDB) when recordType>1. In this case however, there
		   is no mechanism to suppress the assignment, so we will need
		   to prevent optimization all together. */
		// if td.recordType>1!td.isRdb do setAssign^UCREC4OP( PSL.subRou, oid, 2),setOpti^UCGM(oid, oid.scopeLevel, -1)
		if td.isRdb do setAssign^UCREC4OP( PSL.subRou, oid, 1)
		if td.recordType>1 do setOpti^UCGM(oid, oid.scopeLevel, -1)
	}

	/* The returned value may contain TABs when this is an RDB masterfield
	   retrieval, or a masterfield assignment (MDB/RDB). If the code does
	   not cause a linelength exception, then replace the TAB:
	   - if fset the TAB is the "line separator", and can be removed
	   - else the TAB is the "expression separator" and replace it by the
	     concatenation operator.
	  If the code does exceed the linelength, then insert as subroutine
	  calls. Note that the if-statement below assumes that there is no
	  substantial amount of additional code on the line that contains the
	  column assignment.
	   */
	if return [ 9.char() do {
		if return.fitsLineLength() set return = return.translate( 9.char(), $SELECT(fset:"",1:"_")) quit
		if fset set return=$$longSet( cd, return, bAudit) quit
		set return=$$longGet( cd, return)
	}

	quit return

	// ---------------------------------------------------------------------
getColNm( String cln)		// column name
	/* ---------------------------------------------------------------------
	Helper function to return the column name in all uppercase, or unquoted.
	*/
	if cln.ascii() quit $$UPCASE^UCGM( cln)
	quit $$UNTOK^%ZS( cln, PSL.tok).stripQuotes()
	
	// ---------------------------------------------------------------------
getPslCln( String tbl,		// table name
	String cln)		// column name
	/* ---------------------------------------------------------------------
	Helper function to return a PSLColumn from the pslCln() cache.
	The descriptor will be added if it does not yet occur in the cache.
	*/
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	type String ref

	if cln.ascii() set cln=$$UPCASE^UCGM( cln)
	else  set cln=$$QSUB^%ZS($$UNTOK^%ZS( cln, PSL.tok),"""")

	set ref = tbl_ "."_ cln

	catch xcpt {
		if xcpt.type ["RECNOFL" set xcpt.type="%PSL-E-INVALIDREF",xcpt.context=ref
		throw xcpt
	}
	if 'pslCln(ref).exists() set pslCln(ref) = PSL.getPSLColumn(tbl, cln, .pslTbl())
	quit pslCln(ref)

	// ---------------------------------------------------------------------
getPslTbl( String tbl)		// table name
	/* ---------------------------------------------------------------------
	Helper function to return a PSLTable from the pslTbl() cache.
	The descriptor will be added if it does not yet occur in the cache.
	*/
	type public PSLColumn pslCln()
	type public PSLTable  pslTbl()

	/* ensure PSLTable instance for this table exists.
	   This will throw an exception when the tablename is invalid.
	   Ensure that information level is 1, to be able to use all properties.
	   Note that this must be enforced for ALL instances, not just the new
	   instances. */
	catch xcpt {
		if xcpt.type ["RECNOFL" set xcpt.type="%PSL-E-INVALIDREF",xcpt.context=tbl
		throw xcpt
	}
	if 'pslTbl( tbl).exists() set pslTbl(tbl) = PSL.getPSLTable( tbl, 0)
	set pslTbl( tbl) = pslTbl(tbl).assertLevel( 1, .pslCln())
	quit pslTbl(tbl)

	// ---------------------------------------------------------------------
private longGet( PSLColumn cd,
		String expr)
	/* ---------------------------------------------------------------------
	Force subroutine for retrieval of Masterfield when the expression may
	exceed PSL.maxLineLength.

	Because the object instance may have been optimized, expr may contain
	"arbitrary" values. So use a separate subroutine for each call.

	NOTES:
	. Subroutine sharing would be possible under the following conditions:
		- the reference is known to be un-optimized
		- the reference is to the same declaration
	*/
	type String cmt = cd.table_"."_cd.column_".get()"

	type PSLSubrou sr = PSL.addSubrou( "CoGet", "()", cmt, 1)

	do sr.addCode( " N vV")

	type PSLExpression code = "S vV="_ expr.piece( 9.char())
	type String nxt
	type Number pce

	for pce=2:1:expr.length( 9.char()) do {
		set nxt = expr.piece( 9.char(), pce)
		if code.fitsLineLength( nxt.toByteString().length() + 1) set code = code_ "_"_ nxt quit
		do sr.addCode( code)
		set code = " S vV=vV_"_ nxt
	}
	do sr.addCode( code)
	do sr.addCode(" Q")
		
	quit "$$"_ sr.toString()_ "()"

	// ---------------------------------------------------------------------
private longSet( PSLColumn cd,
		String leftexp,		// instance var or declaration position
		String rightexp,
		Number mode)
	/* ---------------------------------------------------------------------
	Return complete M statement to assign (masterfield) column, which may
	be longer than PSL.maxLineLength.

	Because leftepxr may be an assignment to an optimized instance (unlikely
	but possible), each call will create a separate subroutine.
	*/
	type String cmt = cd.table_"."_cd.column_".set("_ leftexp_ ","_ mode_ ")"

	type Number pce
	type PSLSubrou sr = PSL.addSubrou( "CoSet", "(vV)", cmt, 1)
	type String expr = cd.getUpdateCode( leftexp, "vV", mode)

	for pce=1:1:expr.length( 9.char()) do sr.addCode( " "_ expr.piece( 9.char(), pce))
	do sr.addCode(" Q")

	quit " D "_ sr.toString()_ "("_ rightexp_ ")"

	// ---------------------------------------------------------------------
litVal( PSLIdentifier  oid,	// object variable instance
	String  property,	// column name
	Boolean fset)		// set (1) or get (0)
	/* ---------------------------------------------------------------------
	Return the column value of a literal Record instance.
	This function uses $$propGet^DBSDYNRA()
	*/
	if fset do PSL.error( "Db class is read-Only under LITERAL scope") quit ""

	type String vOid = $$getExpr^UCGM( oid)
	if vOid="" do PSL.error( "LITERAL scope "_ oid_ " was not instantiated") quit ""

	type String val = $$propGet^DBSDYNRA(vOid, property)
	if val.isNumber() quit val
	quit val.addQuotes()

	// ---------------------------------------------------------------------
colProp( PSLIdentifier recVar,	// record instance variable
	String  colnm,		// column name
	Boolean fset,		// assignment flag
	PSLExpression propExpr,	// object expression (*4)
	Number  ptr)		// character pointer (*5)		/MECH=REFNAM:RW
	/* ---------------------------------------------------------------------
	Process column methods
	If the property exists in the Column class, return the property
	value.  Otherwise return the current column value and class
	and process this property on that class.
	
	The formal parameters are the same as the (corresponding) formal
	parameters in $$curVal()

	Column properties: CURVAL,DES,JOURNAL,KEY,LEN,OLDVAL,TYP

	ARGUMENTS:
	(*4) propExpr = object expression
		Passed to and by $$curVal(). Used here to obtain the name of the
		property (or method)
	(*5) ptr - character pointer
		Although the use as formal parameter suggests "local scope",
		this is not the case. Because this function may call
		$$property^UCGM(), the name 'ptr' is essential, because it is
		the public variable that is expected by $$property^UCGM().

	*/
	type public String class
	type public String setVar

	type Number optr = ptr		// old value of ptr
	type String prop		// Column property

	set ptr  = ptr + 1		// skip "."
	set prop = $$ATOM^%ZS( propExpr, .ptr, ".", , 1)

	if prop.upperCase() = "CURVAL" quit $$curVal( recVar, colnm, fset, propExpr, .ptr)

	type String z = $$opGet^UCXOBJ( , "Column", prop, 1)

	/* Not found at all. Must be property (or method) of Primitive
	   descendant, that is applied to recVar.colnm
	   Reset ptr to its original value (for the caller of $$curVal()), and
	   return just $$curVal(). */
	if z.isNull() set ptr=optr quit $$curVal(recVar,colnm,fset,"",0)

	if ptr>0,fset do PSL.error( "Column class property is readOnly") quit ""

	/* Create a dummy entry in type(,) to represent the Column instance.
	   FSCW CR18163: the purpose of this instance is unknown */
	set class="Column"
	type PSLIdentifier colId
	type Number i

	for i=1:1 set colId = "vol"_i  quit:$$getNew^UCGM(colId)=""
	do typeDec^UCGM( colId, class, "PUBLIC")

	set colnm = $$getColNm(colnm)	// standardize name
	quit $$property^UCGM( colId, PSL.level, prop, .class, .setVar)

	// ---------------------------------------------------------------------
private des	// Property table.column.des ; Return Schema Description
	/* ----------------------------------------------------------------------
	*/
	type public String property,return,table
	set return=$$QADD^%ZS($$DES^SQLDD(table_"."_property))
	quit

	// ---------------------------------------------------------------------
private len	// Property table.column.len ; Return Schema Length
	/* ---------------------------------------------------------------------
	*/
	type public String property,table
	type PSLColumn cd = {PSLColumn}$$getPslCln(table,property)

	set PSL.return = cd.length
	if PSL.return.isNull() set PSL.return = PSL.return.addQuotes()
	quit

	// ---------------------------------------------------------------------
private typ	// Property table.column.typ ; Return Schema type
	/* ---------------------------------------------------------------------
	*/
	type public String property,table
	type PSLColumn cd = {PSLColumn}$$getPslCln(table,property)

	set PSL.return = cd.dataType.addQuotes()
	quit

	// ---------------------------------------------------------------------
private req	// Property table.column.req ; Return Schema is required
	/* ---------------------------------------------------------------------
	*/
	type public String property,return,table
	set return=$$QADD^%ZS($$REQ^SQLDD(table_"."_property))
	quit

	// ---------------------------------------------------------------------
private key	// Property table.column.key ; Return Schema key level (Null if not key)
	/* ---------------------------------------------------------------------
	*/
	type public String property,table
	
	type PSLColumn cd = {PSLColumn}$$getPslCln( table, property)
	if cd.node["*" set PSL.return = cd.position
	else  set PSL.return = """"""

	/* begin old code ------------------------------------------------------
	type String keys

	if '$D(fsn(table)) do fsn^SQLDD(.fsn,table) if ER do ERROR^UCGM quit

	set keys = fsn(table).piece("|",3)
	for return=1:1:keys.length(",") if keys.piece(",",return) = property quit

	if $T=0 set return=""""""
	-------------------------------------------------------- end old code */

	quit

	// ---------------------------------------------------------------------
private oldVal	// Property table.column.oldVal
	/* ---------------------------------------------------------------------
	This subroutine is called because it is listed in OBJECTPROP.ROUTINE for
	the combination ('Column', 'oldVal'). The call stack will be as follows:
	- property^UCGM calls curVal^UCCOLUMN for Record.column.colProp
		objExpr and ptr will be supplied
	- curVal^UCCOLUMN calls colProp^UCCOLUMN
		this subroutine uses:
		- recVar to name the Record instance variable
		- colnm to name the column
		- propExpr for the object expression that includes the .oldVal
		- ptr for the character pointer into propExpr
	- colProp^UCCOLUMN calls property^UCGM
		this subroutine has objectName, objectLevel, ref, class, and
		setVar as formal parameters, so the values are overwritten by
		whatever colProp supplied
	- property^UCGM calls oldVal^UCCOLUMN
	
	This subroutine needs access to the following entities:
	- the Record instance variable
	- the name of the column
	Both are accessed using the (formal parameter) name from colProp.

	NOTES:
	. This subroutine assumes that property^UCGM will take care of the fact
		that oldVal is a "read-only property".
	*/
	type public String	  colnm		// columnname as used by colProp
	type public Boolean       commands(,)	// references commands("WARN","SCOPE")
	type public PSLColumn     pslCln()	// column descriptor cache
	type public PSLTable      pslTbl()	// column descriptor cache
	type public PSLIdentifier recVar	// recordvar as used by colProp

	type String    table = $$getReTable^UCGM( recVar.class)
	type String    ref   = table_ "."_ colnm
	type PSLColumn cd    = PSL.cachePSLColumn( .pslCln(), ref, .pslTbl())
	type Boolean   bHasRoot
	type Number    accPos = $$clnByOvs^UCREC4OP( PSL.subRou, recVar, cd, 0, 0, .bHasRoot)
	
	/* If this column reference does not have a root instance, report a
	   warning */
	if 'bHasRoot,recVar.scope'="LITERAL",commands("WARN","SCOPE").get() do PSL.warn("SCOPE: Variable "_ recVar_ " may not have been instantiated")

	/* Turn off optimization for recVar, because .oldVal requires vobj() by
	   definition. */
	do setOpti^UCGM( recVar, recVar.scopeLevel, -1)

	/* Construct the return code based on the PSLColumn methods.
	   Do not generate placeholder code, because .oldvar assumes needVobj.
	   Replace TAB by underscore for masterfield.oldval (see curVal).
	   */
	set PSL.class = cd.getClass()
	set PSL.return = cd.getOldExpr( recVar, 0)
	if PSL.return [ 9.char() set PSL.return = PSL.return.translate( 9.char(), "_")
	quit

	// ---------------------------------------------------------------------
journal	; private ; Property ; table.column.journal
	/* ---------------------------------------------------------------------
	*/
	type public Boolean fset
	type public String	  colnm		// columnname as used by colProp
	type public PSLIdentifier recVar	// recordvar as used by colProp
	
	/* ================ start v6.3 change
	if '$G(type(level,var,5)) Q		; check audit flag
	=============== end v6.3 change */
	set fset=0
	set PSL.return = PSL.oLvn_ "("_ recVar_ ",-400,"""_ colnm_ """)"
	quit

	// ---------------------------------------------------------------------
private getKey( List keys, String di)	; Return the key index
	/* ---------------------------------------------------------------------
	
	================ begin old code
	type Number i
	for i=1:1:keys.length(",") if keys.piece(",",i)=di quit
	if  quit (-2-i)
	================ end old code */
	if 'keys.contains(di) quit ""
	quit -2 - keys.position(di)

	// ---------------------------------------------------------------------
private dynamic( Boolean external,	// are values in external representation?
		PSLIdentifier var,	// object variable instance
		String  table,		// table name (*3)
		String  property,	// column expression (*4)
		Boolean fset)		// set (1) or get (0)
	/* ---------------------------------------------------------------------
	Property passed through indirection.
	This subroutine is also called by overlay^UCRECORD.
	
	ARGUMENTS:
	(*3) table name
		If an empty table name is supplied, then the intention is to
		generate assignment to or retrieval from an arbitrary Record
		descendent at runtime. That code will be added later.
	(*4) property
		The value will be supplied as detected by the caller, i.e.
		including the initial "@", that will be stripped unconditionally.
		The remaining leftexpr will be used in as the actual parameter
		to represent the column name at runtime.
	(*6) leftexpr
		This parameter is ignored when fset=0, and it is required when
		fset=1. In that case it represents the value to be assigned to
		the column.

	INPUTS:
	. String append(,)
		Subroutines and functions to be appended to the generated code
	. SchemaColumn pslCln(table.property)
		Shall have been initiated by the caller

	OUTPUTS:
	. $$  if fset=0:
		Function call for indirect column retrieval
	      if fset=1:
		var_","_property (with "@" removed from property). This is the
		first part of argument list to be supplied to the subroutine
		specified in struct("setProperty"). The code in UCGM will add
		the value to be assigned as the last parameter.

	NOTES:
	. See subroutine setProperty for another example of code that uses
		struct("setProperty").
	. If property starts with "@@", this subroutine fills return with:
		property.extract(3, property.extract(3, property.length()))
		i.e. the characters following "@@" are interpreted numerically,
		and that number of characters is returned immediately.
		The purpose of this behavior is unclear to FSCW.
	. The code generated by this function will be capable to retrieve a
		computed column at runtime. To do that, it must determine the
		columns required to pass to the	computation and it must load the
		nodes for those columns. Since this is done at runtime,
		indirection is used to "compute" the return value, and it calls
		itself to recursively obtain the values of the columns that
		participate in the computation. This is obviously slow.
		Programmers should be discouraged against runtime indirection of
		computed columns even though this code works.
	*/
	type literal String LEFTEXMARK = 31.char()

	type public String	append(,)	// used to generate next label
	type public PSLColumn	pslCln()	// PSLCoumn cache
	type public PSLTable	pslTbl()	// PSLTable cache
	type public String	struct()	// used to pass "setProperty"

	type String dynamic	// function return value
	type Number i		// scratch variable
	type String nodChk	// node check for type 11 tables
	type Number varLvl = $$getLevel^UCGM( var)	// type level of var
	type Boolean bAudit = ''$$getAtt^UCGM( var, varLvl, 12)

	/* First things to do:
	   - turn off optimization of the object instance
	   - mark as subroutine call that passes object
	   	Because this subroutine is called for Record.overlay(), the
	   	supplied var may be dummy. So ignore the declaration not found
	   	exception.
	   */
	do setOpti^UCGM( var, varLvl, -1)
	do {
		catch errRec {
			// ignore insert error
		}
		type Number dummy = $$insByOvs^UCREC4OP( PSL.subRou, var, "", "U")
	}
	set property = property.extract(2, property.length())

	// For now, resolve at runtime
	set PSL.class = "String"

	/* Dynamic Record instances generate calls to propXyz^DBSDYNRA()
	   */
	if table.isNull(),fset quit " D propSet^DBSDYNRA("_ var_ ","_ property_ ","_ LEFTEXMARK_ ","_ bAudit_ ")"
	if table.isNull() quit "$$propGet^DBSDYNRA("_ var_ ","_ property_ ")"

	/* FSCW CR15028: Intention of next line completely unclear ... */
	if property.extract() = "@" quit property.extract(2, property.extract(2, property.length()))

	// Track indirection use
	do addXref^UCGM("I"_fset, table, var)

	type PSLTable td    = {PSLTable}$$getPslTbl( table)
	type String comment = "Record"_ table.upperCase()_ "."

	/* bAudit as stored in type() is an insufficient condition for change
	   auditing: If the table has index columns, it will need bAudit
	   behavior to track index changes. To be safe:
	   set bAudit if the table has indexes. Modify bAudit before the
	   comment is constructed, so it can be used to allocate the correct
	   label. */
	if fset do {
		if 'td.indexList.isNull() set bAudit = 1
		set comment = comment _ "setColumn("_ bAudit_ ","_ external_ ")"
	}
	else  set comment = comment _ "getColumn()"

	// Find next label number to use
	// type String label = "vCoInd"
	// for i = 1:1 quit:'append(label_i).data()  quit:append(label_i,2).piece("; ",2)=comment
	// set label = label_ i
	type String label = $$findSubr^UCGM("vCoInd",comment)

	/* Compose the formallist and the actuallist. The object id and column
	   name are always included. In case of reference, the value returned by
	   $$dynamic() will be the code to be inserted, including the actual
	   parameters (var and property). In case of assignment, the lists also
	   include the value to be assigned. In that case, the value returned by
	   $$dynamic() will be the parameters that must be appended to the
	   struct("setProperty") value.
	*/
	type String fpl = "String vOid, String vCol"
	if fset do {
		set fpl = fpl_ ", String vVal"
		set dynamic = var_","_property
		set struct("setProperty") = label
	}
	else  set dynamic = "$$"_ label_ "("_var_","_property_")"

	if 'append(label).data() do {
		type PSLBuffer sr = PSL.openBuffer( fpl, comment)

		// replace next line by vP = PSL.getPSLColumn() once supported
		do sr.add(" type PSLColumn vP = PSL.getPSLColumn("""_table_""",vCol.upperCase())")
		do sr.add(" type String vNod=vP.node")
		do sr.add(" type Number vPos")

		// if audit/rdb and set, or table has Blob/Memo, dataType is needed
		/*  bAudit is an insufficient condition: If the table has index
		    columns, it will force bAudit behavior. To be safe: include
		    the line always if fset.
		if ((bAudit!td.isRdb) & fset) ! td.hasBlob ! td.hasMemo do sr.add(" type String vTyp = vP.dataType")
		------------------------------------------------------------- */
		if fset ! td.hasBlob ! td.hasMemo do sr.add(" type String vTyp = vP.dataType")

		do dynKey(td,sr,fset,bAudit)

		/* Code for retrieval and assignment of computed values is only
		   included if table has them. */
		if td.hasComputed do {
			do sr.add(" //")
			do sr.add(" type String vCmp=vP.computation")
			if 'fset,td.recordType=1 do {
				do sr.add(" if vCmp'="""" set vCmp=vP.getCurrentExpr(""vOid"",0) quit @vCmp")
			}
			else  if 'fset do {
				do sr.add(" if vCmp'="""" do { quit @vCmp")
				do sr.add("   type String vpt()")
				do sr.add("   do parseCmp^UCXDD( vCmp, .vpt())")
				do sr.add("   type Number vCnt = vpt("""").order(-1)")
				do sr.add("   type String vVal")
				do sr.add("   type Number vElm")
				do sr.add("   set vCmp=""""")
				do sr.add("   for vElm=2:2:vCnt set vCmp=vCmp_vpt(vElm-1)_($$"_label_"(vOid,vpt(vElm))).addQuotes()")
				do sr.add("   set vCmp=vCmp_vpt(vCnt)")
				do sr.add(" }")
			}
			else  do sr.add(" if vCmp'="""" throw Class.new(""Error"",""%PSL-E-INVALIDREF"")")
		}
		do sr.add(" //")
		do sr.add(" set vPos = vP.position")

		if td.recordType>1 do dynLd( td, sr, .nodChk)
		if td.hasBlob!td.hasMemo do dynLdBM( td, sr, fset, bAudit)
	
		if 'fset do dynGet(td, sr, nodChk.get())
		if fset  do dynSet(td, sr, nodChk.get(),bAudit,external)
	
		do sr.insert( label)
	}

	/* Pass struct("setProperty") just prior to quit. If assigned before
	   calling PSLBuffer.insert(), it will be interpreted by the nested
	   call to the compiler ... */
	if fset set struct("setProperty") = label

	quit dynamic

	// ---------------------------------------------------------------------
dynGet( PSLTable td,
	PSLBuffer sr,
	String check)		// node-not-bottomkey check (see dynLd())
	/* ---------------------------------------------------------------------
	Column indirection - Generate code for ordinary non-key column.
	Note that the code for the retrieval of Blob/Memo is part of the
	dbload code generated by dynLdBM().
	*/
	type literal String oLvn = "vobj"
	
	type String dlm  = "$C("_ td.columnDelimiter_ ")"
	type Number ftyp = td.recordType

	do sr.add(" type String vRet")

	// RDB masterfield retrieval preceeds ordinary column construction
	type List mlst = td.masterfieldList
	if 'mlst.isNull(),td.isRdb do {
		/* Include code for masterfield retrieval on RDB:
		   Call $$getMfRDB^UCCOLSF() to get the retrieval expression, and
		   call getMf2A^UCCOLSF() to break it down in pieces that fit
		   the GT.M line length. If it fits on a single line (code()
		   contains 1 line), insert at once, else insert as series of
		   lines inside nested DO-block. */
		type String code()	// masterfield code array
		type Number i,j		// iterators
		type String mcol	// master column name
		type String mget	// masterfield retrieval expr
		type String z		// scratch var
		for i=1:1:mlst.count() do {
			set mcol = mlst.elementAt(i)
			set mget = $$rtMfRDB^UCCOLSF(td.table, mcol, "vOid")
			set z = " if vCol="""_mcol_""" "
			do getMf2A^UCCOLSF(mget,"vRet",.code())
			set j = code("").order(-1)
			if j>1 do {
				do sr.add( z_ "do { quit vRet")
				for j=1:1:j do sr.add("  "_code(j))
				do sr.add( "}")
			}
			else  do sr.add( z_ "quit "_ code(1).extract(code(1).find("vRet="),code(1).length()))
		}
	}

	if ftyp=11 do {	// need to include conditional code
		do sr.add(" if "_ check_ " set vRet="_ oLvn_ "(vOid,vNod)")
		do sr.add(" else  set vRet="_ oLvn_ "(vOid)")
	}
	else  do {	// correct node always known at compile time
		type String ref

		if ftyp=1 set ref = oLvn_"(vOid)"
		else  set ref= oLvn_ "(vOid,vNod)"
		do sr.add(" set vRet="_ ref))
	}
	do sr.add(" set vRet=vRet.piece("_dlm_",vPos)")

	if 'mlst.isNull(),'td.isRdb do {
		/* Include code for subfield retrieval on MDB:
		   Generate runtime call to $$gsetSf^UCCOLSF() with all
		   vP.subfieldXxx properties of this column. */
		type String z = "$$getSf^UCCOLSF(vRet,vP.subfieldTag,vP.subfieldMajor,vP.subfieldMinor,vP.subfieldPosition)"
		do sr.add(" if 'vP.subfieldPosition.isNull() quit "_ z)
	}
	do sr.add(" quit vRet")
	quit

	// ---------------------------------------------------------------------
dynKey( PSLTable td,
	PSLBuffer sr,
	Boolean fset,
	Boolean bAudit)
	/* ---------------------------------------------------------------------
	Column indirection - Add code to retrieve or assign a key column
	*/
	type Number i
	type String keys = td.primaryKeys
	type String z

	// retrieve a key value
	if keys'="",'fset do {
		set z = " if vNod[""*"" quit "_ PSL.oLvn_ "(vOid,"
		if keys.length(",")=1 set z = z_"-3)"
		else  do {
			//set z=z_"$S(" 
			//for i=1:1:keys.length(",")-1 set z = z_"vCol="""_keys.piece(",",i)_""":-"_(i+2)_","
			//set z=z_"1:-"_(i+3)_")"
			set z = z_"-vP.position-2)"
		}
		do sr.add(z_ ".get()")
	}

	// assign to a key value
	if keys'="",fset do {
		set z = " if vNod[""*"" set vPos="
		if keys.length(",")=1 set z = z_"-3"
		else  do {
			//set z=z_"$S(" 
			//for i=1:1:keys.length(",")-1 set z = z_"vCol="""_keys.piece(",",i)_""":-"_(i+2)_","
			//set z=z_"1:-"_(i+3)_")"
			set z = z_"-vP.position-2"
		}
		// if Record.setAuditFlag(1), then add code to track change of key column value
		if bAudit do {
			type PSLExpression oldLvn = $$cdOldLvn^UCXDD("vOid","vP.position_""*""","vCol")
			set z = z_" set:'"_ oldLvn_ ".exists() "_ oldLvn_ "=vTyp_""000""_"_ PSL.oLvn_ "(vOid,vPos)"
		}
		if td.isRdb do {	// include assignment(s) to -150 for key column
			type String set150 = $$cdRdbAsn^UCXDD( "vOid", """"_ td.internalNames_ """", "vP.internalColumn", """0*""", "vPos", "$$toValMod^UCXDD(vTyp,vP.isNullToZero)")
			if td.internalNames [ "," do {
				type Number t
				type String setNod, setTbl
				for t=1:1:td.internalNames.count() do {
					set setTbl = td.internalNames.elementAt(t)
					set setNod = $$tbl2nod^DBMAP( setTbl)
					if 'setNod.isNull() set set150 = set150_","_ $$cdRdbAsn^UCXDD( "vOid", """"_ setTbl_ """", "vP.internalColumn", setNod, "vPos", "$$toValMod^UCXDD(vTyp,vP.isNullToZero)")
				}
			}
			set z = z_ " set "_ set150
		}
		do sr.add(z_ " set "_ PSL.oLvn_ "(vOid,vPos)=vVal quit")
	}
	quit

	// ---------------------------------------------------------------------
dynLd(  local PSLTable td,
	local PSLBuffer sr,
	public String btmKeyCk)		// (*3)				  /NOREQ
	/* ---------------------------------------------------------------------
	Column indirection - Add code for incremental load of vobj(oid,node)
	Shall only be called when td.recordType > 1.

	ARGUMENTS:
	(*3) btmKeyChk = if-argument to check that the node does NOT name the
		bottom key. This value will only be useful if td.recordType=11.
	*/
	type Number ftyp   = td.recordType
	type String gbl    = $$getGbl^UCXDD( td, "vOid")
	type String keys   = td.primaryKeys
	type String ref    = PSL.oLvn_ "(vOid,vNod)"
	type String sublst
	type String var    = "vOid"

	/* If table has negative nodes, PSLColumn.node is only used in the gbl
	   subscript, and vNod must contain PSLColumn.getCurrentNode() because
	   other dynamic code uses vNod as subscript in vobj(,). */
	if td.hasNegativeNode do {
		do sr.add(" type String vNd1 = vNod set vNod = vP.getCurrentNode()")
		set btmKeyCk = "vNod'="""""
		set sublst = "vNd1"
	}
	else  do {
		set btmKeyCk = "vNod'=""" _ keys.piece(",", keys.length(",")) _ """"
		set sublst = "vNod"
	}

	if keys="" do {	quit	// can never occur for RDB (td.recordType > 1)
		//if 'gbl.endsWith("(") set gbl = gbl_ ","
		do sr.add(" if '"_ ref_ ".data() set "_ ref_ "="_ gbl_ sublst_ ").get()")
	}

	/* remainder: keys not null. */
	type String z = " if "
	if ftyp=11 set z = z_ btmKeyCk_ ","
	set z = z_ "'"_ ref_ ".data()"
	if td.hasBlob!td.hasMemo set z = z_ ",""MB""'[vTyp"
	do sr.add( z_ " do {")
	do sr.add("   if '"_ PSL.oLvn_ "(vOid,-2).get() set "_ref_"="""" quit")
	if td.isRdb do {
		/* code generated for dbLoad of wide table node uses the
		   fact that the wide tables have a single key (as stored
		   in variable keys. */
		do sr.add("   new vData,vEr,vRm")
		type String z = "   set vEr=$$SELECT^%DBAPI(0"
		set z = z_ ",""SELECT * FROM ""_ vP.internalTable_ "" where "_ keys_ "=:v1"""
		set z = z_ ",$C("_ td.columnDelimiter_ ")"
		do sr.add( z_ ",vobj(vOid,-3)_$C("_ td.columnDelimiter_ "),.vData,.vRm)")
		do sr.add("   if vEr<0 throw Class.new(""Error"",""%PSL-E-SELFAIL"")")
		do sr.add("   set "_ ref_ "=vData")
	}
	else  do {
		do sr.add("   set "_ ref_ "="_ gbl_ sublst_ ").get()")
	}
	do sr.add(" }")

	quit

	// ---------------------------------------------------------------------
dynLdBM( PSLTable td,
	PSLBuffer sr,	
	Boolean fset,
	Boolean bAudit)
	/* ---------------------------------------------------------------------
	Column indirection - Add dbLoad code for Blom / Memo.
	Shall only be called if td.hasBlob or td.hasMemo.
	For retrieval, the code will always be included, and the generated code
	will always quit the value that is already there or has just been loaded.
	For assignment, the code will only be included if audit is on and the the
	table is RDB.

	NOTES:
	. The current code declares both BMNODE and glbBM as ordinary variables,
		that depend on td.recordType. Once all code is adapted to use
		vobj(o,n,1) for Blob/Memo, BMNODE effectively becomes a literal.
		However, gblBM will remain a variable that depends on the
		record type, because there will be no change to the database
		structure.
	*/
	type String BMNODE
	type String gbl = $$getGbl^UCXDD( td, "vOid")
	type String gblBM		// Global that contains Blob/Memo

	if td.recordType=1,'td.isRdb do {
		set BMNODE = "vobj(vOid,1,1)"
		set gblBM  = gbl_"v1)"
	}
	else  do {
		set BMNODE = "vobj(vOid,vNod,1)"
		set gblBM  = gbl_"vNod,v1)"
	}

	if 'fset!(bAudit&td.isRdb) do {
		do sr.add(" if ""MB""[vTyp do {"_$SELECT(fset:"",1:" quit "_BMNODE))
		do sr.add("   if "_ BMNODE_ ".exists() quit")
		do sr.add("   if 'vobj(vOid,-2).get() set "_BMNODE_"="""" quit")
       		if td.isRdb do {
       			/* construct the where-clause and the vList for
       			   this table:
       			   * for each column add a AND KEY=:vN to where
			   * and add vobj(vOid,-key) to vList */
			type String dlm = "$C("_ td.columnDelimiter_ ")"
			type Number i
			type String keys = td.primaryKeys
			type String lst = "$$QADD^%ZS(vobj(vOid,-3))"
			type String whr = " where "_ keys.piece(",")_"=:v1"
			type String z
			for i=2:1:keys.length(",") do {
				set whr = whr_ " AND "_ keys.piece(",",i)_"=:v"_ i
				set lst = lst_ "_"_ dlm_ "_"_ "$$QADD^%ZS(vobj(vOid,-"_ (i-2)_ "))"
			}
       			do sr.add("   // Incremental load of Blob/Memo")
			do sr.add("   new vData,vEr,vList,vRm,vSql")
			set z = """SELECT ""_vP.internalColumn_"" FROM ""_vP.internalTable_"""
			do sr.add("   set vSql="_ z_ whr_"""")
			do sr.add("   set vList="_ lst)
			do sr.add("   set vEr=$$SELECT^%DBAPI(0,vSql,"_dlm_",vList,.vData,.vRm)")
			do sr.add("   if vEr<0 throw Class.new(""Error"",""%PSL-E-SELFAIL"")")
			do sr.add("   set "_ BMNODE_ "=vData")
       		}
        	else  do {
			do sr.add("   type String v1,vVal set (v1,vVal)=""""")
			do sr.add("   for  set v1="_ gblBM_ ".order() quit:v1.isNull()  set vVal=vVal_"_gblBM)
			do sr.add("   set "_ BMNODE_ "=vVal")
       		}
		do sr.add(" }")
	}
	quit

	// ---------------------------------------------------------------------
dynSet( PSLTable td,
	PSLBuffer sr,
	String check,		// node-not-bottomkey check (see dynLd())
	Boolean bAudit,
	Boolean bExtern)	// values (in vVal) will be in external format
	/* ---------------------------------------------------------------------
	Column indirection - Generate code for assignment to non-key column.
	Unlike dynGet(), this subroutine must handle (assignments to) Blob / Memo
	columns.

	NOTES:
	. This subroutine generates code that maintains the -100 tree for Blob
		and Memo columns (on RDB only).
	*/
	type literal String oLvn = "vobj"

	/* Temporary code (until selective audit of index columns is supported)
	   */
	type String TBL = td.table
	if Db.isDefined("DBTBL8","%LIBS='SYSDEV' and FID=:TBL", 1) set bAudit = 1

	/* Construct an expr that represents the lvn that contains the Blob or
	   Memo data. It will only be used when the table contains Blob/Memo. */
	type String BMNODE
	if td.recordType=1 set BMNODE = oLvn_ "(vOid,1,1)"
	else  set BMNODE = oLvn_ "(vOid,vNod,1)"

	type String  getPce = ".piece($C("_ td.columnDelimiter_ "),vPos)"
	type Number  ftyp   = td.recordType
	type Boolean bRdb   = td.isRdb
	type Boolean bBM    = td.hasBlob!td.hasMemo
	type String  z			// scratch variable

	/* Construct an expr that represents the retrieval of the current value
	   of the column. This is used to save the column.oldVal in the -100
	   tree, and to retrieve masterfields in MDB. */
	type String curVal
	if ftyp = 1 set curVal = oLvn_"(vOid)"
	else  if ftyp = 10 set curVal = oLvn_"(vOid,vNod)"
	else  set curVal = "$S("_check_":"_oLvn_"(vOid,vNod),1:"_oLvn_"(vOid))"
	set curVal = curVal_ getPce

	if bExtern!bRdb do sr.add(" type Boolean vNul = vP.isNullToZero")

	if bExtern do {		// convert external to internal
		do sr.add(" if ""CDLU""[vTyp set vVal=$$INT^%ZM(vVal,vTyp)")
		do sr.add(" if ""$N""[vTyp,'vVal.isNull()!vNul set vVal=+$$INT^%ZM(vVal,vTyp,,vP.precision)")
	}

	// handle masterfield assignments (identical on RDB and MDB)
	type List mlst = td.masterfieldList
	if 'mlst.isNull() do {
		type Number i		// iterator
		type String mcol	// master column name
		for i=1:1:mlst.count() do {
			set mcol = mlst.elementAt(i)
			do sr.add(" if vCol="""_mcol_""" do "_$$setMaster^UCCOLSF(td.table,mcol,bAudit)_"(vOid,vVal) quit")
		}
	}

	// handle -150 maintenance for RDB
	if bRdb do {
		type String nodExpr = $SELECT(ftyp=1:"""0*""",1:"$S("_check_":vNod,1:""0*"")")
		do sr.add( " set "_ $$cdRdbAsn^UCXDD("vOid","vP.internalTable","vP.internalColumn",nodExpr,"vPos","$$toValMod^UCXDD(vTyp,vNul)"))
	}

	/* Allocate var and assign value of oldNode, and use this var
	   in -100 tree. Include only if ftyp>1 or bAudit. */
	if (ftyp>1)!bAudit do sr.add("type String vOldNod=vP.getOldNode(0)")
	type String  oldLvn = $$cdOldLvn^UCXDD("vOid","vOldNod","vCol")

	// handle vobj(vOid,-100,vOldNod,vCol) if bAudit
	if bAudit do {
		type String cur
		if 'mlst.isNull(),'bRdb do {
			// additional code to retrieve subfield.oldVal on MDB
			do sr.add(" type String vOld = "_curVal)
			set z = $$GETSUB^UCSTRING("vP.subfieldTag","vP.subfieldMajor","vP.subfieldMinor","vP.subfieldPosition","vOld",1)
			do sr.add(" if 'vP.subfieldPosition.isNull() set vOld="_ z)
			set cur = "vOld"
		}
		else  set cur = curVal

		// exclude -100 maintenance of Blob/Memo on MDB (if present)
		if bBM,'bRdb set z = """MB""'[vTyp,"
		else  set z = ""
		set z = " if "_ z_ "'$D("_ oldLvn_ ")) set "
		do sr.add(z_ oldLvn_ "=vTyp_$E(1000+vPos,2,4)_"_ cur)
	}

	// Independent of audit, maintain vobj(vOid,-100,vOldNod), except for type 1 tables
	if ftyp>1 do sr.add(" set "_ $$cdNodChg^UCXDD("vOid","vOldNod")_ "=""""")

	// Assignment to Blob/Memo possible without additional processing
	if bBM do sr.add(" if ""MB""[vTyp set "_ BMNODE_ "=vVal quit")

	/* Add code to for subfield assignment on MDB.
	   The final assignment will be to the masterfield. The generated code
	   will replace the supplied vVal by the value of the masterfield with
	   the supplied vVal inserted at the correct subfield position */
	if 'mlst.isNull(),'bRdb do {
		// additional code to set subfield on MDB
		set z = $$PUTSUB^UCSTRING("vVal","vP.subfieldTag","vP.subfieldMajor","vP.subfieldMinor","vP.subfieldPosition",curVal,1)
		do sr.add(" if 'vP.subfieldPosition.isNull() set vVal="_ z)
	}

	// now we are ready to generate the code for the final assignment
        if ftyp=1 do sr.add(" set "_ oLvn_ "(vOid)"_ getPce_ "=vVal")
        if ftyp=10 do sr.add(" set "_ oLvn_ "(vOid,vNod)"_ getPce_ "=vVal")
	if ftyp=11 do {
		do sr.add(" if "_ check_ " set "_ oLvn_ "(vOid,vNod)"_ getPce_ "=vVal quit")
		do sr.add(" set "_ oLvn_ "(vOid)"_ getPce_ "=vVal")
	}
	do sr.add(" quit")
	quit
