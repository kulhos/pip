//DO NOT MODIFY  PSL Number Class Method Library|UCNUMBER|||||||1
	/*
	ORIG: FSANCHEZ - 03/17/2003
	DESC: PSL Number Class Method Library

	*************************************************************************
	* IMPORTANT NOTE:							*
	*	Although this DQ procedure is considered a member of the	*
	*	Insensitive group, it does contain code that may fail during	*
	*	bootstraps. See rndCRCD for details.				*
	*************************************************************************

	---- Environment Sensitive Elements ------------------------------------
	%CRCD
		Used to generate code for Number.roundCur()
	$$curdec^CRCDUTL()
		This function will be called when a Number.roundCur() method has
		an explicit or implicit constant currency value, and the routine
		does already exist.

	---- Methods implemented in other units --------------------------------
	Number.byte()
		This method is implemented in UCBYTSTR, because the code
		generated for this method  must obey the same rules as class
		ByteStream.
	Number.char()
		This method is implemented through psl2m^UCPRIM()
	Number.fnumber( local String format,local Number decimals)
		This method is implemented through psl2m^UCPRIM()
	Number.random()
		This method is implemented through psl2m^UCPRIM()

	---- Revision History --------------------------------------------------
	09/20/06 - Frans S.C. Witte - CRs: 22720 / 22274
		Replaced public String x by PSL.x equivalents

	11/01/05 - Frans S.C. Witte - CRs: 15592 / 15593
		Removed subroutines that were commented out by previous CRs.
		Eliminated reference to CUVAR.CO in rndCRCD.
		Removed #IF CUVAR.%CRCD, so genereated code will always check
		CUVAR.%CRCD at compile time, independent of the state of
		CUVAR.%CRCD when UCNUMBER itself was compiled.
		Replaced this. by PSL., and removed #XECUTE do init^UCMETHOD.

	12/21/04 - Frans S.C. Witte - CRs: 13403 / 13404
		Inserted QUIT before rndDec to prevent depecation warning.
		Commented out subroutines unpack and unpack2.

	10/25/04 - Frans S.C. Witte - CRs: 11445 / 11446
		Moved subroutines unpack and unpack2 to UCSTRING, because they
		implement methods of class String.
		Added accessibility of subsroutines.
		Fixed code generated by subroutine roundSub() (second param is
		String roundoption, third param is decimals).

        05/20/04 - RussellDS - CR9676
		Move Profile04 version to Profile01 to support single code
		base for PSL.		   

	05/20/04 - RussellDS - CR9172
		   Fix scope errors in section zero.

 	12/08/03 - spier 7403
 		psl compiler warning message clean up.
 		
        09/16/03 - Spier CR 6031,6032,6034  - arq 51423
             Retrofit of changes made in v7.0 up to this date into Profile01
             as well as release for v7.0


	 03/26/03 - Spier cr 3104
		     Retrofited to Profile01
	*/
	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	// ---------------------------------------------------------------------
private rndDec   // Number.roundDec(Number decimal,String opt,Number just)
	// Returns rounded value

	if PSL.actual(1).isNull(1) set PSL.actual(1) = 2
	if PSL.actual(3).isNull(1) set PSL.actual(3) = 0

	if PSL.actual(2).isNull(1) set PSL.return = "$J("_ PSL.objectName_ ","_ PSL.actual(3)_ ","_ PSL.actual(1)_ ")"
	else  do roundSub( PSL.actual(1), PSL.actual(2), PSL.actual(3))

	quit

	// ---------------------------------------------------------------------
private rndCRCD	// Number.roundCRCD(String CRCD,String opt,Number just)
	/* ---------------------------------------------------------------------
	Generate code for rounded currency value

	INPUTS:
	. PSL.actual(1) = currency code
		If absent or "", the system currency (CUVAR.%CRCD) will be used.
		If the value is literal, and the routine CRCDUTL does exist,
		a compiletime call to $$curdec^CRCDUTL() is made to obtain the
		number of decimals at compile time.
		If the routine does not yet exist, the call to
		$$curdec^CRCDUTL() will be deferred to runtime. Note that this
		will only occur during initial environment creation.
	. PSL.actual(2)
		rounding option.
	. PSL.actual(3)
		character length of result.

	NOTES:
	. The version of UCNUMBER that is called during phase 1 and phase 2 of
		an upgrade will use the number of decimals of the system
		currency at the ORIGINATING site in case of an absent or empty
		currency argument.
	*/
	type public Number commands(,)

	type Number dec

	if PSL.actual(1).isNull(1) do {
		set PSL.actual(1) = CUVAR.%CRCD.addQuotes()
		if PSL.actual(1).isNull(1) set dec = 2
	}

	if 'PSL.actual(1).isNull(1) do {
		if PSL.actual(1).isLiteral(),$$VALID^%ZRTNS("CRCDUTL") set dec = +$$curdec^CRCDUTL( PSL.actual(1).stripQuotes())
		else  set dec = "+$$curdec^CRCDUTL("_ PSL.actual(1)_ ")"
	}

	if PSL.actual(3).isNull(1) set PSL.actual(3) = 0
	if PSL.actual(2).isNull(1) set PSL.return = "$J("_ PSL.objectName_ ","_ PSL.actual(3)_ ","_ dec_ ")"
	else  do roundSub( dec, PSL.actual(2), PSL.actual(3))

	quit

	// ---------------------------------------------------------------------
private toString	// Method: Number.toString(Number decimal,String mask)

	/* Convert a number into a formatted string

	Uses mask syntax from $$NUM^%ZM as 2nd parameter
			Byte#1 = Decimal character
			Byte#2 = Thousand separator character
			Byte#3 = Negative value format (Supported by $FN)
			Byte#4 = Prefix character
	*/

	if PSL.objectName.isNull(1),PSL.actual(1).isNull(1) quit """"""

	if PSL.actual(1).isNull() set PSL.actual(1) = PSL.actual(1).addQuotes()
	if PSL.actual(2).isNull() set PSL.actual(2) = PSL.actual(2).addQuotes()

	if PSL.actual(2).isNull(1)!(PSL.actual(2)=""".""") set PSL.return = "$J("_ PSL.objectName_ ",0,"_ PSL.actual(1)_ ")" quit

	if PSL.actual(2).isLiteral() do { quit

		type String msk = PSL.actual(2).stripQuotes()
 		type String vm = msk.extract(1)					//	Replace Decimal
		type String vf = msk.extract(3)			 		//	Negative Number
		if 9'[msk.extract(2) set vf = vf_",", vm = vm_msk.extract(2) 	//	Replace thousand sep

		if 'vf.isNull() do {
			set PSL.return = "$FN("_ PSL.objectName_ ","""_ vf_ """,+"_ PSL.actual(1)_ ")"
			if vm.extract(1,2)'=".," set PSL.return = "$TR("_ PSL.return_ ","".,"","""_ vm_ """)"
		}

		else  do {
			set PSL.return = "$J("_ PSL.objectName_ ",0,+"_ PSL.actual(1)_ ")"
			if vm'="." set PSL.return = "$TR("_ PSL.return_ ",""."","""_ vm_ """)"
		}

		if msk.length()=4 set PSL.return = """"_ msk.extract(4)_ """_"_ PSL.return

	}

	set PSL.return = "$$NUM^%ZM("_ PSL.objectName_ ","_ PSL.actual(1)_ ","_ PSL.actual(2)_ ")"

	quit

	// ---------------------------------------------------------------------
roundSub(Number dec,String option,Number jus)	//  Round a number up/down to decimal precision
	/* This is a local subroutine.
	*/
	type String label = "vNumRnd"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(Number p1,String p2,Number p3)","Number.round")
	
		do buf.add("type Number y=p1.find(""."")+p3-1")
		do buf.add("if y<p3!(y=p1.length()) quit p1.justify(p3)")
		do buf.add("if p1.extract(y+1)=0 quit p1.extract(1,y).justify(p3)")
		do buf.add("if p2=""+"" set p1=p1+("".0000000000000"".extract(1,p3)_1)")
		do buf.add("quit p1.extract(1,y).justify(p3)")

		do buf.insert(label)
	}
	
	set PSL.return="$$"_label_"("_PSL.objectName_","_dec_","_option_")"
	quit

	// ---------------------------------------------------------------------
private zero	// Method Number.zero - returns zero fill
	
	if PSL.actual(1).isNull(1) do PSL.error("Length required")
	if PSL.actual(2).isNull(1) set PSL.actual(2)=0
	if PSL.actual(3)>1!(PSL.actual(3)<0) do PSL.error($$^MSG(7609))
	if PSL.actual(3).isNull(1) set PSL.actual(3)=0
	if PSL.actual(4)>2!(PSL.actual(4)<0) do PSL.error($$^MSG(7609))
	if PSL.actual(4).isNull(1) set PSL.actual(4)=0

	type String label = "vstrZero"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(Number object,Number p1,Number p2,Number p3,Number p4)","String.zero")

		do buf.add("type String SIGN,X")
		do buf.add("set X=""""")
		do buf.add("set object=object.roundDec(p2)")
		do buf.add("if p3=1 S object=object*$S(p2'=0:(10**p2),1:1)")
		do buf.add("if p4'=0 do {")
		do buf.add(" set p1=p1-1")
		do buf.add(" if object<0 set object=object*-1,SIGN=""-""")
		do buf.add(" else  set SIGN=""+""")
		do buf.add(" }")
	//	do buf.add("I object.length()>p1 set $ZS=""0,""_$ZPOS_"",""_$$^MSG(3037,object,p1) X $ZT")
		do buf.add("set X.piece(0,p1-object.length())=0 set object=X_object")
		do buf.add("if p4=0 quit object")
		do buf.add("if p4=1 quit SIGN_object")
		do buf.add("quit object_SIGN")

		do buf.insert(label)
	}

	set PSL.return="$$"_label_"("_ PSL.objectName_","_PSL.actual(1)_","_PSL.actual(2)_","_PSL.actual(3)_","_PSL.actual(4)_")"

	quit
	
