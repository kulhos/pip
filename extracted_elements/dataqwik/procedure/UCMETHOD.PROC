//DO NOT MODIFY  Library of PSL methods|UCMETHOD|||||||1
	  /*
	ORIG: FSANCHEZ - 02/19/2003
	DESC: Library of PSL methods

	---------- Revision History --------------------------------------------
	04/05/07 - Frans S.C. Witte - CR: 26334
		Corrected fitsLinLen to add parenthesis to actual(1) if needed

	03/01/07 - RussellDS - CR26386
		* Changes to support archiving
		   - Added PSLTable.getArchive* methods.
		   - Added PSLTable.getQuery and .isParent methods.
	
	01/18/07 - Frans S.S. Witte - CRs:  25185 / 25186 / 25187
		* Subroutine INSERT: added support for ResultClass
		* Subroutune insBuf removed (method Buffer.insert now
		  implemented using insMet()
		* renamed stdMet() to statMet()

	10/17/06 - Frans S.C. Witte - CRs: 22719 / 20613
		* Added additional parameters in code generated for
		  PSLTable.getSaveCode() and PSLTable.getUpdateKey()
		* Added second parameter to all calls to $$tokenPush^UCPATCH().
		* Added $$stdCall() and stdMet

	07/11/06 - Frans S.C. Witte - CRs: 22720 / 22274
		* Added commands("Options","ResultClass") in call to
		  $$fromSubrou^UCPSLLR()
		* Added documentation to decribe use of $$tokenPush^UCPATCH()
		  and $$tokenPush^UCPATCH() with PSL.mExpr().

	06/15/06 - Frans S.C. Witte - CRs: 22060 / 22061
		* Corrected code generated for PSLSubrou.insCode() and
		  PSLSubrou.getLine, added in-line code generation for
		  PSLSubrou.addExe(), PSLSubrou.addLvn(), PSLSubrou.addTag(),
		  PSLSubrou.getLvn(), PSLSubrou.getLvnMax(), PSLSubrou.getTag(),
		  PSLSubrou.getTagMax(), PSLSubrou.getTagPrefix(),
		  PSLSubrou.setTagPrefix().
		* Added code generation for PSLExpression.fitsLineLength()
		* Modified code generated for PSLTable.getFilerLogic()

	06/14/06 - Frans S.C. Witte - CRs: 21791 / 21792
		* Added code generation for PSLTable.getFilerLogic(), and
		  PSLTable.getSaveCode().

	05/31/06 - Frans S.C. Witte - CRs: 21394 / 21395
		* Added tblHasNeg to implement PSLTbale.hasNegativeNode

	03/14/06 - Frans S.C. Witte - CRs: 20280 / 18164
		* INSERT modified the #WARN adn #OPTIMIZE settings, but did not
		  restore the previous values. This has been corrected. The
		  subroutine now uses PSLLabelRecord.
		* openBuff now stores both parameters in negative vobj() nodes.

	11/17/05 - Frans S.C. Witte - CRs: 18163/18164
		* Modified to support pslSt, and dbAcc
		* Added code generation for PSL.cachePSLColumn(),
		  PSL.cachePSLTable(), PSLColumn.getClass(),
		  PSLColumn.getPurposeNode(), and PSLTable.isOneNode().
		* Rewrote INSERT (code now added to PSL source).

	08/31/05 - Frans S.C. Witte - CRs: 15592, 17056 / 15593, 17057
		* Added subroutine getPslValue to implement properties of class
		  PSL that contain system-wide, site-dependent values.
		* Added code generation for PSLTable methods: tAssert,
		  getLodCode, getNewCode, getUpdKet, tblHasBlob, tblHasMemo,
		  tblIsRdb, tblHasMasF.
		* Use of #XECUTE init^UCMATHOD now deprecated
		* Modified code generated for getCurrentNode() and getOldNode()

	05/24/05 - Frans S.C. Witte - CRs: 15028 / 16039
		* Subroutine INSERT now also NEWs struct().
		* Added subroutines getCurExpr, getOldExpr, and getUpdCode, that
		  generate code for methods of the PSLColumn class.

	03/29/05 - Frans S.C. Witte - CRs: 14919 / 14920
		* Subroutine addSubr: Added 4th parameter to indicate call to
		  $$newLabel^UCGM() as part of generating subroutine label.
		* Added subroutine isArr (implementation of PSLExprssion.isArray)
		* Added subroutine isVar (implementation of
		  PSLExprssion.isVariable)
		* Removed code that was commented out by previous CR.
		* Grouped subroutines and functions based on class.
		* Subroutine openBuff: parenthesis to formallist will be added
		  if absent.
		* Added subroutines getCurLvn, getCurNode, getOldLvn, getOldNode,
		  and getPslCln, that generate code for methods of the PSL class
		  and the PSLColumn class. These methods will not be called until
		  CR15028 is deployed.

	11/02/04 - Frans S.C. Witte - CRs: 11445 / 11446
		Removed references / assignments to primtyp(), which is now handled
		exclusively by UCPRIM module.
		Class "Subrou" renamed to "PSLSubrou".
		Subroutine init: removed "hidden" definitions of PSLBuffer and
		PSLSubrou because these classes, and their methods are now stored
		in the OBJECT related tables.
		Added subroutine addCode to implement PSLSubrou.addCode().
		Declared PUBLIC/PRIVATE accessability of subroutines.
		Removed label newBuff (it is not used).
		#optimize and #warn follow defaults, but turn function warning on.
		replaced M intrinsic function references by method calls.
		Fixed code generated for PSLSubrou.addCode.
		Replaced .data() with .exists() and .order().
		Subroutine mExpr: removed "fif" argument from code generated for
		mExpr.
		Subroutine INSERT(): Added save/restore WARN and OPTIMIZE and
		force miminal settings for generated code.
	

        05/12/04 - RussellDS - CR9676
		Move Profile04 version to Profile01 to support single code
		base for PSL.

	09/24/03 - Frank Sanchez
		Changed PSLBUffer.insert method parameter from Literal to String

        09/16/03 - Spier CR 6031,6032,6034  - arq 51423
        	Retrofit of changes made in v7.0 up to this date into Profile01
        	as well as release for v7.0
	*/
	// I18N=QUIT
	// *******************************************************************
	// * IMPORTANT NOTE:                                                 *
	// * According to the rules that apply to PSL compiler upgrades,     *
	// * the generated M routine associated with this procedure must be  *
	// * checked into StarTeam and released with the procedure whenever  *
	// * changes are made to this procedure.                             *
	// *                                                                 *
	// * The M routine will be loaded to the mrtns directory during      *
	// * upgrades and will then be removed from that directory as part   *
	// * of the upgrade process.  Therefore, other than during an        *
	// * upgrade an mrtns version of this routine should not exist.      *
	// *                                                                 *
	// * Keep these comments as single line to ensure they exist in the  *
	// * generated M code.                                               *
	// *******************************************************************
	quit

	// ---------------------------------------------------------------------
cmdsRest( String cmdsRest(,))	// array to restore commands() from
	/* Restores switch(es) in commands().
	   This is the "inverse" of cmdsSave().
	*/
	type public Boolean commands(,)
	
	#ACCEPT DATE=11/02/04;CR=11445;PGM=FSCW
	#BYPASS
	KILL commands("WARN"),commands("OPTIMIZE")
	MERGE commands("WARN")=cmdsRest("WARN")
	MERGE commands("OPTIMIZE")=cmdsRest("OPTIMIZE")
	#ENDBYPASS

	quit

	// ---------------------------------------------------------------------
cmdsSave( String cmdsSave(,))	// array in which commands() is to be saved
	/* This procedure saves commands("WARN") and commands("OPTIMIZE") and
	   forces:
	   #WARN OFF
	   #OPTIMIZE FUNCTIONS OFF
	*/
	type public Boolean commands(,)
	
	#ACCEPT DATE=11/02/04;CR=11445;PGM=FSCW
	#BYPASS
	MERGE cmdsSave("WARN")=commands("WARN")
	MERGE cmdsSave("OPTIMIZE")=commands("OPTIMIZE")
	KILL commands("WARN"),commands("OPTIMIZE")
	#ENDBYPASS
	
	/* save current setting of commands("OPTIMIZE","OBJECTS") */
	set commands("OPTIMIZE","OBJECTS")=cmdsSave("OPTIMIZE","OBJECTS").get()

	/* force commands("OPTIMIZE","FUNCTIONS")=0 */
	set commands("OPTIMIZE","FUNCTIONS")=0

	quit

	/* ******** COMMENTED OUT (NO LONGER CALLED)
	// ---------------------------------------------------------------------
private init	// Initialize the method and property array(s) DEPRECATED

	do WARNDEP^UCGM("'this.': Use PSL.method or PSL.property")

	// Instantiate the 'this' object
	;;do setScop^UCGM("this",-1,0,"NEW")
	;;do setType^UCGM("this","PSL",-1)
	do setScope^UCGM("this",-1,0,"NEW","PSL")
	do setInst^UCGM("this",-1,"")
	do setOpti^UCGM("this",-1,-1)

	// Instantiate the parameter array - actual
	;;do setScop^UCGM("actual()",-1,0,"PUBLIC")
	;;do setType^UCGM("actual()","String",-1)
	do setScope^UCGM("actual()",-1,0,"PUBLIC","String")

	quit
	******** */

	// ---------------------------------------------------------------------
private INSERT( Number object,	// object id		/REQ/MECH=VAL
	String subRou,		// name of subroutine	/REQ/MECH=VAL
	String resCls)		// ResultClass (*3)
	/* ---------------------------------------------------------------------
	Runtime subroutine, called to convert PSL to M and insert buffer.

	The current version of the code (in #IF 1 block) just appends the PSL
	code to the existing m2src() array. In order to prevent duplicate
	insertions, endless loops, etc. it keeps track of the subroutines that
	it inserted:
	- set labels(subRou) = data

	ARGUMENTS:
	(*3) resCls = ResultClass
		if absent or empty, then #OPTION ResultClass will be forced
		false. Else #OPTION ResultClass will be forced true, and the
		supplied value will be prepended.
	
	NOTES:
	. The code in subRou^UCGM, and other code that uses labels() must be
		kept in sync. However, this should be relatively simple when all
		code uses PSLLableRecord to manipulate the array.	
	. This used to be very tricky code. It simulated PART of main, including
		the calls to line(), ^UCTPACH, and dbLoad^UCRECORD(), and it
		tried to recreate a clean environment. It implied that the code
		had always to be synchronized with main^UCGM() to ensure that all
		pre-conditions for line(), UCPATCH, and dbLoad^UCRECORD were met.
		It seemed that the only reason for this behavior was the ability
		to put the compiled M code into the append(,) array, that may be
		subject to manipulation by the caller's version of UCPATCH.
	. The inserted code may contain a lot of identical #OPTION ResultClass
		settings. It is tempting to "optimize" this, and only insert a
		line if the INSERT requires a different setting. However, this
		is NOT possible, because the setting may change during the
		compilation, so there is no guarantee that the setting that was
		in effect when the code was inserted will still apply when the
		code is compiled.
	. Saving the settings of #INFO, #OPTOIN, #OPTIMIZE, and #WARNING, and
		restoring them after inserting the PSL source, is an overkill.
		As long as all inserted PSL code follows the original PSL code,
		it is sufficient to "force" the settings that need to be in
		effect for the inserted code. The only exception is the setting
		of #OPTIMIZE OBJECTS, but this setting is not changed here.
	*/

	#IF 1
	/* NEW CODE */
	type public PSLLabelRecord labels()
	//type public Primitive commands(,)
	
	type String  decl
	type List    savCmds()
	//type Boolean savResCl = commands( "Options", "ResultClass").get( false)
	type Boolean mtdResCl = '(resCls.get().isNull())

	if subRou.isNull() do PSL.error("Subroutine name required") quit

	/* Setting labels(subRou) = "" will serve as an indication that a
	   subroutine with this label has been appended to the PSL source code.
	   By quiting if subRou already exists, the implementation of the method
	   will silently ignore unintended duplications.
	   (The "OLD" implementation silently rewrote each previous definition)
	   */
	if labels(subRou).exists() quit			// insert only once
	if mtdResCl set decl = resCls_ " "_ subRou_ vobj( object, 1)
	else  set decl = subRou_ vobj( object, 1)
	set labels(subRou) = {PSLLabelRecord}$$fromSubrou^UCPSLLR( decl, 0, mtdResCl)
	//set labels(subRou).comment = vobj( object, -2)

	/* Save current settings of commands("WARN",*) and
	   commands("OPTIMIZE",*) */
	//type String l1,l2
	//for l1="WARN","OPTIMIZE" do {
	//	set savCmds(l1) = ""
	//	set l2 = ""
	//	for  set l2 = commands(l1,l2).order() quit:l2=""  if commands(l1,l2) set savCmds(l1) = savCmds(l1).add(l2)
	//}

	do addM2src^UCGM( " // ----------------")
	do addM2src^UCGM(" #OPTION ResultClass "_ mtdResCl)
	do addM2src^UCGM( decl)	// Insert declaration
	do addM2src^UCGM( " //")
	do addM2src^UCGM( " #WARN "_ $$allWARN^UCGMC()_ " OFF")
	do addM2src^UCGM( " #OPTIMIZE FUNCTIONS OFF")

	type Number ln = 1

	for  set ln = vobj(object,ln).order() quit:ln.isNull()  do addM2src^UCGM( vobj(object,ln))

	//do addM2src^UCGM(" #OPTION ResultClass "_ savResCl)
	//for l1="WARN","OPTIMIZE" if 'savCmds(l1).isNull() do addM2src^UCGM( " #"_l1_ " "_ savCmds(l1)_ " ON")

	#ELSE
	/* OLD CODE */
	type Public String append(,)
	type Public String commands(,)
	type Public String labels()
	type Public String type(,)
	type Public String vobj(,)
	
	type String saveCmds()

	if subRou.isNull() do PSL.error("Subroutine name required") quit
	
	if append(subRou).exists() kill append(subRou),labels(subRou)

	// variables that hide variables from main^UCGM() (UGH!)
	type Number level,ifLevel=0,line=0
	type String dbLoad(),dbAcc(),msrc(),m2src(),level(),patch(),struct()
	type String doStack="",ifStack="",forStack=""
	type String pslSt=""
	type List   pslNew()
	type String del,lptr,mcode,var,return,class,cmd,cmdNum,cmdDel

	type String v="",ztype()
	for  set v=type(-1,v).order() quit:v.isNull()  set ztype(v)=type(-1,v)

	#ACCEPT CR=18163;DATE=2005-11-07;PGM=FSCW
	type String type	// not a very clean way to achieve this ...
	for  set v=ztype(v).order() quit:v.isNull()  set type(-1,v)=ztype(v)

	set level=0,level(level)=0,msrc=0
	set lptr=""

	set m2src(1)=" //"
	set m2src(2)=subRou_vobj(object,1)	// Insert label
	set m2src(3)=" //"

	// save commands("WARN") and commands("OPTIMIZE") and force values
	// for generated code
	do cmdsSave(.saveCmds())
	
	do {
		catch pslException {
			do PSL.error( "%PSL-E-COMPILE: error during processing of PSLBuffer.insert()")
		}
		set subRou="",lptr=1

		// First copy the append buffer into m2src & delete append buffer
		for line=4:1 set lptr=vobj(object,lptr).order() quit:lptr.isNull()  set m2src(line)=vobj(object,lptr)

		// Then process m2src into M in the compiler
		for line=1:1 set lptr=m2src(lptr).order() quit:lptr.isNull()  do line^UCGM(m2src(lptr))

		// See UCGM for correct order !!
		if patch("").order()'="" do ^UCPATCH
		if dbAcc("").order()'="" do optNload^UCREC4OP( .msrc(), +commands("OPTIMIZE","OBJECTS").get(),0)
		if dbLoad("").order()'="" do PSL.warn("%PSL-W-INTERNAL: dbLoad exists for PSLBuffer.insert()")

		set subRou=m2src(2).piece(" ",1).piece("(",1)		// Retrieve subRou
		if 'pslNew(subRou).isNull() set msrc(2.00001)=" N "_pslNew(subRou)

		// Finally move the M code back into append
		for line=1:1 set lptr=msrc(lptr).order() quit:lptr.isNull()  set append(subRou,line)=msrc(lptr)
	}

	// Finally, restore Switch(es)
	do cmdsRest(.saveCmds())
	#END

	quit

	// ---------------------------------------------------------------------
private insMet( local String prefix, local Number missing)
	/* ---------------------------------------------------------------------
	Support procedure for methods that simply translate into a call to a
	function or subroutine with objectName and all supplied actuals
	("instance" method).

	ARGUMENTS:
	. prefix = call prefix.
		Will be used as supplied, and objectName will be concatenated
		without any delimiter
	. missing = treatment of missing / empty actuals
		-1: exception when no actual supplied
		0: ignore
		1: force ""
	*/
	set PSL.return = prefix_ PSL.objectName_ ","
	type Number ap

	for ap = 1:1:PSL.actual("").order(-1) do {
		if missing = -1, PSL.actual(ap).isNull() throw class.new("Error","%PSL-E-MISSING, missing required argument (#"_ap_")")
		if missing = 1, PSL.actual(ap).isNull() set PSL.actual(ap) = """"""
		if ap>1 set PSL.return = PSL.return_ ","
		set PSL.return = PSL.return_ PSL.actual(ap)
	}
	set PSL.return =  PSL.return_ ")"
	quit

	// ---------------------------------------------------------------------
private statMet( local String prefix, local Number missing)
	/* ---------------------------------------------------------------------
	Support procedure for methods that simply translate into a call to a
	function or subroutine with all supplied actuals ("static" method)

	ARGUMENTS:
	. prefix = call prefix.
		Will be used as supplied, and PSL.actual(1) will be concatenated
		without any delimiter
	. missing = treatment of missing / empty actuals
		-1: exception when no actual supplied
		0: ignore
		1: force ""
	*/
	set PSL.return = prefix
	type Number ap

	for ap = 1:1:PSL.actual("").order(-1) do {
		if missing = -1, PSL.actual(ap).isNull() throw class.new("Error","%PSL-E-MISSING, missing required argument (#"_ap_")")
		if missing = 1, PSL.actual(ap).isNull() set PSL.actual(ap) = """"""
		if ap>1 set PSL.return = PSL.return_ ","
		set PSL.return = PSL.return_ PSL.actual(ap)
	}
	set PSL.return =  PSL.return_ ")"
	quit

	// ---------------------------------------------------------------------
stdCall(String prefix, String aplist())
	/* ---------------------------------------------------------------------
	Support function that appends the supplied aplist to prefix

	ARGUMENTS:
	. prefix = call prefix.
		Will be used as supplied, and aplist(1) will be concatenated
		without any delimiter
	. aplist() = actual parameters
		the function will simply add the supplied arguments as-is,
		separated by commas.
	*/
	type String ret = prefix_ aplist(1)
	type Number ap

	for ap = 1:1:ap("").order(-1) set ret = ret_ ","_ aplist(ap)
	quit ret_")"

	/* =====================================================================
	Implementation of methods and properties of class PSL
	*/
	// ---------------------------------------------------------------------
private addSubr	// Method: PSL.addSubrou - Add a subroutine

	type literal String label="vaddSubr"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(String p1,String p2,String p3,Boolean p4)","PSL.addSubrou")

		do buf.add("type Public PSLLabelRecord labels()")
		do buf.add("if p4.get() set p1=$$newLabel^UCGM(p1,.labels)")
		do buf.add("else  if labels(p1).exists() do PSL.error(""Subroutine exists: ""_p1) quit p1")
		do buf.add("do addSubr^UCGM(p1,p2,p3)")
		do buf.add("quit p1")

		do buf.insert(label)
	}

	// ensure that a call with 4 parameters is generated
	if PSL.actual(2).isNull()  set PSL.actual(2) = """"""
	if PSL.actual(3).isNull()  set PSL.actual(3) = """"""
	if PSL.actual(4).isNull(1) set PSL.actual(4) = 0

	set PSL.return="$$"_label_"("_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_","_ PSL.actual(4)_")"
	quit

	// ---------------------------------------------------------------------
private arrayProp	// Method PSL.actual - "array property" actual()
	/* Because PSL will interpret PSL.actual(val) as a method call, this method
	is used to transform the method call to a property reference.
	Because this subroutine uses PSL.method as the "name" value, it can be
	used as the implementing method for all array properties of the PSL class.
	*/

	set PSL.return = PSL.method _ "(" _ PSL.actual(1) _")"
	quit

	// ---------------------------------------------------------------------
private caPslCln	// void
	/* ---------------------------------------------------------------------
	method PSL.cachePSLColumn(PSLColumn(),String,PSLTable())

	INPUTS:
	. PSL.actual(1) = name of PSLColumn() cache array
	. PSL.actual(2) = qualified column name (table.column, dynamic value allowed)
	. PSL.actual(3) = name of PSLTable() cache array (optional)

	OUTPUTS:
	. return = code to retrieve value at runtime ($$caPslCln^UCXDD)
	*/
	if PSL.actual(3).isNull() set PSL.return = "$$caPslCln^UCXDD("_ PSL.actual(1)_","_ PSL.actual(2)_")"
	else  set PSL.return = "$$caPslCln^UCXDD("_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_")"
	quit

	// ---------------------------------------------------------------------
private caPslTbl	// void
	/* ---------------------------------------------------------------------
	method PSL.cachePSLTable(PSLTable(),String,Number)

	INPUTS:
	. PSL.actual(1) = name of PSLTable() cache array
	. PSL.actual(2) = table name (dynamic value allowed)
	. PSL.actual(3) = information level (defaults to zero)

	OUTPUTS:
	. return = code to retrieve value at runtime ($$caPslTbl^UCXDD)
	*/
	if PSL.actual(3).isNull() set PSL.actual(3) = 0
	set PSL.return = "$$caPslTbl^UCXDD("_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_")"
	quit

	// ---------------------------------------------------------------------
private error	// Method: PSL.error - Report a compile-time error

	set PSL.return = "ERROR^UCGM("_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
private getDbLoad	// PSL.getDbLoad - Return dbLoad record map

	set PSL.return = "$G(dbLoad("_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_"))"
	quit

	// ---------------------------------------------------------------------
private getLabel	// PSL.getLabelRecord - Return label record

	set PSL.return = "$G(labels("_ PSL.actual(1)_"))"
	quit

	// ---------------------------------------------------------------------
private getPslCln	// void
	/* ---------------------------------------------------------------------
	method PSL.getPSLColumn(String,String,PSLTable())

	INPUTS:
	. PSL.actual(1) = name of table (dynamic value allowed)
	. PSL.actual(2) = name of column (dynamic value allowed)
	. PSL.actual(3) = name of PSLTable() cache array ("optional")

	OUTPUTS:
	. return = code to retrieve value at runtime (getPslCln^UCXDD)
	*/
	if PSL.actual(3).isNull() set PSL.return = "$$getPslCln^UCXDD("_ PSL.actual(1)_","_ PSL.actual(2)_")"
	else  do {
		if PSL.actual(3).extract() '= "." set PSL.actual(3) = "."_ PSL.actual(3)
		set PSL.return = "$$getPslCln^UCXDD("_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_")"
	}
	quit

	// ---------------------------------------------------------------------
private getPslTbl	// void
	/* ---------------------------------------------------------------------
	method PSL.getPSLTable(String,Number)

	INPUTS:
	. PSL.actual(1) = name of table (dynamic value allowed)
	. PSL.actual(2) = information level (dynamic value allowed)
		If "absent", the maximum will be used

	OUTPUTS:
	. return = code to retrieve value at runtime (getPslTbl^UCXDD1)
	NOTES:
	. The default / maximum value for PSL.actual(2) shall be synchronized with
		tAssert^UCMETHOD and tAssert^UCXDD
	*/
	if PSL.actual(2).isNull() set PSL.actual(2) = 1
	set PSL.return = "$$getPslTbl^UCXDD("_ PSL.actual(1)_ ","_ PSL.actual(2)_ ")"
	quit

	// ---------------------------------------------------------------------
private getPslValue( Primitive default)	// default value (*1)
	/* ---------------------------------------------------------------------
	This subroutine generates the code for PSL properties such as
	PSL.maxStringLength and PSL.maxLineLength.

	ARGUMENTS:
	(*1) default = default value
		The definition of OBJECTPROP.ROUTINE will include the literal
		value that shall be used as default value for the property.
		The default value will be used if:
		- code is generated in compiler completion mode
			(i.e. $GET(PSL.commands("boot","restrictionlevel"))>1)
		- the call to $$getPslValue^UCOPTS() returns ""

	INPUTS:
	. public Boolean commands(,)
		the value commands("boot","restrictionlevel") is used to bypass the call
		to $$getPslValue^UCOPTS()
	. public String ref
		The name of the property is passed to $$getPslValue^UCOPTS()

	OUTPUTS:
	. PSL.return = value of constant

	NOTES:
	. The default value of the property is coded into the value of
		OBJECTPROP.ROUTINE. For example, a default value of 450 for
		PSL.maxDataLength would be coded as:
			OBJECTPROP.ROUTINE = 'getPslValue^UCMETHOD(450)'
	*/
	type public Boolean commands(,)
	type public String ref

	if commands("boot","restrictionlevel").get()>1 set PSL.return = default
	else  set PSL.return = $$getPslValue^UCOPTS( ref) if PSL.return.isNull() set PSL.return = default
	quit

	// ---------------------------------------------------------------------
private getProp	// Property procedure of class PSL

	/* Property implementation method for properties of class PSL.
	Initially all property names will be the same as the UCGM

	actual(1-n) = Actual parameters passed
	attrib(1-2) = Attributes of parameters vptr<tab>class<tab>byref
	var         = Variable return assigned to unless void
	varLevel    = Stack level where var was scoped
	objectName  = Name of the object identifier
	objectLevel = Stack level where identifier was scoped
	objectScope = Scope of identifier (FORMAL,NEW,PUBLIC,LITERAL)	
	class       = Expect return class of this method
	fset        = Flag var within assignment scope 
	oLvn        = Object storage array name
	mcode       = Current M generated code for this line
	msrc        = The last line in the code output buffer
	reClass     = Record<class> Prefix 
	*/

	if $$getNew^UCGM(PSL.ref) do PSL.error("Object scope is not visible: PSL."_ PSL.ref) quit

	set PSL.return=PSL.ref

	if PSL.ref="objectName"!(PSL.ref="var") set PSL.class="PSLIdentifier"
	else  if PSL.ref="return" set PSL.class="PSLExpression"
	else  set PSL.class="String"

	quit

	// ---------------------------------------------------------------------
private insLine		// PSL.insertLine(PSLcode,line,level)
	// Convert a line of PSL code to M code and insert into program
	// after first comment free line after parameter line.

	type String p2 = PSL.actual(2)
	if p2 = "line",'p2.beginsWith(".") set p2="."_p2

	set PSL.return = "newLine^UCGM("_ PSL.actual(1)_","_p2_","_ PSL.actual(3)_")"
	quit

	// ---------------------------------------------------------------------
private isRecord	// PSL.isRecord(String class)

	set PSL.return="$$isRecord^UCGM("_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
private isSubr	// Method: PSL.subrExists - Return whether a subroutine exists

	set PSL.return="$D(labels("_ PSL.actual(1)_"))"
	quit

	// ---------------------------------------------------------------------
private mExpr	// PSL.mExpr(expr)
	/* ---------------------------------------------------------------------
	Return an M expression from a PSL expression.

	This is a very powerful method that allows the compiler writer to
	express the code generated for a method as a PSL expression. Programmers
	that use this method shall be aware of the following:
	When the code generator for the method
		MyClass.myMethod(local Primitive Arg1, local Primitive Arg2)
	will be invoked, the Myclass instance will be available in objecName,
	and the arguments will be available in actual(1) and actual(2). Due to
	the nature of the compiler, all these entities will no longer contain
	PSL code, but will instead contain the "pass 1 code" that the compiler
	generated for each of these entities. To prevent these entities from
	being interpreted during the evaluation of the PSL expression, the
	entities that are inserted in the argument to PSL.mExpr() must be
	wrapped before they are inserted into the code. And they must be
	unwrapped from the value returned by PSL.mExpr() before being returned
	in PSL.return.

	A typical implementation of a code generator that uses PSL.mExpr will
	then read:
	myMethod // method with 2 actuals

		type String mExpr = "psl code"_  $$tokenPush^UCPATCH( PSL.objectName, "objectClass")
		set mExpr = mExpr_ "more psl code"_ $$tokenPush^UCPATCH( PSL.actual(1), "agr1Class")
		set mExpr = mExpr_ "and more psl code"_ $$tokenPush^UCPATCH( PSL.actual(2), "arg2Class")
	
		set mExpr = PSL.mExpr( mExpr )

		set PSL.return = $$tokenPop^UCPATCH( mExpr, 3)

		quit
	*/
	
	type literal String label="vMExpr"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(String v1)","PSL.mExpr")

		do buf.add("type public Primitive commands(,)")
		do buf.add("type String vExp,mcode,tok")	// 'tok' and 'mcode' used as public var by $$valExpr !!!!
		do buf.add("type Boolean vFun=commands(""OPTIMIZE"",""FUNCTIONS"").get(0)")
		do buf.add("set commands(""OPTIMIZE"",""FUNCTIONS"")=0")
		do buf.add("set mcode="""",v1=$$TOKEN^%ZS(v1,.tok),vExp=$$valExpr^UCGM(v1,,0)")
		do buf.add("set commands(""OPTIMIZE"",""FUNCTIONS"")=vFun")
		do buf.add("quit vExp")

		do buf.insert(label)
	}

	set PSL.return="$$"_label_"("_ PSL.actual(1)_")"

	quit

	// ---------------------------------------------------------------------
private newVar	// PSL.newVariable

	set PSL.return = "$$nxtSym^UCGM"
	quit

	// ---------------------------------------------------------------------
private patch	// PSL.patch(String expression) - Replace expression with 

	set PSL.return="$$patch^UCPATCH(subRou,objectName,objectLevel,"_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
private warn	// Method PSL.warn - Report a compile-time warning

	set PSL.return="WARN^UCGM("_ PSL.actual(1)_")"
	quit


	/* =====================================================================
	Implementation of methods of class PSLBuffer

	PSLBuffer uses the following structure:
	vobj(oid,-2) = comment (cmt)
	vobj(oid,-1) = formal parameter list (fpl)
	vobj(oid,1)  = fpl_ " // "_ cmt
	*/
	// ---------------------------------------------------------------------
private openBuff	// Method: PSL.openBuffer - Open a PSL code buffer
	
	type literal String label="vopenBuf"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(List v1,String v2)","PSL.openBuffer")

		do buf.add("type Public String vobj(,)")
		do buf.add("type Number vOid")
		do buf.add("set vOid=vobj("""").order(-1)+1")
		do buf.add("if v1.extract()'=""("",'v1.isNull() set v1=""(""_v1_"")""")
		do buf.add("set vobj(vOid,-1)=v1")
		do buf.add("set vobj(vOid,-2)=v2")
		do buf.add("set vobj(vOid,1)=v1_"" // ""_v2")
		do buf.add("quit vOid")

		do buf.insert(label)
	}

	set PSL.return="$$"_label_"("_ PSL.actual(1)_","_ PSL.actual(2)_")"

	quit

	// ---------------------------------------------------------------------
private addBuff	// Method: PSLBuffer.add - Add code to an existing buffer

	type literal String label="vaddBuff"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(Number object,String p1)","PSLBuffer.add")

		do buf.add("type Public String vobj(,)")
		do buf.add("type Number line")
		do buf.add("set line=vobj(object,"""").order(-1)+1")
		do buf.add("set vobj(object,line)="" ""_p1")
		do buf.add("quit")

		do buf.insert(label)
	}

	set PSL.return=label_"(" _ PSL.objectName_","_ PSL.actual(1)_")"

	quit

	// ---------------------------------------------------------------------
	/*
private insBuff	// Method: PSLBuffer.insert - Convert PSL to M and insert buffer
	
	set PSL.return="INSERT^UCMETHOD("_ PSL.objectName_","_ PSL.actual(1)_")"
	quit
	*/

	/* =====================================================================
	Implementation of methods and properties of class PSLColumn
	*/
	// ---------------------------------------------------------------------
private getPcClass	// Method: PSLColumn.getClass()

	set PSL.return="$$getClass^UCXDD("_ PSL.objectName_ ")"
	quit

	// ---------------------------------------------------------------------
private getCurExpr	// Method: PSLColumn.getCurrentExpr(PSLIdentifier,Boolean)

	if PSL.actual(2).isNull() set PSL.actual(2) = 0
	set PSL.return="$$getCurExpr^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
	quit

	// ---------------------------------------------------------------------
private getCurLvn	// Method: PSLColumn.getCurrentLvn(PSLIdentifier)

	set PSL.return="$$getCurLvn^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
private getCurNode	// Method: PSLColumn.getCurrentNode(Boolean)

	if PSL.actual(1).isNull(1) set PSL.actual(1) = 0
	set PSL.return="$$getCurNode^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
private getOldExpr	// Method: PSLColumn.getOldExpr(PSLIdentifier,Boolean)

	if PSL.actual(2).isNull() set PSL.actual(2) = 0
	set PSL.return="$$getOldExpr^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
	quit

	// ---------------------------------------------------------------------
private getOldLvn	// Method: PSLColumn.getOldLvn(PSLIdentifier)

	set PSL.return="$$getOldLvn^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
private getOldNode	// Method: PSLColumn.getOldNode(Boolean)

	if PSL.actual(1).isNull(1) set PSL.actual(1) = 0
	set PSL.return="$$getOldNode^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_")"
	quit

	// ---------------------------------------------------------------------
private getPurNode	// Method: PSLColumn.getPurposeNode()

	set PSL.return="$$getPurNode^UCXDD("_ PSL.objectName_ ")"
	quit

	// ---------------------------------------------------------------------
private getUpdCode	// Method: PSLColumn.getUpdateCode(PSLIdent,PSLExpr,Bool)

	if PSL.actual(3).isNull() set PSL.actual(3) = 1
	set PSL.return="$$getUpdCode^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_")"
	quit

	/* =====================================================================
	Implementation of methods of class PSLExpression
	*/
	// ---------------------------------------------------------------------
private fitsLinLen	// Method: PSLExpression.fitsLineLength( Number extra)
	/* ---------------------------------------------------------------------
	This method will cast the PSLExpression as a ByteString, and return 1 if
	and only if the (byte) length of the PSLExpression is not greater than
	the maximum line length minus the value of extra.

	PSLExpression.fitsLineLength( ) is equivalent to
		PSLExpression.fitsLineLength( 0)
	*/
	type PSLExpression xtr
	type Number pop = 1

	if PSL.actual(1).isNull(1) set xtr = ""
	else  if PSL.actual(1) = 0 set xtr = ""
	else  {
		set xtr = $$tokenPush^UCPATCH( PSL.actual(1), "Number"), pop = 2
		if PSL.actual(1).translate("*/\#") = PSL.actual(1) set xtr = "+"_ xtr quit
		set xtr = "+("_ xtr_ ")"
	}

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "(("_ $$tokenPush^UCPATCH( PSL.objectName, "PSLExpression")_ ").toByteString().length() "_ xtr_ "'> PSL.maxLineLength)"), pop)
	quit

	// ---------------------------------------------------------------------
private isArr   // Method: PSLExpression.isArray

	set PSL.return="$$isArr^UCGM("_ PSL.objectName_")"
	quit

	// ---------------------------------------------------------------------
private isLit   // Method: PSLExpression.isLiteral
	/* ---------------------------------------------------------------------
	Overrides String.isLiteral. Unlike its ancestor method, this method will
	not interpret the compiletime value.
	*/

	set PSL.return="$$isLit^UCGM("_ PSL.objectName_")"
	quit

	// ---------------------------------------------------------------------
private isVar   // Method: PSLExpression.isVariable

	set PSL.return="$$isVar^UCGM("_ PSL.objectName_")"
	quit

	// ---------------------------------------------------------------------
private toConsta	// Method PSLExpression.toValue

	set PSL.return="$$toLit^UCGM("_ PSL.objectName_")"
	quit


	/* =====================================================================
	Implementation of methods of class PSLIdentifier
	*/
	// ---------------------------------------------------------------------
private getSym(Number pos)	// PSLIdentifier properties
	/* Return the code to retrieve one of the properties of a PSLIdentifier.
	The mapping of propertyname to position is hard-coded in the value of
	OBJECTPROP.ROUTINE for the property.
	*/

	if PSL.fset do PSL.error("Identifier table properties are read only")

	type String keys=PSL.objectName
	if keys.beginsWith("vo") set keys=$$getExpr^UCGM(keys)

	if keys="objectName" set keys="objectName,objectLevel"
	else  if keys="var" set keys="var,varLevel"
	else  set keys=keys_","

	set PSL.return="$$getAtt^UCGM("_keys_","_pos_")"

	quit

	// ---------------------------------------------------------------------
private getLevel	// PSLIdentifier.scopeLevel property

	type String var=PSL.objectName
	if var.beginsWith("vo") set var=$$getExpr^UCGM(var)

	set PSL.return="$$getLevel^UCGM("_var_")"
	quit

	// ---------------------------------------------------------------------
private opti	// Method: PSLIdentifier.allowOptimize - Allow backfill optimize

	type literal String label="vPSLopti"

	if 'PSL.subrouExists(label) do {

		type PSLBuffer buf=PSL.openBuffer("(PSLIdentifier var)","PSLIdentifier.allowOPtimize")

		do buf.add("type Number varLevel=var.scopeLevel")
		do buf.add("type Number opti=var.noPatch")
		do buf.add("if opti>PSL.msrc set opti=0 do setOpti^UCGM(var,varLevel,0)")
		do buf.add("quit 'opti")

		do buf.insert(label)
	}
 
	set PSL.return="$$"_label_"("_$$getExpr^UCGM(PSL.objectName)_")"
	quit


	/* =====================================================================
	Implementation of methods of class PSLSubroutine
	*/
	// ---------------------------------------------------------------------
private addCode	// Method: PSLSubroutine.addCode - add a line of code
	/* INPUTS:
	. PSL.actual(1) = code to add
	
	RETURNS:
	. PSL.return = addCode^UCPSLSR( PSL.objectName, PSL.actual(1))
	*/

	set PSL.return = "addCode^UCPSLSR("_ PSL.objectName_ ","_ PSL.actual(1)_ ")"
	quit

	// ---------------------------------------------------------------------
private addExe	// Method: PSLSubroutine.addExe - add a line from exe() to code
	/* INPUTS:
	. PSL.actual(1) = code to add
	
	RETURNS:
	. PSL.return = addExe^UCPSLSR( PSL.objectName, PSL.actual(1))
	*/

	set PSL.return = "addExe^UCPSLSR("_ PSL.objectName_ ","_ PSL.actual(1)_ ")"
	quit

	// ---------------------------------------------------------------------
private addLvn	// Method: PSLSubroutine.addLvn - add vsql() replacement

	set PSL.mcode = $$backup^UCGM( PSL.mcode)
	set PSL.return=" S"_ PSL.postCond_" append("_ PSL.objectName_ ",-3,"_ PSL.actual(1)_ ")="_ PSL.actual(2)
	quit

	// ---------------------------------------------------------------------
private addTag	// Method: PSLSubroutine.addTag - add tag to append(,-2)

	set PSL.mcode = $$backup^UCGM( PSL.mcode)
	if PSL.actual(2).isNull() set PSL.actual(2) = """"""
	set PSL.return=" S"_ PSL.postCond_" append("_ PSL.objectName_ ",-2,"_ PSL.actual(1)_")="_ PSL.actual(2)
	quit

	// ---------------------------------------------------------------------
private getCode	// Method: PSLSubroutine.getCode - return the code on a line

	set PSL.return="$G(append("_ PSL.objectName_","_ PSL.actual(1)_"))"
	quit

	// ---------------------------------------------------------------------
private getLine	// Method: PSLSubroutine.getline - return the current line

	set PSL.return="$O(append("_ PSL.objectName_",""""),-1)"
	quit

	// ---------------------------------------------------------------------
private getLvn	// Method: PSLSubroutine.getLvn - return vsql() substitution value

	set PSL.return="$G(append("_ PSL.objectName_",-3,"_ PSL.actual(1)_ "))"
	quit

	// ---------------------------------------------------------------------
private getLvnMax	// Method: PSLSubroutine.getLvnMax - highest number used

	set PSL.return="+$O(append("_ PSL.objectName_",-3,""""),-1)"
	quit

	// ---------------------------------------------------------------------
private getTag	// Method: PSLSubroutine.getTag - return the tag for exe(nr)
	/* INPUTS:
	. PSL.actual(1) = subscript in exe()
	
	RETURNS:
	. PSL.return = getTag^UCPSLSR( PSL.objectName, PSL.actual(1))
	*/

	set PSL.return = "$$getTag^UCPSLSR("_ PSL.objectName_ ","_ PSL.actual(1)_ ")"
	quit

	// ---------------------------------------------------------------------
private getTagMax	// Method: PSLSubroutine.getTagMax - highest TAG number used

	set PSL.return="+$O(append("_ PSL.objectName_",-2,""""),-1)"
	quit

	// ---------------------------------------------------------------------
private getTagPrefix	// Method: PSLSubroutine.getTagPrefix - prefix used by addExe()

	set PSL.return="$G(append("_ PSL.objectName_ ",-2))"
	quit

	// ---------------------------------------------------------------------
private insCode	// Method: PSLSubroutine.insCode - Insert code at line

	set PSL.mcode = $$backup^UCGM( PSL.mcode)
	set PSL.return=" S"_ PSL.postCond_" append("_ PSL.objectName_","_ PSL.actual(1)_")="_ PSL.actual(2)
	quit

	// ---------------------------------------------------------------------
private setTagPrefix	// Method: PSLSubroutine.getTagPrefix - prefix used by addExe()

	set PSL.mcode = $$backup^UCGM( PSL.mcode)
	set PSL.return=" S"_ PSL.postCond_" append("_ PSL.objectName_ ",-2)="_ PSL.actual(1)
	quit

	/* =====================================================================
	Implementation of methods and properties of class PSLTable
	*/
	// ---------------------------------------------------------------------
private tAssert	// Method: PSLTable.assertLevel(Number,PSLColumn())
	/* ---------------------------------------------------------------------
	method PSLtable.assertLevel(Number,PSLColumn())

	INPUTS:
	. PSL.actual(1) = information level (dynamic value allowed)
		If "absent", the maximum will be used
	. PSL.actual(2) = PSL Column cache.
		Allows to cache PSLColumn instances that are retrieved for
		information levels greater than zero.

	OUTPUTS:
	. return = code to retrieve value at runtime (tAssert^UCXDD)
	NOTES:
	. The default / maximum value for actual(1) shall be synchronized with
		getPslTbl^UCMETHOD and tAssert^UCXDD
	*/

	if PSL.actual(1).isNull() set PSL.actual(1) = 1
	if PSL.actual(2).isNull() set PSL.return = "$$tAssert^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_")"
	else  set PSL.return = "$$tAssert^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
	quit

	// ---------------------------------------------------------------------
private getArchivable	//Method: PSLTable.getArchivable()

	set PSL.return = "$$getArchivable^DBARCHIVE("_  PSL.objectName_")"
	quit
	
	// ---------------------------------------------------------------------
private getArchiveIncluded	//Method: PSLTable.getArchiveIncluded()

	set PSL.return = "$$getArchiveIncluded^DBARCHIVE("_  PSL.objectName_")"
	quit
	
	// ---------------------------------------------------------------------
private getArchiveKey	//Method: PSLTable.getArchiveKey(Boolean)

	if PSL.actual(1).isNull() set PSL.actual(1) = 0
	set PSL.return = "$$getArchiveKey^DBARCHIVE("_  PSL.objectName_","_ PSL.actual(1)_")"
	quit
	
	// ---------------------------------------------------------------------
private getArchiveSubs	//Method: PSLTable.getArchiveSubs()

	set PSL.return = "$$getArchiveSubs^DBARCHIVE("_  PSL.objectName_")"
	quit
	
	// ---------------------------------------------------------------------
private getArchiveTable	//Method: PSLTable.getArchiveTable()

	set PSL.return = "$$getArchiveTable^DBARCHIVE("_  PSL.objectName_")"
	quit

	// ---------------------------------------------------------------------
private getFlrLgc	// Method: PSLTable.getFilerLogic(String,Boolean())

	if PSL.actual(3).isNull() set PSL.actual(3) = 0
	set PSL.return = "$$getFlrLgc^UCXDD("_  PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_","_ PSL.actual(3)_")"
	quit

	// ---------------------------------------------------------------------
private getLodCode	// Method: PSLTable.getLoadCode()
	/* ---------------------------------------------------------------------
	ACTUALS:
	. 1 PSLIdentifier recInst
	. 2 String node
	. 3 Number mode
	. 4 Boolean bExists
	. 5 PSLIdentifier lvpm()	/NOREQ
	None of the required actual() values has a default value.
	*/

	set PSL.return = "$$getLodCode^UCXDD("_ PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)
	set PSL.return = PSL.return_","_ PSL.actual(3)_","_ PSL.actual(4)
	if 'PSL.actual(5).isNull() set PSL.return = PSL.return_","_ PSL.actual(5)
	set PSL.return = PSL.return_")"
	quit

	// ---------------------------------------------------------------------
private getNewCode	// Method: PSLTable.getNewCode(PSLIdentifier,PSLExpression)

	set PSL.return = "$$getNewCode^UCXDD("_  PSL.objectName_","_ PSL.actual(1)_","_ PSL.actual(2)_")"
	quit
	
	// ---------------------------------------------------------------------
private getQuery	// Method: PSLTable.getQuery()

	set PSL.return = "$$getQuery^UCXDD("_  PSL.objectName_")"
	quit
	
	// ---------------------------------------------------------------------
private getSavCode	// Method: PSLTable.getSaveCode()
	/* ---------------------------------------------------------------------
	ACTUALS:
	. 1 PSLIdentifier recInst
	. 2 String node
	. 3 Number mode
	. 4 PSLIdentifier lvpm()	/NOREQ
	. 5 PSLColumn rdbCol()		/NOREQ
	None of the required actual() values has a default value.
	*/

	set PSL.return = "$$getSavCode^UCXDD("_ PSL.objectName_","_ PSL.actual(1)
	set PSL.return = PSL.return_","_ PSL.actual(2)_","_ PSL.actual(3)
	//if 'PSL.actual(4).isNull() set PSL.return = PSL.return_","_ PSL.actual(4)
	if 'PSL.actual(4).isNull()!'PSL.actual(5).isNull() set PSL.return = PSL.return_","_ PSL.actual(4)
	if 'PSL.actual(5).isNull() set PSL.return = PSL.return_","_ PSL.actual(5)
	set PSL.return = PSL.return_")"
	quit

	// ---------------------------------------------------------------------
private getUpdKey	// Method: PSLTable.getUpdateKey(PSLIdentifier,String())

	set PSL.return = "$$getUpdKey^UCXDD("_  PSL.objectName_","_ PSL.actual(1)
	if 'PSL.actual(2).isNull() set PSL.return = PSL.return_","_ PSL.actual(2)
	set PSL.return = PSL.return_")"
	quit
	
	// ---------------------------------------------------------------------
private isParent	// Method: PSLTable.isParent()

	set PSL.return = "$$isParent^UCXDD("_  PSL.objectName_")"
	quit
	
	// ---------------------------------------------------------------------
private isOneNode	//Method: PSLTable.isOneNode()

	set PSL.return = "$$isOneNode^UCXDD("_  PSL.objectName_")"
	quit

	// ---------------------------------------------------------------------
private tblHasBlob	// property PSLTable.hasBlob: Return 1 if table has Blob

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "("_ $$tokenPush^UCPATCH( PSL.objectName, "PSLTable")_ ".dataTypes[""B"")"), 1)
	quit

	// ---------------------------------------------------------------------
private tblHasMemo	// property PSLTable.hasMemo: Return 1 if table has Memo

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "("_ $$tokenPush^UCPATCH( PSL.objectName, "PSLTable")_ ".dataTypes[""M"")"), 1)
	quit

	// ---------------------------------------------------------------------
private tblHasNeg	// property PSLTable.hasNegativeNode: Return 1 if table has node with negative subscript

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "("",""_"_ $$tokenPush^UCPATCH( PSL.objectName, "PSLTable")_ ".nodeQuotedList["",""""v"")"), 1)
	quit

	// ---------------------------------------------------------------------
private tblIsRdb	// property PSLTable.isRdb: 1 if table stored in RDB
	/* ---------------------------------------------------------------------
	The generated code uses the values of the "literals" DQINT and SEP.
	As long as PSL does nopt support "global literals", the definition of
	this literal shall be coordinated with the values in UCXDD.
	*/
	type literal String SEP = "|"
	type literal String DQINT = "GTM"

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "("_ $$tokenPush^UCPATCH( PSL.objectName, "PSLTable")_ ".database'="""_DQINT_""")"), 1)
	quit

	// ---------------------------------------------------------------------
private tblHasMasf	// property PSLTable.hasMasterfield: Return 1 table has Masterfields

	set PSL.return = $$tokenPop^UCPATCH( PSL.mExpr( "'"_ $$tokenPush^UCPATCH( PSL.objectName, "PSLTable")_ ".masterfieldList.isNull()"), 1)
	quit
